===== TITLE: check-recovery-triggers.txt =====

// supabase/functions/check-recovery-triggers/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveUserTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

function mean(arr: number[]): number | null {
  if (arr.length === 0) return null;
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}

function stdDev(arr: number[], avg: number): number | null {
  if (arr.length < 2) return null;
  const squaredDiffs = arr.map((x) => (x - avg) ** 2);
  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / arr.length);
}

const ABSOLUTE_LOW_THRESHOLD = 33;
const MIN_DAYS_FOR_SD = 14;

serve(async (req) => {
  console.log("[check-recovery-triggers] start", {
    nowUtc: new Date().toISOString(),
    method: req.method,
  });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "check-recovery-triggers" } },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);

    // Parse optional force flag and date override from request body
    let force = false;
    let dateOverride: string | null = null;
    try {
      const body = await req.json();
      force = body?.force === true;
      dateOverride = typeof body?.date === "string" ? body.date : null;
    } catch {
      // No body or invalid JSON
    }

    // Get users with recovery triggers enabled
    const { data: triggerSettings, error: tsErr } = await supabase
      .from("trigger_settings")
      .select("user_id, trigger_type, enabled")
      .in("trigger_type", ["recovery_low", "recovery_unusually_low"])
      .eq("enabled", true);

    if (tsErr) {
      throw new Error(`trigger_settings query failed: ${tsErr.message}`);
    }

    if (!triggerSettings || triggerSettings.length === 0) {
      return jsonResponse({
        ok: true,
        message: "No users with recovery triggers enabled",
        processed: 0,
      });
    }

    // Group by user
    const userTriggerTypes = new Map<string, Set<string>>();
    for (const ts of triggerSettings) {
      if (!userTriggerTypes.has(ts.user_id)) {
        userTriggerTypes.set(ts.user_id, new Set());
      }
      userTriggerTypes.get(ts.user_id)!.add(ts.trigger_type);
    }

    const results: unknown[] = [];

    for (const [userId, enabledTypes] of userTriggerTypes) {
      const userResult: Record<string, unknown> = { userId, triggers: [] };

      // Resolve user timezone
      const timezone = await resolveUserTimezone(supabase, userId, utcDate);
      if (!timezone) {
        userResult.status = "no_timezone";
        results.push(userResult);
        continue;
      }

      userResult.timezone = timezone;

      // Get local time for this user
      const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
      userResult.localTime = `${String(hh).padStart(2, "0")}:${String(mm).padStart(2, "0")}`;

      // Use date override if provided, otherwise use local date
      const targetDate = dateOverride ?? localDate;
      userResult.targetDate = targetDate;

      // Only process if 9:00-9:09 AM local time (unless forced or date override)
      if (!force && !dateOverride && (hh !== 9 || mm >= 10)) {
        userResult.status = "outside_9am_window";
        results.push(userResult);
        continue;
      }

      // Get target date's recovery score
      const { data: todayRecovery, error: recErr } = await supabase
        .from("recovery_score_daily")
        .select("date, value_pct")
        .eq("user_id", userId)
        .eq("date", targetDate)
        .maybeSingle();

      if (recErr) {
        userResult.error = `recovery fetch failed: ${recErr.message}`;
        results.push(userResult);
        continue;
      }

      if (!todayRecovery || todayRecovery.value_pct == null) {
        userResult.status = "no_recovery_data_for_date";
        results.push(userResult);
        continue;
      }

      const todayValue = todayRecovery.value_pct as number;
      userResult.todayValue = todayValue;

      // Check absolute threshold
      if (enabledTypes.has("recovery_low") && todayValue < ABSOLUTE_LOW_THRESHOLD) {
        const created = await createTriggerIfNotExists(
          supabase,
          userId,
          "recovery_low",
          targetDate,
          `Recovery ${todayValue.toFixed(0)}% - below ${ABSOLUTE_LOW_THRESHOLD}% threshold`
        );
        (userResult.triggers as unknown[]).push({
          type: "recovery_low",
          created,
          value: todayValue,
        });
      }

      // Check 2SD threshold
      if (enabledTypes.has("recovery_unusually_low")) {
        const startDate = addDaysIsoDate(targetDate, -MIN_DAYS_FOR_SD);
        const endDate = addDaysIsoDate(targetDate, -1);

        const { data: historyData, error: histErr } = await supabase
          .from("recovery_score_daily")
          .select("value_pct")
          .eq("user_id", userId)
          .gte("date", startDate)
          .lte("date", endDate);

        if (histErr) {
          userResult.sdError = `history fetch failed: ${histErr.message}`;
        } else {
          const values = (historyData ?? [])
            .map((r: { value_pct: unknown }) => r.value_pct)
            .filter((v): v is number => typeof v === "number");

          if (values.length >= MIN_DAYS_FOR_SD) {
            const avg = mean(values);
            const sd = avg != null ? stdDev(values, avg) : null;

            if (avg != null && sd != null && sd > 0) {
              const threshold = avg - 2 * sd;
              userResult.sdStats = { avg: avg.toFixed(1), sd: sd.toFixed(1), threshold: threshold.toFixed(1) };

              if (todayValue < threshold) {
                const created = await createTriggerIfNotExists(
                  supabase,
                  userId,
                  "recovery_unusually_low",
                  targetDate,
                  `Recovery ${todayValue.toFixed(0)}% - below 2SD (threshold: ${threshold.toFixed(0)}%, avg: ${avg.toFixed(0)}%)`
                );
                (userResult.triggers as unknown[]).push({
                  type: "recovery_unusually_low",
                  created,
                  value: todayValue,
                  threshold: threshold.toFixed(1),
                });
              }
            } else {
              userResult.sdStatus = "insufficient_variance";
            }
          } else {
            userResult.sdStatus = `insufficient_history (${values.length}/${MIN_DAYS_FOR_SD} days)`;
          }
        }
      }

      userResult.status = "processed";
      results.push(userResult);
    }

    const summary = {
      total: results.length,
      processed: results.filter((r: any) => r.status === "processed").length,
      outside9am: results.filter((r: any) => r.status === "outside_9am_window").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      noData: results.filter((r: any) => r.status === "no_recovery_data_for_date").length,
    };

    return jsonResponse({
      ok: true,
      nowUtc: nowUtc.toISOString(),
      utcDate,
      forced: force,
      summary,
      results,
    });
  } catch (e) {
    console.error("[check-recovery-triggers] error", e);
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});

async function createTriggerIfNotExists(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  triggerType: string,
  date: string,
  notes: string
): Promise<boolean> {
  const dayStart = `${date}T00:00:00Z`;
  const dayEnd = `${date}T23:59:59Z`;

  const { data: existing, error: checkErr } = await supabase
    .from("triggers")
    .select("id")
    .eq("user_id", userId)
    .eq("type", triggerType)
    .eq("source", "system")
    .gte("start_at", dayStart)
    .lte("start_at", dayEnd)
    .limit(1);

  if (checkErr) {
    console.error(`[check-recovery-triggers] check existing failed: ${checkErr.message}`);
    return false;
  }

  if (existing && existing.length > 0) {
    return false;
  }

  const { error: insertErr } = await supabase.from("triggers").insert({
    user_id: userId,
    type: triggerType,
    source: "system",
    start_at: `${date}T09:00:00Z`,
    notes,
    active: true,
  });

  if (insertErr) {
    console.error(`[check-recovery-triggers] insert failed: ${insertErr.message}`);
    return false;
  }

  return true;
}


===== TITLE: combined.txt =====



===== TITLE: compute-stress-daily.txt =====

// FILE: supabase/functions/compute-stress-index/index.ts
//
// Cron-triggered edge function that runs every 10 minutes.
// For users where it's 9:00–9:10 AM local time and stress_index_daily is enabled,
// computes a stress index (0–100) from HRV + resting HR data.
//
// Formula:
//   - Uses personal 14-day baseline for both HRV and resting HR
//   - Lower HRV than baseline = more stress
//   - Higher resting HR than baseline = more stress
//   - Combined into a 0–100 score where 0 = very relaxed, 100 = very stressed
//
// Runs AFTER wearable sync so hrv_daily and resting_hr_daily are populated.

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T) => Promise<R>
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i]);
    }
  }

  await Promise.all(Array.from({ length: Math.min(limit, items.length) }, () => worker()));
  return results;
}

/**
 * Compute stress index (0–100) from HRV and resting HR relative to personal baseline.
 *
 * HRV component (0–50):
 *   - HRV at or above baseline → 0 (no stress signal)
 *   - HRV 50% below baseline → 50 (max stress signal from HRV)
 *
 * Resting HR component (0–50):
 *   - RHR at or below baseline → 0 (no stress signal)
 *   - RHR 20 bpm above baseline → 50 (max stress signal from RHR)
 *
 * If no baseline (< 3 days of data), uses population defaults:
 *   - HRV baseline: 50 ms (moderate)
 *   - RHR baseline: 65 bpm (moderate)
 */
function computeStressScore(
  todayHrv: number | null,
  todayRhr: number | null,
  baselineHrv: number | null,
  baselineRhr: number | null,
  baselineDays: number
): number | null {
  // Need at least one input
  if (todayHrv == null && todayRhr == null) return null;

  const DEFAULT_HRV = 50;
  const DEFAULT_RHR = 65;
  const MIN_BASELINE_DAYS = 3;

  const refHrv = (baselineDays >= MIN_BASELINE_DAYS && baselineHrv != null) ? baselineHrv : DEFAULT_HRV;
  const refRhr = (baselineDays >= MIN_BASELINE_DAYS && baselineRhr != null) ? baselineRhr : DEFAULT_RHR;

  let hrvScore = 25; // neutral if missing
  let rhrScore = 25;

  if (todayHrv != null && refHrv > 0) {
    // How much lower is today's HRV vs baseline? Lower = more stress.
    const drop = (refHrv - todayHrv) / refHrv; // fraction, e.g. 0.3 = 30% drop
    // Clamp: -0.5 (way above baseline) to 0.5 (way below)
    const clamped = Math.max(-0.5, Math.min(0.5, drop));
    // Map: -0.5 → 0, 0 → 25, 0.5 → 50
    hrvScore = Math.round((clamped + 0.5) * 50);
  }

  if (todayRhr != null) {
    // How much higher is today's RHR vs baseline? Higher = more stress.
    const rise = todayRhr - refRhr; // bpm above baseline
    // Clamp: -10 (well below baseline) to 20 (well above)
    const clamped = Math.max(-10, Math.min(20, rise));
    // Map: -10 → 0, 0 → 16.7, 20 → 50
    rhrScore = Math.round(((clamped + 10) / 30) * 50);
  }

  return Math.max(0, Math.min(100, hrvScore + rhrScore));
}

serve(async (req) => {
  console.log("[compute-stress-index] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);
    const BASELINE_DAYS = 14;

    // Get users with stress_index_daily enabled
    const { data: metricRows, error: metricErr } = await supabase
      .from("metric_settings")
      .select("user_id")
      .eq("metric", "stress_index_daily")
      .eq("enabled", true);

    if (metricErr) throw new Error(`metric_settings query failed: ${metricErr.message}`);

    const userIds = [...new Set((metricRows ?? []).map((r: any) => String(r.user_id)))];
    console.log(`[compute-stress-index] ${userIds.length} users with stress enabled`);

    if (userIds.length === 0) {
      return jsonResponse({ ok: true, processed: 0 });
    }

    const results = await mapLimit(userIds, 10, async (userId) => {
      try {
        // Resolve timezone
        const timezone = await resolveTimezone(supabase, userId, utcDate);
        if (!timezone) {
          return { userId, status: "no_timezone" };
        }

        // Check if 9:00–9:10 AM local time
        const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
        if (hh !== 9 || mm > 10) {
          return { userId, status: "not_9am", localHour: hh };
        }

        const yesterday = addDaysIsoDate(localDate, -1);

        // Fetch yesterday's HRV
        const { data: hrvRow } = await supabase
          .from("hrv_daily")
          .select("value_rmssd_ms")
          .eq("user_id", userId)
          .eq("date", yesterday)
          .maybeSingle();

        // Fetch yesterday's resting HR
        const { data: rhrRow } = await supabase
          .from("resting_hr_daily")
          .select("value_bpm")
          .eq("user_id", userId)
          .eq("date", yesterday)
          .maybeSingle();

        const todayHrv = hrvRow?.value_rmssd_ms ?? null;
        const todayRhr = rhrRow?.value_bpm ?? null;

        if (todayHrv == null && todayRhr == null) {
          return { userId, status: "no_input_data", date: yesterday };
        }

        // Fetch baseline (past 14 days, excluding yesterday)
        const baselineStart = addDaysIsoDate(yesterday, -BASELINE_DAYS);
        const baselineEnd = addDaysIsoDate(yesterday, -1);

        const { data: hrvBaseline } = await supabase
          .from("hrv_daily")
          .select("value_rmssd_ms")
          .eq("user_id", userId)
          .gte("date", baselineStart)
          .lte("date", baselineEnd)
          .not("value_rmssd_ms", "is", null);

        const { data: rhrBaseline } = await supabase
          .from("resting_hr_daily")
          .select("value_bpm")
          .eq("user_id", userId)
          .gte("date", baselineStart)
          .lte("date", baselineEnd)
          .not("value_bpm", "is", null);

        const hrvValues = (hrvBaseline ?? []).map((r: any) => Number(r.value_rmssd_ms)).filter((v) => !isNaN(v));
        const rhrValues = (rhrBaseline ?? []).map((r: any) => Number(r.value_bpm)).filter((v) => !isNaN(v));

        const baselineDays = Math.max(hrvValues.length, rhrValues.length);
        const baselineHrv = hrvValues.length > 0
          ? hrvValues.reduce((a, b) => a + b, 0) / hrvValues.length
          : null;
        const baselineRhr = rhrValues.length > 0
          ? rhrValues.reduce((a, b) => a + b, 0) / rhrValues.length
          : null;

        const stressValue = computeStressScore(todayHrv, todayRhr, baselineHrv, baselineRhr, baselineDays);

        if (stressValue == null) {
          return { userId, status: "no_score", date: yesterday };
        }

        // Compute z-scores for storage
        const MIN_BASELINE_DAYS = 3;
        const refHrv = (baselineDays >= MIN_BASELINE_DAYS && baselineHrv != null) ? baselineHrv : 50;
        const refRhr = (baselineDays >= MIN_BASELINE_DAYS && baselineRhr != null) ? baselineRhr : 65;
        const hrvZ = (todayHrv != null && refHrv > 0) ? (refHrv - todayHrv) / refHrv : null;
        const rhrZ = todayRhr != null ? todayRhr - refRhr : null;

        // Upsert
        const { error: upsertErr } = await supabase
          .from("stress_index_daily")
          .upsert(
            {
              user_id: userId,
              date: yesterday,
              value: stressValue,
              hrv_z: hrvZ,
              rhr_z: rhrZ,
              baseline_window_days: baselineDays,
              computed_at: new Date().toISOString(),
            },
            { onConflict: "user_id,date" }
          );

        if (upsertErr) throw upsertErr;

        return {
          userId,
          status: "ok",
          date: yesterday,
          value: stressValue,
          inputs: { hrv: todayHrv, rhr: todayRhr },
          baseline: { hrv: baselineHrv, rhr: baselineRhr, days: baselineDays },
        };
      } catch (e: any) {
        return { userId, status: "error", error: String(e?.message ?? e) };
      }
    });

    const summary = {
      total: results.length,
      ok: results.filter((r: any) => r.status === "ok").length,
      not9am: results.filter((r: any) => r.status === "not_9am").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      noInput: results.filter((r: any) => r.status === "no_input_data").length,
      errors: results.filter((r: any) => r.status === "error").length,
    };

    console.log("[compute-stress-index] done", summary);

    return jsonResponse({ ok: true, summary, results });

  } catch (e: any) {
    console.error("[compute-stress-index] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: convert-predicted-menstruations.txt =====

// FILE: supabase/functions/convert-predicted-menstruations/index.ts
// Runs HOURLY and converts predicted triggers ONLY when it's 9:00-9:10 AM local time
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveUserTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

serve(async (req) => {
  try {
    console.log("[convert-predicted-menstruations] start", {
      nowUtc: new Date().toISOString(),
      method: req.method,
      url: req.url
    });

    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "convert-predicted-menstruations" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const utcDate = nowIso.slice(0, 10);

    // Get all users with menstruation enabled
    const { data: userRows, error: userErr } = await supabase
      .from("metric_settings")
      .select("user_id")
      .eq("metric", "menstruation")
      .eq("enabled", true);

    if (userErr) {
      throw new Error(`Failed to query users: ${userErr.message}`);
    }

    if (!userRows || userRows.length === 0) {
      console.log("[convert-predicted-menstruations] No users with menstruation enabled");
      return jsonResponse({
        ok: true,
        message: "No users with menstruation enabled",
        converted: 0
      });
    }

    console.log(`[convert-predicted-menstruations] Checking ${userRows.length} users`);

    const results = [];

    for (const userRow of userRows) {
      const userId = userRow.user_id;

      try {
        // Resolve user's timezone
        const timezone = await resolveUserTimezone(supabase, userId, utcDate);
        if (!timezone) {
          console.log(`[convert-predicted-menstruations] User ${userId}: No timezone, skipping`);
          continue;
        }

        // Get local time for this user RIGHT NOW
        const localTime = getLocalTimeParts(timezone, nowUtc);
        
        // CRITICAL: Only process if it's between 9:00 and 9:10 AM local time
        if (localTime.hh !== 9 || localTime.mm >= 10) {
          // Not 9:00-9:10 AM for this user, skip
          continue;
        }

        console.log(`[convert-predicted-menstruations] User ${userId}: It's 9:0${localTime.mm} AM! (${timezone})`);

        // Find predicted trigger
        const { data: predictedTriggers, error: queryError } = await supabase
          .from("triggers")
          .select("id, user_id, type, start_at, source, active")
          .eq("user_id", userId)
          .eq("type", "menstruation_predicted")
          .eq("source", "system")
          .eq("active", true);

        if (queryError) {
          console.error(`[convert-predicted-menstruations] User ${userId}: Query error:`, queryError.message);
          results.push({ userId, status: "error", reason: queryError.message });
          continue;
        }

        if (!predictedTriggers || predictedTriggers.length === 0) {
          console.log(`[convert-predicted-menstruations] User ${userId}: No predicted trigger`);
          continue;
        }

        const predicted = predictedTriggers[0];
        const predictedDate = predicted.start_at.slice(0, 10);

        // Check if predicted date is TODAY (in user's local timezone)
        if (predictedDate !== localTime.localDate) {
          console.log(`[convert-predicted-menstruations] User ${userId}: Predicted date ${predictedDate} != today ${localTime.localDate}`);
          continue;
        }

        console.log(`[convert-predicted-menstruations] User ${userId}: Predicted trigger is DUE TODAY!`);

        // Check if already converted today (avoid duplicates if function runs multiple times in the 9:00-9:10 window)
        const { data: existingToday, error: checkError } = await supabase
          .from("triggers")
          .select("id")
          .eq("user_id", userId)
          .eq("type", "menstruation")
          .eq("source", "auto")
          .gte("start_at", `${localTime.localDate}T00:00:00Z`)
          .lte("start_at", `${localTime.localDate}T23:59:59Z`);

        if (checkError) {
          console.error(`[convert-predicted-menstruations] User ${userId}: Check error:`, checkError.message);
          results.push({ userId, status: "error", reason: checkError.message });
          continue;
        }

        if (existingToday && existingToday.length > 0) {
          console.log(`[convert-predicted-menstruations] User ${userId}: Already converted today, skipping`);
          results.push({ userId, status: "skipped", reason: "Already converted today" });
          continue;
        }

        // Check if user manually logged period nearby (within 3 days)
        const threeDaysAgo = addDaysIsoDate(localTime.localDate, -3);
        const threeDaysLater = addDaysIsoDate(localTime.localDate, 3);

        const { data: manualPeriods, error: manualError } = await supabase
          .from("triggers")
          .select("id")
          .eq("user_id", userId)
          .eq("type", "menstruation")
          .in("source", ["manual", "health_connect"])
          .gte("start_at", `${threeDaysAgo}T00:00:00Z`)
          .lte("start_at", `${threeDaysLater}T23:59:59Z`);

        if (manualError) {
          console.error(`[convert-predicted-menstruations] User ${userId}: Manual check error:`, manualError.message);
          results.push({ userId, status: "error", reason: manualError.message });
          continue;
        }

        if (manualPeriods && manualPeriods.length > 0) {
          console.log(`[convert-predicted-menstruations] User ${userId}: User logged period manually nearby, skipping auto-conversion`);
          results.push({ userId, status: "skipped", reason: "Manual period logged nearby" });
          continue;
        }

        // INSERT REAL MENSTRUATION TRIGGER
        const { error: insertError } = await supabase
          .from("triggers")
          .insert({
            user_id: userId,
            type: "menstruation",
            start_at: `${localTime.localDate}T09:00:00Z`,
            source: "auto",
            active: true,
            notes: "Auto-generated from predicted menstruation"
          });

        if (insertError) {
          console.error(`[convert-predicted-menstruations] User ${userId}: Insert error:`, insertError.message);
          results.push({ userId, status: "error", reason: insertError.message });
          continue;
        }

        console.log(`[convert-predicted-menstruations] ✓ User ${userId}: Converted predicted to real!`);
        results.push({ 
          userId, 
          status: "converted", 
          timezone, 
          localDate: localTime.localDate,
          localTime: `${localTime.hh}:${String(localTime.mm).padStart(2, '0')}`
        });

        // Note: Database trigger will automatically update the predicted trigger's date

      } catch (userError) {
        console.error(`[convert-predicted-menstruations] User ${userId}: Error:`, userError);
        results.push({ userId, status: "error", reason: String(userError) });
      }
    }

    const summary = {
      ok: true,
      nowUtc: nowIso,
      utcDate,
      totalUsers: userRows.length,
      converted: results.filter(r => r.status === "converted").length,
      skipped: results.filter(r => r.status === "skipped").length,
      errors: results.filter(r => r.status === "error").length,
      results: results
    };

    console.log("[convert-predicted-menstruations] done", summary);
    return jsonResponse(summary);

  } catch (e) {
    console.error("[convert-predicted-menstruations] error", e);
    return jsonResponse({
      ok: false,
      error: String(e)
    }, 500);
  }
});


===== TITLE: daily-9am-noise-index.txt =====

// FILE: supabase/functions/daily-9am-noise-index/index.ts
//
// Dispatcher that runs every 10 minutes via cron.
// For users where it's 9:00-9:10 AM local time and noise is enabled,
// queues a job to sync_jobs_noise for yesterday's date.

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T) => Promise<R>
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i]);
    }
  }

  await Promise.all(Array.from({ length: Math.min(limit, items.length) }, () => worker()));
  return results;
}

serve(async (req) => {
  console.log("[daily-9am-noise-index] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);

    // Get users with ambient_noise_samples enabled
    const { data: metricRows, error: metricErr } = await supabase
      .from("metric_settings")
      .select("user_id")
      .eq("metric", "ambient_noise_samples")
      .eq("enabled", true);

    if (metricErr) throw new Error(`metric_settings query failed: ${metricErr.message}`);

    const userIds = [...new Set((metricRows ?? []).map((r: any) => String(r.user_id)))].filter(Boolean);

    console.log(`[daily-9am-noise-index] ${userIds.length} users with noise enabled`);

    const results = await mapLimit(userIds, 10, async (userId) => {
      try {
        // Resolve timezone
        const timezone = await resolveTimezone(supabase, userId, utcDate);
        if (!timezone) {
          return { userId, status: "no_timezone" };
        }

        // Check if 9:00-9:10 AM local time
        const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
        if (hh !== 9 || mm > 10) {
          return { userId, status: "not_9am", localHour: hh };
        }

        // Queue job for YESTERDAY (complete day)
        const yesterday = addDaysIsoDate(localDate, -1);

        // Upsert job (idempotent - won't duplicate if already queued)
        const { error: upsertErr } = await supabase
          .from("sync_jobs_noise")
          .upsert(
            {
              user_id: userId,
              local_date: yesterday,
              timezone: timezone,
              status: "queued",
              attempts: 0,
              updated_at: new Date().toISOString(),
            },
            { onConflict: "user_id,local_date", ignoreDuplicates: true }
          );

        if (upsertErr) {
          return { userId, status: "queue_error", error: upsertErr.message };
        }

        return { userId, status: "queued", date: yesterday, timezone };

      } catch (e: any) {
        return { userId, status: "error", error: String(e?.message ?? e) };
      }
    });

    const summary = {
      total: results.length,
      queued: results.filter((r: any) => r.status === "queued").length,
      not9am: results.filter((r: any) => r.status === "not_9am").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      errors: results.filter((r: any) => r.status === "error" || r.status === "queue_error").length,
    };

    console.log("[daily-9am-noise-index] done", summary);

    return jsonResponse({ ok: true, summary, results });

  } catch (e: any) {
    console.error("[daily-9am-noise-index] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: daily-9am-nutrition.txt =====

// FILE: supabase/functions/daily-9am-nutrition/index.ts
//
// Dispatcher that runs every 10 minutes via cron.
// For users where it's 9:00-9:10 AM local time and nutrition is enabled,
// queues a job to sync_jobs_nutrition for yesterday's date.
//
// Pattern copied from daily-9am-noise-index

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T) => Promise<R>
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i]);
    }
  }

  await Promise.all(Array.from({ length: Math.min(limit, items.length) }, () => worker()));
  return results;
}

serve(async (req) => {
  console.log("[daily-9am-nutrition] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);

    // Get users with nutrition enabled
    const { data: metricRows, error: metricErr } = await supabase
      .from("metric_settings")
      .select("user_id")
      .eq("metric", "nutrition")
      .eq("enabled", true);

    if (metricErr) throw new Error(`metric_settings query failed: ${metricErr.message}`);

    const userIds = [...new Set((metricRows ?? []).map((r: any) => String(r.user_id)))].filter(Boolean);

    console.log(`[daily-9am-nutrition] ${userIds.length} users with nutrition enabled`);

    const results = await mapLimit(userIds, 10, async (userId) => {
      try {
        // Resolve timezone
        const timezone = await resolveTimezone(supabase, userId, utcDate);
        if (!timezone) {
          return { userId, status: "no_timezone" };
        }

        // Check if 9:00-9:10 AM local time
        const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
        if (hh !== 9 || mm > 10) {
          return { userId, status: "not_9am", localHour: hh };
        }

        // Queue job for YESTERDAY (complete day)
        const yesterday = addDaysIsoDate(localDate, -1);

        // Upsert job (idempotent - won't duplicate if already queued)
        const { error: upsertErr } = await supabase
          .from("sync_jobs_nutrition")
          .upsert(
            {
              user_id: userId,
              local_date: yesterday,
              timezone: timezone,
              status: "queued",
              attempts: 0,
              updated_at: new Date().toISOString(),
            },
            { onConflict: "user_id,local_date", ignoreDuplicates: true }
          );

        if (upsertErr) {
          return { userId, status: "queue_error", error: upsertErr.message };
        }

        return { userId, status: "queued", date: yesterday, timezone };

      } catch (e: any) {
        return { userId, status: "error", error: String(e?.message ?? e) };
      }
    });

    const summary = {
      total: results.length,
      queued: results.filter((r: any) => r.status === "queued").length,
      not9am: results.filter((r: any) => r.status === "not_9am").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      errors: results.filter((r: any) => r.status === "error" || r.status === "queue_error").length,
    };

    console.log("[daily-9am-nutrition] done", summary);

    return jsonResponse({ ok: true, summary, results });

  } catch (e: any) {
    console.error("[daily-9am-nutrition] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: daily-9am-phone-behavior.txt =====

// FILE: supabase/functions/daily-9am-phone-behavior/index.ts
//
// Cron-triggered edge function that runs every 10 minutes.
// For users where it's 9:00–9:10 AM local time and any phone behavior metric is enabled,
// aggregates yesterday's samples into daily tables:
//
//   phone_brightness_samples  → phone_brightness_daily  (AVG, MAX, COUNT)
//   phone_volume_samples      → phone_volume_daily      (AVG, COUNT)
//   phone_dark_mode_samples   → phone_dark_mode_daily   (estimated hours, dark count, total count)
//   phone_unlock_samples      → phone_unlock_daily      (MAX cumulative count)

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

/** Concurrency-limited parallel mapper */
async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T) => Promise<R>
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i]);
    }
  }

  await Promise.all(Array.from({ length: Math.min(limit, items.length) }, () => worker()));
  return results;
}

const PHONE_BEHAVIOR_METRICS = [
  "phone_brightness_daily",
  "phone_volume_daily",
  "phone_dark_mode_daily",
  "phone_unlock_daily",
];

serve(async (req) => {
  console.log("[daily-9am-phone-behavior] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);

    // Get users with ANY phone behavior metric enabled
    const { data: metricRows, error: metricErr } = await supabase
      .from("metric_settings")
      .select("user_id, metric")
      .in("metric", PHONE_BEHAVIOR_METRICS)
      .eq("enabled", true);

    if (metricErr) throw new Error(`metric_settings query failed: ${metricErr.message}`);

    // Group enabled metrics by user
    const userMetrics = new Map<string, Set<string>>();
    for (const row of metricRows ?? []) {
      const uid = String(row.user_id);
      if (!userMetrics.has(uid)) userMetrics.set(uid, new Set());
      userMetrics.get(uid)!.add(row.metric);
    }

    const userIds = [...userMetrics.keys()];
    console.log(`[daily-9am-phone-behavior] ${userIds.length} users with phone behavior enabled`);

    const results = await mapLimit(userIds, 10, async (userId) => {
      try {
        // Resolve timezone
        const timezone = await resolveTimezone(supabase, userId, utcDate);
        if (!timezone) {
          return { userId, status: "no_timezone" };
        }

        // Check if 9:00–9:10 AM local time
        const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
        if (hh !== 9 || mm > 10) {
          return { userId, status: "not_9am", localHour: hh };
        }

        const yesterday = addDaysIsoDate(localDate, -1);
        const enabledMetrics = userMetrics.get(userId)!;
        const aggregated: string[] = [];
        const errors: string[] = [];

        // ── Brightness ───────────────────────────────────────────────
        if (enabledMetrics.has("phone_brightness_daily")) {
          try {
            const { data, error } = await supabase.rpc("aggregate_phone_brightness", {
              p_user_id: userId,
              p_date: yesterday,
              p_timezone: timezone,
            });

            if (error) throw error;
            if (data && data.length > 0 && data[0].sample_count > 0) {
              const row = data[0];
              const { error: upsertErr } = await supabase
                .from("phone_brightness_daily")
                .upsert(
                  {
                    user_id: userId,
                    date: yesterday,
                    value_mean: row.value_mean,
                    value_max: row.value_max,
                    sample_count: row.sample_count,
                    source: "computed",
                    updated_at: new Date().toISOString(),
                  },
                  { onConflict: "user_id,date" }
                );
              if (upsertErr) throw upsertErr;
              aggregated.push("brightness");
            }
          } catch (e: any) {
            errors.push(`brightness: ${e.message}`);
          }
        }

        // ── Volume ───────────────────────────────────────────────────
        if (enabledMetrics.has("phone_volume_daily")) {
          try {
            const { data, error } = await supabase.rpc("aggregate_phone_volume", {
              p_user_id: userId,
              p_date: yesterday,
              p_timezone: timezone,
            });

            if (error) throw error;
            if (data && data.length > 0 && data[0].sample_count > 0) {
              const row = data[0];
              const { error: upsertErr } = await supabase
                .from("phone_volume_daily")
                .upsert(
                  {
                    user_id: userId,
                    date: yesterday,
                    value_mean_pct: row.value_mean_pct,
                    sample_count: row.sample_count,
                    source: "computed",
                    updated_at: new Date().toISOString(),
                  },
                  { onConflict: "user_id,date" }
                );
              if (upsertErr) throw upsertErr;
              aggregated.push("volume");
            }
          } catch (e: any) {
            errors.push(`volume: ${e.message}`);
          }
        }

        // ── Dark Mode ────────────────────────────────────────────────
        if (enabledMetrics.has("phone_dark_mode_daily")) {
          try {
            const { data, error } = await supabase.rpc("aggregate_phone_dark_mode", {
              p_user_id: userId,
              p_date: yesterday,
              p_timezone: timezone,
            });

            if (error) throw error;
            if (data && data.length > 0 && data[0].sample_count > 0) {
              const row = data[0];
              const { error: upsertErr } = await supabase
                .from("phone_dark_mode_daily")
                .upsert(
                  {
                    user_id: userId,
                    date: yesterday,
                    value_hours: row.value_hours,
                    dark_samples: row.dark_samples,
                    sample_count: row.sample_count,
                    source: "computed",
                    updated_at: new Date().toISOString(),
                  },
                  { onConflict: "user_id,date" }
                );
              if (upsertErr) throw upsertErr;
              aggregated.push("dark_mode");
            }
          } catch (e: any) {
            errors.push(`dark_mode: ${e.message}`);
          }
        }

        // ── Unlocks ──────────────────────────────────────────────────
        if (enabledMetrics.has("phone_unlock_daily")) {
          try {
            const { data, error } = await supabase.rpc("aggregate_phone_unlocks", {
              p_user_id: userId,
              p_date: yesterday,
              p_timezone: timezone,
            });

            if (error) throw error;
            if (data && data.length > 0 && data[0].sample_count > 0) {
              const row = data[0];
              const { error: upsertErr } = await supabase
                .from("phone_unlock_daily")
                .upsert(
                  {
                    user_id: userId,
                    date: yesterday,
                    value_count: row.value_count,
                    source: "computed",
                    updated_at: new Date().toISOString(),
                  },
                  { onConflict: "user_id,date" }
                );
              if (upsertErr) throw upsertErr;
              aggregated.push("unlocks");
            }
          } catch (e: any) {
            errors.push(`unlocks: ${e.message}`);
          }
        }

        return {
          userId,
          status: errors.length > 0 ? "partial" : "ok",
          date: yesterday,
          aggregated,
          errors: errors.length > 0 ? errors : undefined,
        };
      } catch (e: any) {
        return { userId, status: "error", error: String(e?.message ?? e) };
      }
    });

    const summary = {
      total: results.length,
      ok: results.filter((r: any) => r.status === "ok").length,
      partial: results.filter((r: any) => r.status === "partial").length,
      not9am: results.filter((r: any) => r.status === "not_9am").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      errors: results.filter((r: any) => r.status === "error").length,
    };

    console.log("[daily-9am-phone-behavior] done", summary);

    return jsonResponse({ ok: true, summary, results });
  } catch (e: any) {
    console.error("[daily-9am-phone-behavior] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: daily-9am-stress-index.txt =====

// FILE: supabase/functions/daily-9am-stress-index/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type ResolveRow = {
  city_id: number | null;  // UPDATED: Now nullable
  timezone: string | null;
  resolved_date?: string | null;
};

type MetricSettingRow = {
  user_id: string;
  metric: string;
  enabled: boolean;
  preferred_source: string | null;
  allowed_sources: string[] | null;
};

type SyncJobInsert = {
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  updated_at: string;
  created_by: string;
  timezone: string;
  city_id: number | null;
  attempts?: number;
  locked_at?: string | null;
  last_error?: string | null;
};

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    // Direct query to user_location_daily - no RPC needed!
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone, date")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) {
      throw new Error(`user_location_daily query failed for date=${d}: ${error.message}`);
    }

    if (data?.timezone) {
      const row: ResolveRow = {
        city_id: null,  // No longer needed
        timezone: data.timezone,
        resolved_date: data.date
      };
      return { row, usedDate: data.date };
    }
  }

  return { row: null, usedDate: null };
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T, idx: number) => Promise<R>,
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i], i);
    }
  }

  const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
  await Promise.all(workers);
  return results;
}

serve(async (req) => {
  console.log("[daily-9am-stress-index] start", { nowUtc: new Date().toISOString(), method: req.method, url: req.url });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "daily-9am-stress-index-dispatcher" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const utcDate = nowIso.slice(0, 10);

    // Users: anyone with at least one enabled metric row
    const { data: userRows, error: userErr } = await supabase
      .from("metric_settings")
      .select("user_id")
      .eq("enabled", true);

    if (userErr) throw new Error(`metric_settings query failed: ${userErr.message}`);

    const userIds = Array.from(new Set((userRows ?? []).map((r: any) => String(r.user_id)))).filter(Boolean);

    const perUser = await mapLimit(userIds, 12, async (userId) => {
      let resolved: ResolveRow | null = null;
      let usedResolveDate: string | null = null;

      try {
        const out = await resolveWithDateFallback(supabase, userId, utcDate);
        resolved = out.row;
        usedResolveDate = out.usedDate;
      } catch (e) {
        return { userId, status: "resolver_error", error: (e as Error).message };
      }

      if (!resolved?.timezone) return { userId, status: "no_timezone" };

      const tz = resolved.timezone;
      const cityId = typeof resolved.city_id === "number" ? resolved.city_id : null;
      const { localDate } = getLocalTimeParts(tz, nowUtc);

      // Only enqueue if stress metric is enabled
      const { data: metrics, error: metErr } = await supabase
        .from("metric_settings")
        .select("user_id,metric,enabled,preferred_source,allowed_sources")
        .eq("user_id", userId)
        .eq("enabled", true)
        .eq("metric", "stress_index_daily");

      if (metErr) {
        return { userId, status: "metrics_error", error: metErr.message, timezone: tz, localDate };
      }

      const enabled = (metrics ?? []) as MetricSettingRow[];
      const needed = enabled.length > 0;

      if (!needed) {
        return { userId, status: "no_jobs_needed", timezone: tz, localDate, usedResolveDate };
      }

      const job: SyncJobInsert = {
        job_type: "stress_index_daily",
        user_id: userId,
        local_date: localDate,
        status: "queued",
        updated_at: nowIso,
        created_by: "daily-9am-stress",
        timezone: tz,
        city_id: cityId,
        // Self-heal stuck jobs / allow retries
        attempts: 0,
        locked_at: null,
        last_error: null,
      };

      const { error: insErr } = await supabase
        .from("sync_jobs")
        .upsert([job], { onConflict: "job_type,user_id,local_date" });

      if (insErr) {
        return { userId, status: "enqueue_error", error: insErr.message, timezone: tz, localDate, usedResolveDate };
      }

      return { userId, status: "enqueued", timezone: tz, localDate, usedResolveDate, enqueued: ["stress_index_daily"] };
    });

    const summary = {
      checkedUsers: userIds.length,
      enqueuedUsers: perUser.filter((r: any) => r.status === "enqueued").length,
      noJobsNeeded: perUser.filter((r: any) => r.status === "no_jobs_needed").length,
      noTimezone: perUser.filter((r: any) => r.status === "no_timezone").length,
      errors: perUser.filter((r: any) => String(r.status).includes("error")).length,
      nowUtc: nowIso,
    };

    console.log("[daily-9am-stress-index] done", { summary });
    return jsonResponse({ ok: true, summary, results: perUser });
  } catch (e) {
    console.log("[daily-9am-stress-index] error", { error: (e as Error).message });
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});


===== TITLE: daily-9am-sync.txt =====

// supabase/functions/daily-9am-sync/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type ResolveRow = {
  city_id: number | null;  // UPDATED: Now nullable
  timezone: string | null;
  resolved_date?: string | null;
};

type MetricSettingRow = {
  user_id: string;
  metric: string;
  enabled: boolean;
  preferred_source: string | null;
  allowed_sources: string[] | null;
};

type SyncJobInsert = {
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  updated_at: string;
  created_by: string;
  timezone: string;
  city_id: number | null;
  attempts?: number;
  locked_at?: string | null;
  last_error?: string | null;
};

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    // Direct query to user_location_daily - no RPC needed!
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone, date")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) {
      throw new Error(`user_location_daily query failed for date=${d}: ${error.message}`);
    }

    if (data?.timezone) {
      const row: ResolveRow = {
        city_id: null,  // No longer needed
        timezone: data.timezone,
        resolved_date: data.date
      };
      return { row, usedDate: data.date };
    }
  }

  return { row: null, usedDate: null };
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T, idx: number) => Promise<R>,
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i], i);
    }
  }

  const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
  await Promise.all(workers);
  return results;
}

serve(async (req) => {
  console.log("[daily-9am-sync] dispatcher_start", {
    nowUtc: new Date().toISOString(),
    method: req.method,
    url: req.url,
  });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "daily-9am-sync-dispatcher" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const utcDate = nowIso.slice(0, 10);

    // Users to check: anyone with at least one enabled metric row
    const { data: userRows, error: userErr } = await supabase
      .from("metric_settings")
      .select("user_id")
      .eq("enabled", true);

    if (userErr) throw new Error(`metric_settings query failed: ${userErr.message}`);

    const userIds = Array.from(new Set((userRows ?? []).map((r: any) => String(r.user_id)))).filter(Boolean);

    const perUser = await mapLimit(userIds, 12, async (userId) => {
      // Resolve timezone so we enqueue with correct local_date
      let resolved: ResolveRow | null = null;
      let usedResolveDate: string | null = null;

      try {
        const out = await resolveWithDateFallback(supabase, userId, utcDate);
        resolved = out.row;
        usedResolveDate = out.usedDate;
      } catch (e) {
        return { userId, status: "resolver_error", error: (e as Error).message };
      }

      if (!resolved?.timezone) {
        return { userId, status: "no_timezone" };
      }

      const tz = resolved.timezone;
      const cityId = typeof resolved.city_id === "number" ? resolved.city_id : null;

      const { localDate } = getLocalTimeParts(tz, nowUtc);

      // Fetch enabled metrics and decide which job types are needed
      const { data: metrics, error: metErr } = await supabase
        .from("metric_settings")
        .select("user_id,metric,enabled,preferred_source,allowed_sources")
        .eq("user_id", userId)
        .eq("enabled", true);

      if (metErr) {
        return { userId, status: "metrics_error", error: metErr.message, timezone: tz, localDate };
      }

      const enabledMetrics = (metrics ?? []) as MetricSettingRow[];

      const whoopNeeded = enabledMetrics.some((m) => {
        const pref = (m.preferred_source ?? "").toLowerCase();
        const allowed = (m.allowed_sources ?? []).map((s) => String(s).toLowerCase());
        return pref === "whoop" || allowed.includes("whoop");
      });

      const jobs: SyncJobInsert[] = [];
      if (whoopNeeded) {
        jobs.push({
          job_type: "whoop_daily",
          user_id: userId,
          local_date: localDate,
          status: "queued",
          updated_at: nowIso,
          created_by: "daily-9am",
          timezone: tz,
          city_id: cityId,
          // Self-heal stuck jobs (e.g. attempts hit cap, or timezone null)
          attempts: 0,
          locked_at: null,
          last_error: null,
        });
      }

      if (!jobs.length) {
        return {
          userId,
          status: "no_jobs_needed",
          timezone: tz,
          localDate,
          usedResolveDate,
        };
      }

      // IMPORTANT: do NOT ignoreDuplicates here; we want to "repair" existing rows for today
      const { error: insErr } = await supabase
        .from("sync_jobs")
        .upsert(jobs, { onConflict: "job_type,user_id,local_date" });

      if (insErr) {
        return {
          userId,
          status: "enqueue_error",
          error: insErr.message,
          timezone: tz,
          localDate,
          usedResolveDate,
        };
      }

      return {
        userId,
        status: "enqueued",
        timezone: tz,
        localDate,
        usedResolveDate,
        enqueued: jobs.map((j) => j.job_type),
      };
    });

    const summary = {
      checkedUsers: userIds.length,
      enqueuedUsers: perUser.filter((r: any) => r.status === "enqueued").length,
      noJobsNeeded: perUser.filter((r: any) => r.status === "no_jobs_needed").length,
      noTimezone: perUser.filter((r: any) => r.status === "no_timezone").length,
      errors: perUser.filter((r: any) => String(r.status).includes("error")).length,
      nowUtc: nowIso,
    };

    console.log("[daily-9am-sync] dispatcher_done", { summary });

    return jsonResponse({ ok: true, summary, results: perUser });
  } catch (e) {
    console.log("[daily-9am-sync] dispatcher_error", { error: (e as Error).message });
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});


===== TITLE: daily-9am-triggers.txt =====

// supabase/functions/daily-9am-triggers/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveUserTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

serve(async (req) => {
  console.log("[daily-9am-triggers] start", {
    nowUtc: new Date().toISOString(),
    method: req.method,
  });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "daily-9am-triggers" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const utcDate = nowIso.slice(0, 10);

    // Get all users with any trigger enabled
    const { data: triggerSettings, error: tsErr } = await supabase
      .from("trigger_settings")
      .select("user_id")
      .eq("enabled", true);

    if (tsErr) {
      throw new Error(`trigger_settings query failed: ${tsErr.message}`);
    }

    const userIds = [...new Set((triggerSettings ?? []).map((r) => r.user_id))];

    if (userIds.length === 0) {
      return jsonResponse({
        ok: true,
        message: "No users with triggers enabled",
        enqueued: 0,
      });
    }

    const results: unknown[] = [];
    let enqueuedCount = 0;

    for (const userId of userIds) {
      const userResult: Record<string, unknown> = { userId };

      // Resolve timezone
      const timezone = await resolveUserTimezone(supabase, userId, utcDate);
      if (!timezone) {
        userResult.status = "no_timezone";
        results.push(userResult);
        continue;
      }

      userResult.timezone = timezone;

      // Get local time
      const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
      userResult.localTime = `${String(hh).padStart(2, "0")}:${String(mm).padStart(2, "0")}`;
      userResult.localDate = localDate;

      // Only enqueue if 9:00-9:09 AM local
      if (hh !== 9 || mm >= 10) {
        userResult.status = "outside_9am_window";
        results.push(userResult);
        continue;
      }

      // Enqueue trigger job
      const { error: insErr } = await supabase.from("trigger_jobs").upsert(
        {
          job_type: "daily_triggers",
          user_id: userId,
          local_date: localDate,
          status: "queued",
          attempts: 0,
          locked_at: null,
          last_error: null,
          created_by: "daily-9am-triggers",
          timezone,
          updated_at: nowIso,
        },
        { onConflict: "job_type,user_id,local_date", ignoreDuplicates: true }
      );

      if (insErr) {
        userResult.status = "enqueue_error";
        userResult.error = insErr.message;
      } else {
        userResult.status = "enqueued";
        enqueuedCount++;
      }

      results.push(userResult);
    }

    const summary = {
      totalUsers: userIds.length,
      enqueued: enqueuedCount,
      outside9am: results.filter((r: any) => r.status === "outside_9am_window").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      errors: results.filter((r: any) => r.status === "enqueue_error").length,
    };

    return jsonResponse({
      ok: true,
      nowUtc: nowIso,
      utcDate,
      summary,
      results,
    });
  } catch (e) {
    console.error("[daily-9am-triggers] error", e);
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});


===== TITLE: daily-9am-weather-dispatcher.txt =====

// FILE: supabase/functions/daily-9am-weather-dispatcher/index.ts
//
// Dispatcher that runs every 10 minutes via cron.
// For users where it's 9:00-9:10 AM local time and weather is enabled,
// queues a job to sync_jobs_weather for today's date.

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveTimezone(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string
): Promise<string | null> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) continue;
    if (data?.timezone) return data.timezone;
  }

  return null;
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T) => Promise<R>
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i]);
    }
  }

  await Promise.all(Array.from({ length: Math.min(limit, items.length) }, () => worker()));
  return results;
}

serve(async (req) => {
  console.log("[daily-9am-weather-dispatcher] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);

    // Get users with weather OR location enabled (need location to know their city)
    const { data: metricRows, error: metricErr } = await supabase
      .from("metric_settings")
      .select("user_id, metric")
      .eq("enabled", true)
      .in("metric", ["weather", "location"]);

    if (metricErr) throw new Error(`metric_settings query failed: ${metricErr.message}`);

    // Group by user - need both location AND weather enabled
    const userMetrics = new Map<string, Set<string>>();
    for (const row of metricRows ?? []) {
      const userId = String(row.user_id);
      if (!userMetrics.has(userId)) userMetrics.set(userId, new Set());
      userMetrics.get(userId)!.add(row.metric);
    }

    // Filter to users with location enabled (weather is optional - we'll still fetch for them)
    const eligibleUsers = [...userMetrics.entries()]
      .filter(([_, metrics]) => metrics.has("location"))
      .map(([userId]) => userId);

    console.log(`[daily-9am-weather-dispatcher] ${eligibleUsers.length} eligible users`);

    const results = await mapLimit(eligibleUsers, 10, async (userId) => {
      try {
        // Resolve timezone
        const timezone = await resolveTimezone(supabase, userId, utcDate);
        if (!timezone) {
          return { userId, status: "no_timezone" };
        }

        // Check if 9:00-9:10 AM local time
        const { localDate, hh, mm } = getLocalTimeParts(timezone, nowUtc);
        if (hh !== 9 || mm > 10) {
          return { userId, status: "not_9am", localHour: hh };
        }

        // Queue job for TODAY (weather is fetched for current day)
        const { error: upsertErr } = await supabase
          .from("sync_jobs_weather")
          .upsert(
            {
              user_id: userId,
              local_date: localDate,
              timezone: timezone,
              status: "queued",
              attempts: 0,
              updated_at: new Date().toISOString(),
            },
            { onConflict: "user_id,local_date", ignoreDuplicates: true }
          );

        if (upsertErr) {
          return { userId, status: "queue_error", error: upsertErr.message };
        }

        return { userId, status: "queued", date: localDate, timezone };

      } catch (e: any) {
        return { userId, status: "error", error: String(e?.message ?? e) };
      }
    });

    const summary = {
      total: results.length,
      queued: results.filter((r: any) => r.status === "queued").length,
      not9am: results.filter((r: any) => r.status === "not_9am").length,
      noTimezone: results.filter((r: any) => r.status === "no_timezone").length,
      errors: results.filter((r: any) => r.status === "error" || r.status === "queue_error").length,
    };

    console.log("[daily-9am-weather-dispatcher] done", summary);

    return jsonResponse({ ok: true, summary, results });

  } catch (e: any) {
    console.error("[daily-9am-weather-dispatcher] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: enqueue-login-backfill.txt =====

// supabase/functions/enqueue-login-backfill/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type ResolveRow = {
  city_id: number;
  timezone: string | null;
  resolved_date?: string | null;
};

type MetricSettingRow = {
  user_id: string;
  metric: string;
  enabled: boolean;
  preferred_source: string | null;
  allowed_sources: string[] | null;
};

type SyncJobInsert = {
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  updated_at: string;
  created_by: string;
  timezone: string;
  city_id: number | null;
  attempts?: number;
  locked_at?: string | null;
  last_error?: string | null;
};

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    // Direct query to user_location_daily - no RPC needed!
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone, date")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) {
      throw new Error(`user_location_daily query failed for date=${d}: ${error.message}`);
    }

    if (data?.timezone) {
      const row: ResolveRow = {
        city_id: null,  // No longer needed
        timezone: data.timezone,
        resolved_date: data.date
      };
      return { row, usedDate: data.date };
    }
  }

  return { row: null, usedDate: null };
}
async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    // Direct query to user_location_daily - no RPC needed!
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone, date")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) {
      throw new Error(`user_location_daily query failed for date=${d}: ${error.message}`);
    }

    if (data?.timezone) {
      const row: ResolveRow = {
        city_id: null,  // No longer needed
        timezone: data.timezone,
        resolved_date: data.date
      };
      return { row, usedDate: data.date };
    }
  }

  return { row: null, usedDate: null };
}
async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    // Direct query to user_location_daily - no RPC needed!
    const { data, error } = await supabase
      .from("user_location_daily")
      .select("timezone, date")
      .eq("user_id", userId)
      .eq("date", d)
      .not("timezone", "is", null)
      .order("updated_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) {
      throw new Error(`user_location_daily query failed for date=${d}: ${error.message}`);
    }

    if (data?.timezone) {
      const row: ResolveRow = {
        city_id: null,  // No longer needed
        timezone: data.timezone,
        resolved_date: data.date
      };
      return { row, usedDate: data.date };
    }
  }

  return { row: null, usedDate: null };
}


===== TITLE: fetch_bucket.txt =====

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type City = { id: number; lat: number; lon: number; timezone: string | null };

// Hardcode your project URL to avoid extra secrets
const SB_URL = "https://qykflarpibofvffmzghi.supabase.co";
// Keep using the service-role key from function secrets
const SB_KEY = Deno.env.get("SB_SERVICE_ROLE_KEY")!;

const sb = createClient(SB_URL, SB_KEY);

function bad(status: number, msg: string) {
  return new Response(msg, { status });
}

serve(async (req) => {
  try {
    // bucket can be in query (?bucket=5) or JSON body { "bucket": 5 }
    const url = new URL(req.url);
    let bucket = Number(url.searchParams.get("bucket"));
    if (!bucket) {
      const body = await req.json().catch(() => ({}));
      bucket = Number(body?.bucket);
    }
    if (!Number.isInteger(bucket) || bucket < 1 || bucket > 12) {
      return bad(400, "bucket=1.12 required");
    }

    const { data: cities, error } = await sb
      .from("city")
      .select("id,lat,lon,timezone")
      .eq("bucket", bucket)
      .returns<City[]>();
    if (error) return bad(500, error.message);
    if (!cities?.length)
      return new Response(JSON.stringify({ bucket, ok: 0, err: 0 }), {
        headers: { "content-type": "application/json" },
      });

    let ok = 0,
      err = 0;
    for (const c of cities) {
      try {
        const tz = c.timezone ?? "auto";
        const u = new URL("https://api.open-meteo.com/v1/forecast");
        u.searchParams.set("latitude", String(c.lat));
        u.searchParams.set("longitude", String(c.lon));
        u.searchParams.set(
          "daily",
          "temperature_2m_min,temperature_2m_max,temperature_2m_mean,surface_pressure_mean,surface_pressure_min,surface_pressure_max,relative_humidity_2m_mean,relative_humidity_2m_min,relative_humidity_2m_max,uv_index_max,wind_speed_10m_mean,wind_speed_10m_max,weathercode",
        );
        u.searchParams.set("past_days", "2");
        u.searchParams.set("forecast_days", "7");
        u.searchParams.set("timezone", tz);

        const resp = await fetch(u.toString(), {
          headers: { accept: "application/json" },
        });
        if (!resp.ok) throw new Error(`open-meteo ${resp.status}`);
        const d = (await resp.json())?.daily;
        if (!d?.time) throw new Error("missing daily block");

        const { error: rpcErr } = await sb.rpc("upsert_city_weather_batch", {
          p_city_id: c.id,
          p_days: d.time,
          p_tmin: d.temperature_2m_min,
          p_tmax: d.temperature_2m_max,
          p_tmean: d.temperature_2m_mean,
          p_pmean: d.surface_pressure_mean,
          p_pmin: d.surface_pressure_min,
          p_pmax: d.surface_pressure_max,
          p_hmean: d.relative_humidity_2m_mean,
          p_hmin: d.relative_humidity_2m_min,
          p_hmax: d.relative_humidity_2m_max,
          p_uv_max: d.uv_index_max,
          p_wind_mean: d.wind_speed_10m_mean,
          p_wind_max: d.wind_speed_10m_max,
          p_weather_code: d.weathercode,
        });
        if (rpcErr) throw rpcErr;
        ok++;
      } catch {
        err++;
      }
    }
    return new Response(JSON.stringify({ bucket, ok, err }), {
      headers: { "content-type": "application/json" },
    });
  } catch (e) {
    return bad(500, String(e));
  }
});


===== TITLE: noise-index-worker.txt =====

// FILE: supabase/functions/noise-index-worker/index.ts
//
// Worker that processes jobs from sync_jobs_noise.
// Aggregates samples from ambient_noise_samples into ambient_noise_index_daily.
// Computes baseline from past 14 days and calculates value_index_pct.

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function parseGmtOffsetToMinutes(gmt: string): number | null {
  const raw = (gmt ?? "").trim().toUpperCase();
  if (raw === "GMT" || raw === "UTC" || raw === "UT") return 0;

  const m = raw.match(/(?:GMT|UTC)?\s*([+-])\s*(\d{1,2})(?::?(\d{2}))?$/);
  if (!m) return null;

  const sign = m[1] === "-" ? -1 : 1;
  const hh = Number(m[2]);
  const mm = m[3] ? Number(m[3]) : 0;
  return sign * (hh * 60 + mm);
}

function getOffsetMinutesForInstant(timeZone: string, instant: Date): number {
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone,
    timeZoneName: "shortOffset",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
  const parts = fmt.formatToParts(instant);
  const tzPart = parts.find((p) => p.type === "timeZoneName")?.value ?? "";
  const mins = parseGmtOffsetToMinutes(tzPart);
  if (mins == null) throw new Error(`Could not parse timezone offset "${tzPart}" for tz=${timeZone}`);
  return mins;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

/**
 * Convert local date to UTC timestamp range for that entire day
 */
function getUtcRangeForLocalDate(
  timeZone: string,
  localDate: string
): { startUtc: string; endUtc: string } {
  const [y, m, d] = localDate.split("-").map(Number);

  // Start of day (00:00:00) in local time
  const startLocal = new Date(Date.UTC(y, m - 1, d, 0, 0, 0));
  const startOffset = getOffsetMinutesForInstant(timeZone, startLocal);
  const startUtc = new Date(startLocal.getTime() - startOffset * 60_000);

  // End of day (23:59:59.999) in local time
  const endLocal = new Date(Date.UTC(y, m - 1, d, 23, 59, 59, 999));
  const endOffset = getOffsetMinutesForInstant(timeZone, endLocal);
  const endUtc = new Date(endLocal.getTime() - endOffset * 60_000);

  return {
    startUtc: startUtc.toISOString(),
    endUtc: endUtc.toISOString(),
  };
}

/**
 * Calculate value_index_pct: how today compares to baseline
 * 0 = quietest (at or below baseline), 100 = loudest (significantly above baseline)
 */
function calculateIndexPct(
  dayMeanLmean: number,
  baselineMeanLmean: number | null,
  baselineDays: number
): number {
  // If no baseline or insufficient data, return 100 (assume it's notable)
  if (baselineMeanLmean == null || baselineDays < 3) {
    return 100;
  }

  // Calculate how much louder today is vs baseline
  // Using a simple ratio approach
  const diff = dayMeanLmean - baselineMeanLmean;
  
  if (diff <= 0) {
    // At or below baseline = quiet day
    return 0;
  }

  // Scale: if diff > 2.0 (log scale), consider it 100%
  // This is roughly 7x louder in linear scale
  const maxDiff = 2.0;
  const pct = Math.min(100, Math.round((diff / maxDiff) * 100));
  
  return pct;
}

serve(async (req) => {
  console.log("[noise-index-worker] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowIso = new Date().toISOString();
    const MAX_ATTEMPTS = 3;
    const BATCH_SIZE = 20;
    const BASELINE_DAYS = 14;

    // Fetch queued jobs
    const { data: jobs, error: jobsErr } = await supabase
      .from("sync_jobs_noise")
      .select("*")
      .eq("status", "queued")
      .lt("attempts", MAX_ATTEMPTS)
      .order("created_at", { ascending: true })
      .limit(BATCH_SIZE);

    if (jobsErr) throw new Error(`Failed to fetch jobs: ${jobsErr.message}`);

    if (!jobs || jobs.length === 0) {
      console.log("[noise-index-worker] no queued jobs");
      return jsonResponse({ ok: true, processed: 0 });
    }

    console.log(`[noise-index-worker] processing ${jobs.length} jobs`);

    const results: { jobId: string; status: string; error?: string; sampleCount?: number }[] = [];

    for (const job of jobs) {
      const jobId = job.id;
      const userId = job.user_id;
      const localDate = job.local_date;
      const timezone = job.timezone;

      try {
        // Mark as processing
        await supabase
          .from("sync_jobs_noise")
          .update({ status: "processing", attempts: job.attempts + 1, updated_at: nowIso })
          .eq("id", jobId);

        // Get UTC range for the local date
        const { startUtc, endUtc } = getUtcRangeForLocalDate(timezone, localDate);

        console.log(`[noise-index-worker] job=${jobId} user=${userId} date=${localDate} range=${startUtc} to ${endUtc}`);

        // Fetch noise samples for this user and date range
        const { data: samples, error: samplesErr } = await supabase
          .from("ambient_noise_samples")
          .select("l_mean, l_p90, l_max, duration_s")
          .eq("user_id", userId)
          .gte("start_ts", startUtc)
          .lte("start_ts", endUtc);

        if (samplesErr) {
          throw new Error(`Failed to fetch samples: ${samplesErr.message}`);
        }

        // Calculate day metrics (even if no samples, we record 0)
        let dayMeanLmean: number | null = null;
        let dayMeanLp90: number | null = null;
        let dayMaxLmax: number | null = null;
        const samplesCount = samples?.length ?? 0;

        if (samples && samples.length > 0) {
          const lMeanValues = samples.map((s: any) => s.l_mean as number);
          const lP90Values = samples.filter((s: any) => s.l_p90 != null).map((s: any) => s.l_p90 as number);
          const lMaxValues = samples.filter((s: any) => s.l_max != null).map((s: any) => s.l_max as number);

          dayMeanLmean = lMeanValues.reduce((a, b) => a + b, 0) / lMeanValues.length;
          dayMeanLp90 = lP90Values.length > 0
            ? lP90Values.reduce((a, b) => a + b, 0) / lP90Values.length
            : null;
          dayMaxLmax = lMaxValues.length > 0 ? Math.max(...lMaxValues) : null;
        }

        // Fetch baseline from past 14 days (excluding today)
        const baselineStartDate = addDaysIsoDate(localDate, -BASELINE_DAYS);
        const baselineEndDate = addDaysIsoDate(localDate, -1);

        const { data: baselineRows, error: baselineErr } = await supabase
          .from("ambient_noise_index_daily")
          .select("day_mean_lmean, day_mean_lp90, day_max_lmax")
          .eq("user_id", userId)
          .gte("date", baselineStartDate)
          .lte("date", baselineEndDate)
          .not("day_mean_lmean", "is", null);

        if (baselineErr) {
          console.warn(`[noise-index-worker] baseline query failed: ${baselineErr.message}`);
        }

        // Calculate baseline metrics
        let baselineDays = 0;
        let baselineMeanLmean: number | null = null;
        let baselineMeanLp90: number | null = null;
        let baselineMaxLmax: number | null = null;

        if (baselineRows && baselineRows.length > 0) {
          baselineDays = baselineRows.length;
          
          const blLmean = baselineRows.map((r: any) => Number(r.day_mean_lmean)).filter((v) => !isNaN(v));
          const blLp90 = baselineRows.filter((r: any) => r.day_mean_lp90 != null).map((r: any) => Number(r.day_mean_lp90));
          const blLmax = baselineRows.filter((r: any) => r.day_max_lmax != null).map((r: any) => Number(r.day_max_lmax));

          if (blLmean.length > 0) {
            baselineMeanLmean = blLmean.reduce((a, b) => a + b, 0) / blLmean.length;
          }
          if (blLp90.length > 0) {
            baselineMeanLp90 = blLp90.reduce((a, b) => a + b, 0) / blLp90.length;
          }
          if (blLmax.length > 0) {
            baselineMaxLmax = Math.max(...blLmax);
          }
        }

        // Calculate index percentage
        const valueIndexPct = dayMeanLmean != null
          ? calculateIndexPct(dayMeanLmean, baselineMeanLmean, baselineDays)
          : 0;

        // Upsert to ambient_noise_index_daily
        const { error: upsertErr } = await supabase
          .from("ambient_noise_index_daily")
          .upsert(
            {
              user_id: userId,
              date: localDate,
              source: "computed",
              value_index_pct: valueIndexPct,
              samples_count: samplesCount,
              day_mean_lmean: dayMeanLmean,
              day_mean_lp90: dayMeanLp90,
              day_max_lmax: dayMaxLmax,
              baseline_days: baselineDays,
              baseline_mean_lmean: baselineMeanLmean,
              baseline_mean_lp90: baselineMeanLp90,
              baseline_max_lmax: baselineMaxLmax,
              computed_at: nowIso,
              updated_at: nowIso,
            },
            { onConflict: "user_id,date" }
          );

        if (upsertErr) {
          throw new Error(`Failed to upsert daily index: ${upsertErr.message}`);
        }

        // Mark job as done
        await supabase
          .from("sync_jobs_noise")
          .update({ status: "done", updated_at: nowIso })
          .eq("id", jobId);

        results.push({ jobId, status: "done", sampleCount: samplesCount });
        console.log(`[noise-index-worker] job=${jobId} done, ${samplesCount} samples, index=${valueIndexPct}%`);

      } catch (e: any) {
        console.error(`[noise-index-worker] job=${jobId} error:`, e);

        // Mark as failed or back to queued for retry
        const newStatus = job.attempts + 1 >= MAX_ATTEMPTS ? "failed" : "queued";
        await supabase
          .from("sync_jobs_noise")
          .update({
            status: newStatus,
            last_error: String(e?.message ?? e),
            updated_at: nowIso,
          })
          .eq("id", jobId);

        results.push({ jobId, status: "error", error: String(e?.message ?? e) });
      }
    }

    const summary = {
      total: results.length,
      done: results.filter((r) => r.status === "done").length,
      errors: results.filter((r) => r.status === "error").length,
    };

    console.log("[noise-index-worker] done", summary);

    return jsonResponse({ ok: true, summary, results });

  } catch (e: any) {
    console.error("[noise-index-worker] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: nutrition-daily-worker.txt =====

// FILE: supabase/functions/nutrition-daily-worker/index.ts
//
// Worker that processes jobs from sync_jobs_nutrition.
// Reads nutrition_records for a user/date window, aggregates them,
// and upserts to nutrition_daily.
//
// Pattern copied from noise-index-worker

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type SyncJobRow = {
  id: string | number;
  user_id: string;
  local_date: string;
  timezone: string;
  status: string;
  attempts: number;
  locked_at: string | null;
};

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function parseGmtOffsetToMinutes(gmt: string): number | null {
  const raw = (gmt ?? "").trim().toUpperCase();
  if (raw === "GMT" || raw === "UTC" || raw === "UT") return 0;

  const m = raw.match(/(?:GMT|UTC)?\s*([+-])\s*(\d{1,2})(?::?(\d{2}))?$/);
  if (!m) return null;

  const sign = m[1] === "-" ? -1 : 1;
  const hh = Number(m[2]);
  const mm = m[3] ? Number(m[3]) : 0;
  return sign * (hh * 60 + mm);
}

function getOffsetMinutesForInstant(timeZone: string, instant: Date): number {
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone,
    timeZoneName: "shortOffset",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
  const parts = fmt.formatToParts(instant);
  const tzPart = parts.find((p) => p.type === "timeZoneName")?.value ?? "";
  const mins = parseGmtOffsetToMinutes(tzPart);
  if (mins == null) throw new Error(`Could not parse timezone offset "${tzPart}" for tz=${timeZone}`);
  return mins;
}

function localDateTimeToUtcIso(
  timeZone: string,
  y: number,
  m: number,
  d: number,
  hh: number,
  mm: number,
  ss: number,
): string {
  const baseUtc = Date.UTC(y, m - 1, d, hh, mm, ss);
  let guess = baseUtc;

  // converge offset for DST transitions
  for (let i = 0; i < 3; i++) {
    const offsetMin = getOffsetMinutesForInstant(timeZone, new Date(guess));
    guess = baseUtc - offsetMin * 60_000;
  }

  return new Date(guess).toISOString();
}

function numOrNull(v: unknown): number | null {
  const n = typeof v === "number" ? v : typeof v === "string" ? Number(v) : NaN;
  return Number.isFinite(n) ? n : null;
}

serve(async (req) => {
  console.log("[nutrition-daily-worker] start", { nowUtc: new Date().toISOString(), method: req.method, url: req.url });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "nutrition-daily-worker" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const staleCutoffIso = new Date(nowUtc.getTime() - 30 * 60_000).toISOString();

    // Pick nutrition jobs
    const { data: jobs, error: jobsErr } = await supabase
      .from("sync_jobs_nutrition")
      .select("id,user_id,local_date,timezone,status,attempts,locked_at")
      .or(`status.eq.queued,status.eq.running.and(locked_at.lt.${staleCutoffIso})`)
      .order("local_date", { ascending: true })
      .order("created_at", { ascending: true })
      .limit(50);

    if (jobsErr) throw new Error(`sync_jobs_nutrition select failed: ${jobsErr.message}`);

    const picked = (jobs ?? []) as SyncJobRow[];
    if (!picked.length) {
      return jsonResponse({ ok: true, summary: { picked: 0, nowUtc: nowIso } });
    }

    async function lockJob(job: SyncJobRow): Promise<boolean> {
      const lockIso = new Date().toISOString();

      if (job.status === "queued") {
        const { data, error } = await supabase
          .from("sync_jobs_nutrition")
          .update({ status: "running", locked_at: lockIso, updated_at: lockIso, last_error: null })
          .eq("id", job.id)
          .eq("status", "queued")
          .select("id")
          .maybeSingle();

        if (error) return false;
        return Boolean(data);
      }

      const { data, error } = await supabase
        .from("sync_jobs_nutrition")
        .update({ status: "running", locked_at: lockIso, updated_at: lockIso })
        .eq("id", job.id)
        .eq("status", "running")
        .lt("locked_at", staleCutoffIso)
        .select("id")
        .maybeSingle();

      if (error) return false;
      return Boolean(data);
    }

    async function bumpAttempts(jobId: string | number): Promise<number> {
      const { data: row, error: selErr } = await supabase.from("sync_jobs_nutrition").select("attempts").eq("id", jobId).maybeSingle();
      if (selErr) throw new Error(`bump_attempts_select_failed: ${selErr.message}`);

      const current = typeof (row as any)?.attempts === "number" ? (row as any).attempts : 0;
      const next = current + 1;

      const { error: updErr } = await supabase
        .from("sync_jobs_nutrition")
        .update({ attempts: next, updated_at: new Date().toISOString() })
        .eq("id", jobId);

      if (updErr) throw new Error(`bump_attempts_update_failed: ${updErr.message}`);

      return next;
    }

    async function markJobDone(jobId: string | number) {
      const endIso = new Date().toISOString();
      await supabase.from("sync_jobs_nutrition").update({ status: "done", finished_at: endIso, updated_at: endIso, locked_at: null }).eq("id", jobId);
    }

    async function markJobError(jobId: string | number, errMsg: string) {
      const endIso = new Date().toISOString();
      await supabase
        .from("sync_jobs_nutrition")
        .update({ status: "error", last_error: errMsg, finished_at: endIso, updated_at: endIso, locked_at: null })
        .eq("id", jobId);
    }

    async function process(job: SyncJobRow) {
      const locked = await lockJob(job);
      if (!locked) return { jobId: job.id, status: "skipped_lock_race" };

      const userId = String(job.user_id);
      const jobLocalDate = String(job.local_date);
      const tz = job.timezone;

      try {
        await bumpAttempts(job.id);

        if (!tz) {
          await markJobError(job.id, "no_timezone");
          return { jobId: job.id, userId, date: jobLocalDate, status: "no_timezone" };
        }

        // 24h window: midnight to midnight local time for the given date
        const [y, m, d] = jobLocalDate.split("-").map((x) => Number(x));
        const windowStartUtcIso = localDateTimeToUtcIso(tz, y, m, d, 0, 0, 0);
        const windowEndUtcIso = localDateTimeToUtcIso(tz, y, m, d, 23, 59, 59);

        // Pull nutrition records in window
        const { data: rows, error } = await supabase
          .from("nutrition_records")
          .select(`
            id, timestamp, meal_type,
            calories, protein, total_carbohydrate, total_fat,
            dietary_fiber, sugar, saturated_fat, unsaturated_fat,
            monounsaturated_fat, polyunsaturated_fat, trans_fat, cholesterol,
            calcium, chloride, chromium, copper, iodine, iron,
            magnesium, manganese, molybdenum, phosphorus, potassium,
            selenium, sodium, zinc,
            vitamin_a, vitamin_b6, vitamin_b12, vitamin_c, vitamin_d,
            vitamin_e, vitamin_k, biotin, folate, folic_acid,
            niacin, pantothenic_acid, riboflavin, thiamin,
            caffeine
          `)
          .eq("user_id", userId)
          .gte("timestamp", windowStartUtcIso)
          .lte("timestamp", windowEndUtcIso)
          .order("timestamp", { ascending: true });

        if (error) throw new Error(`nutrition_records query failed: ${error.message}`);

        const records = (rows ?? []) as any[];

        // Aggregate values - initialize all totals
        const totals = {
          calories: 0,
          protein: 0,
          carbs: 0,
          fat: 0,
          fiber: 0,
          sugar: 0,
          saturatedFat: 0,
          unsaturatedFat: 0,
          monounsaturatedFat: 0,
          polyunsaturatedFat: 0,
          transFat: 0,
          cholesterol: 0,
          // Minerals
          calcium: 0,
          chloride: 0,
          chromium: 0,
          copper: 0,
          iodine: 0,
          iron: 0,
          magnesium: 0,
          manganese: 0,
          molybdenum: 0,
          phosphorus: 0,
          potassium: 0,
          selenium: 0,
          sodium: 0,
          zinc: 0,
          // Vitamins
          vitaminA: 0,
          vitaminB6: 0,
          vitaminB12: 0,
          vitaminC: 0,
          vitaminD: 0,
          vitaminE: 0,
          vitaminK: 0,
          biotin: 0,
          folate: 0,
          folicAcid: 0,
          niacin: 0,
          pantothenicAcid: 0,
          riboflavin: 0,
          thiamin: 0,
          // Other
          caffeine: 0,
        };

        const mealTypes = new Set<string>();
        let recordCount = 0;

        for (const r of records) {
          recordCount++;

          // Helper to add to total
          const add = (key: keyof typeof totals, val: unknown) => {
            const n = numOrNull(val);
            if (n != null) totals[key] += n;
          };

          // Macros
          add("calories", r?.calories);
          add("protein", r?.protein);
          add("carbs", r?.total_carbohydrate);
          add("fat", r?.total_fat);
          add("fiber", r?.dietary_fiber);
          add("sugar", r?.sugar);
          add("saturatedFat", r?.saturated_fat);
          add("unsaturatedFat", r?.unsaturated_fat);
          add("monounsaturatedFat", r?.monounsaturated_fat);
          add("polyunsaturatedFat", r?.polyunsaturated_fat);
          add("transFat", r?.trans_fat);
          add("cholesterol", r?.cholesterol);

          // Minerals
          add("calcium", r?.calcium);
          add("chloride", r?.chloride);
          add("chromium", r?.chromium);
          add("copper", r?.copper);
          add("iodine", r?.iodine);
          add("iron", r?.iron);
          add("magnesium", r?.magnesium);
          add("manganese", r?.manganese);
          add("molybdenum", r?.molybdenum);
          add("phosphorus", r?.phosphorus);
          add("potassium", r?.potassium);
          add("selenium", r?.selenium);
          add("sodium", r?.sodium);
          add("zinc", r?.zinc);

          // Vitamins
          add("vitaminA", r?.vitamin_a);
          add("vitaminB6", r?.vitamin_b6);
          add("vitaminB12", r?.vitamin_b12);
          add("vitaminC", r?.vitamin_c);
          add("vitaminD", r?.vitamin_d);
          add("vitaminE", r?.vitamin_e);
          add("vitaminK", r?.vitamin_k);
          add("biotin", r?.biotin);
          add("folate", r?.folate);
          add("folicAcid", r?.folic_acid);
          add("niacin", r?.niacin);
          add("pantothenicAcid", r?.pantothenic_acid);
          add("riboflavin", r?.riboflavin);
          add("thiamin", r?.thiamin);

          // Other
          add("caffeine", r?.caffeine);

          const mealType = r?.meal_type;
          if (mealType && mealType !== "unknown") mealTypes.add(mealType);
        }

        const mealCount = mealTypes.size;
        const computedAt = new Date().toISOString();

        // Helper: return value or null if no records
        const valOrNull = (v: number) => recordCount > 0 ? v : null;

        // Upsert to nutrition_daily
        const { error: upErr } = await supabase
          .from("nutrition_daily")
          .upsert(
            {
              user_id: userId,
              date: jobLocalDate,
              source: "computed",

              // Energy
              total_calories: valOrNull(totals.calories),

              // Macros
              total_protein_g: valOrNull(totals.protein),
              total_carbs_g: valOrNull(totals.carbs),
              total_fat_g: valOrNull(totals.fat),
              total_fiber_g: valOrNull(totals.fiber),
              total_sugar_g: valOrNull(totals.sugar),
              total_saturated_fat_g: valOrNull(totals.saturatedFat),
              total_unsaturated_fat_g: valOrNull(totals.unsaturatedFat),
              total_monounsaturated_fat_g: valOrNull(totals.monounsaturatedFat),
              total_polyunsaturated_fat_g: valOrNull(totals.polyunsaturatedFat),
              total_trans_fat_g: valOrNull(totals.transFat),
              total_cholesterol_mg: valOrNull(totals.cholesterol),

              // Minerals
              total_calcium_mg: valOrNull(totals.calcium),
              total_chloride_mg: valOrNull(totals.chloride),
              total_chromium_mcg: valOrNull(totals.chromium),
              total_copper_mg: valOrNull(totals.copper),
              total_iodine_mcg: valOrNull(totals.iodine),
              total_iron_mg: valOrNull(totals.iron),
              total_magnesium_mg: valOrNull(totals.magnesium),
              total_manganese_mg: valOrNull(totals.manganese),
              total_molybdenum_mcg: valOrNull(totals.molybdenum),
              total_phosphorus_mg: valOrNull(totals.phosphorus),
              total_potassium_mg: valOrNull(totals.potassium),
              total_selenium_mcg: valOrNull(totals.selenium),
              total_sodium_mg: valOrNull(totals.sodium),
              total_zinc_mg: valOrNull(totals.zinc),

              // Vitamins
              total_vitamin_a_mcg: valOrNull(totals.vitaminA),
              total_vitamin_b6_mg: valOrNull(totals.vitaminB6),
              total_vitamin_b12_mcg: valOrNull(totals.vitaminB12),
              total_vitamin_c_mg: valOrNull(totals.vitaminC),
              total_vitamin_d_mcg: valOrNull(totals.vitaminD),
              total_vitamin_e_mg: valOrNull(totals.vitaminE),
              total_vitamin_k_mcg: valOrNull(totals.vitaminK),
              total_biotin_mcg: valOrNull(totals.biotin),
              total_folate_mcg: valOrNull(totals.folate),
              total_folic_acid_mcg: valOrNull(totals.folicAcid),
              total_niacin_mg: valOrNull(totals.niacin),
              total_pantothenic_acid_mg: valOrNull(totals.pantothenicAcid),
              total_riboflavin_mg: valOrNull(totals.riboflavin),
              total_thiamin_mg: valOrNull(totals.thiamin),

              // Other
              total_caffeine_mg: valOrNull(totals.caffeine),

              meal_count: mealCount,
              record_count: recordCount,

              computed_at: computedAt,
              created_at: computedAt,
              updated_at: computedAt,
            },
            { onConflict: "user_id,date,source" },
          );

        if (upErr) throw new Error(`nutrition_daily upsert failed: ${upErr.message}`);

        await markJobDone(job.id);

        return {
          jobId: job.id,
          status: "done",
          userId,
          date: jobLocalDate,
          timezone: tz,
          windowStartUtcIso,
          windowEndUtcIso,
          recordCount,
          mealCount,
          totalCalories: totals.calories,
          totalProtein: totals.protein,
          totalCarbs: totals.carbs,
          totalFat: totals.fat,
        };
      } catch (e) {
        const msg = (e as Error).message;
        await markJobError(job.id, msg);
        return { jobId: job.id, status: "error", error: msg, userId, date: jobLocalDate };
      }
    }

    const results: any[] = [];
    for (const j of picked) results.push(await process(j));

    const summary = {
      picked: picked.length,
      done: results.filter((r) => r.status === "done").length,
      errors: results.filter((r) => r.status === "error").length,
      nowUtc: nowIso,
    };

    return jsonResponse({ ok: true, summary, results });
  } catch (e) {
    console.log("[nutrition-daily-worker] fatal", { error: (e as Error).message });
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});


===== TITLE: send-fcm-push.txt =====

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const FIREBASE_SERVICE_ACCOUNT = JSON.parse(
  Deno.env.get("FIREBASE_SERVICE_ACCOUNT")!
);

// Get Firebase access token using service account
async function getFirebaseAccessToken(): Promise<string> {
  const now = Math.floor(Date.now() / 1000);
  const expiry = now + 3600;

  // Create JWT header and payload
  const header = { alg: "RS256", typ: "JWT" };
  const payload = {
    iss: FIREBASE_SERVICE_ACCOUNT.client_email,
    scope: "https://www.googleapis.com/auth/firebase.messaging",
    aud: "https://oauth2.googleapis.com/token",
    iat: now,
    exp: expiry,
  };

  // Encode to base64url
  const encoder = new TextEncoder();
  const headerB64 = btoa(JSON.stringify(header))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
  const payloadB64 = btoa(JSON.stringify(payload))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");

  const signatureInput = `${headerB64}.${payloadB64}`;

  // Import private key and sign
  const pemContents = FIREBASE_SERVICE_ACCOUNT.private_key
    .replace("-----BEGIN PRIVATE KEY-----", "")
    .replace("-----END PRIVATE KEY-----", "")
    .replace(/\s/g, "");

  const binaryKey = Uint8Array.from(atob(pemContents), (c) => c.charCodeAt(0));

  const cryptoKey = await crypto.subtle.importKey(
    "pkcs8",
    binaryKey,
    { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
    false,
    ["sign"]
  );

  const signature = await crypto.subtle.sign(
    "RSASSA-PKCS1-v1_5",
    cryptoKey,
    encoder.encode(signatureInput)
  );

  const signatureB64 = btoa(String.fromCharCode(...new Uint8Array(signature)))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");

  const jwt = `${signatureInput}.${signatureB64}`;

  // Exchange JWT for access token
  const tokenResponse = await fetch("https://oauth2.googleapis.com/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`,
  });

  const tokenData = await tokenResponse.json();
  return tokenData.access_token;
}

// Send FCM message to a single device
async function sendFcmMessage(
  accessToken: string,
  fcmToken: string,
  messageType: string
): Promise<boolean> {
  const projectId = FIREBASE_SERVICE_ACCOUNT.project_id;
  const url = `https://fcm.googleapis.com/v1/projects/${projectId}/messages:send`;

  const message = {
    message: {
      token: fcmToken,
      data: {
        type: messageType,
      },
      android: {
        priority: "high",
      },
    },
  };

  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(message),
  });

  if (!response.ok) {
    const error = await response.text();
    console.error(`FCM send failed for token ${fcmToken.slice(0, 20)}...: ${error}`);
    return false;
  }

  return true;
}

serve(async (req) => {
  try {
    // Allow both POST (manual trigger) and GET (cron trigger)
    const url = new URL(req.url);
    let messageType = "sync_hourly";

    if (req.method === "POST") {
      const body = await req.json();
      messageType = body.type || "sync_hourly";
    } else {
      messageType = url.searchParams.get("type") || "sync_hourly";
    }

    console.log(`Sending FCM push: type=${messageType}`);

    // Get all users with FCM tokens who have this metric enabled
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    // Map message type to metric name for filtering users
    // sync_health_connect checks if user has ANY health connect metric enabled
    const metricMap: Record<string, string> = {
      sync_hourly: "user_location_daily", // triggers location + screen time
      sync_location: "user_location_daily",
      sync_screen_time: "screen_time_daily",
      sync_weather: "weather",
      sync_noise: "ambient_noise_samples",
      sync_health_connect: "hrv_daily", // Use HRV as proxy - if they have HC connected, they'll have this
    };

    const metric = metricMap[messageType] || "user_location_daily";

    let enabledUserIds: Set<string>;

    if (messageType === "sync_health_connect") {
      // For Health Connect, get users who have ANY health_connect metric enabled
      const healthConnectMetrics = [
        "sleep_duration_daily",
        "hrv_daily",
        "resting_hr_daily",
        "steps_daily",
        "weight_daily",
        "body_fat_daily",
        "hydration_daily",
        "blood_pressure_daily",
        "blood_glucose_daily",
        "spo2_daily",
        "respiratory_rate_daily",
        "skin_temp_daily",
      ];

      const { data: enabledUsers, error: settingsError } = await supabase
        .from("metric_settings")
        .select("user_id")
        .in("metric", healthConnectMetrics)
        .eq("enabled", true)
        .eq("preferred_source", "health_connect");

      if (settingsError) {
        console.error("Error fetching metric_settings:", settingsError);
        return new Response(JSON.stringify({ error: settingsError.message }), {
          status: 500,
        });
      }

      enabledUserIds = new Set((enabledUsers || []).map((u) => u.user_id));
    } else {
      // Standard single metric check
      const { data: enabledUsers, error: settingsError } = await supabase
        .from("metric_settings")
        .select("user_id")
        .eq("metric", metric)
        .eq("enabled", true);

      if (settingsError) {
        console.error("Error fetching metric_settings:", settingsError);
        return new Response(JSON.stringify({ error: settingsError.message }), {
          status: 500,
        });
      }

      enabledUserIds = new Set((enabledUsers || []).map((u) => u.user_id));
    }

    console.log(`Found ${enabledUserIds.size} users with ${messageType} enabled`);

    if (enabledUserIds.size === 0) {
      return new Response(
        JSON.stringify({ success: true, sent: 0, message: "No users with metric enabled" }),
        { status: 200 }
      );
    }

    // Get FCM tokens for these users
    const { data: profiles, error: profilesError } = await supabase
      .from("profiles")
      .select("user_id, fcm_token")
      .not("fcm_token", "is", null);

    if (profilesError) {
      console.error("Error fetching profiles:", profilesError);
      return new Response(JSON.stringify({ error: profilesError.message }), {
        status: 500,
      });
    }

    // Filter to only users who have the metric enabled
    const tokensToSend = (profiles || [])
      .filter((p) => p.fcm_token && enabledUserIds.has(p.user_id))
      .map((p) => p.fcm_token);

    console.log(`Sending to ${tokensToSend.length} devices`);

    if (tokensToSend.length === 0) {
      return new Response(
        JSON.stringify({ success: true, sent: 0, message: "No FCM tokens found" }),
        { status: 200 }
      );
    }

    // Get Firebase access token
    const firebaseToken = await getFirebaseAccessToken();

    // Send to all devices
    let sent = 0;
    let failed = 0;

    for (const fcmToken of tokensToSend) {
      const success = await sendFcmMessage(firebaseToken, fcmToken, messageType);
      if (success) {
        sent++;
      } else {
        failed++;
      }
    }

    console.log(`FCM push complete: sent=${sent}, failed=${failed}`);

    return new Response(
      JSON.stringify({ success: true, sent, failed, type: messageType }),
      { status: 200 }
    );
  } catch (error) {
    console.error("FCM push error:", error);
    return new Response(JSON.stringify({ error: String(error) }), {
      status: 500,
    });
  }
});


===== TITLE: stress-worker.txt =====

// FILE: supabase/functions/stress-worker/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function median(xs: number[]): number | null {
  const a = xs.filter((n) => Number.isFinite(n)).slice().sort((p, q) => p - q);
  if (!a.length) return null;
  const mid = Math.floor(a.length / 2);
  return a.length % 2 ? a[mid] : (a[mid - 1] + a[mid]) / 2;
}

function mad(xs: number[], med: number): number | null {
  const dev = xs.map((x) => Math.abs(x - med)).filter((n) => Number.isFinite(n));
  return median(dev);
}

function robustZ(x: number, xs: number[]): number | null {
  const med = median(xs);
  if (med == null) return null;
  const m = mad(xs, med);
  if (m == null || m <= 1e-9) return null;
  const robustStd = 1.4826 * m;
  return (x - med) / robustStd;
}

function clamp(n: number, lo: number, hi: number): number {
  return Math.max(lo, Math.min(hi, n));
}

function zToPct(z: number): number {
  const pct = 100 / (1 + Math.exp(-z));
  return clamp(pct, 0, 100);
}

type SyncJobRow = {
  id: string;
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  attempts: number | null;
  locked_at: string | null;
};

async function insertBackendMetricRun(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  localDate: string,
): Promise<boolean> {
  const { error } = await supabase.from("backend_metric_runs").insert({
    user_id: userId,
    local_date: localDate,
    metric: "stress_index_daily",
    source: "computed",
  });

  if (!error) return true;

  const msg = (error.message ?? "").toLowerCase();
  if (msg.includes("duplicate") || msg.includes("unique")) return false;

  throw new Error(`backend_metric_runs insert failed: ${error.message}`);
}

async function lockJob(
  supabase: ReturnType<typeof createClient>,
  job: SyncJobRow,
  staleCutoffIso: string,
): Promise<boolean> {
  const nowIso = new Date().toISOString();

  if (job.status === "queued") {
    const { data, error } = await supabase
      .from("sync_jobs")
      .update({ status: "running", locked_at: nowIso, updated_at: nowIso, last_error: null })
      .eq("id", job.id)
      .eq("status", "queued")
      .select("id")
      .maybeSingle();

    if (error) return false;
    return Boolean(data);
  }

  const { data, error } = await supabase
    .from("sync_jobs")
    .update({ status: "running", locked_at: nowIso, updated_at: nowIso })
    .eq("id", job.id)
    .eq("status", "running")
    .lt("locked_at", staleCutoffIso)
    .select("id")
    .maybeSingle();

  if (error) return false;
  return Boolean(data);
}

async function bumpAttempts(supabase: ReturnType<typeof createClient>, jobId: string, current: number): Promise<number> {
  const next = current + 1;
  const { error } = await supabase
    .from("sync_jobs")
    .update({ attempts: next, updated_at: new Date().toISOString() })
    .eq("id", jobId);

  if (error) throw new Error(`attempts_update_failed: ${error.message}`);
  return next;
}

async function markJobDone(
  supabase: ReturnType<typeof createClient>,
  jobId: string,
  lastError: string | null,
  attempts: number,
) {
  const nowIso = new Date().toISOString();
  await supabase
    .from("sync_jobs")
    .update({
      status: "done",
      finished_at: nowIso,
      updated_at: nowIso,
      locked_at: null,
      last_error: lastError,
      attempts,
    })
    .eq("id", jobId);
}

async function markJobError(supabase: ReturnType<typeof createClient>, jobId: string, errMsg: string) {
  const nowIso = new Date().toISOString();
  await supabase
    .from("sync_jobs")
    .update({
      status: "error",
      finished_at: nowIso,
      updated_at: nowIso,
      locked_at: null,
      last_error: errMsg,
    })
    .eq("id", jobId);
}

async function computeOne(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  localDate: string,
): Promise<{ status: "written" | "already_done" | "skipped"; reason?: string; value?: number }> {
  const { data: stressSetting, error: msErr } = await supabase
    .from("metric_settings")
    .select("enabled")
    .eq("user_id", userId)
    .eq("metric", "stress_index_daily")
    .maybeSingle();

  if (msErr) throw new Error(`metric_settings read failed: ${msErr.message}`);
  if (!stressSetting?.enabled) return { status: "skipped", reason: "stress_index_disabled" };

  const [{ data: hrvRow, error: hrvErr }, { data: rhrRow, error: rhrErr }] = await Promise.all([
    supabase
      .from("hrv_daily")
      .select("value_rmssd_ms")
      .eq("user_id", userId)
      .eq("date", localDate)
      .limit(1)
      .maybeSingle(),
    supabase
      .from("resting_hr_daily")
      .select("value_bpm")
      .eq("user_id", userId)
      .eq("date", localDate)
      .limit(1)
      .maybeSingle(),
  ]);

  if (hrvErr) throw new Error(`hrv_daily read failed: ${hrvErr.message}`);
  if (rhrErr) throw new Error(`resting_hr_daily read failed: ${rhrErr.message}`);

  const hrv = typeof (hrvRow as any)?.value_rmssd_ms === "number" ? (hrvRow as any).value_rmssd_ms : null;
  const rhr = typeof (rhrRow as any)?.value_bpm === "number" ? (rhrRow as any).value_bpm : null;

  if (hrv == null || rhr == null) return { status: "skipped", reason: "missing_inputs" };

  const startDate = addDaysIsoDate(localDate, -14);
  const endDate = addDaysIsoDate(localDate, -1);

  const [{ data: hrvBase, error: hrvBaseErr }, { data: rhrBase, error: rhrBaseErr }] = await Promise.all([
    supabase
      .from("hrv_daily")
      .select("date,value_rmssd_ms")
      .eq("user_id", userId)
      .gte("date", startDate)
      .lte("date", endDate),
    supabase
      .from("resting_hr_daily")
      .select("date,value_bpm")
      .eq("user_id", userId)
      .gte("date", startDate)
      .lte("date", endDate),
  ]);

  if (hrvBaseErr) throw new Error(`hrv baseline read failed: ${hrvBaseErr.message}`);
  if (rhrBaseErr) throw new Error(`rhr baseline read failed: ${rhrBaseErr.message}`);

  const hrvXs = (hrvBase ?? [])
    .map((r: any) => (typeof r.value_rmssd_ms === "number" ? r.value_rmssd_ms : null))
    .filter((n: any) => typeof n === "number") as number[];

  const rhrXs = (rhrBase ?? [])
    .map((r: any) => (typeof r.value_bpm === "number" ? r.value_bpm : null))
    .filter((n: any) => typeof n === "number") as number[];

  if (hrvXs.length < 5 || rhrXs.length < 5) return { status: "skipped", reason: "insufficient_baseline" };

  const zRhr = robustZ(rhr, rhrXs);
  const zHrv = robustZ(hrv, hrvXs);
  if (zRhr == null || zHrv == null) return { status: "skipped", reason: "baseline_zero_variance" };

  const zCombined = (0.55 * zRhr) + (0.45 * (-zHrv));
  const stressValue = zToPct(zCombined);

  const proceed = await insertBackendMetricRun(supabase, userId, localDate);
  if (!proceed) return { status: "already_done" };

  const computedAt = new Date().toISOString();
  const baselineWindowDays = Math.min(hrvXs.length, rhrXs.length);

  const { error: upErr } = await supabase.from("stress_index_daily").upsert(
    {
      user_id: userId,
      date: localDate,
      value: stressValue,
      hrv_z: zHrv,
      rhr_z: zRhr,
      baseline_window_days: baselineWindowDays,
      computed_at: computedAt,
    },
    { onConflict: "user_id,date" },
  );

  if (upErr) throw new Error(`stress_index_daily upsert failed: ${upErr.message}`);

  return { status: "written", value: stressValue };
}

serve(async (req) => {
  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "stress-worker" } },
    });

    const nowUtc = new Date();
    const staleCutoffIso = new Date(nowUtc.getTime() - 30 * 60_000).toISOString();

    const { data: jobs, error: jobsErr } = await supabase
      .from("sync_jobs")
      .select("id,job_type,user_id,local_date,status,attempts,locked_at")
      .eq("job_type", "stress_index_daily")
      .or(`status.eq.queued,status.eq.running.and(locked_at.lt.${staleCutoffIso})`)
      .order("local_date", { ascending: true })
      .order("created_at", { ascending: true })
      .limit(50);

    if (jobsErr) throw new Error(`sync_jobs select failed: ${jobsErr.message}`);

    const picked = (jobs ?? []) as SyncJobRow[];

    const results: any[] = [];

    for (const job of picked) {
      const locked = await lockJob(supabase, job, staleCutoffIso);
      if (!locked) {
        results.push({ jobId: job.id, status: "skipped_lock_race" });
        continue;
      }

      const userId = String(job.user_id);
      const localDate = String(job.local_date);

      try {
        const currentAttempts = typeof job.attempts === "number" ? job.attempts : 0;
        const attempts = await bumpAttempts(supabase, job.id, currentAttempts);

        const out = await computeOne(supabase, userId, localDate);

        if (out.status === "written" || out.status === "already_done") {
          await markJobDone(supabase, job.id, null, attempts);
          results.push({ jobId: job.id, userId, localDate, status: "done", result: out.status, value: out.value ?? null });
        } else {
          await markJobDone(supabase, job.id, out.reason ?? "skipped", attempts);
          results.push({ jobId: job.id, userId, localDate, status: "done", reason: out.reason ?? "skipped" });
        }
      } catch (e) {
        const msg = (e as Error).message;
        await markJobError(supabase, job.id, msg);
        results.push({ jobId: job.id, status: "error", error: msg });
      }
    }

    const summary = {
      picked: picked.length,
      done: results.filter((r) => r.status === "done").length,
      errors: results.filter((r) => r.status === "error").length,
      nowUtc: nowUtc.toISOString(),
      jobType: "stress_index_daily",
      staleReclaimMinutes: 30,
      maxPickAttempts: 10,
    };

    return jsonResponse({ ok: true, summary, results });
  } catch (e) {
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});


===== TITLE: sync-worker.txt =====

// supabase/functions/sync-worker/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type ResolveRow = {
  city_id: number;
  timezone: string | null;
  resolved_date?: string | null;
};

type MetricSettingRow = {
  user_id: string;
  metric: string;
  enabled: boolean;
  preferred_source: string | null;
  allowed_sources: string[] | null;
};

type WhoopTokenRow = {
  user_id: string;
  access_token: string;
  refresh_token: string;
  token_type: string | null;
  expires_at: string | null; // timestamptz
};

type WhoopRecord = Record<string, unknown>;

type SyncJobRow = {
  id: string | number;
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  attempts: number;
  locked_at: string | null;
};

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function optionalEnv(name: string): string | null {
  return Deno.env.get(name) ?? null;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T, idx: number) => Promise<R>,
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const i = nextIndex++;
      if (i >= items.length) return;
      results[i] = await fn(items[i], i);
    }
  }

  const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
  await Promise.all(workers);
  return results;
}

function parseGmtOffsetToMinutes(gmt: string): number | null {
  const raw = (gmt ?? "").trim().toUpperCase();
  if (raw === "GMT" || raw === "UTC" || raw === "UT") return 0;

  const m = raw.match(/(?:GMT|UTC)?\s*([+-])\s*(\d{1,2})(?::?(\d{2}))?$/);
  if (!m) return null;

  const sign = m[1] === "-" ? -1 : 1;
  const hh = Number(m[2]);
  const mm = m[3] ? Number(m[3]) : 0;
  return sign * (hh * 60 + mm);
}

function getOffsetMinutesForInstant(timeZone: string, instant: Date): number {
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone,
    timeZoneName: "shortOffset",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
  const parts = fmt.formatToParts(instant);
  const tzPart = parts.find((p) => p.type === "timeZoneName")?.value ?? "";
  const mins = parseGmtOffsetToMinutes(tzPart);
  if (mins == null) {
    throw new Error(`Could not parse timezone offset "${tzPart}" for tz=${timeZone}`);
  }
  return mins;
}

function localDateTimeToUtcIso(
  timeZone: string,
  y: number,
  m: number,
  d: number,
  hh: number,
  mm: number,
  ss: number,
): string {
  const baseUtc = Date.UTC(y, m - 1, d, hh, mm, ss);
  let guess = baseUtc;

  for (let i = 0; i < 3; i++) {
    const offsetMin = getOffsetMinutesForInstant(timeZone, new Date(guess));
    guess = baseUtc - offsetMin * 60_000;
  }

  return new Date(guess).toISOString();
}

function getWhoopNoonWindowUtcIso(timeZone: string, localDate: string) {
  const prev = addDaysIsoDate(localDate, -1).split("-").map((x) => Number(x));
  const next = addDaysIsoDate(localDate, +1).split("-").map((x) => Number(x));

  const startUtcIso = localDateTimeToUtcIso(timeZone, prev[0], prev[1], prev[2], 12, 0, 0);
  const endUtcIso = localDateTimeToUtcIso(timeZone, next[0], next[1], next[2], 12, 0, 0);

  return { startUtcIso, endUtcIso };
}

async function whoopFetchJson(url: string, accessToken: string) {
  const res = await fetch(url, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      "Content-Type": "application/json",
      Accept: "application/json",
    },
  });

  const text = await res.text();
  if (!res.ok) {
    throw new Error(`WHOOP request failed (${res.status}): ${text}`);
  }
  try {
    return JSON.parse(text);
  } catch {
    throw new Error(`WHOOP response not JSON: ${text}`);
  }
}

async function whoopFetchPagedRecords(
  path: string,
  startUtcIso: string,
  endUtcIso: string,
  accessToken: string,
): Promise<WhoopRecord[]> {
  const base = "https://api.prod.whoop.com/developer/v2";
  const out: WhoopRecord[] = [];
  let nextToken: string | null = null;

  for (let page = 0; page < 20; page++) {
    const url = new URL(base + path);
    url.searchParams.set("start", startUtcIso);
    url.searchParams.set("end", endUtcIso);
    url.searchParams.set("limit", "25");
    if (nextToken) url.searchParams.set("nextToken", nextToken);

    const json = await whoopFetchJson(url.toString(), accessToken);

    const records = (json?.records ?? json?.data ?? json?.items) as unknown;
    if (Array.isArray(records)) {
      for (const r of records) out.push((r ?? {}) as WhoopRecord);
    }

    const ntRaw = (json?.next_token ?? json?.nextToken) as unknown;
    const nt = typeof ntRaw === "string" ? ntRaw : null;
    nextToken = nt && nt.toLowerCase() !== "null" && nt.trim() ? nt : null;

    if (!nextToken) break;
  }

  return out;
}

function isExpiredSoon(expiresAtIso: string | null, nowUtc: Date): boolean {
  // If expires_at is NULL or invalid, assume expired and refresh to be safe
  if (!expiresAtIso) return true;
  const exp = new Date(expiresAtIso).getTime();
  if (Number.isNaN(exp)) return true;
  return exp <= nowUtc.getTime() + 5 * 60_000;
}

// PATCHED: refresh wrapper (newline-safe)
// - strips \n and \r and trims refresh_token before sending to WHOOP
// - fails clearly if refresh_token is empty after sanitation
// - validates access_token exists
// - strips \n/\r from returned refresh_token as well
async function refreshWhoopToken(
  refreshTokenRaw: string,
): Promise<{ access_token: string; refresh_token: string; expires_in: number; token_type?: string }> {
  const clientId = requireEnv("WHOOP_CLIENT_ID");
  const clientSecret = requireEnv("WHOOP_CLIENT_SECRET");

  const refreshToken = String(refreshTokenRaw ?? "").replace(/\r?\n/g, "").replace(/\r/g, "").trim();
  if (!refreshToken) {
    throw new Error("WHOOP token refresh failed (400): refresh_token_empty");
  }

  const body = new URLSearchParams();
  body.set("grant_type", "refresh_token");
  body.set("refresh_token", refreshToken);
  body.set("client_id", clientId);
  body.set("client_secret", clientSecret);

  const res = await fetch("https://api.prod.whoop.com/oauth/oauth2/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body,
  });

  const text = await res.text();
  if (!res.ok) {
    throw new Error(`WHOOP token refresh failed (${res.status}): ${text}`);
  }

  const json = JSON.parse(text);

  const access = String(json.access_token ?? "").trim();
  if (!access) {
    throw new Error(`WHOOP token refresh failed (200): missing_access_token`);
  }

  const newRefresh = String(json.refresh_token ?? refreshToken).replace(/\r?\n/g, "").replace(/\r/g, "").trim();

  return {
    access_token: access,
    refresh_token: newRefresh,
    expires_in: Number(json.expires_in ?? 0),
    token_type: json.token_type ? String(json.token_type) : undefined,
  };
}

async function upsertDailyRow(
  supabase: ReturnType<typeof createClient>,
  table: string,
  row: Record<string, unknown>,
  onConflict = "user_id,date,source",
) {
  const { error } = await supabase.from(table).upsert(row, { onConflict });
  if (error) throw new Error(`Upsert to ${table} failed: ${error.message}`);
}

async function tryMarkMetricRan(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  localDate: string,
  metric: string,
  source: string,
): Promise<boolean> {
  const { error } = await supabase.from("backend_metric_runs").insert({
    user_id: userId,
    local_date: localDate,
    metric,
    source,
  });

  if (!error) return true;

  const msg = (error.message ?? "").toLowerCase();
  if (msg.includes("duplicate") || msg.includes("unique")) return false;

  throw new Error(`backend_metric_runs insert failed: ${error.message}`);
}

function numOrNull(v: unknown): number | null {
  const n = typeof v === "number" ? v : typeof v === "string" ? Number(v) : NaN;
  return Number.isFinite(n) ? n : null;
}

function intOrNull(v: unknown): number | null {
  const n = numOrNull(v);
  if (n == null) return null;
  return Math.trunc(n);
}

function whoopTzMinutes(rec: any): number {
  const a = numOrNull(rec?.timezone_offset_minutes);
  if (a != null) return a;
  const b = numOrNull(rec?.timezone_offset);
  if (b != null) return b / 60.0;
  return 0;
}

function whoopShiftedIso(rec: any, key: "start" | "end"): string | null {
  const utc = typeof rec?.[key] === "string" ? String(rec[key]) : "";
  if (!utc) return null;
  const tzMin = whoopTzMinutes(rec);
  const ms = new Date(utc).getTime();
  if (Number.isNaN(ms)) return null;
  return new Date(ms + tzMin * 60_000).toISOString();
}

function selectWhoopSleepRecordByWakeup(records: any[], targetLocalDate: string, timeZone: string): any | null {
  let bestExact: any | null = null;
  let latest: any | null = null;
  let latestEndLocalMs: number | null = null;

  for (const rec of records) {
    const endUtc = typeof rec?.end === "string" ? String(rec.end) : "";
    if (!endUtc) continue;

    const tzMin = whoopTzMinutes(rec);
    const endUtcMs = new Date(endUtc).getTime();
    if (Number.isNaN(endUtcMs)) continue;

    const endLocalMs = endUtcMs + tzMin * 60_000;
    const endLocalDate = getLocalTimeParts(timeZone, new Date(endLocalMs)).localDate;

    if (endLocalDate === targetLocalDate) bestExact = rec;

    if (latestEndLocalMs == null || endLocalMs > latestEndLocalMs) {
      latestEndLocalMs = endLocalMs;
      latest = rec;
    }
  }

  return bestExact ?? latest;
}

function whoopMeasureId(rec: any): string | null {
  const raw =
    rec?.id ??
    rec?.sleep_id ??
    rec?.recovery_id ??
    rec?.record_id ??
    rec?.activity_id ??
    rec?.cycle_id ??
    rec?.score_id ??
    rec?.score?.id ??
    rec?.summary?.id ??
    null;

  if (raw == null) return null;

  const s = String(raw).trim();
  return s ? s : null;
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  isoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(isoDate, -1), isoDate, addDaysIsoDate(isoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase.rpc("resolve_user_city_for_date", {
      p_user_id: userId,
      p_date: d,
    });

    if (error) throw new Error(`resolve_user_city_for_date failed for date=${d}: ${error.message}`);

    const row: ResolveRow | undefined = Array.isArray(data) ? data[0] : data;
    if (row?.timezone) return { row, usedDate: row.resolved_date ?? d };
  }

  return { row: null, usedDate: null };
}

function getForceFlag(req: Request): boolean {
  const url = new URL(req.url);
  const raw = url.searchParams.get("force");
  if (!raw) return false;
  return raw === "1" || raw.toLowerCase() === "true" || raw.toLowerCase() === "yes";
}

// Retry window: 9:00 - 9:45 local time
const RETRY_START_HOUR = 9;
const RETRY_END_HOUR = 9;
const RETRY_END_MINUTE = 45;

function isWithinRetryWindow(hh: number, mm: number): boolean {
  if (hh < RETRY_START_HOUR) return false;
  if (hh > RETRY_END_HOUR) return false;
  if (hh === RETRY_END_HOUR && mm > RETRY_END_MINUTE) return false;
  return true;
}

const MAX_PICK_ATTEMPTS = 10;

serve(async (req) => {
  console.log("[sync-worker] start", { nowUtc: new Date().toISOString(), method: req.method, url: req.url });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const whoopConfigured = Boolean(optionalEnv("WHOOP_CLIENT_ID") && optionalEnv("WHOOP_CLIENT_SECRET"));
    const force = getForceFlag(req);

    // Also check for force in request body (for webhook invocation)
    let bodyForce = false;
    let bodyUserId: string | null = null;
    try {
      const body = await req.clone().json();
      bodyForce = body?.force === true;
      bodyUserId = typeof body?.userId === "string" ? body.userId : null;
    } catch {
      // No body or invalid JSON
    }

    const isForced = force || bodyForce;

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "sync-worker" } },
    });

    const nowUtc = new Date();
    const utcDate = nowUtc.toISOString().slice(0, 10);
    const staleCutoffIso = new Date(nowUtc.getTime() - 30 * 60_000).toISOString();

    // NOTE: attempts gating prevents hot-looping and runaway attempts.
    // Force mode bypasses this gate.
    let jobsQuery = supabase
      .from("sync_jobs")
      .select("id,job_type,user_id,local_date,status,attempts,locked_at")
      .eq("job_type", "whoop_daily")
      .or(`status.eq.queued,status.eq.running.and(locked_at.lt.${staleCutoffIso})`)
      .order("local_date", { ascending: true })
      .order("created_at", { ascending: true })
      .limit(50);

    // If specific userId provided (from webhook), filter to just that user
    if (bodyUserId) {
      jobsQuery = jobsQuery.eq("user_id", bodyUserId);
    }

    const { data: jobs, error: jobsErr } = await jobsQuery;

    if (jobsErr) throw new Error(`sync_jobs select failed: ${jobsErr.message}`);

    const all = (jobs ?? []) as SyncJobRow[];

    // Filter attempts only here so we preserve the original select shape
    const picked = all.filter((j) => isForced || (j.attempts ?? 0) < MAX_PICK_ATTEMPTS);

    if (!picked.length) {
      return jsonResponse({
        ok: true,
        summary: {
          picked: 0,
          whoopClientConfigured: whoopConfigured,
          forced: isForced,
          maxPickAttempts: MAX_PICK_ATTEMPTS,
          filteredOut: all.length,
        },
      });
    }

    async function lockJob(job: SyncJobRow): Promise<boolean> {
      const nowIso = new Date().toISOString();

      // IMPORTANT:
      // Do NOT increment attempts here. We only increment when we actually attempt WHOOP fetch work.
      if (job.status === "queued") {
        const { data, error } = await supabase
          .from("sync_jobs")
          .update({
            status: "running",
            locked_at: nowIso,
            updated_at: nowIso,
            last_error: null,
          })
          .eq("id", job.id)
          .eq("status", "queued")
          .select("id")
          .maybeSingle();

        if (error) return false;
        return Boolean(data);
      }

      const { data, error } = await supabase
        .from("sync_jobs")
        .update({
          status: "running",
          locked_at: nowIso,
          updated_at: nowIso,
        })
        .eq("id", job.id)
        .eq("status", "running")
        .lt("locked_at", staleCutoffIso)
        .select("id")
        .maybeSingle();

      if (error) return false;
      return Boolean(data);
    }

    async function bumpAttempts(jobId: string | number): Promise<number> {
      // In supabase-js v2, rpc/from/select return builders; they do NOT support `.catch`.
      // We do explicit { data, error } checks.

      // Optional RPC path if you add it later:
      // create hookup:
      //   create or replace function public.increment_sync_job_attempts(p_job_id uuid) returns int ...
      const { data: rpcData, error: rpcErr } = await supabase.rpc("increment_sync_job_attempts", { p_job_id: jobId });

      if (!rpcErr) {
        // If RPC returns a number, prefer it. Otherwise fall through to re-select.
        const n = typeof rpcData === "number" ? rpcData : null;
        if (n != null) return n;
      }

      // If RPC does not exist (or fails), do a safe read+write.
      // This is not perfectly atomic, but it matches your previous fallback intent and avoids `.catch` crashes.
      const { data: row, error: selErr } = await supabase
        .from("sync_jobs")
        .select("attempts")
        .eq("id", jobId)
        .maybeSingle();

      if (selErr) throw new Error(`bump_attempts_select_failed: ${selErr.message}`);

      const current = typeof (row as any)?.attempts === "number" ? (row as any).attempts : 0;
      const next = current + 1;

      const { error: updErr } = await supabase
        .from("sync_jobs")
        .update({ attempts: next, updated_at: new Date().toISOString() })
        .eq("id", jobId);

      if (updErr) throw new Error(`bump_attempts_update_failed: ${updErr.message}`);

      return next;
    }

    async function markJobDone(jobId: string | number, lastError: string | null = null) {
      const nowIso = new Date().toISOString();
      await supabase
        .from("sync_jobs")
        .update({
          status: "done",
          finished_at: nowIso,
          updated_at: nowIso,
          last_error: lastError,
          locked_at: null,
        })
        .eq("id", jobId);
    }

    async function markJobQueued(jobId: string | number, reason: string) {
      const nowIso = new Date().toISOString();
      await supabase
        .from("sync_jobs")
        .update({
          status: "queued",
          last_error: reason,
          updated_at: nowIso,
          locked_at: null,
        })
        .eq("id", jobId);
    }

    async function markJobError(jobId: string | number, errMsg: string) {
      const nowIso = new Date().toISOString();
      await supabase
        .from("sync_jobs")
        .update({
          status: "error",
          last_error: errMsg,
          finished_at: nowIso,
          updated_at: nowIso,
          locked_at: null,
        })
        .eq("id", jobId);
    }

    async function processJob(job: SyncJobRow) {
      const locked = await lockJob(job);
      if (!locked) return { jobId: job.id, status: "skipped_lock_race" };

      const userId = String(job.user_id);
      const jobLocalDate = String(job.local_date);

      try {
        const out = await resolveWithDateFallback(supabase, userId, jobLocalDate);
        const resolved = out.row;

        if (!resolved?.timezone) {
          await markJobError(job.id, "no_timezone");
          return { jobId: job.id, userId, localDate: jobLocalDate, status: "no_timezone" };
        }

        const tz = resolved.timezone;
        const { localDate: currentLocalDate, hh, mm } = getLocalTimeParts(tz, nowUtc);
        const localTime = `${hh}:${String(mm).padStart(2, "0")}`;
        const isTodayJob = jobLocalDate === currentLocalDate;

        // If already finalized for that local_date, mark job done
        const { data: already, error: ranErr } = await supabase
          .from("backend_daily_runs")
          .select("user_id")
          .eq("user_id", userId)
          .eq("local_date", jobLocalDate)
          .maybeSingle();

        if (ranErr) throw new Error(`run_check_error: ${ranErr.message}`);
        if (already) {
          await markJobDone(job.id, null);
          return { jobId: job.id, userId, localDate: jobLocalDate, status: "already_ran", timezone: tz, localTime };
        }

        // Fetch enabled metrics (needed before any stop decision)
        const { data: metrics, error: metErr } = await supabase
          .from("metric_settings")
          .select("user_id,metric,enabled,preferred_source,allowed_sources")
          .eq("user_id", userId)
          .eq("enabled", true);

        if (metErr) throw new Error(`metrics_error: ${metErr.message}`);

        const enabledMetrics = (metrics ?? []) as MetricSettingRow[];

        const whoopEnabledForAny = enabledMetrics.some((m) => {
          const pref = (m.preferred_source ?? "").toLowerCase();
          const allowed = (m.allowed_sources ?? []).map((s) => String(s).toLowerCase());
          return pref === "whoop" || allowed.includes("whoop");
        });

        // If WHOOP isn't needed, finalize immediately
        if (!whoopEnabledForAny) {
          const { error: insErr } = await supabase.from("backend_daily_runs").insert({
            user_id: userId,
            utc_date: utcDate,
            local_date: jobLocalDate,
            timezone: tz,
            city_id: resolved.city_id,
            ran_at: nowUtc.toISOString(),
          });

          if (insErr) {
            const msg = (insErr.message ?? "").toLowerCase();
            if (!msg.includes("duplicate") && !msg.includes("unique")) {
              throw new Error(`run_insert_error: ${insErr.message}`);
            }
          }

          await markJobDone(job.id, null);
          return {
            jobId: job.id,
            userId,
            localDate: jobLocalDate,
            status: "done",
            timezone: tz,
            localTime,
            finalizedBecause: "no_whoop_needed",
          };
        }

        // Gate by retry window ONLY for today jobs (unless forced by webhook)
        // IMPORTANT: do not increment attempts for gating-only requeues.
        if (isTodayJob && !isForced) {
          if (!isWithinRetryWindow(hh, mm)) {
            const reason = (hh > RETRY_END_HOUR || (hh === RETRY_END_HOUR && mm > RETRY_END_MINUTE))
              ? "after_retry_window_waiting_for_whoop_data"
              : "outside_retry_window";
            await markJobQueued(job.id, reason);
            return { jobId: job.id, userId, localDate: jobLocalDate, status: reason, timezone: tz, localTime };
          }
        }

        // From here on, we will actually attempt WHOOP work. Increment attempts once.
        // This prevents "attempts explosion" from gating-only requeues.
        const currentAttempt = await bumpAttempts(job.id);

        const metricResults: any[] = [];
        let whoopSleepFound = false;
        let whoopRecoveryFound = false;
        let whoopWorkoutFound = false;

        // WHOOP token
        const { data: tok, error: tokErr } = await supabase
          .from("whoop_tokens")
          .select("user_id,access_token,refresh_token,token_type,expires_at")
          .eq("user_id", userId)
          .maybeSingle();

        if (tokErr) throw new Error(`whoop_token_error: ${tokErr.message}`);

        if (!tok) {
          if (isTodayJob) {
            await markJobQueued(job.id, "whoop_not_connected");
            return { jobId: job.id, userId, localDate: jobLocalDate, status: "whoop_not_connected", timezone: tz, localTime };
          } else {
            await markJobError(job.id, "whoop_not_connected");
            return { jobId: job.id, userId, localDate: jobLocalDate, status: "whoop_not_connected_backfill_error", timezone: tz, localTime };
          }
        }

        let whoopToken = tok as WhoopTokenRow;

        // refresh if expiring
        try {
          if (isExpiredSoon(whoopToken.expires_at, nowUtc)) {
            const refreshed = await refreshWhoopToken(whoopToken.refresh_token);
            const expiresInSec = refreshed.expires_in || 3600; // Default 1 hour if missing
            const expiresAt = new Date(nowUtc.getTime() + expiresInSec * 1000).toISOString();

            const { error: updErr } = await supabase
              .from("whoop_tokens")
              .update({
                access_token: refreshed.access_token,
                refresh_token: refreshed.refresh_token,
                token_type: refreshed.token_type ?? whoopToken.token_type ?? "Bearer",
                expires_at: expiresAt,
                updated_at: new Date().toISOString(),
              })
              .eq("user_id", userId);

            if (updErr) throw new Error(updErr.message);

            whoopToken = {
              ...whoopToken,
              access_token: refreshed.access_token,
              refresh_token: refreshed.refresh_token,
              token_type: refreshed.token_type ?? whoopToken.token_type,
              expires_at: expiresAt,
            };
            
            // Log successful refresh to edge_audit
            await supabase.from("edge_audit").insert({
              fn: "sync-worker",
              user_id: userId,
              ok: true,
              stage: "whoop_refresh_ok",
              message: `expires_in=${expiresInSec}s`,
            }).catch(() => {});
          }
        } catch (e) {
          const errMsg = (e as Error).message;
          metricResults.push({ source: "whoop", status: "refresh_failed", error: errMsg });
          
          // Log refresh failure to edge_audit - THIS IS CRITICAL TO MONITOR
          await supabase.from("edge_audit").insert({
            fn: "sync-worker",
            user_id: userId,
            ok: false,
            stage: "whoop_refresh_failed",
            message: errMsg.slice(0, 500),
          }).catch(() => {});
        }

        const whoopEnabled = (metric: string) => {
          const m = enabledMetrics.find((x) => x.metric === metric);
          if (!m) return false;
          const pref = (m.preferred_source ?? "").toLowerCase();
          const allowed = (m.allowed_sources ?? []).map((s) => String(s).toLowerCase());
          return pref === "whoop" || allowed.includes("whoop");
        };

        if (whoopToken.access_token) {
          const { startUtcIso, endUtcIso } = getWhoopNoonWindowUtcIso(tz, jobLocalDate);

          // RECOVERY
          try {
            const recs = await whoopFetchPagedRecords("/recovery", startUtcIso, endUtcIso, whoopToken.access_token);
            const rec = recs.length ? (recs[0] as any) : null;

            if (!rec) {
              metricResults.push({ source: "whoop", status: "no_recovery_record" });
            } else {
              whoopRecoveryFound = true;

              const scoreObj = rec?.score ?? null;
              const sourceMeasureId = whoopMeasureId(rec);

              const recoveryPct = numOrNull(scoreObj?.recovery_score);
              const restingHr = numOrNull(scoreObj?.resting_heart_rate);
              const hrvMs = numOrNull(scoreObj?.hrv_rmssd_milli);
              const skinTemp = numOrNull(scoreObj?.skin_temp_celsius);
              const spo2 = numOrNull(scoreObj?.spo2_percentage);

              if (whoopEnabled("recovery_score_daily") && recoveryPct != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "recovery_score_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "recovery_score_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_pct: recoveryPct,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "recovery_score_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("resting_hr_daily") && restingHr != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "resting_hr_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "resting_hr_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_bpm: restingHr,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "resting_hr_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("hrv_daily") && hrvMs != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "hrv_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "hrv_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_rmssd_ms: hrvMs,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "hrv_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("skin_temp_daily") && skinTemp != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "skin_temp_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "skin_temp_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_celsius: skinTemp,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "skin_temp_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("spo2_daily") && spo2 != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "spo2_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "spo2_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_pct: spo2,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "spo2_daily", status: proceed ? "written" : "already_done" });
              }

              metricResults.push({ source: "whoop", status: "recovery_processed" });
            }
          } catch (e) {
            metricResults.push({ source: "whoop", status: "recovery_fetch_failed", error: (e as Error).message });
          }

          // SLEEP
          try {
            const recs = await whoopFetchPagedRecords("/activity/sleep", startUtcIso, endUtcIso, whoopToken.access_token);
            const rec = recs.length ? selectWhoopSleepRecordByWakeup(recs as any[], jobLocalDate, tz) : null;

            if (!rec) {
              metricResults.push({ source: "whoop", status: "no_sleep_record_for_day" });
            } else {
              whoopSleepFound = true;

              const sourceMeasureId = whoopMeasureId(rec);
              const score = (rec as any)?.score ?? null;
              const stage = score?.stage_summary ?? null;

              const lightMs = numOrNull(stage?.total_light_sleep_time_milli) ?? 0;
              const swsMs = numOrNull(stage?.total_slow_wave_sleep_time_milli) ?? 0;
              const remMs = numOrNull(stage?.total_rem_sleep_time_milli) ?? 0;

              const durationMs = numOrNull(score?.sleep_duration_milli) ?? 0;
              const durationHours = (durationMs > 0 ? durationMs : (lightMs + swsMs + remMs)) / 3_600_000.0;

              const disturbances = intOrNull(stage?.disturbance_count) ?? 0;

              const perfPct = numOrNull(score?.sleep_performance_percentage);
              const effPct = numOrNull(score?.sleep_efficiency_percentage);

              const fellAsleepAt = whoopShiftedIso(rec, "start");
              const wokeUpAt = whoopShiftedIso(rec, "end");

              if (whoopEnabled("sleep_duration_daily") && durationHours > 0) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "sleep_duration_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "sleep_duration_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_hours: durationHours,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "sleep_duration_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("sleep_score_daily") && perfPct != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "sleep_score_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "sleep_score_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_pct: perfPct,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "sleep_score_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("sleep_efficiency_daily") && effPct != null) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "sleep_efficiency_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "sleep_efficiency_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_pct: effPct,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "sleep_efficiency_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("sleep_disturbances_daily")) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "sleep_disturbances_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "sleep_disturbances_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_count: disturbances,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "sleep_disturbances_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("sleep_stages_daily") && (lightMs > 0 || swsMs > 0 || remMs > 0)) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "sleep_stages_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(
                    supabase,
                    "sleep_stages_daily",
                    {
                      user_id: userId,
                      date: jobLocalDate,
                      source: "whoop",
                      source_measure_id: sourceMeasureId,
                      value_sws_hm: swsMs / 3_600_000.0,
                      value_rem_hm: remMs / 3_600_000.0,
                      value_light_hm: lightMs / 3_600_000.0,
                      created_at: new Date().toISOString(),
                    },
                    "user_id,date,source",
                  );
                }
                metricResults.push({ metric: "sleep_stages_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("fell_asleep_time_daily") && fellAsleepAt) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "fell_asleep_time_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "fell_asleep_time_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_at: fellAsleepAt,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "fell_asleep_time_daily", status: proceed ? "written" : "already_done" });
              }

              if (whoopEnabled("woke_up_time_daily") && wokeUpAt) {
                const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "woke_up_time_daily", "whoop");
                if (proceed) {
                  await upsertDailyRow(supabase, "woke_up_time_daily", {
                    user_id: userId,
                    date: jobLocalDate,
                    value_at: wokeUpAt,
                    source: "whoop",
                    source_measure_id: sourceMeasureId,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                  });
                }
                metricResults.push({ metric: "woke_up_time_daily", status: proceed ? "written" : "already_done" });
              }

              metricResults.push({ source: "whoop", status: "sleep_processed" });
            }
          } catch (e) {
            metricResults.push({ source: "whoop", status: "sleep_fetch_failed", error: (e as Error).message });
          }

          // WORKOUTS / HR ZONES (WHOOP v2)
          // - Per-session rows (activity_hr_zones_sessions) and/or daily aggregate (time_in_high_hr_zones_daily)
          // - Uses existing table: time_in_high_hr_zones_daily
          //   Unique constraint: (user_id, source, source_measure_id) -> upsert with that onConflict
          try {
            const wantSessions = whoopEnabled("activity_hr_zones_sessions");
            const wantDailyHigh = whoopEnabled("time_in_high_hr_zones_daily");

            if (!wantSessions && !wantDailyHigh) {
              metricResults.push({ source: "whoop", status: "workouts_skipped_not_enabled" });
            } else {
              const workouts = await whoopFetchPagedRecords("/activity/workout", startUtcIso, endUtcIso, whoopToken.access_token);
              const ws = (workouts ?? []) as any[];

              if (!ws.length) {
                metricResults.push({ source: "whoop", status: "no_workouts_in_window" });
              } else {
                // Helpers (kept inline to avoid changing global structure)
                const msToMinutes = (ms: unknown): number => {
                  const n = numOrNull(ms);
                  if (n == null || n <= 0) return 0;
                  return n / 60_000.0;
                };

                const workoutLocalDateByEnd = (rec: any): string | null => {
                  const endUtc = typeof rec?.end === "string" ? String(rec.end) : "";
                  if (!endUtc) return null;
                  const tzMin = whoopTzMinutes(rec);
                  const endUtcMs = new Date(endUtc).getTime();
                  if (Number.isNaN(endUtcMs)) return null;
                  const endLocalMs = endUtcMs + tzMin * 60_000;
                  return getLocalTimeParts(tz, new Date(endLocalMs)).localDate;
                };

                const zoneMs = (rec: any, key: string): number => {
                  const zd = rec?.score?.zone_durations ?? null;
                  const v = zd && typeof zd === "object" ? (zd as any)[key] : null;
                  const n = numOrNull(v);
                  return n != null && n > 0 ? n : 0;
                };

                // Only count workouts that "belong" to this job day by end-local-date
                const dayWorkouts = ws.filter((w) => workoutLocalDateByEnd(w) === jobLocalDate);

                if (!dayWorkouts.length) {
                  metricResults.push({ source: "whoop", status: "no_workouts_for_local_day" });
                } else {
                  whoopWorkoutFound = true;

                  // Aggregate sums for optional daily write
                  let sumZ0 = 0;
                  let sumZ1 = 0;
                  let sumZ2 = 0;
                  let sumZ3 = 0;
                  let sumZ4 = 0;
                  let sumZ5 = 0;
                  let sumZ6 = 0;

                  // Per-session inserts (no backend_metric_runs gating; uniqueness is per workout id)
                  if (wantSessions) {
                    let inserted = 0;
                    let deduped = 0;

                    for (const w of dayWorkouts) {
                      const sourceMeasureId = whoopMeasureId(w);
                      if (!sourceMeasureId) continue;

                      const z0m = zoneMs(w, "zone_zero_milli");
                      const z1m = zoneMs(w, "zone_one_milli");
                      const z2m = zoneMs(w, "zone_two_milli");
                      const z3m = zoneMs(w, "zone_three_milli");
                      const z4m = zoneMs(w, "zone_four_milli");
                      const z5m = zoneMs(w, "zone_five_milli");
                      const z6m = zoneMs(w, "zone_six_milli");

                      sumZ0 += z0m; sumZ1 += z1m; sumZ2 += z2m; sumZ3 += z3m; sumZ4 += z4m; sumZ5 += z5m; sumZ6 += z6m;

                      const highTotalMinutes = (z3m + z4m + z5m + z6m) / 60_000.0;

                      const startAt = whoopShiftedIso(w, "start");
                      const endAt = whoopShiftedIso(w, "end");

                      const activityType =
                        (typeof w?.sport_name === "string" && w.sport_name) ? String(w.sport_name) :
                        (typeof w?.sport === "string" && w.sport) ? String(w.sport) :
                        (typeof w?.activity_type === "string" && w.activity_type) ? String(w.activity_type) :
                        "workout";

                      const { error } = await supabase.from("time_in_high_hr_zones_daily").upsert(
                        {
                          user_id: userId,
                          date: jobLocalDate,
                          value_minutes: highTotalMinutes,
                          zone_zero_minutes: z0m / 60_000.0,
                          zone_one_minutes: z1m / 60_000.0,
                          zone_two_minutes: z2m / 60_000.0,
                          zone_three_minutes: z3m / 60_000.0,
                          zone_four_minutes: z4m / 60_000.0,
                          zone_five_minutes: z5m / 60_000.0,
                          zone_six_minutes: z6m / 60_000.0,
                          source: "whoop",
                          source_measure_id: sourceMeasureId,
                          created_at: new Date().toISOString(),
                          activity_type: activityType,
                          start_at: startAt,
                          end_at: endAt,
                        },
                        { onConflict: "user_id,source,source_measure_id" },
                      );

                      if (!error) {
                        inserted += 1;
                      } else {
                        const msg = (error.message ?? "").toLowerCase();
                        if (msg.includes("duplicate") || msg.includes("unique")) {
                          deduped += 1;
                        } else {
                          throw new Error(`time_in_high_hr_zones_daily session upsert failed: ${error.message}`);
                        }
                      }
                    }

                    metricResults.push({
                      metric: "activity_hr_zones_sessions",
                      status: "processed",
                      workouts: dayWorkouts.length,
                      inserted,
                      deduped,
                    });
                  } else {
                    for (const w of dayWorkouts) {
                      sumZ0 += zoneMs(w, "zone_zero_milli");
                      sumZ1 += zoneMs(w, "zone_one_milli");
                      sumZ2 += zoneMs(w, "zone_two_milli");
                      sumZ3 += zoneMs(w, "zone_three_milli");
                      sumZ4 += zoneMs(w, "zone_four_milli");
                      sumZ5 += zoneMs(w, "zone_five_milli");
                      sumZ6 += zoneMs(w, "zone_six_milli");
                    }
                  }

                  if (wantDailyHigh) {
                    const proceed = await tryMarkMetricRan(supabase, userId, jobLocalDate, "time_in_high_hr_zones_daily", "whoop");
                    if (proceed) {
                      const dailySourceMeasureId = `whoop_workout_daily_${jobLocalDate}`;
                      const highTotalMinutes = (sumZ3 + sumZ4 + sumZ5 + sumZ6) / 60_000.0;

                      await supabase.from("time_in_high_hr_zones_daily").upsert(
                        {
                          user_id: userId,
                          date: jobLocalDate,
                          value_minutes: highTotalMinutes,
                          zone_zero_minutes: sumZ0 / 60_000.0,
                          zone_one_minutes: sumZ1 / 60_000.0,
                          zone_two_minutes: sumZ2 / 60_000.0,
                          zone_three_minutes: sumZ3 / 60_000.0,
                          zone_four_minutes: sumZ4 / 60_000.0,
                          zone_five_minutes: sumZ5 / 60_000.0,
                          zone_six_minutes: sumZ6 / 60_000.0,
                          source: "whoop",
                          source_measure_id: dailySourceMeasureId,
                          created_at: new Date().toISOString(),
                          activity_type: "daily_total",
                          start_at: null,
                          end_at: null,
                        },
                        { onConflict: "user_id,source,source_measure_id" },
                      );
                    }

                    metricResults.push({ metric: "time_in_high_hr_zones_daily", status: proceed ? "written" : "already_done" });
                  }
                }
              }
            }
          } catch (e) {
            metricResults.push({ source: "whoop", status: "workouts_fetch_failed", error: (e as Error).message });
          }
        }

        const hasWhoopData = whoopSleepFound || whoopRecoveryFound || whoopWorkoutFound;

        if (!hasWhoopData) {
          if (isTodayJob) {
            const pastWindow = (hh > RETRY_END_HOUR || (hh === RETRY_END_HOUR && mm > RETRY_END_MINUTE));
            const reason = (!isForced && pastWindow)
              ? "after_retry_window_waiting_for_whoop_data"
              : "retry_waiting_for_whoop_data";
            await markJobQueued(job.id, reason);
            return {
              jobId: job.id,
              userId,
              localDate: jobLocalDate,
              status: reason,
              timezone: tz,
              localTime,
              metricResults,
              whoopSleepFound,
              whoopRecoveryFound,
              attempt: currentAttempt,
            };
          }

          if (currentAttempt < 3) {
            await markJobQueued(job.id, "retry_waiting_for_whoop_data");
            return {
              jobId: job.id,
              userId,
              localDate: jobLocalDate,
              status: "retry_waiting_for_whoop_data_backfill",
              timezone: tz,
              localTime,
              metricResults,
              whoopSleepFound,
              whoopRecoveryFound,
              attempt: currentAttempt,
            };
          }

          await markJobError(job.id, "no_whoop_data");
          return {
            jobId: job.id,
            userId,
            localDate: jobLocalDate,
            status: "no_whoop_data_error",
            timezone: tz,
            localTime,
            metricResults,
            whoopSleepFound,
            whoopRecoveryFound,
            attempt: currentAttempt,
          };
        }

        const { error: insErr } = await supabase.from("backend_daily_runs").insert({
          user_id: userId,
          utc_date: utcDate,
          local_date: jobLocalDate,
          timezone: tz,
          city_id: resolved.city_id,
          ran_at: nowUtc.toISOString(),
        });

        if (insErr) {
          const msg = (insErr.message ?? "").toLowerCase();
          if (!msg.includes("duplicate") && !msg.includes("unique")) {
            throw new Error(`run_insert_error: ${insErr.message}`);
          }
        }

        await markJobDone(job.id, null);

        return {
          jobId: job.id,
          userId,
          localDate: jobLocalDate,
          status: "done",
          timezone: tz,
          localTime,
          metricResults,
          whoopSleepFound,
          whoopRecoveryFound,
          finalizedBecause: isTodayJob ? "whoop_data_found" : "whoop_data_found_backfill",
        };
      } catch (e) {
        const msg = (e as Error).message;
        await markJobError(job.id, msg);
        return { jobId: job.id, status: "error", error: msg };
      }
    }

    const results = await mapLimit(picked, 6, async (j) => processJob(j));

    const summary = {
      picked: picked.length,
      done: results.filter((r: any) => r.status === "done" || r.status === "already_ran").length,
      requeued: results.filter(
        (r: any) =>
          r.status === "outside_retry_window" ||
          String(r.status).includes("retry_waiting_for_whoop_data") ||
          String(r.status).includes("after_retry_window_waiting_for_whoop_data") ||
          r.status === "whoop_not_connected",
      ).length,
      errors: results.filter((r: any) => r.status === "error" || String(r.status).includes("error")).length,
      nowUtc: nowUtc.toISOString(),
      whoopClientConfigured: whoopConfigured,
      forced: isForced,
      retryWindowLocal: `${String(RETRY_START_HOUR).padStart(2, "0")}:00-${String(RETRY_END_HOUR).padStart(2, "0")}:${String(RETRY_END_MINUTE).padStart(2, "0")}`,
      staleReclaimMinutes: 30,
      maxPickAttempts: MAX_PICK_ATTEMPTS,
    };

    return jsonResponse({ ok: true, summary, results });
  } catch (e) {
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});


===== TITLE: trigger_worker.txt =====

// supabase/functions/trigger-worker/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function mean(arr: number[]): number | null {
  if (arr.length === 0) return null;
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}

function stdDev(arr: number[], avg: number): number | null {
  if (arr.length < 2) return null;
  const squaredDiffs = arr.map((x) => (x - avg) ** 2);
  return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / arr.length);
}

const STALE_LOCK_MINUTES = 10;
const MAX_ATTEMPTS = 3;

// Thresholds
const RECOVERY_LOW_THRESHOLD = 33;
const MIN_DAYS_FOR_SD = 14;

serve(async (req) => {
  console.log("[trigger-worker] start", {
    nowUtc: new Date().toISOString(),
    method: req.method,
  });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "trigger-worker" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const staleCutoff = new Date(nowUtc.getTime() - STALE_LOCK_MINUTES * 60_000).toISOString();

    // Pick queued jobs (or stale locked jobs)
    const { data: jobs, error: pickErr } = await supabase
      .from("trigger_jobs")
      .select("*")
      .eq("status", "queued")
      .lt("attempts", MAX_ATTEMPTS)
      .or(`locked_at.is.null,locked_at.lt.${staleCutoff}`)
      .limit(20);

    if (pickErr) {
      throw new Error(`Failed to pick jobs: ${pickErr.message}`);
    }

    if (!jobs || jobs.length === 0) {
      return jsonResponse({ ok: true, message: "No jobs to process", processed: 0 });
    }

    const results: unknown[] = [];

    for (const job of jobs) {
      const jobResult: Record<string, unknown> = {
        jobId: job.id,
        userId: job.user_id,
        localDate: job.local_date,
        triggerResults: [],
      };

      // Lock the job
      const { error: lockErr } = await supabase
        .from("trigger_jobs")
        .update({ locked_at: nowIso, attempts: job.attempts + 1, updated_at: nowIso })
        .eq("id", job.id);

      if (lockErr) {
        jobResult.status = "lock_failed";
        jobResult.error = lockErr.message;
        results.push(jobResult);
        continue;
      }

      try {
        const userId = job.user_id;
        const localDate = job.local_date;

        // Get user's enabled trigger types
        const { data: userTriggers, error: trigErr } = await supabase
          .from("trigger_settings")
          .select("trigger_type")
          .eq("user_id", userId)
          .eq("enabled", true);

        if (trigErr) {
          throw new Error(`trigger_settings query failed: ${trigErr.message}`);
        }

        const enabledTypes = new Set((userTriggers ?? []).map((t) => t.trigger_type));
        jobResult.enabledTypes = [...enabledTypes];

        // Process recovery triggers
        if (enabledTypes.has("recovery_low") || enabledTypes.has("recovery_unusually_low")) {
          const recoveryResult = await processRecoveryTriggers(
            supabase,
            userId,
            localDate,
            enabledTypes
          );
          (jobResult.triggerResults as unknown[]).push(recoveryResult);
        }

        // Mark job done
        await supabase
          .from("trigger_jobs")
          .update({ status: "done", locked_at: null, last_error: null, updated_at: nowIso })
          .eq("id", job.id);

        jobResult.status = "done";
      } catch (e) {
        const errMsg = (e as Error).message;
        jobResult.status = "error";
        jobResult.error = errMsg;

        // Mark job error or requeue
        const newStatus = job.attempts + 1 >= MAX_ATTEMPTS ? "error" : "queued";
        await supabase
          .from("trigger_jobs")
          .update({ status: newStatus, locked_at: null, last_error: errMsg, updated_at: nowIso })
          .eq("id", job.id);
      }

      results.push(jobResult);
    }

    const summary = {
      picked: jobs.length,
      done: results.filter((r: any) => r.status === "done").length,
      errors: results.filter((r: any) => r.status === "error").length,
    };

    return jsonResponse({ ok: true, nowUtc: nowIso, summary, results });
  } catch (e) {
    console.error("[trigger-worker] error", e);
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});

async function processRecoveryTriggers(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  localDate: string,
  enabledTypes: Set<string>
): Promise<Record<string, unknown>> {
  const result: Record<string, unknown> = { metric: "recovery", triggers: [] };

  // Get recovery score for the date
  const { data: recovery, error: recErr } = await supabase
    .from("recovery_score_daily")
    .select("value_pct")
    .eq("user_id", userId)
    .eq("date", localDate)
    .maybeSingle();

  if (recErr) {
    result.error = `recovery fetch failed: ${recErr.message}`;
    return result;
  }

  if (!recovery || recovery.value_pct == null) {
    result.status = "no_data";
    return result;
  }

  const value = recovery.value_pct as number;
  result.value = value;

  // Check absolute low threshold
  if (enabledTypes.has("recovery_low") && value < RECOVERY_LOW_THRESHOLD) {
    const created = await createTriggerIfNotExists(
      supabase,
      userId,
      "recovery_low",
      localDate,
      `Recovery ${value.toFixed(0)}% - below ${RECOVERY_LOW_THRESHOLD}% threshold`
    );
    (result.triggers as unknown[]).push({ type: "recovery_low", created, value });
  }

  // Check 2SD threshold
  if (enabledTypes.has("recovery_unusually_low")) {
    const startDate = addDaysIsoDate(localDate, -MIN_DAYS_FOR_SD);
    const endDate = addDaysIsoDate(localDate, -1);

    const { data: history, error: histErr } = await supabase
      .from("recovery_score_daily")
      .select("value_pct")
      .eq("user_id", userId)
      .gte("date", startDate)
      .lte("date", endDate);

    if (histErr) {
      result.sdError = `history fetch failed: ${histErr.message}`;
    } else {
      const values = (history ?? [])
        .map((r: { value_pct: unknown }) => r.value_pct)
        .filter((v): v is number => typeof v === "number");

      if (values.length >= MIN_DAYS_FOR_SD) {
        const avg = mean(values);
        const sd = avg != null ? stdDev(values, avg) : null;

        if (avg != null && sd != null && sd > 0) {
          const threshold = avg - 2 * sd;
          result.sdStats = { avg: avg.toFixed(1), sd: sd.toFixed(1), threshold: threshold.toFixed(1) };

          if (value < threshold) {
            const created = await createTriggerIfNotExists(
              supabase,
              userId,
              "recovery_unusually_low",
              localDate,
              `Recovery ${value.toFixed(0)}% - below 2SD (threshold: ${threshold.toFixed(0)}%, avg: ${avg.toFixed(0)}%)`
            );
            (result.triggers as unknown[]).push({
              type: "recovery_unusually_low",
              created,
              value,
              threshold: threshold.toFixed(1),
            });
          }
        } else {
          result.sdStatus = "insufficient_variance";
        }
      } else {
        result.sdStatus = `insufficient_history (${values.length}/${MIN_DAYS_FOR_SD} days)`;
      }
    }
  }

  result.status = "processed";
  return result;
}

async function createTriggerIfNotExists(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  triggerType: string,
  date: string,
  notes: string
): Promise<boolean> {
  const dayStart = `${date}T00:00:00Z`;
  const dayEnd = `${date}T23:59:59Z`;

  const { data: existing, error: checkErr } = await supabase
    .from("triggers")
    .select("id")
    .eq("user_id", userId)
    .eq("type", triggerType)
    .eq("source", "system")
    .gte("start_at", dayStart)
    .lte("start_at", dayEnd)
    .limit(1);

  if (checkErr) {
    console.error(`[trigger-worker] check existing failed: ${checkErr.message}`);
    return false;
  }

  if (existing && existing.length > 0) {
    return false;
  }

  const { error: insertErr } = await supabase.from("triggers").insert({
    user_id: userId,
    type: triggerType,
    source: "system",
    start_at: `${date}T09:00:00Z`,
    notes,
    active: true,
  });

  if (insertErr) {
    console.error(`[trigger-worker] insert failed: ${insertErr.message}`);
    return false;
  }

  return true;
}


===== TITLE: upsert-whoop-token.txt =====

// supabase/functions/upsert-whoop-token/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

type MetricToggle = { metric: string; enabled: boolean };

type Body = {
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_at?: string | null;
  expires_in?: number | null;  // WHOOP OAuth returns this (seconds until expiry)
  metric_settings?: MetricToggle[] | null;
};

type ResolveRow = {
  city_id: number;
  timezone: string | null;
  resolved_date?: string | null;
};

type SyncJobInsert = {
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  updated_at: string;
  created_by: string;
  timezone: string;
  city_id: number | null;
};

const WHOOP_METRICS = [
  "recovery_score_daily",
  "resting_hr_daily",
  "hrv_daily",
  "skin_temp_daily",
  "spo2_daily",
  "sleep_duration_daily",
  "sleep_score_daily",
  "sleep_efficiency_daily",
  "sleep_disturbances_daily",
  "sleep_stages_daily",
  "fell_asleep_time_daily",
  "woke_up_time_daily",
  "activity_hr_zones_sessions",
  "hr_zones_daily",
  "steps_daily",
  "time_in_high_hr_zones_daily",
  "stress_index_daily",
] as const;

const WHOOP_METRIC_SET = new Set<string>(WHOOP_METRICS as unknown as string[]);

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function dateRangeInclusive(startIso: string, endIso: string) {
  const out: string[] = [];
  let cur = startIso;
  for (let guard = 0; guard < 500; guard++) {
    out.push(cur);
    if (cur === endIso) break;
    cur = addDaysIsoDate(cur, +1);
  }
  return out;
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase.rpc("resolve_user_city_for_date", {
      p_user_id: userId,
      p_date: d,
    });

    if (error) {
      throw new Error(`resolve_user_city_for_date failed for date=${d}: ${error.message}`);
    }

    const row: ResolveRow | undefined = Array.isArray(data) ? data[0] : data;
    if (row?.timezone) return { row, usedDate: row.resolved_date ?? d };
  }

  return { row: null, usedDate: null };
}

function normalizeClientMetricToggles(raw: unknown): { applied: MetricToggle[]; ignored: string[] } {
  if (!Array.isArray(raw)) return { applied: [], ignored: [] };

  const applied: MetricToggle[] = [];
  const ignored: string[] = [];

  for (const item of raw) {
    const metric = typeof (item as any)?.metric === "string" ? String((item as any).metric).trim() : "";
    const enabled = (item as any)?.enabled;

    if (!metric || typeof enabled !== "boolean") {
      ignored.push(metric || "(invalid)");
      continue;
    }

    if (!WHOOP_METRIC_SET.has(metric)) {
      ignored.push(metric);
      continue;
    }

    applied.push({ metric, enabled });
  }

  const map = new Map<string, boolean>();
  for (const t of applied) map.set(t.metric, t.enabled);
  return {
    applied: Array.from(map.entries()).map(([metric, enabled]) => ({ metric, enabled })),
    ignored,
  };
}

function sanitizeTokenField(raw: unknown): string {
  if (typeof raw !== "string") return "";
  return raw.replace(/\r?\n/g, "").replace(/\r/g, "").trim();
}

// FIXED: Now handles both expires_at (ISO string) and expires_in (seconds)
function computeExpiresAt(expiresAtRaw: unknown, expiresInRaw: unknown, nowUtc: Date): string {
  // First try expires_at (ISO timestamp string)
  if (expiresAtRaw != null && typeof expiresAtRaw === "string") {
    const s = expiresAtRaw.trim();
    if (s) {
      const ms = new Date(s).getTime();
      if (!Number.isNaN(ms) && ms > nowUtc.getTime()) {
        return new Date(ms).toISOString();
      }
    }
  }

  // Then try expires_in (seconds until expiry) - this is what WHOOP OAuth returns
  if (expiresInRaw != null) {
    const seconds = typeof expiresInRaw === "number" ? expiresInRaw : Number(expiresInRaw);
    if (!Number.isNaN(seconds) && seconds > 0) {
      return new Date(nowUtc.getTime() + seconds * 1000).toISOString();
    }
  }

  // Default: 1 hour from now (WHOOP tokens typically last ~1 hour)
  console.log("[upsert-whoop-token] No valid expires_at or expires_in provided, defaulting to 1 hour");
  return new Date(nowUtc.getTime() + 3600 * 1000).toISOString();
}

// Fetch WHOOP user ID from their API - WITH LOGGING
async function fetchWhoopUserId(accessToken: string): Promise<number | null> {
  try {
    console.log("[upsert-whoop-token] fetching WHOOP user profile...");
    
    const res = await fetch("https://api.prod.whoop.com/developer/v2/user/profile/basic", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
      },
    });

    console.log("[upsert-whoop-token] WHOOP profile response status:", res.status);

    if (!res.ok) {
      const text = await res.text();
      console.log("[upsert-whoop-token] WHOOP profile error:", text);
      return null;
    }

    const data = await res.json();
    console.log("[upsert-whoop-token] WHOOP profile data:", JSON.stringify(data));
    
    const whoopUserId = data?.user_id;
    
    if (typeof whoopUserId === "number") {
      return whoopUserId;
    }
    
    return null;
  } catch (e) {
    console.log("[upsert-whoop-token] fetch error:", (e as Error).message);
    return null;
  }
}

serve(async (req) => {
  console.log("[upsert-whoop-token] start", {
    nowUtc: new Date().toISOString(),
    method: req.method,
    url: req.url,
  });

  const supabaseUrl = requireEnv("SUPABASE_URL");
  const anonKey = requireEnv("SUPABASE_ANON_KEY");
  const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

  const admin = createClient(supabaseUrl, serviceRoleKey, {
    auth: { persistSession: false },
    global: { headers: { "X-Client-Info": "upsert-whoop-token-admin" } },
  });

  async function audit(fn: string, userId: string | null, ok: boolean, stage: string, message: string | null) {
    try {
      await admin.from("edge_audit").insert({ fn, user_id: userId, ok, stage, message });
    } catch (e) {
      console.log("[upsert-whoop-token] audit failed", e);
    }
  }

  try {
    if (req.method !== "POST") {
      await audit("upsert-whoop-token", null, false, "method_not_allowed", req.method);
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const authHeader = req.headers.get("Authorization") ?? "";
    if (!authHeader.toLowerCase().startsWith("bearer ")) {
      await audit("upsert-whoop-token", null, false, "missing_auth", "Authorization header missing/invalid");
      return jsonResponse({ ok: false, error: "Unauthorized" }, 401);
    }

    const jwt = authHeader.slice(7);
    const userClient = createClient(supabaseUrl, anonKey, {
      auth: { persistSession: false },
      global: { headers: { Authorization: `Bearer ${jwt}` } },
    });

    const { data: userData, error: userErr } = await userClient.auth.getUser();
    if (userErr || !userData?.user?.id) {
      await audit("upsert-whoop-token", null, false, "auth_failed", userErr?.message ?? "no user");
      return jsonResponse({ ok: false, error: "Unauthorized" }, 401);
    }

    const userId = userData.user.id;
    await audit("upsert-whoop-token", userId, true, "auth_ok", null);

    const body = (await req.json().catch(() => null)) as Body | null;

    const access = sanitizeTokenField(body?.access_token);
    const refresh = sanitizeTokenField(body?.refresh_token);

    if (!access || !refresh) {
      await audit("upsert-whoop-token", userId, false, "bad_body", "missing access_token or refresh_token");
      return jsonResponse({ ok: false, error: "Missing access_token/refresh_token" }, 400);
    }

    const tokenType = sanitizeTokenField(body?.token_type) || "Bearer";

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const utcDate = nowIso.slice(0, 10);

    // FIXED: Now handles both expires_at and expires_in
    const expiresAt = computeExpiresAt(body?.expires_at, body?.expires_in, nowUtc);

    // Fetch WHOOP user ID for webhook mapping
    const whoopUserId = await fetchWhoopUserId(access);
    if (whoopUserId) {
      await audit("upsert-whoop-token", userId, true, "whoop_user_id_fetched", `whoop_user_id=${whoopUserId}`);
    } else {
      await audit("upsert-whoop-token", userId, false, "whoop_user_id_fetch_failed", "see logs");
    }

    // Upsert WHOOP tokens
    const tokenData: Record<string, unknown> = {
      user_id: userId,
      access_token: access,
      refresh_token: refresh,
      token_type: tokenType,
      expires_at: expiresAt,
      updated_at: nowIso,
      created_at: nowIso,
    };

    if (whoopUserId) {
      tokenData.whoop_user_id = whoopUserId;
    }

    const { error: upsertErr } = await admin.from("whoop_tokens").upsert(tokenData, { onConflict: "user_id" });

    if (upsertErr) {
      await audit("upsert-whoop-token", userId, false, "whoop_tokens_upsert_failed", upsertErr.message);
      return jsonResponse({ ok: false, error: upsertErr.message }, 500);
    }

    await audit("upsert-whoop-token", userId, true, "whoop_tokens_upsert_ok", `expires_at=${expiresAt}`);

    // Parse client-provided toggles
    const { applied: clientMetricToggles, ignored: ignoredClientMetrics } = normalizeClientMetricToggles(
      (body as any)?.metric_settings,
    );

    // Enable all WHOOP metrics
    let enabledCount = 0;
    const enableRows = WHOOP_METRICS.map((metric) => ({
      user_id: userId,
      metric,
      enabled: true,
      preferred_source: "whoop",
      allowed_sources: ["whoop"],
      updated_at: nowIso,
    }));

    const { error: enableErr } = await admin.from("metric_settings").upsert(enableRows, {
      onConflict: "user_id,metric",
    });

    if (!enableErr) {
      enabledCount = WHOOP_METRICS.length;
      await audit("upsert-whoop-token", userId, true, "metric_enable_ok", `enabled=${enabledCount}`);
    }

    // Enqueue backfill
    let enqueuedJobs = 0;
    try {
      const resolved = await resolveWithDateFallback(admin, userId, utcDate);
      const row = resolved.row;

      if (row?.timezone) {
        const tz = row.timezone;
        const cityId = typeof row.city_id === "number" ? row.city_id : null;
        const { localDate } = getLocalTimeParts(tz, nowUtc);

        const startLocalDate = addDaysIsoDate(localDate, -29);
        const endLocalDate = localDate;
        const days = dateRangeInclusive(startLocalDate, endLocalDate);

        const { data: alreadyRan } = await admin
          .from("backend_daily_runs")
          .select("local_date")
          .eq("user_id", userId)
          .in("local_date", days);

        const ranSet = new Set((alreadyRan ?? []).map((r: any) => String(r.local_date)));

        const jobs: SyncJobInsert[] = [];
        for (const d of days) {
          if (ranSet.has(d)) continue;
          jobs.push({
            job_type: "whoop_daily",
            user_id: userId,
            local_date: d,
            status: "queued",
            updated_at: nowIso,
            created_by: "whoop-connect",
            timezone: tz,
            city_id: cityId,
          });
        }

        if (jobs.length) {
          await admin.from("sync_jobs").upsert(jobs, {
            onConflict: "job_type,user_id,local_date",
            ignoreDuplicates: true,
          });
          enqueuedJobs = jobs.length;
          await audit("upsert-whoop-token", userId, true, "backfill_enqueued", `jobs=${enqueuedJobs}`);
        }
      }
    } catch (e) {
      await audit("upsert-whoop-token", userId, false, "backfill_exception", (e as Error).message);
    }

    return jsonResponse({
      ok: true,
      userId,
      whoopUserId,
      enqueuedJobs,
      expiresAt,
      metricSettings: { enabled: enabledCount },
    });
  } catch (e) {
    const msg = (e as Error).message;
    console.error("[upsert-whoop-token] exception", e);
    return jsonResponse({ ok: false, error: msg }, 500);
  }
});


===== TITLE: weather_worker.txt =====

// FILE: supabase/functions/weather-worker/index.ts
//
// Worker that processes jobs from sync_jobs_weather.
// Looks up user's location, finds nearest city, copies weather to user_weather_daily.

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

/**
 * Find nearest city to given coordinates using Haversine distance
 */
async function findNearestCity(
  supabase: ReturnType<typeof createClient>,
  lat: number,
  lon: number
): Promise<{ cityId: number; name: string; distance: number } | null> {
  // Query cities within ~2 degrees (rough bounding box first for performance)
  const { data: cities, error } = await supabase
    .from("city")
    .select("id, name, lat, lon")
    .gte("lat", lat - 2)
    .lte("lat", lat + 2)
    .gte("lon", lon - 2)
    .lte("lon", lon + 2)
    .limit(100);

  if (error || !cities || cities.length === 0) {
    // Fallback: get any city (shouldn't happen often)
    const { data: fallback } = await supabase
      .from("city")
      .select("id, name, lat, lon")
      .limit(50);
    
    if (!fallback || fallback.length === 0) return null;
    
    // Find nearest from fallback
    let nearest = fallback[0];
    let minDist = haversine(lat, lon, nearest.lat, nearest.lon);
    
    for (const city of fallback) {
      const dist = haversine(lat, lon, city.lat, city.lon);
      if (dist < minDist) {
        minDist = dist;
        nearest = city;
      }
    }
    
    return { cityId: nearest.id, name: nearest.name, distance: minDist };
  }

  // Find nearest city
  let nearest = cities[0];
  let minDist = haversine(lat, lon, nearest.lat, nearest.lon);

  for (const city of cities) {
    const dist = haversine(lat, lon, city.lat, city.lon);
    if (dist < minDist) {
      minDist = dist;
      nearest = city;
    }
  }

  return { cityId: nearest.id, name: nearest.name, distance: minDist };
}

/**
 * Haversine distance in km
 */
function haversine(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Earth's radius in km
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function toRad(deg: number): number {
  return deg * (Math.PI / 180);
}

serve(async (req) => {
  console.log("[weather-worker] start", new Date().toISOString());

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    const nowIso = new Date().toISOString();
    const MAX_ATTEMPTS = 3;
    const BATCH_SIZE = 20;

    // Fetch queued jobs
    const { data: jobs, error: jobsErr } = await supabase
      .from("sync_jobs_weather")
      .select("*")
      .eq("status", "queued")
      .lt("attempts", MAX_ATTEMPTS)
      .order("created_at", { ascending: true })
      .limit(BATCH_SIZE);

    if (jobsErr) throw new Error(`Failed to fetch jobs: ${jobsErr.message}`);

    if (!jobs || jobs.length === 0) {
      console.log("[weather-worker] no queued jobs");
      return jsonResponse({ ok: true, processed: 0 });
    }

    console.log(`[weather-worker] processing ${jobs.length} jobs`);

    const results: { jobId: string; status: string; error?: string; cityName?: string }[] = [];

    for (const job of jobs) {
      const jobId = job.id;
      const userId = job.user_id;
      const localDate = job.local_date;
      const timezone = job.timezone;

      try {
        // Mark as processing
        await supabase
          .from("sync_jobs_weather")
          .update({ status: "processing", attempts: job.attempts + 1, updated_at: nowIso })
          .eq("id", jobId);

        // Get user's location for this date (or nearby dates)
        const candidates = [localDate, addDaysIsoDate(localDate, -1), addDaysIsoDate(localDate, +1)];
        let userLat: number | null = null;
        let userLon: number | null = null;

        for (const d of candidates) {
          const { data: locData } = await supabase
            .from("user_location_daily")
            .select("latitude, longitude")
            .eq("user_id", userId)
            .eq("date", d)
            .maybeSingle();

          if (locData?.latitude && locData?.longitude) {
            userLat = locData.latitude;
            userLon = locData.longitude;
            break;
          }
        }

        if (userLat == null || userLon == null) {
          throw new Error("No location data found for user");
        }

        // Find nearest city
        const nearestCity = await findNearestCity(supabase, userLat, userLon);
        if (!nearestCity) {
          throw new Error("No cities found in database");
        }

        console.log(`[weather-worker] job=${jobId} user=${userId} city=${nearestCity.name} (${nearestCity.distance.toFixed(1)}km)`);

        // Get weather for this city and date
        const { data: cityWeather, error: weatherErr } = await supabase
          .from("city_weather_daily")
          .select("*")
          .eq("city_id", nearestCity.cityId)
          .eq("day", localDate)
          .maybeSingle();

        if (weatherErr) {
          throw new Error(`Failed to fetch city weather: ${weatherErr.message}`);
        }

        if (!cityWeather) {
          // No weather data for this city/date yet - mark as done (will retry tomorrow or via backfill)
          await supabase
            .from("sync_jobs_weather")
            .update({ status: "done", updated_at: nowIso })
            .eq("id", jobId);

          results.push({ jobId, status: "no_weather_data", cityName: nearestCity.name });
          continue;
        }

        // Upsert to user_weather_daily
        const { error: upsertErr } = await supabase
          .from("user_weather_daily")
          .upsert(
            {
              user_id: userId,
              date: localDate,
              temp_c_min: cityWeather.temp_c_min,
              temp_c_max: cityWeather.temp_c_max,
              temp_c_mean: cityWeather.temp_c_mean,
              pressure_hpa_min: cityWeather.pressure_hpa_min,
              pressure_hpa_max: cityWeather.pressure_hpa_max,
              pressure_hpa_mean: cityWeather.pressure_hpa_mean,
              humidity_pct_min: cityWeather.humidity_pct_min,
              humidity_pct_max: cityWeather.humidity_pct_max,
              humidity_pct_mean: cityWeather.humidity_pct_mean,
              wind_speed_mps_mean: cityWeather.wind_speed_mps_mean,
              wind_speed_mps_max: cityWeather.wind_speed_mps_max,
              uv_index_max: cityWeather.uv_index_max,
              weather_code: cityWeather.weather_code,
              is_thunderstorm_day: cityWeather.is_thunderstorm_day,
              city_id: nearestCity.cityId,
              timezone: timezone,
              updated_at: nowIso,
            },
            { onConflict: "user_id,date" }
          );

        if (upsertErr) {
          throw new Error(`Failed to upsert user weather: ${upsertErr.message}`);
        }

        // Mark job as done
        await supabase
          .from("sync_jobs_weather")
          .update({ status: "done", updated_at: nowIso })
          .eq("id", jobId);

        results.push({ jobId, status: "done", cityName: nearestCity.name });
        console.log(`[weather-worker] job=${jobId} done`);

      } catch (e: any) {
        console.error(`[weather-worker] job=${jobId} error:`, e);

        // Mark as failed or back to queued for retry
        const newStatus = job.attempts + 1 >= MAX_ATTEMPTS ? "failed" : "queued";
        await supabase
          .from("sync_jobs_weather")
          .update({
            status: newStatus,
            last_error: String(e?.message ?? e),
            updated_at: nowIso,
          })
          .eq("id", jobId);

        results.push({ jobId, status: "error", error: String(e?.message ?? e) });
      }
    }

    const summary = {
      total: results.length,
      done: results.filter((r) => r.status === "done").length,
      noWeatherData: results.filter((r) => r.status === "no_weather_data").length,
      errors: results.filter((r) => r.status === "error").length,
    };

    console.log("[weather-worker] done", summary);

    return jsonResponse({ ok: true, summary, results });

  } catch (e: any) {
    console.error("[weather-worker] error", e);
    return jsonResponse({ ok: false, error: String(e?.message ?? e) }, 500);
  }
});


===== TITLE: whoop-webhook.txt =====

// supabase/functions/whoop-webhook/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

serve(async (req) => {
  const supabaseUrl = requireEnv("SUPABASE_URL");
  const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

  const supabase = createClient(supabaseUrl, serviceRoleKey, {
    auth: { persistSession: false },
  });

  async function audit(ok: boolean, stage: string, message: string | null, userId: string | null = null) {
    try {
      await supabase.from("edge_audit").insert({
        fn: "whoop-webhook",
        user_id: userId,
        ok,
        stage,
        message,
      });
    } catch (e) {
      console.log("[whoop-webhook] audit failed", e);
    }
  }

  try {
    if (req.method !== "POST") {
      return jsonResponse({ ok: true });
    }

    const body = await req.json();
    const whoopUserId = body?.user_id;
    const eventType = body?.type;

    console.log("[whoop-webhook] event", { whoopUserId, eventType });

    await audit(true, "received", `whoop_user_id=${whoopUserId} type=${eventType}`, null);

    if (!whoopUserId || !eventType) {
      return jsonResponse({ ok: true });
    }

    // Find our user
    const { data: tokenRow } = await supabase
      .from("whoop_tokens")
      .select("user_id")
      .eq("whoop_user_id", whoopUserId)
      .maybeSingle();

    if (!tokenRow) {
      await audit(false, "user_not_found", `whoop_user_id=${whoopUserId}`, null);
      return jsonResponse({ ok: true });
    }

    const userId = tokenRow.user_id;
    const today = new Date().toISOString().slice(0, 10);

    // Get timezone
    const { data: locData } = await supabase
      .from("user_location_daily")
      .select("timezone")
      .eq("user_id", userId)
      .not("timezone", "is", null)
      .order("date", { ascending: false })
      .limit(1)
      .maybeSingle();

    const timezone = locData?.timezone || "UTC";

    // Queue sync job and trigger immediate sync
    if (eventType === "sleep.updated" || eventType === "recovery.updated" || eventType === "workout.updated") {
      // Still queue the job as a fallback/record
      const { error: jobErr } = await supabase
        .from("sync_jobs")
        .upsert({
          job_type: "whoop_daily",
          user_id: userId,
          local_date: today,
          status: "queued",
          attempts: 0,
          created_by: `webhook:${eventType}`,
          timezone: timezone,
          updated_at: new Date().toISOString(),
        }, { onConflict: "job_type,user_id,local_date" });

      if (jobErr) {
        await audit(false, "job_queue_failed", jobErr.message, userId);
      } else {
        await audit(true, "job_queued", `event=${eventType}`, userId);
      }

      // Immediately trigger sync-worker for this user
      try {
        await supabase.functions.invoke('sync-worker', {
          body: { userId, force: true }
        });
        await audit(true, "sync_invoked", `event=${eventType}`, userId);
      } catch (invokeErr: any) {
        await audit(false, "sync_invoke_failed", invokeErr?.message ?? String(invokeErr), userId);
      }
    }

    return jsonResponse({ ok: true });

  } catch (e) {
    console.error("[whoop-webhook] error", e);
    return jsonResponse({ ok: true });
  }
});


