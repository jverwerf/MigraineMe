// supabase/functions/upsert-whoop-token/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

type MetricToggle = { metric: string; enabled: boolean };

type Body = {
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_at?: string | null;

  // NEW: optional client-provided metric toggles
  metric_settings?: MetricToggle[] | null;
};

type EdgeAuditInsert = {
  fn: string;
  user_id: string | null;
  ok: boolean;
  stage: string;
  message: string | null;
};

type ResolveRow = {
  city_id: number;
  timezone: string | null;
  resolved_date?: string | null;
};

type SyncJobInsert = {
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  updated_at: string;
  created_by: string;
  timezone: string;
  city_id: number | null;
};

// Added two toggles (metric_settings rows) so WHOOP connect seeds them for new users.
// Note: reconnect should NOT override user choices unless the client explicitly sends metric_settings.
const WHOOP_METRICS = [
  "recovery_score_daily",
  "resting_hr_daily",
  "hrv_daily",
  "skin_temp_daily",
  "spo2_daily",
  "sleep_duration_daily",
  "sleep_score_daily",
  "sleep_efficiency_daily",
  "sleep_disturbances_daily",
  "sleep_stages_daily",
  "fell_asleep_time_daily",
  "woke_up_time_daily",

  // Activities toggles (these are YOUR internal metric keys; ingestion must consume them)
  "activity_hr_zones_sessions",
  "hr_zones_daily",
] as const;

const WHOOP_METRIC_SET = new Set<string>(WHOOP_METRICS as unknown as string[]);

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function dateRangeInclusive(startIso: string, endIso: string) {
  const out: string[] = [];
  let cur = startIso;
  for (let guard = 0; guard < 500; guard++) {
    out.push(cur);
    if (cur === endIso) break;
    cur = addDaysIsoDate(cur, +1);
  }
  return out;
}

function getLocalTimeParts(timeZone: string, now = new Date()) {
  const fmt = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = fmt.formatToParts(now);
  const get = (type: string) => parts.find((p) => p.type === type)?.value;

  const year = get("year");
  const month = get("month");
  const day = get("day");
  const hour = get("hour");
  const minute = get("minute");

  if (!year || !month || !day || !hour || !minute) {
    throw new Error(`Failed to compute local time parts for timezone=${timeZone}`);
  }

  const localDate = `${year}-${month}-${day}`;
  const hh = Number(hour);
  const mm = Number(minute);

  return { localDate, hh, mm };
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  utcIsoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(utcIsoDate, -1), utcIsoDate, addDaysIsoDate(utcIsoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase.rpc("resolve_user_city_for_date", {
      p_user_id: userId,
      p_date: d,
    });

    if (error) {
      throw new Error(`resolve_user_city_for_date failed for date=${d}: ${error.message}`);
    }

    const row: ResolveRow | undefined = Array.isArray(data) ? data[0] : data;
    if (row?.timezone) return { row, usedDate: row.resolved_date ?? d };
  }

  return { row: null, usedDate: null };
}

function normalizeClientMetricToggles(raw: unknown): { applied: MetricToggle[]; ignored: string[] } {
  if (!Array.isArray(raw)) return { applied: [], ignored: [] };

  const applied: MetricToggle[] = [];
  const ignored: string[] = [];

  for (const item of raw) {
    const metric = typeof (item as any)?.metric === "string" ? String((item as any).metric).trim() : "";
    const enabled = (item as any)?.enabled;

    if (!metric || typeof enabled !== "boolean") {
      ignored.push(metric || "(invalid)");
      continue;
    }

    if (!WHOOP_METRIC_SET.has(metric)) {
      ignored.push(metric);
      continue;
    }

    applied.push({ metric, enabled });
  }

  // de-dupe by metric, last one wins
  const map = new Map<string, boolean>();
  for (const t of applied) map.set(t.metric, t.enabled);
  return {
    applied: Array.from(map.entries()).map(([metric, enabled]) => ({ metric, enabled })),
    ignored,
  };
}

// PATCH: sanitize token fields (trim + remove embedded newlines)
function sanitizeTokenField(raw: unknown): string {
  if (typeof raw !== "string") return "";
  return raw.replace(/\r?\n/g, "").replace(/\r/g, "").trim();
}

// PATCH: Only accept expires_at if it parses AND is in the future.
// If client sends old/invalid, store null so we don't poison DB.
function normalizeClientExpiresAt(raw: unknown, nowUtc: Date): string | null {
  if (raw == null) return null;
  if (typeof raw !== "string") return null;

  const s = raw.trim();
  if (!s) return null;

  const ms = new Date(s).getTime();
  if (Number.isNaN(ms)) return null;

  if (ms <= nowUtc.getTime()) return null;

  return new Date(ms).toISOString();
}

serve(async (req) => {
  console.log("[upsert-whoop-token] start", {
    nowUtc: new Date().toISOString(),
    method: req.method,
    url: req.url,
  });

  const supabaseUrl = requireEnv("SUPABASE_URL");
  const anonKey = requireEnv("SUPABASE_ANON_KEY");
  const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

  const admin = createClient(supabaseUrl, serviceRoleKey, {
    auth: { persistSession: false },
    global: { headers: { "X-Client-Info": "upsert-whoop-token-admin" } },
  });

  async function audit(a: EdgeAuditInsert) {
    try {
      await admin.from("edge_audit").insert(a);
    } catch (e) {
      console.log("[upsert-whoop-token] audit_insert_failed", { error: (e as Error).message });
    }
  }

  try {
    if (req.method !== "POST") {
      await audit({
        fn: "upsert-whoop-token",
        user_id: null,
        ok: false,
        stage: "method_not_allowed",
        message: req.method,
      });
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const authHeader = req.headers.get("Authorization") ?? "";
    if (!authHeader.toLowerCase().startsWith("bearer ")) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: null,
        ok: false,
        stage: "missing_auth",
        message: "Authorization header missing/invalid",
      });
      return jsonResponse({ ok: false, error: "Unauthorized" }, 401);
    }

    const userClient = createClient(supabaseUrl, anonKey, {
      auth: { persistSession: false },
      global: {
        headers: {
          Authorization: authHeader,
          "X-Client-Info": "upsert-whoop-token-user",
        },
      },
    });

    const { data: userData, error: userErr } = await userClient.auth.getUser();
    if (userErr || !userData?.user) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: null,
        ok: false,
        stage: "auth_get_user_failed",
        message: userErr?.message ?? "no user",
      });
      return jsonResponse({ ok: false, error: "Unauthorized" }, 401);
    }

    const userId = userData.user.id;
    await audit({ fn: "upsert-whoop-token", user_id: userId, ok: true, stage: "auth_ok", message: null });

    const body = (await req.json().catch(() => null)) as Body | null;

    const access = sanitizeTokenField(body?.access_token);
    const refresh = sanitizeTokenField(body?.refresh_token);

    if (!access || !refresh) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: userId,
        ok: false,
        stage: "bad_body",
        message: "missing access_token or refresh_token",
      });
      return jsonResponse({ ok: false, error: "Missing access_token/refresh_token" }, 400);
    }

    const tokenType = sanitizeTokenField(body?.token_type) || "Bearer";

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const utcDate = nowIso.slice(0, 10);

    const expiresAt = normalizeClientExpiresAt(body?.expires_at ?? null, nowUtc);

    // 1) Upsert WHOOP tokens (auth only)
    const { error: upsertErr } = await admin.from("whoop_tokens").upsert(
      {
        user_id: userId,
        access_token: access,
        refresh_token: refresh,
        token_type: tokenType,
        expires_at: expiresAt,
        updated_at: nowIso,
        created_at: nowIso,
      },
      { onConflict: "user_id" },
    );

    if (upsertErr) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: userId,
        ok: false,
        stage: "whoop_tokens_upsert_failed",
        message: upsertErr.message,
      });
      return jsonResponse({ ok: false, error: upsertErr.message }, 500);
    }

    await audit({
      fn: "upsert-whoop-token",
      user_id: userId,
      ok: true,
      stage: "whoop_tokens_upsert_ok",
      message: null,
    });

    // NEW: parse client-provided toggles (optional)
    const { applied: clientMetricToggles, ignored: ignoredClientMetrics } = normalizeClientMetricToggles(
      (body as any)?.metric_settings,
    );

    if (ignoredClientMetrics.length) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: userId,
        ok: true,
        stage: "metric_client_ignored",
        message: `ignored=${ignoredClientMetrics.slice(0, 20).join(",")}`,
      });
    }

    // 2a) If client sent toggles, upsert those rows with enabled=true/false (this UPDATES existing rows)
    let clientAppliedCount = 0;
    if (clientMetricToggles.length) {
      const rows = clientMetricToggles.map((t) => ({
        user_id: userId,
        metric: t.metric,
        enabled: t.enabled,
        preferred_source: "whoop",
        allowed_sources: ["whoop"],
        created_at: nowIso,
        updated_at: nowIso,
      }));

      const { error } = await admin.from("metric_settings").upsert(rows, { onConflict: "user_id,metric" });
      if (error) {
        await audit({
          fn: "upsert-whoop-token",
          user_id: userId,
          ok: false,
          stage: "metric_client_upsert_failed",
          message: error.message,
        });
      } else {
        clientAppliedCount = rows.length;
        await audit({
          fn: "upsert-whoop-token",
          user_id: userId,
          ok: true,
          stage: "metric_client_upsert_ok",
          message: `applied=${clientAppliedCount}`,
        });
      }
    }

    // 2b) Seed any missing WHOOP metrics without overriding existing user choices.
    const seedRows = WHOOP_METRICS.map((metric) => ({
      user_id: userId,
      metric,
      enabled: true,
      preferred_source: "whoop",
      allowed_sources: ["whoop"],
      created_at: nowIso,
      updated_at: nowIso,
    }));

    const { error: seedErr } = await admin.from("metric_settings").upsert(seedRows, {
      onConflict: "user_id,metric",
      ignoreDuplicates: true,
    });

    if (seedErr) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: userId,
        ok: false,
        stage: "metric_bootstrap_failed",
        message: seedErr.message,
      });
      // Do not fail connect if tokens succeeded
    } else {
      await audit({
        fn: "upsert-whoop-token",
        user_id: userId,
        ok: true,
        stage: "metric_bootstrap_ok",
        message: `seeded_missing_metrics count=${WHOOP_METRICS.length}`,
      });
    }

    // 3) Enqueue initial backfill immediately (30 days local, skip finalized days)
    let enqueuedJobs = 0;
    try {
      const resolved = await resolveWithDateFallback(admin, userId, utcDate);
      const row = resolved.row;

      if (!row?.timezone) {
        await audit({
          fn: "upsert-whoop-token",
          user_id: userId,
          ok: true,
          stage: "backfill_skipped_no_timezone",
          message: `usedResolveDate=${resolved.usedDate ?? "null"}`,
        });
      } else {
        const tz = row.timezone;
        const cityId = typeof row.city_id === "number" ? row.city_id : null;

        const { localDate } = getLocalTimeParts(tz, nowUtc);

        const startLocalDate = addDaysIsoDate(localDate, -29);
        const endLocalDate = localDate;
        const days = dateRangeInclusive(startLocalDate, endLocalDate);

        const { data: alreadyRan, error: ranErr } = await admin
          .from("backend_daily_runs")
          .select("local_date")
          .eq("user_id", userId)
          .in("local_date", days);

        if (ranErr) throw new Error(`backend_daily_runs query failed: ${ranErr.message}`);

        const ranSet = new Set((alreadyRan ?? []).map((r: any) => String(r.local_date)));

        const jobs: SyncJobInsert[] = [];
        for (const d of days) {
          if (ranSet.has(d)) continue;
          jobs.push({
            job_type: "whoop_daily",
            user_id: userId,
            local_date: d,
            status: "queued",
            updated_at: nowIso,
            created_by: "whoop-connect",
            timezone: tz,
            city_id: cityId,
          });
        }

        if (jobs.length) {
          const { error: insErr } = await admin.from("sync_jobs").upsert(jobs, {
            onConflict: "job_type,user_id,local_date",
            ignoreDuplicates: true,
          });
          if (insErr) throw new Error(`sync_jobs upsert failed: ${insErr.message}`);

          enqueuedJobs = jobs.length;
          await audit({
            fn: "upsert-whoop-token",
            user_id: userId,
            ok: true,
            stage: "backfill_enqueued",
            message: `local=${startLocalDate}..${endLocalDate} jobs=${enqueuedJobs} tz=${tz}`,
          });
        } else {
          await audit({
            fn: "upsert-whoop-token",
            user_id: userId,
            ok: true,
            stage: "backfill_nothing_missing",
            message: `local=${startLocalDate}..${endLocalDate} tz=${tz}`,
          });
        }
      }
    } catch (e) {
      await audit({
        fn: "upsert-whoop-token",
        user_id: userId,
        ok: false,
        stage: "backfill_exception",
        message: (e as Error).message,
      });
    }

    return jsonResponse({
      ok: true,
      userId,
      enqueuedJobs,
      metricSettings: {
        clientApplied: clientAppliedCount,
        clientIgnored: ignoredClientMetrics,
        allowlisted: WHOOP_METRICS.length,
      },
    });
  } catch (e) {
    const msg = (e as Error).message;
    await audit({ fn: "upsert-whoop-token", user_id: null, ok: false, stage: "exception", message: msg });
    return jsonResponse({ ok: false, error: msg }, 500);
  }
});
