// FILE: supabase/functions/noise-index-worker/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.45.4";

type ResolveRow = {
  city_id: number;
  timezone: string | null;
  resolved_date?: string | null;
};

type SyncJobRow = {
  id: string | number;
  job_type: string;
  user_id: string;
  local_date: string;
  status: string;
  attempts: number;
  locked_at: string | null;
};

function jsonResponse(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function requireEnv(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

function addDaysIsoDate(isoDate: string, deltaDays: number): string {
  const [y, m, d] = isoDate.split("-").map((x) => Number(x));
  const dt = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));
  dt.setUTCDate(dt.getUTCDate() + deltaDays);
  return dt.toISOString().slice(0, 10);
}

function parseGmtOffsetToMinutes(gmt: string): number | null {
  const raw = (gmt ?? "").trim().toUpperCase();
  if (raw === "GMT" || raw === "UTC" || raw === "UT") return 0;

  const m = raw.match(/(?:GMT|UTC)?\s*([+-])\s*(\d{1,2})(?::?(\d{2}))?$/);
  if (!m) return null;

  const sign = m[1] === "-" ? -1 : 1;
  const hh = Number(m[2]);
  const mm = m[3] ? Number(m[3]) : 0;
  return sign * (hh * 60 + mm);
}

function getOffsetMinutesForInstant(timeZone: string, instant: Date): number {
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone,
    timeZoneName: "shortOffset",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
  const parts = fmt.formatToParts(instant);
  const tzPart = parts.find((p) => p.type === "timeZoneName")?.value ?? "";
  const mins = parseGmtOffsetToMinutes(tzPart);
  if (mins == null) throw new Error(`Could not parse timezone offset "${tzPart}" for tz=${timeZone}`);
  return mins;
}

function localDateTimeToUtcIso(
  timeZone: string,
  y: number,
  m: number,
  d: number,
  hh: number,
  mm: number,
  ss: number,
): string {
  const baseUtc = Date.UTC(y, m - 1, d, hh, mm, ss);
  let guess = baseUtc;

  // converge offset for DST transitions
  for (let i = 0; i < 3; i++) {
    const offsetMin = getOffsetMinutesForInstant(timeZone, new Date(guess));
    guess = baseUtc - offsetMin * 60_000;
  }

  return new Date(guess).toISOString();
}

async function resolveWithDateFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  isoDate: string,
): Promise<{ row: ResolveRow | null; usedDate: string | null }> {
  const candidates = [addDaysIsoDate(isoDate, -1), isoDate, addDaysIsoDate(isoDate, +1)];

  for (const d of candidates) {
    const { data, error } = await supabase.rpc("resolve_user_city_for_date", {
      p_user_id: userId,
      p_date: d,
    });

    if (error) throw new Error(`resolve_user_city_for_date failed for date=${d}: ${error.message}`);

    const row: ResolveRow | undefined = Array.isArray(data) ? data[0] : data;
    if (row?.timezone) return { row, usedDate: row.resolved_date ?? d };
  }

  return { row: null, usedDate: null };
}

function numOrNull(v: unknown): number | null {
  const n = typeof v === "number" ? v : typeof v === "string" ? Number(v) : NaN;
  return Number.isFinite(n) ? n : null;
}

function intOrNull(v: unknown): number | null {
  const n = numOrNull(v);
  if (n == null) return null;
  return Math.trunc(n);
}

function clamp01(x: number): number {
  if (x < 0) return 0;
  if (x > 1) return 1;
  return x;
}

// Map mean dB to index in [0..100]:
// <= 40 dB => 100, >= 80 dB => 0 (linear clamp)
function noiseDbToIndex(meanDb: number): number {
  const lo = 40;
  const hi = 80;
  const t = clamp01((meanDb - lo) / (hi - lo));
  return (1 - t) * 100.0;
}

serve(async (req) => {
  console.log("[noise-index-worker] start", { nowUtc: new Date().toISOString(), method: req.method, url: req.url });

  try {
    if (req.method !== "POST" && req.method !== "GET") {
      return jsonResponse({ ok: false, error: "Method not allowed" }, 405);
    }

    const supabaseUrl = requireEnv("SUPABASE_URL");
    const serviceRoleKey = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
      global: { headers: { "X-Client-Info": "noise-index-worker" } },
    });

    const nowUtc = new Date();
    const nowIso = nowUtc.toISOString();
    const staleCutoffIso = new Date(nowUtc.getTime() - 30 * 60_000).toISOString();

    // Pick noise jobs only
    const { data: jobs, error: jobsErr } = await supabase
      .from("sync_jobs")
      .select("id,job_type,user_id,local_date,status,attempts,locked_at")
      .eq("job_type", "noise_index_daily")
      .or(`status.eq.queued,status.eq.running.and(locked_at.lt.${staleCutoffIso})`)
      .order("local_date", { ascending: true })
      .order("created_at", { ascending: true })
      .limit(50);

    if (jobsErr) throw new Error(`sync_jobs select failed: ${jobsErr.message}`);

    const picked = (jobs ?? []) as SyncJobRow[];
    if (!picked.length) {
      return jsonResponse({ ok: true, summary: { picked: 0, nowUtc: nowIso } });
    }

    async function lockJob(job: SyncJobRow): Promise<boolean> {
      const lockIso = new Date().toISOString();

      if (job.status === "queued") {
        const { data, error } = await supabase
          .from("sync_jobs")
          .update({ status: "running", locked_at: lockIso, updated_at: lockIso, last_error: null })
          .eq("id", job.id)
          .eq("status", "queued")
          .select("id")
          .maybeSingle();

        if (error) return false;
        return Boolean(data);
      }

      const { data, error } = await supabase
        .from("sync_jobs")
        .update({ status: "running", locked_at: lockIso, updated_at: lockIso })
        .eq("id", job.id)
        .eq("status", "running")
        .lt("locked_at", staleCutoffIso)
        .select("id")
        .maybeSingle();

      if (error) return false;
      return Boolean(data);
    }

    async function bumpAttempts(jobId: string | number): Promise<number> {
      const { data: row, error: selErr } = await supabase.from("sync_jobs").select("attempts").eq("id", jobId).maybeSingle();
      if (selErr) throw new Error(`bump_attempts_select_failed: ${selErr.message}`);

      const current = typeof (row as any)?.attempts === "number" ? (row as any).attempts : 0;
      const next = current + 1;

      const { error: updErr } = await supabase
        .from("sync_jobs")
        .update({ attempts: next, updated_at: new Date().toISOString() })
        .eq("id", jobId);

      if (updErr) throw new Error(`bump_attempts_update_failed: ${updErr.message}`);

      return next;
    }

    async function markJobDone(jobId: string | number) {
      const endIso = new Date().toISOString();
      await supabase.from("sync_jobs").update({ status: "done", finished_at: endIso, updated_at: endIso, locked_at: null }).eq("id", jobId);
    }

    async function markJobError(jobId: string | number, errMsg: string) {
      const endIso = new Date().toISOString();
      await supabase
        .from("sync_jobs")
        .update({ status: "error", last_error: errMsg, finished_at: endIso, updated_at: endIso, locked_at: null })
        .eq("id", jobId);
    }

    async function process(job: SyncJobRow) {
      const locked = await lockJob(job);
      if (!locked) return { jobId: job.id, status: "skipped_lock_race" };

      const userId = String(job.user_id);
      const jobLocalDate = String(job.local_date);

      try {
        await bumpAttempts(job.id);

        const out = await resolveWithDateFallback(supabase, userId, jobLocalDate);
        if (!out.row?.timezone) {
          await markJobError(job.id, "no_timezone");
          return { jobId: job.id, userId, date: jobLocalDate, status: "no_timezone" };
        }

        const tz = out.row.timezone;

        // 24h window ending at 09:00 LOCAL on this local_date
        const [y, m, d] = jobLocalDate.split("-").map((x) => Number(x));
        const windowEndUtcIso = localDateTimeToUtcIso(tz, y, m, d, 9, 0, 0);
        const windowEndMs = new Date(windowEndUtcIso).getTime();
        const windowStartUtcIso = new Date(windowEndMs - 24 * 60 * 60 * 1000).toISOString();

        // Pull samples in window
        const { data: rows, error } = await supabase
          .from("ambient_noise_samples")
          .select("start_ts,duration_s,l_mean,l_p90,l_max")
          .eq("user_id", userId)
          .gte("start_ts", windowStartUtcIso)
          .lt("start_ts", windowEndUtcIso)
          .order("start_ts", { ascending: true });

        if (error) throw new Error(`ambient_noise_samples query failed: ${error.message}`);

        const samples = (rows ?? []) as any[];

        let sampleCount = 0;
        let totalDur = 0;
        let weightedSum = 0;

        let p90Max: number | null = null;
        let maxMax: number | null = null;

        for (const r of samples) {
          const dur = intOrNull(r?.duration_s) ?? 0;
          const mean = numOrNull(r?.l_mean);
          const p90 = numOrNull(r?.l_p90);
          const mx = numOrNull(r?.l_max);

          if (dur > 0 && mean != null) {
            sampleCount += 1;
            totalDur += dur;
            weightedSum += mean * dur;
          }

          if (p90 != null) p90Max = p90Max == null ? p90 : Math.max(p90Max, p90);
          if (mx != null) maxMax = maxMax == null ? mx : Math.max(maxMax, mx);
        }

        const meanDb = totalDur > 0 ? weightedSum / totalDur : null;
        const indexScore = meanDb == null ? 0 : noiseDbToIndex(meanDb);

        const computedAt = new Date().toISOString();

        // IMPORTANT:
        // Your DB schema has baseline_days as NOT NULL.
        // We are not computing a baseline yet, so we set baseline_days = 0.
        const baselineDays = 0;

        const { error: upErr } = await supabase
          .from("ambient_noise_index_daily")
          .upsert(
            {
              user_id: userId,
              date: jobLocalDate,
              source: "computed",

              value_index_pct: indexScore,
              samples_count: sampleCount,
              day_mean_lmean: meanDb,
              day_mean_lp90: p90Max,
              day_max_lmax: maxMax,

              baseline_days: baselineDays,
              baseline_mean_lmean: null,
              baseline_mean_lp90: null,
              baseline_max_lmax: null,

              computed_at: computedAt,
              created_at: computedAt,
              updated_at: computedAt,
            },
            { onConflict: "user_id,date,source" },
          );

        if (upErr) throw new Error(`ambient_noise_index_daily upsert failed: ${upErr.message}`);

        await markJobDone(job.id);

        return {
          jobId: job.id,
          status: "done",
          userId,
          date: jobLocalDate,
          timezone: tz,
          windowStartUtcIso,
          windowEndUtcIso,
          sampleCount,
          totalDur,
          meanDb,
          p90Max,
          maxMax,
          indexScore,
          baselineDays,
        };
      } catch (e) {
        const msg = (e as Error).message;
        await markJobError(job.id, msg);
        return { jobId: job.id, status: "error", error: msg, userId, date: jobLocalDate };
      }
    }

    const results: any[] = [];
    for (const j of picked) results.push(await process(j));

    const summary = {
      picked: picked.length,
      done: results.filter((r) => r.status === "done").length,
      errors: results.filter((r) => r.status === "error").length,
      nowUtc: nowIso,
    };

    return jsonResponse({ ok: true, summary, results });
  } catch (e) {
    console.log("[noise-index-worker] fatal", { error: (e as Error).message });
    return jsonResponse({ ok: false, error: (e as Error).message }, 500);
  }
});
