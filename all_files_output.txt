title: ActivitiesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun ActivitiesScreen(
    navController: NavController,
    vm: ActivityViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {},
    quickLogMode: Boolean = false,
    onSave: (() -> Unit)? = null,
    linkedMigraineId: String? = null,
    onMigraineSelect: ((String?) -> Unit)? = null
) {
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken, draft.migraine?.beganAtIso) {
        authState.accessToken?.let {
            vm.loadAll(it)
            vm.loadRecent(it, draft.migraine?.beganAtIso)
        }
    }

    // Recent activities: type (lowercase) → days ago / start_at
    val recentDaysAgo by vm.recentDaysAgo.collectAsState()
    val recentStartAts by vm.recentStartAts.collectAsState()
    var hasAutoSelected by remember { mutableStateOf(false) }

    // Reset auto-select when migraine date changes
    LaunchedEffect(draft.migraine?.beganAtIso) {
        hasAutoSelected = false
    }

    fun rebuildDraftWithActivities(acts: List<ActivityDraft>) {
        logVm.replaceActivities(acts)
    }

    // ── Auto-select recent activities (once, on first load — wizard only) ──
    // Recent data uses lowercase activity_type; pool uses title case labels
    // Only auto-select when user has explicitly set a migraine date
    LaunchedEffect(recentDaysAgo, pool) {
        if (!quickLogMode && !hasAutoSelected && recentDaysAgo.isNotEmpty() && pool.isNotEmpty() && draft.migraine?.beganAtIso != null) {
            val currentLabels = draft.activities.map { it.type.lowercase() }.toSet()
            // Build lowercase → title case mapping from pool
            val poolLabelMap = pool.associate { it.label.lowercase() to it.label }
            val toAdd = recentDaysAgo.keys
                .filter { it in poolLabelMap && it !in currentLabels }
            if (toAdd.isNotEmpty()) {
                val newActs = draft.activities + toAdd.map { key ->
                    ActivityDraft(
                        type = poolLabelMap[key] ?: key,
                        startAtIso = recentStartAts[key]
                    )
                }
                rebuildDraftWithActivities(newActs)
            }
            hasAutoSelected = true
        }
    }

    // ── Time dialog: add new ──
    var showAddTimeDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }

    // ── Time dialog: edit existing ──
    var showEditTimeDialog by remember { mutableStateOf(false) }
    var editIndex by remember { mutableStateOf<Int?>(null) }

    fun onTap(label: String) {
        val idx = draft.activities.indexOfFirst { it.type == label }
        if (idx >= 0) {
            rebuildDraftWithActivities(draft.activities.toMutableList().apply { removeAt(idx) })
        } else {
            pendingLabel = label
            showAddTimeDialog = true
        }
    }

    // Add dialog
    if (showAddTimeDialog && pendingLabel != null) {
        ActTimeDialog(
            title = pendingLabel!!,
            initialIso = null,
            initialEndIso = null,
            onDismiss = { showAddTimeDialog = false },
            onSkip = {
                val updated = draft.activities + ActivityDraft(pendingLabel!!, startAtIso = null, endAtIso = null)
                rebuildDraftWithActivities(updated)
                showAddTimeDialog = false
            },
            onConfirm = { startIso, endIso ->
                val updated = draft.activities + ActivityDraft(pendingLabel!!, startAtIso = startIso, endAtIso = endIso)
                rebuildDraftWithActivities(updated)
                showAddTimeDialog = false
            }
        )
    }

    // Edit dialog
    if (showEditTimeDialog && editIndex != null && editIndex!! in draft.activities.indices) {
        val editing = draft.activities[editIndex!!]
        ActTimeDialog(
            title = editing.type,
            initialIso = editing.startAtIso,
            initialEndIso = editing.endAtIso,
            onDismiss = { showEditTimeDialog = false },
            onSkip = {
                val updated = draft.activities.toMutableList().apply {
                    set(editIndex!!, editing.copy(startAtIso = null, endAtIso = null))
                }
                rebuildDraftWithActivities(updated)
                showEditTimeDialog = false
            },
            onConfirm = { startIso, endIso ->
                val updated = draft.activities.toMutableList().apply {
                    set(editIndex!!, editing.copy(startAtIso = startIso, endAtIso = endIso))
                }
                rebuildDraftWithActivities(updated)
                showEditTimeDialog = false
            }
        )
    }

    val frequentLabels = remember(frequent) { frequent.mapNotNull { it.activity?.label }.toSet() }
    val selectedLabels = remember(draft.activities) { draft.activities.map { it.type }.toSet() }
    val grouped = remember(pool) { pool.groupBy { it.category ?: "Other" }.toSortedMap() }

    // Build daysAgo lookup keyed by title-case label (matching pool)
    val daysAgoByLabel = remember(recentDaysAgo, pool) {
        val poolLabelMap = pool.associate { it.label.lowercase() to it.label }
        recentDaysAgo.mapKeys { (k, _) -> poolLabelMap[k] ?: k }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                if (!quickLogMode) {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                        Spacer(Modifier.width(4.dp))
                        Text("Location", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                    }
                } else {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    }
                }
                Text("Activity", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                if (!quickLogMode) {
                    IconButton(onClick = onClose) { Icon(Icons.Outlined.Close, "Close", tint = Color.White, modifier = Modifier.size(28.dp)) }
                } else {
                    Spacer(Modifier.size(28.dp))
                }
            }

            HeroCard {
                Box(Modifier.size(40.dp).drawBehind {
                    HubIcons.run { drawActivityPulse(Color(0xFFFF8A65)) }
                })
                Text("What were you doing?", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.activities.isEmpty()) "Log your activity" else "${draft.activities.size} activit${if (draft.activities.size > 1) "ies" else "y"} added",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center
                )
                if (draft.activities.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.activities.forEachIndexed { index, act ->
                        Row(
                            Modifier.fillMaxWidth().padding(vertical = 3.dp).clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f)).padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Column(Modifier.weight(1f)) {
                                Text(act.type, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium))
                                Text(
                                    if (act.startAtIso == null) "Same as migraine start" else formatActTime(act.startAtIso),
                                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall
                                )
                                if (act.endAtIso != null) {
                                    Text(
                                        "→ ${formatActTime(act.endAtIso)}",
                                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall
                                    )
                                }
                                if (act.startAtIso != null && act.endAtIso != null) {
                                    deriveDurationMinutes(act.startAtIso, act.endAtIso)?.let { mins ->
                                        Text(
                                            if (mins >= 60) "${mins / 60}h ${mins % 60}m" else "${mins}m",
                                            color = AppTheme.AccentPurple.copy(alpha = 0.7f), style = MaterialTheme.typography.labelSmall
                                        )
                                    }
                                }
                            }
                            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                Icon(Icons.Outlined.Edit, "Edit time", tint = AppTheme.AccentPurple.copy(alpha = 0.6f),
                                    modifier = Modifier.size(18.dp).clickable { editIndex = index; showEditTimeDialog = true })
                                Icon(Icons.Outlined.Close, "Remove", tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                    modifier = Modifier.size(18.dp).clickable {
                                        rebuildDraftWithActivities(draft.activities.toMutableList().apply { removeAt(index) })
                                    })
                            }
                        }
                    }
                }
            }

            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Activities", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_ACTIVITIES) })
                }
            }

            if (quickLogMode && onMigraineSelect != null) {
                val firstIso = draft.activities.firstOrNull()?.startAtIso
                MigrainePickerCard(itemStartAtIso = firstIso, authVm = authVm, selectedMigraineId = linkedMigraineId, onSelect = onMigraineSelect)
            }

            BaseCard {
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { act ->
                            ActCircleButton(act.label, act.label in selectedLabels, act.iconKey, daysAgo = daysAgoByLabel[act.label]) { onTap(act.label) }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }
                val entries = grouped.entries.toList()
                entries.forEachIndexed { ci, (cat, items) ->
                    val nonFreq = items.filter { it.label !in frequentLabels }
                    if (nonFreq.isNotEmpty()) {
                        Text(cat, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreq.forEach { act -> ActCircleButton(act.label, act.label in selectedLabels, act.iconKey, daysAgo = daysAgoByLabel[act.label]) { onTap(act.label) } }
                        }
                        if (entries.drop(ci + 1).any { (_, its) -> its.any { it.label !in frequentLabels } })
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                    }
                }
                if (pool.isEmpty()) Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }

            Row(Modifier.fillMaxWidth().padding(vertical = 8.dp), horizontalArrangement = Arrangement.SpaceBetween) {
                OutlinedButton(onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Cancel" else "Back") }
                Button(onClick = { if (quickLogMode) onSave?.invoke() else navController.navigate(Routes.MISSED_ACTIVITIES) },
                    enabled = !quickLogMode || draft.activities.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Save" else "Next") }
            }
            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun ActCircleButton(label: String, isSelected: Boolean, iconKey: String? = null, daysAgo: Int? = null, onClick: () -> Unit) {
    val accent = Color(0xFFFF8A65)
    val icon = ActivityIcons.forKey(iconKey)

    val (bg, border) = when {
        isSelected && daysAgo == null -> accent.copy(alpha = 0.40f) to accent.copy(alpha = 0.7f)
        isSelected && daysAgo == 0   -> accent.copy(alpha = 0.50f) to accent.copy(alpha = 0.85f)
        isSelected && daysAgo == 1   -> Color(0xFFE57373).copy(alpha = 0.35f) to Color(0xFFE57373).copy(alpha = 0.65f)
        isSelected && daysAgo == 2   -> Color(0xFFEF5350).copy(alpha = 0.30f) to Color(0xFFEF5350).copy(alpha = 0.55f)
        isSelected && daysAgo == 3   -> Color(0xFFEF9A9A).copy(alpha = 0.25f) to Color(0xFFEF9A9A).copy(alpha = 0.45f)
        else -> Color.White.copy(alpha = 0.08f) to Color.White.copy(alpha = 0.12f)
    }
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.width(72.dp).clickable(remember { MutableInteractionSource() }, null, onClick = onClick)
    ) {
        Box(Modifier.size(52.dp).clip(CircleShape).background(bg).border(1.5.dp, border, CircleShape), contentAlignment = Alignment.Center) {
            if (icon != null) {
                Icon(imageVector = icon, contentDescription = label, tint = iconTint, modifier = Modifier.size(24.dp))
            } else {
                Text(label.take(2).uppercase(), color = iconTint,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold))
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(label, color = textColor,
            style = MaterialTheme.typography.labelSmall, textAlign = TextAlign.Center, maxLines = 2, modifier = Modifier.fillMaxWidth())
        if (isSelected && daysAgo != null && daysAgo > 0) {
            Text(
                when (daysAgo) { 1 -> "yesterday"; 2 -> "2d ago"; 3 -> "3d ago"; else -> "" },
                color = Color.White.copy(alpha = 0.5f),
                style = MaterialTheme.typography.labelSmall.copy(fontSize = 9.sp),
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
private fun ActTimeDialog(title: String, initialIso: String? = null, initialEndIso: String? = null, onDismiss: () -> Unit, onSkip: (() -> Unit)?, onConfirm: (startIso: String?, endIso: String?) -> Unit) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    var pickedEndIso by remember { mutableStateOf(initialEndIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E), titleContentColor = Color.White, textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Start: ${formatActTime(pickedIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Set start time", onDateTimeSelected = { pickedIso = it })
                Spacer(Modifier.height(4.dp))
                Text("End: ${formatActTime(pickedEndIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Set end time (optional)", onDateTimeSelected = { pickedEndIso = it })
                if (pickedIso != null && pickedEndIso != null) {
                    deriveDurationMinutes(pickedIso!!, pickedEndIso!!)?.let { mins ->
                        Text("Duration: ${if (mins >= 60) "${mins / 60}h ${mins % 60}m" else "${mins}m"}", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                    }
                }
            }
        },
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso, pickedEndIso) }) { Text(if (onSkip != null) "Add" else "Save", color = AppTheme.AccentPurple) } },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) { Text("Cancel", color = AppTheme.SubtleTextColor) }
                if (onSkip != null) TextButton(onClick = onSkip) { Text("Skip", color = Color(0xFFFF8A65)) }
            }
        }
    )
}

private fun formatActTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull() ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) { "Not set" }
}

private fun deriveDurationMinutes(startIso: String, endIso: String): Int? {
    return try {
        val s = runCatching { OffsetDateTime.parse(startIso).toLocalDateTime() }.getOrNull()
            ?: runCatching { LocalDateTime.parse(startIso) }.getOrNull()
            ?: runCatching { Instant.parse(startIso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull() ?: return null
        val e = runCatching { OffsetDateTime.parse(endIso).toLocalDateTime() }.getOrNull()
            ?: runCatching { LocalDateTime.parse(endIso) }.getOrNull()
            ?: runCatching { Instant.parse(endIso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull() ?: return null
        val dur = java.time.Duration.between(s, e)
        if (dur.isNegative) null else dur.toMinutes().toInt()
    } catch (_: Exception) { null }
}


title: ActivityIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

object ActivityIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    // ─── EXERCISE ───────────────────────────────────────────

    /** cycling — bicycle */
    val Cycling: ImageVector by lazy {
        ImageVector.Builder("Cycling", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 18f); arcTo(3f, 3f, 0f, true, true, 1f, 18f); arcTo(3f, 3f, 0f, true, true, 7f, 18f)
                moveTo(23f, 18f); arcTo(3f, 3f, 0f, true, true, 17f, 18f); arcTo(3f, 3f, 0f, true, true, 23f, 18f)
                moveTo(12f, 18f); lineTo(12f, 12f); lineTo(17f, 7f)
                moveTo(12f, 12f); lineTo(4f, 18f)
                moveTo(17f, 7f); lineTo(20f, 7f)
                moveTo(14f, 4f); lineTo(17f, 4f); lineTo(17f, 7f)
            }
        }.build()
    }

    /** exercising — jumping figure */
    val Exercising: ImageVector by lazy {
        ImageVector.Builder("Exercising", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 13f)
                moveTo(12f, 9f); lineTo(6f, 6f); moveTo(12f, 9f); lineTo(18f, 6f)
                moveTo(12f, 13f); lineTo(7f, 20f); moveTo(12f, 13f); lineTo(17f, 20f)
            }
        }.build()
    }

    /** running — runner */
    val Running: ImageVector by lazy {
        ImageVector.Builder("Running", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(16f, 4f); arcTo(2f, 2f, 0f, true, true, 12f, 4f); arcTo(2f, 2f, 0f, true, true, 16f, 4f)
                moveTo(10f, 22f); lineTo(12f, 16f); lineTo(15f, 14f)
                moveTo(6f, 16f); lineTo(9f, 12f); lineTo(14f, 10f); lineTo(18f, 12f)
                moveTo(14f, 10f); lineTo(16f, 6f)
                moveTo(18f, 22f); lineTo(16f, 16f); lineTo(15f, 14f)
            }
        }.build()
    }

    /** swimming — swimmer */
    val Swimming: ImageVector by lazy {
        ImageVector.Builder("Swimming", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 6f); arcTo(2f, 2f, 0f, true, true, 3f, 6f); arcTo(2f, 2f, 0f, true, true, 7f, 6f)
                moveTo(5f, 8f); lineTo(10f, 11f); lineTo(16f, 8f)
                moveTo(10f, 11f); lineTo(10f, 14f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 17f); curveTo(4f, 15f, 6f, 15f, 8f, 17f); curveTo(10f, 19f, 12f, 19f, 14f, 17f)
                curveTo(16f, 15f, 18f, 15f, 20f, 17f); curveTo(21f, 18f, 22f, 18f, 22f, 17f)
            }
        }.build()
    }

    /** walking — person walking */
    val Walking: ImageVector by lazy {
        ImageVector.Builder("Walking", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 14f)
                moveTo(12f, 9f); lineTo(8f, 12f); moveTo(12f, 9f); lineTo(16f, 11f)
                moveTo(12f, 14f); lineTo(9f, 22f); moveTo(12f, 14f); lineTo(15f, 22f)
            }
        }.build()
    }

    /** yoga — tree pose */
    val Yoga: ImageVector by lazy {
        ImageVector.Builder("Yoga", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 16f)
                moveTo(12f, 9f); lineTo(7f, 4f); moveTo(12f, 9f); lineTo(17f, 4f)
                moveTo(12f, 16f); lineTo(12f, 22f)
                moveTo(12f, 14f); lineTo(15f, 16f); lineTo(12f, 18f)
            }
        }.build()
    }

    // ─── LEISURE ────────────────────────────────────────────

    /** gaming — game controller */
    val Gaming: ImageVector by lazy {
        ImageVector.Builder("Gaming", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 9f); curveTo(4f, 7f, 6f, 6f, 8f, 6f); lineTo(16f, 6f); curveTo(18f, 6f, 20f, 7f, 20f, 9f)
                lineTo(20f, 13f); curveTo(20f, 16f, 18f, 18f, 16f, 18f); lineTo(8f, 18f); curveTo(6f, 18f, 4f, 16f, 4f, 13f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 10f); lineTo(8f, 14f); moveTo(6f, 12f); lineTo(10f, 12f)
                moveTo(15f, 10f); lineTo(15.1f, 10f); moveTo(17f, 13f); lineTo(17.1f, 13f)
            }
        }.build()
    }

    /** hobbies — palette */
    val Hobbies: ImageVector by lazy {
        ImageVector.Builder("Hobbies", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); curveTo(17f, 2f, 22f, 6f, 22f, 12f); curveTo(22f, 14f, 20f, 15f, 18f, 15f)
                lineTo(16f, 15f); curveTo(15f, 15f, 14f, 16f, 14f, 17f); curveTo(14f, 18f, 14f, 19f, 13f, 20f)
                curveTo(12f, 21f, 10f, 22f, 8f, 22f); curveTo(4f, 22f, 2f, 18f, 2f, 12f); curveTo(2f, 6f, 6f, 2f, 12f, 2f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 12f); lineTo(7.1f, 12f)
                moveTo(12f, 7f); lineTo(12.1f, 7f)
                moveTo(17f, 10f); lineTo(17.1f, 10f)
            }
        }.build()
    }

    /** reading — open book */
    val Reading: ImageVector by lazy {
        ImageVector.Builder("Reading", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 4f); lineTo(2f, 18f); curveTo(2f, 18f, 5f, 16f, 12f, 16f)
                moveTo(22f, 4f); lineTo(22f, 18f); curveTo(22f, 18f, 19f, 16f, 12f, 16f)
                moveTo(12f, 16f); lineTo(12f, 4f)
                moveTo(2f, 4f); curveTo(2f, 4f, 5f, 2f, 12f, 4f)
                moveTo(22f, 4f); curveTo(22f, 4f, 19f, 2f, 12f, 4f)
            }
        }.build()
    }

    // ─── OTHER ──────────────────────────────────────────────

    /** childcare — baby/person */
    val Childcare: ImageVector by lazy {
        ImageVector.Builder("Childcare", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 5f); arcTo(2f, 2f, 0f, true, true, 15f, 5f); arcTo(2f, 2f, 0f, true, true, 19f, 5f)
                moveTo(17f, 7f); lineTo(17f, 13f)
                moveTo(17f, 10f); lineTo(21f, 12f); moveTo(17f, 10f); lineTo(13f, 8f)
                moveTo(17f, 13f); lineTo(15f, 20f); moveTo(17f, 13f); lineTo(19f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(9f, 8f); arcTo(2f, 2f, 0f, true, true, 5f, 8f); arcTo(2f, 2f, 0f, true, true, 9f, 8f)
                moveTo(7f, 10f); lineTo(7f, 14f)
                moveTo(7f, 14f); lineTo(5f, 19f); moveTo(7f, 14f); lineTo(9f, 19f)
            }
        }.build()
    }

    /** cleaning — broom/sparkle */
    val Cleaning: ImageVector by lazy {
        ImageVector.Builder("Cleaning", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 12f)
                moveTo(8f, 12f); lineTo(16f, 12f); lineTo(18f, 22f); lineTo(6f, 22f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(19f, 3f); lineTo(19f, 5f); moveTo(18f, 4f); lineTo(20f, 4f)
                moveTo(5f, 6f); lineTo(5f, 8f); moveTo(4f, 7f); lineTo(6f, 7f)
            }
        }.build()
    }

    /** cooking — pot with steam */
    val Cooking: ImageVector by lazy {
        ImageVector.Builder("Cooking", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 12f); lineTo(20f, 12f); lineTo(20f, 18f); curveTo(20f, 20f, 18f, 21f, 16f, 21f)
                lineTo(8f, 21f); curveTo(6f, 21f, 4f, 20f, 4f, 18f); close()
                moveTo(2f, 12f); lineTo(22f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(9f, 9f); curveTo(9f, 7f, 10f, 6f, 9f, 5f)
                moveTo(12f, 9f); curveTo(12f, 7f, 13f, 6f, 12f, 5f)
                moveTo(15f, 9f); curveTo(15f, 7f, 16f, 6f, 15f, 5f)
            }
        }.build()
    }

    /** shopping — bag */
    val Shopping: ImageVector by lazy {
        ImageVector.Builder("Shopping", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 8f); lineTo(5f, 20f); lineTo(19f, 20f); lineTo(19f, 8f); close()
                moveTo(8f, 8f); lineTo(8f, 6f); curveTo(8f, 4f, 10f, 2f, 12f, 2f); curveTo(14f, 2f, 16f, 4f, 16f, 6f); lineTo(16f, 8f)
            }
        }.build()
    }

    // ─── SCREEN ─────────────────────────────────────────────

    /** phone — mobile phone */
    val Phone: ImageVector by lazy {
        ImageVector.Builder("Phone", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 2f); lineTo(17f, 2f); curveTo(18f, 2f, 19f, 3f, 19f, 4f); lineTo(19f, 20f)
                curveTo(19f, 21f, 18f, 22f, 17f, 22f); lineTo(7f, 22f); curveTo(6f, 22f, 5f, 21f, 5f, 20f); lineTo(5f, 4f); curveTo(5f, 3f, 6f, 2f, 7f, 2f)
                moveTo(12f, 18f); lineTo(12.1f, 18f)
            }
        }.build()
    }

    /** screen_time — monitor */
    val ScreenTime: ImageVector by lazy {
        ImageVector.Builder("ScreenTime", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 4f); lineTo(21f, 4f); lineTo(21f, 16f); lineTo(3f, 16f); close()
                moveTo(12f, 16f); lineTo(12f, 20f)
                moveTo(8f, 20f); lineTo(16f, 20f)
            }
        }.build()
    }

    /** tv_film — TV with play */
    val TvFilm: ImageVector by lazy {
        ImageVector.Builder("TvFilm", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 5f); lineTo(21f, 5f); lineTo(21f, 17f); lineTo(3f, 17f); close()
                moveTo(7f, 21f); lineTo(17f, 21f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 8f); lineTo(16f, 11f); lineTo(10f, 14f); close()
            }
        }.build()
    }

    // ─── SLEEP ──────────────────────────────────────────────

    /** napping — bed with Zzz */
    val Napping: ImageVector by lazy {
        ImageVector.Builder("Napping", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 20f); lineTo(3f, 12f); lineTo(21f, 12f); lineTo(21f, 20f)
                moveTo(3f, 12f); curveTo(3f, 12f, 5f, 9f, 8f, 9f); curveTo(10f, 9f, 10f, 12f, 10f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(15f, 3f); lineTo(19f, 3f); lineTo(15f, 7f); lineTo(19f, 7f)
            }
        }.build()
    }

    /** sleeping — moon with stars */
    val Sleeping: ImageVector by lazy {
        ImageVector.Builder("Sleeping", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(20f, 12f); curveTo(20f, 16.4f, 16.4f, 20f, 12f, 20f); curveTo(7.6f, 20f, 4f, 16.4f, 4f, 12f)
                curveTo(4f, 7.6f, 7.6f, 4f, 12f, 4f); curveTo(10f, 6f, 9f, 10f, 11f, 14f); curveTo(13f, 18f, 17f, 18f, 20f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(19f, 4f); lineTo(19f, 6f); moveTo(18f, 5f); lineTo(20f, 5f)
            }
        }.build()
    }

    // ─── SOCIAL ─────────────────────────────────────────────

    /** eating_out — fork + knife */
    val EatingOut: ImageVector by lazy {
        ImageVector.Builder("EatingOut", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 2f); lineTo(7f, 9f); curveTo(7f, 11f, 8f, 12f, 10f, 12f); lineTo(10f, 22f)
                moveTo(7f, 6f); lineTo(4f, 6f); lineTo(4f, 2f)
                moveTo(7f, 6f); lineTo(10f, 6f); lineTo(10f, 2f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 2f); lineTo(17f, 8f); curveTo(17f, 10f, 19f, 12f, 20f, 12f)
                moveTo(17f, 12f); lineTo(17f, 22f)
            }
        }.build()
    }

    /** partying — party popper */
    val Partying: ImageVector by lazy {
        ImageVector.Builder("Partying", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 22f); lineTo(10f, 2f); lineTo(20f, 12f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(16f, 3f); lineTo(18f, 2f)
                moveTo(20f, 5f); lineTo(22f, 4f)
                moveTo(21f, 8f); lineTo(22f, 9f)
            }
        }.build()
    }

    /** socialising — two people */
    val Socialising: ImageVector by lazy {
        ImageVector.Builder("Socialising", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(11f, 6f); arcTo(3f, 3f, 0f, true, true, 5f, 6f); arcTo(3f, 3f, 0f, true, true, 11f, 6f)
                moveTo(1f, 20f); curveTo(1f, 16f, 4f, 13f, 8f, 13f); curveTo(12f, 13f, 15f, 16f, 15f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 6f); arcTo(2.5f, 2.5f, 0f, true, true, 14f, 6f); arcTo(2.5f, 2.5f, 0f, true, true, 19f, 6f)
                moveTo(23f, 20f); curveTo(23f, 17f, 21f, 14f, 17f, 14f)
            }
        }.build()
    }

    // ─── TRAVEL ─────────────────────────────────────────────

    /** commuting — train */
    val Commuting: ImageVector by lazy {
        ImageVector.Builder("Commuting", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 3f); lineTo(18f, 3f); curveTo(19f, 3f, 20f, 4f, 20f, 5f); lineTo(20f, 16f)
                curveTo(20f, 17f, 19f, 18f, 18f, 18f); lineTo(6f, 18f); curveTo(5f, 18f, 4f, 17f, 4f, 16f); lineTo(4f, 5f); curveTo(4f, 4f, 5f, 3f, 6f, 3f)
                moveTo(4f, 11f); lineTo(20f, 11f)
                moveTo(7f, 22f); lineTo(4f, 18f); moveTo(17f, 22f); lineTo(20f, 18f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 15f); lineTo(8.1f, 15f); moveTo(16f, 15f); lineTo(16.1f, 15f)
            }
        }.build()
    }

    /** driving — car */
    val Driving: ImageVector by lazy {
        ImageVector.Builder("Driving", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 11f); lineTo(7f, 5f); lineTo(17f, 5f); lineTo(19f, 11f)
                moveTo(3f, 11f); lineTo(21f, 11f); lineTo(21f, 17f); lineTo(3f, 17f); close()
                moveTo(5f, 17f); lineTo(5f, 19f); moveTo(19f, 17f); lineTo(19f, 19f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 14f); lineTo(7.1f, 14f); moveTo(17f, 14f); lineTo(17.1f, 14f)
            }
        }.build()
    }

    // ─── WORK ───────────────────────────────────────────────

    /** meeting — people at table */
    val Meeting: ImageVector by lazy {
        ImageVector.Builder("Meeting", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 14f); lineTo(20f, 14f)
                moveTo(7f, 10f); arcTo(2f, 2f, 0f, true, true, 3f, 10f); arcTo(2f, 2f, 0f, true, true, 7f, 10f)
                moveTo(14f, 10f); arcTo(2f, 2f, 0f, true, true, 10f, 10f); arcTo(2f, 2f, 0f, true, true, 14f, 10f)
                moveTo(21f, 10f); arcTo(2f, 2f, 0f, true, true, 17f, 10f); arcTo(2f, 2f, 0f, true, true, 21f, 10f)
                moveTo(8f, 14f); lineTo(8f, 20f); moveTo(16f, 14f); lineTo(16f, 20f)
            }
        }.build()
    }

    /** presenting — whiteboard */
    val Presenting: ImageVector by lazy {
        ImageVector.Builder("Presenting", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 3f); lineTo(21f, 3f); lineTo(21f, 15f); lineTo(3f, 15f); close()
                moveTo(12f, 15f); lineTo(12f, 19f)
                moveTo(8f, 19f); lineTo(16f, 19f)
                moveTo(12f, 3f); lineTo(12f, 1f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 7f); lineTo(14f, 7f)
                moveTo(7f, 10f); lineTo(11f, 10f)
            }
        }.build()
    }

    /** studying — graduation cap */
    val Studying: ImageVector by lazy {
        ImageVector.Builder("Studying", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 10f); lineTo(12f, 5f); lineTo(22f, 10f); lineTo(12f, 15f); close()
                moveTo(6f, 12f); lineTo(6f, 17f); curveTo(6f, 17f, 9f, 20f, 12f, 20f); curveTo(15f, 20f, 18f, 17f, 18f, 17f); lineTo(18f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(22f, 10f); lineTo(22f, 16f)
            }
        }.build()
    }

    /** working — briefcase */
    val Working: ImageVector by lazy {
        ImageVector.Builder("Working", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 8f); lineTo(21f, 8f); lineTo(21f, 20f); lineTo(3f, 20f); close()
                moveTo(8f, 8f); lineTo(8f, 5f); curveTo(8f, 4f, 9f, 3f, 10f, 3f); lineTo(14f, 3f)
                curveTo(15f, 3f, 16f, 4f, 16f, 5f); lineTo(16f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 13f); lineTo(21f, 13f)
            }
        }.build()
    }

    /** other — activity pulse */
    val Other: ImageVector by lazy {
        ImageVector.Builder("ActivityOther", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); lineTo(6f, 12f); lineTo(9f, 4f); lineTo(12f, 20f); lineTo(15f, 8f); lineTo(18f, 12f); lineTo(22f, 12f)
            }
        }.build()
    }

    // ─── LOOKUP ────────────────────────────────────────────────

    data class ActivityPickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<ActivityPickerIcon> by lazy { listOf(
        ActivityPickerIcon("cycling", "Cycling", Cycling),
        ActivityPickerIcon("exercising", "Exercising", Exercising),
        ActivityPickerIcon("running", "Running", Running),
        ActivityPickerIcon("swimming", "Swimming", Swimming),
        ActivityPickerIcon("walking", "Walking", Walking),
        ActivityPickerIcon("yoga", "Yoga", Yoga),
        ActivityPickerIcon("gaming", "Gaming", Gaming),
        ActivityPickerIcon("hobbies", "Hobbies", Hobbies),
        ActivityPickerIcon("reading", "Reading", Reading),
        ActivityPickerIcon("childcare", "Childcare", Childcare),
        ActivityPickerIcon("cleaning", "Cleaning", Cleaning),
        ActivityPickerIcon("cooking", "Cooking", Cooking),
        ActivityPickerIcon("shopping", "Shopping", Shopping),
        ActivityPickerIcon("phone", "Phone", Phone),
        ActivityPickerIcon("screen_time", "Screen time", ScreenTime),
        ActivityPickerIcon("tv_film", "TV / Film", TvFilm),
        ActivityPickerIcon("napping", "Napping", Napping),
        ActivityPickerIcon("sleeping", "Sleeping", Sleeping),
        ActivityPickerIcon("eating_out", "Eating out", EatingOut),
        ActivityPickerIcon("partying", "Partying", Partying),
        ActivityPickerIcon("socialising", "Socialising", Socialising),
        ActivityPickerIcon("commuting", "Commuting", Commuting),
        ActivityPickerIcon("driving", "Driving", Driving),
        ActivityPickerIcon("meeting", "Meeting", Meeting),
        ActivityPickerIcon("presenting", "Presenting", Presenting),
        ActivityPickerIcon("studying", "Studying", Studying),
        ActivityPickerIcon("working", "Working", Working),
        ActivityPickerIcon("other", "Other", Other),
    ) }

    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: ActivitySessionsScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// ─── Data model ───────────────────────────────────────────────────────────────

data class ActivitySession(
    val date: String,
    val activityType: String,
    val durationMinutes: Double,
    val startAt: String?,
    val endAt: String?,
    val zoneZero: Double?,
    val zoneOne: Double?,
    val zoneTwo: Double?,
    val zoneThree: Double,
    val zoneFour: Double,
    val zoneFive: Double,
    val zoneSix: Double,
    val source: String?
)

// ─── Screen ───────────────────────────────────────────────────────────────────

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ActivitySessionsScreen(
    date: String,
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    var sessions by remember { mutableStateOf<List<ActivitySession>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }

    LaunchedEffect(date) {
        scope.launch {
            sessions = fetchActivitySessions(context, date)
            isLoading = false
        }
    }

    val displayDate = try {
        LocalDate.parse(date).format(DateTimeFormatter.ofPattern("EEEE, MMM d"))
    } catch (_: Exception) { date }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .padding(horizontal = 16.dp, vertical = 12.dp)
            .verticalScroll(rememberScrollState())
    ) {
        // Header
        Row(verticalAlignment = Alignment.CenterVertically) {
            IconButton(onClick = onBack, modifier = Modifier.size(32.dp)) {
                Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = AppTheme.BodyTextColor)
            }
            Spacer(Modifier.width(8.dp))
            Column {
                Text("Activities", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                Text(displayDate, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }
        }

        Spacer(Modifier.height(16.dp))

        if (isLoading) {
            Box(Modifier.fillMaxWidth().padding(vertical = 40.dp), contentAlignment = Alignment.Center) {
                CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
            }
        } else if (sessions.isEmpty()) {
            Text(
                "No activities recorded for this day",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth().padding(vertical = 40.dp)
            )
        } else {
            // Summary
            val totalDuration = sessions.sumOf { it.durationMinutes }
            val totalHighZone = sessions.sumOf { it.zoneThree + it.zoneFour + it.zoneFive + it.zoneSix }

            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                    SummaryItem("Activities", "${sessions.size}", Color(0xFFFF7043))
                    SummaryItem("Total Time", "${totalDuration.toInt()} min", Color(0xFF4FC3F7))
                    SummaryItem("High HR", "${totalHighZone.toInt()} min", Color(0xFFE57373))
                }
            }

            Spacer(Modifier.height(12.dp))

            // Individual sessions
            sessions.forEachIndexed { index, session ->
                ActivitySessionCard(session)
                if (index < sessions.size - 1) Spacer(Modifier.height(8.dp))
            }
        }

        Spacer(Modifier.height(24.dp))
    }
}

@Composable
private fun SummaryItem(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(value, color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}

@Composable
private fun ActivitySessionCard(session: ActivitySession) {
    val activityLabel = formatActivityType(session.activityType)
    val activityIcon = activityEmoji(session.activityType)
    val timeRange = formatTimeRange(session.startAt, session.endAt)

    BaseCard {
        // Activity header
        Row(
            Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(activityIcon, style = MaterialTheme.typography.titleMedium)
                Spacer(Modifier.width(8.dp))
                Column {
                    Text(activityLabel, color = AppTheme.TitleColor, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold))
                    if (timeRange != null) {
                        Text(timeRange, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    }
                }
            }
            Text(
                "${session.durationMinutes.toInt()} min",
                color = Color(0xFFFF7043),
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Bold)
            )
        }

        Spacer(Modifier.height(10.dp))

        // Zone breakdown bars
        val zones = listOf(
            ZoneData("Zone 0", session.zoneZero ?: 0.0, Color(0xFF90CAF9)),
            ZoneData("Zone 1", session.zoneOne ?: 0.0, Color(0xFF81C784)),
            ZoneData("Zone 2", session.zoneTwo ?: 0.0, Color(0xFFFFEB3B)),
            ZoneData("Zone 3", session.zoneThree, Color(0xFFFFB74D)),
            ZoneData("Zone 4", session.zoneFour, Color(0xFFFF8A65)),
            ZoneData("Zone 5", session.zoneFive, Color(0xFFE57373)),
            ZoneData("Zone 6", session.zoneSix, Color(0xFFEF5350))
        )

        val maxZone = zones.maxOfOrNull { it.minutes }?.coerceAtLeast(1.0) ?: 1.0

        zones.filter { it.minutes > 0 }.forEach { zone ->
            Row(
                Modifier.fillMaxWidth().padding(vertical = 2.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    zone.label,
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall,
                    modifier = Modifier.width(48.dp)
                )
                Box(
                    Modifier
                        .weight(1f)
                        .height(14.dp)
                        .clip(RoundedCornerShape(4.dp))
                        .background(AppTheme.BaseCardContainer)
                ) {
                    Box(
                        Modifier
                            .fillMaxHeight()
                            .fillMaxWidth((zone.minutes / maxZone).toFloat().coerceIn(0.02f, 1f))
                            .clip(RoundedCornerShape(4.dp))
                            .background(zone.color)
                    )
                }
                Spacer(Modifier.width(6.dp))
                Text(
                    "${String.format("%.1f", zone.minutes)} min",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.labelSmall,
                    modifier = Modifier.width(52.dp),
                    textAlign = TextAlign.End
                )
            }
        }

        // High HR total
        val highTotal = session.zoneThree + session.zoneFour + session.zoneFive + session.zoneSix
        if (highTotal > 0) {
            Spacer(Modifier.height(6.dp))
            HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.15f))
            Spacer(Modifier.height(4.dp))
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                Text("High HR Zones (3-6)", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                Text(
                    "${String.format("%.1f", highTotal)} min",
                    color = Color(0xFFE57373),
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }

        // Source
        if (session.source != null) {
            Spacer(Modifier.height(4.dp))
            Text(
                "Source: ${session.source.uppercase()}",
                color = AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                style = MaterialTheme.typography.labelSmall
            )
        }
    }
}

private data class ZoneData(val label: String, val minutes: Double, val color: Color)

// ─── Helpers ──────────────────────────────────────────────────────────────────

fun formatActivityType(raw: String?): String {
    if (raw.isNullOrBlank() || raw == "daily_total") return "Workout"
    return raw.replace("_", " ").split(" ").joinToString(" ") { word ->
        word.lowercase().replaceFirstChar { it.uppercase() }
    }
}

fun activityEmoji(type: String?): String {
    val t = type?.lowercase() ?: ""
    return when {
        "run" in t -> "🏃"
        "cycling" in t || "biking" in t -> "🚴"
        "swim" in t -> "🏊"
        "yoga" in t -> "🧘"
        "weight" in t || "strength" in t -> "🏋️"
        "hiking" in t -> "🥾"
        "walk" in t -> "🚶"
        "basketball" in t -> "🏀"
        "soccer" in t || "football" in t -> "⚽"
        "tennis" in t -> "🎾"
        "boxing" in t || "martial" in t -> "🥊"
        "rowing" in t -> "🚣"
        "ski" in t || "snowboard" in t -> "⛷️"
        "dance" in t -> "💃"
        "golf" in t -> "⛳"
        "stretch" in t || "pilates" in t -> "🤸"
        "hiit" in t || "high_intensity" in t || "boot_camp" in t -> "🔥"
        "cricket" in t -> "🏏"
        "climbing" in t -> "🧗"
        "surf" in t -> "🏄"
        else -> "💪"
    }
}

private fun formatTimeRange(startAt: String?, endAt: String?): String? {
    if (startAt.isNullOrBlank()) return null
    val fmt = DateTimeFormatter.ofPattern("h:mm a")
    return try {
        val start = if (startAt.contains("T")) {
            java.time.LocalDateTime.parse(startAt.substringBefore("Z").substringBefore("+")).format(fmt)
        } else startAt

        val end = if (!endAt.isNullOrBlank() && endAt.contains("T")) {
            java.time.LocalDateTime.parse(endAt.substringBefore("Z").substringBefore("+")).format(fmt)
        } else null

        if (end != null) "$start – $end" else start
    } catch (_: Exception) { startAt }
}

// ─── Data fetching ────────────────────────────────────────────────────────────

suspend fun fetchActivitySessions(
    context: android.content.Context,
    date: String
): List<ActivitySession> = withContext(Dispatchers.IO) {
    try {
        val token = SessionStore.getValidAccessToken(context) ?: return@withContext emptyList()
        val userId = SessionStore.readUserId(context) ?: return@withContext emptyList()
        val client = okhttp3.OkHttpClient()

        val url = "${BuildConfig.SUPABASE_URL}/rest/v1/time_in_high_hr_zones_daily" +
            "?user_id=eq.$userId&date=eq.$date" +
            "&activity_type=neq.daily_total" +
            "&select=date,value_minutes,zone_zero_minutes,zone_one_minutes,zone_two_minutes,zone_three_minutes,zone_four_minutes,zone_five_minutes,zone_six_minutes,activity_type,start_at,end_at,source" +
            "&order=start_at.asc"

        val request = okhttp3.Request.Builder().url(url).get()
            .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
            .addHeader("Authorization", "Bearer $token")
            .build()

        val response = client.newCall(request).execute()
        val body = response.body?.string()
        response.close()

        if (!response.isSuccessful || body.isNullOrBlank()) return@withContext emptyList()

        val arr = org.json.JSONArray(body)
        val sessions = mutableListOf<ActivitySession>()

        for (i in 0 until arr.length()) {
            val obj = arr.getJSONObject(i)
            sessions.add(
                ActivitySession(
                    date = obj.optString("date", date),
                    activityType = obj.optString("activity_type", "workout"),
                    durationMinutes = obj.optDouble("value_minutes", 0.0),
                    startAt = obj.optString("start_at", null),
                    endAt = obj.optString("end_at", null),
                    zoneZero = obj.optDouble("zone_zero_minutes").takeIf { !it.isNaN() },
                    zoneOne = obj.optDouble("zone_one_minutes").takeIf { !it.isNaN() },
                    zoneTwo = obj.optDouble("zone_two_minutes").takeIf { !it.isNaN() },
                    zoneThree = obj.optDouble("zone_three_minutes", 0.0),
                    zoneFour = obj.optDouble("zone_four_minutes", 0.0),
                    zoneFive = obj.optDouble("zone_five_minutes", 0.0),
                    zoneSix = obj.optDouble("zone_six_minutes", 0.0),
                    source = obj.optString("source", null)
                )
            )
        }

        sessions
    } catch (e: Exception) {
        Log.e("ActivitySessions", "Failed to fetch: ${e.message}", e)
        emptyList()
    }
}

// Fetch activity count for a date (used in log screen)
suspend fun fetchActivityCount(
    context: android.content.Context,
    date: String
): Int = withContext(Dispatchers.IO) {
    try {
        val token = SessionStore.getValidAccessToken(context) ?: return@withContext 0
        val userId = SessionStore.readUserId(context) ?: return@withContext 0
        val client = okhttp3.OkHttpClient()

        val url = "${BuildConfig.SUPABASE_URL}/rest/v1/time_in_high_hr_zones_daily" +
            "?user_id=eq.$userId&date=eq.$date" +
            "&activity_type=neq.daily_total" +
            "&select=date"

        val request = okhttp3.Request.Builder().url(url).get()
            .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
            .addHeader("Authorization", "Bearer $token")
            .addHeader("Prefer", "count=exact")
            .addHeader("Range", "0-0")
            .build()

        val response = client.newCall(request).execute()
        val contentRange = response.header("content-range") ?: ""
        response.close()

        // content-range: 0-0/5 -> 5
        val total = contentRange.substringAfter("/", "0").toIntOrNull() ?: 0
        total
    } catch (e: Exception) {
        Log.e("ActivitySessions", "Failed to count: ${e.message}", e)
        0
    }
}

title: ActivityViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class ActivityViewModel : ViewModel() {

    private val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserActivityRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserActivityRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.ActivityPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.ActivityPrefRow>> = _frequent

    /** Map of activity type (lowercase) → days ago. */
    private val _recentDaysAgo = MutableStateFlow<Map<String, Int>>(emptyMap())
    val recentDaysAgo: StateFlow<Map<String, Int>> = _recentDaysAgo

    /** Map of activity type (lowercase) → most recent start_at ISO. */
    private val _recentStartAts = MutableStateFlow<Map<String, String>>(emptyMap())
    val recentStartAts: StateFlow<Map<String, String>> = _recentStartAts

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            runCatching {
                _pool.value = db.getAllActivityPool(accessToken)
                _frequent.value = db.getActivityPrefs(accessToken).sortedBy { it.position }
            }.onFailure { it.printStackTrace() }
        }
    }

    fun loadRecent(accessToken: String, referenceDate: String? = null) {
        viewModelScope.launch {
            try {
                val refDate = referenceDate?.let {
                    try { java.time.LocalDate.parse(it.substring(0, 10)) } catch (_: Exception) { null }
                } ?: java.time.LocalDate.now()
                val rows = db.getRecentActivities(accessToken, daysBack = 3, referenceDate = refDate.toString())
                val daysMap = mutableMapOf<String, Int>()
                val isoMap = mutableMapOf<String, String>()
                for (row in rows) {
                    val type = row.activityType ?: continue
                    val dateStr = row.date ?: row.startAt?.substring(0, 10) ?: continue
                    val date = try {
                        java.time.LocalDate.parse(dateStr.substring(0, 10))
                    } catch (_: Exception) { continue }
                    val daysAgo = kotlin.math.abs(java.time.temporal.ChronoUnit.DAYS.between(date, refDate).toInt())
                    if (daysAgo in 0..3) {
                        val existing = daysMap[type]
                        if (existing == null || daysAgo < existing) {
                            daysMap[type] = daysAgo
                            isoMap[type] = row.startAt ?: (dateStr + "T00:00:00Z")
                        }
                    }
                }
                _recentDaysAgo.value = daysMap
                _recentStartAts.value = isoMap
            } catch (e: Exception) {
                e.printStackTrace()
                _recentDaysAgo.value = emptyMap()
                _recentStartAts.value = emptyMap()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null) {
        viewModelScope.launch {
            runCatching { db.upsertActivityToPool(accessToken, label, category); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun removeFromPool(accessToken: String, id: String) {
        viewModelScope.launch {
            runCatching { db.deleteActivityFromPool(accessToken, id); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun addToFrequent(accessToken: String, id: String) {
        viewModelScope.launch {
            runCatching {
                val pos = (_frequent.value.maxOfOrNull { it.position } ?: -1) + 1
                db.insertActivityPref(accessToken, id, pos, "frequent"); loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            runCatching { db.deleteActivityPref(accessToken, prefId); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun setCategory(accessToken: String, id: String, category: String?) {
        viewModelScope.launch {
            runCatching { db.setActivityCategory(accessToken, id, category); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun setAutomation(accessToken: String, id: String, enabled: Boolean) {
        viewModelScope.launch {
            runCatching { db.setActivityAutomation(accessToken, id, enabled); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }
}


title: AdjustMedicinesScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.material3.rememberSwipeToDismissBoxState
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustMedicinesScreen(
    navController: NavController,
    vm: MedicineViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        Log.d("AdjustMedicines", "token present? ${authState.accessToken != null}")
        authState.accessToken?.let { vm.loadAll(it) }
    }

    LazyColumn(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.background)
            .padding(horizontal = 16.dp),
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Back
        item {
            ElevatedCard(
                onClick = { navController.popBackStack() },
                shape = MaterialTheme.shapes.medium,
                colors = CardDefaults.elevatedCardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Row(
                    modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    Spacer(Modifier.width(8.dp))
                    Text("Back")
                }
            }
        }

        // Add new to pool
        item {
            Column {
                OutlinedTextField(
                    value = newLabel,
                    onValueChange = { newLabel = it },
                    label = { Text("New medicine label") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
                Spacer(Modifier.height(8.dp))
                Button(
                    onClick = {
                        val token = authState.accessToken ?: return@Button
                        val label = newLabel.trim()
                        if (label.isNotEmpty()) {
                            vm.addNewToPool(token, label)
                            newLabel = ""
                        }
                    },
                    enabled = newLabel.isNotBlank()
                ) {
                    Icon(Icons.Default.Add, contentDescription = "Add to Pool")
                    Spacer(Modifier.width(8.dp))
                    Text("Add to list")
                }
            }
        }

        // Frequent
        item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }
        items(frequent, key = { it.id }) { pref ->
            ElevatedCard(
                shape = MaterialTheme.shapes.medium,
                colors = CardDefaults.elevatedCardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                ),
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp, horizontal = 8.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(pref.medicine?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                    IconButton(onClick = {
                        val token = authState.accessToken ?: return@IconButton
                        vm.removeFromFrequent(token, pref.id)
                    }) {
                        Icon(Icons.Default.Delete, contentDescription = "Remove from Frequent")
                    }
                }
            }
        }

        // All medicines
        item { Text("All Medicines", style = MaterialTheme.typography.titleMedium) }

        val frequentIds = frequent.map { it.medicineId }.toSet()
        val remaining = pool.filter { it.id !in frequentIds }

        items(remaining, key = { it.id }) { med ->
            val dismissState = rememberSwipeToDismissBoxState(
                initialValue = Settled,
                confirmValueChange = { value ->
                    if (value == EndToStart) {
                        val token = authState.accessToken
                            ?: return@rememberSwipeToDismissBoxState false
                        vm.removeFromPool(token, med.id)
                        true
                    } else false
                }
            )
            SwipeToDismissBox(
                state = dismissState,
                enableDismissFromStartToEnd = false,
                enableDismissFromEndToStart = true,
                backgroundContent = { }
            ) {
                ElevatedCard(
                    shape = MaterialTheme.shapes.medium,
                    colors = CardDefaults.elevatedCardColors(
                        containerColor = MaterialTheme.colorScheme.surface
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(med.label, style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: run {
                                Log.d("AdjustMedicines", "token null on + click")
                                return@IconButton
                            }
                            Log.d("AdjustMedicines", "addToFrequent id=${med.id}")
                            vm.addToFrequent(token, med.id)
                        }) {
                            Icon(Icons.Default.Add, contentDescription = "Add to Frequent")
                        }
                    }
                }
            }
        }

        item { Spacer(Modifier.height(24.dp)) }
    }
}

title: AdjustMigrainesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustMigrainesScreen(
    navController: NavController,
    vm: MigraineViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    Scaffold { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Back arrow card
            item {
                Card(
                    onClick = { navController.popBackStack() },
                    shape = MaterialTheme.shapes.medium,
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                ) {
                    Row(
                        modifier = Modifier
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.ArrowBack,
                            contentDescription = "Back"
                        )
                        Spacer(Modifier.width(8.dp))
                        Text("Back")
                    }
                }
            }

            // New migraine input
            item {
                Column {
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        label = { Text("New migraine label") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                    Spacer(Modifier.height(8.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        Button(
                            onClick = {
                                val token = authState.accessToken ?: return@Button
                                val label = newLabel.trim()
                                if (label.isNotEmpty()) {
                                    vm.addNewToPool(token, label)
                                    newLabel = ""
                                }
                            },
                            enabled = newLabel.isNotBlank()
                        ) {
                            Icon(Icons.Default.Add, contentDescription = null)
                            Spacer(Modifier.width(8.dp))
                            Text("Add to list")
                        }
                    }
                }
            }

            // Frequent header
            item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }

            // Frequent items
            items(frequent, key = { it.id }) { pref ->
                Surface(
                    color = MaterialTheme.colorScheme.surface,
                    tonalElevation = 0.dp,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(pref.migraine?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: return@IconButton
                            vm.removeFromFrequent(token, pref.id)
                        }) {
                            Icon(Icons.Default.Delete, contentDescription = "Remove from Frequent")
                        }
                    }
                }
            }

            // All Migraines header
            item { Text("All Migraines", style = MaterialTheme.typography.titleMedium) }

            // All Migraines with swipe-to-delete
            val frequentIds = frequent.map { it.migraineId }.toSet()
            val remaining = pool.filter { it.id !in frequentIds }

            items(remaining, key = { it.id }) { mg ->
                val dismissState = rememberSwipeToDismissBoxState(
                    initialValue = Settled,
                    confirmValueChange = { value ->
                        if (value == EndToStart) {
                            val token = authState.accessToken ?: return@rememberSwipeToDismissBoxState false
                            vm.removeFromPool(token, mg.id)
                            true
                        } else false
                    }
                )

                SwipeToDismissBox(
                    state = dismissState,
                    enableDismissFromStartToEnd = false,
                    enableDismissFromEndToStart = true,
                    backgroundContent = {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(
                                    if (dismissState.targetValue == EndToStart)
                                        MaterialTheme.colorScheme.error
                                    else
                                        MaterialTheme.colorScheme.error.copy(alpha = 0.25f)
                                )
                                .padding(horizontal = 16.dp),
                            contentAlignment = Alignment.CenterEnd
                        ) {
                            Icon(
                                Icons.Default.Delete,
                                contentDescription = "Delete",
                                tint = Color.White
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Surface(
                        color = MaterialTheme.colorScheme.surface,
                        tonalElevation = 0.dp,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp, horizontal = 8.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(mg.label, style = MaterialTheme.typography.bodyLarge)
                            IconButton(onClick = {
                                val token = authState.accessToken ?: return@IconButton
                                vm.addToFrequent(token, mg.id)
                            }) {
                                Icon(Icons.Default.Add, contentDescription = "Add to Frequent")
                            }
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(24.dp)) }
        }
    }
}

title: AdjustReliefsScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.material3.rememberSwipeToDismissBoxState
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustReliefsScreen(
    navController: NavController,
    vm: ReliefViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    val snackbar = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        Log.d("AdjustReliefs", "token=${authState.accessToken != null}")
        authState.accessToken?.let { vm.loadAll(it) }
    }

    Scaffold(snackbarHost = { SnackbarHost(snackbar) }) { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                ElevatedCard(
                    onClick = { navController.popBackStack() },
                    shape = MaterialTheme.shapes.medium
                ) {
                    Row(
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                        Spacer(Modifier.width(8.dp))
                        Text("Back")
                    }
                }
            }

            item {
                Column {
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        label = { Text("New relief label") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                    Spacer(Modifier.height(8.dp))
                    Button(
                        onClick = {
                            val token = authState.accessToken
                            val label = newLabel.trim()
                            if (token.isNullOrBlank() || label.isEmpty()) return@Button
                            runCatching {
                                vm.addNewToPool(token, label)
                                newLabel = ""
                            }.onFailure { e ->
                                e.printStackTrace()
                                scope.launch { snackbar.showSnackbar("Failed to add: ${e.message ?: "error"}") }
                            }
                        },
                        enabled = newLabel.isNotBlank()
                    ) {
                        Icon(Icons.Filled.Add, contentDescription = "Add to Pool")
                        Spacer(Modifier.width(8.dp))
                        Text("Add to list")
                    }
                }
            }

            item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }
            items(frequent, key = { it.id }) { pref ->
                ElevatedCard(
                    shape = MaterialTheme.shapes.medium,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(pref.relief?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: return@IconButton
                            runCatching { vm.removeFromFrequent(token, pref.id) }
                                .onFailure { e ->
                                    e.printStackTrace()
                                    scope.launch { snackbar.showSnackbar("Failed to remove: ${e.message ?: "error"}") }
                                }
                        }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Remove from Frequent")
                        }
                    }
                }
            }

            item { Text("All Reliefs", style = MaterialTheme.typography.titleMedium) }

            val frequentIds = frequent.map { it.reliefId }.toSet()
            val remaining = pool.filter { it.id !in frequentIds }

            items(remaining, key = { it.id }) { rel ->
                val dismissState = rememberSwipeToDismissBoxState(
                    initialValue = Settled,
                    confirmValueChange = { value ->
                        if (value == EndToStart) {
                            val token = authState.accessToken ?: return@rememberSwipeToDismissBoxState false
                            runCatching {
                                vm.removeFromPool(token, rel.id)
                                true
                            }.onFailure { e ->
                                e.printStackTrace()
                                scope.launch { snackbar.showSnackbar("Delete failed: ${e.message ?: "error"}") }
                            }.getOrDefault(false)
                        } else false
                    }
                )
                SwipeToDismissBox(
                    state = dismissState,
                    enableDismissFromStartToEnd = false,
                    enableDismissFromEndToStart = true,
                    backgroundContent = { }
                ) {
                    ElevatedCard(
                        shape = MaterialTheme.shapes.medium,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp, horizontal = 8.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(rel.label, style = MaterialTheme.typography.bodyLarge)
                            IconButton(onClick = {
                                val token = authState.accessToken ?: return@IconButton
                                runCatching { vm.addToFrequent(token, rel.id) }
                                    .onFailure { e ->
                                        e.printStackTrace()
                                        scope.launch { snackbar.showSnackbar("Add failed: ${e.message ?: "error"}") }
                                    }
                            }) {
                                Icon(Icons.Filled.Add, contentDescription = "Add to Frequent")
                            }
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(24.dp)) }
        }
    }
}

title: AdjustTriggersScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustTriggersScreen(
    navController: NavController,
    vm: TriggerViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    Scaffold { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Back arrow card
            item {
                Card(
                    onClick = { navController.popBackStack() },
                    shape = MaterialTheme.shapes.medium,
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                ) {
                    Row(
                        modifier = Modifier
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.ArrowBack,
                            contentDescription = "Back"
                        )
                        Spacer(Modifier.width(8.dp))
                        Text("Back")
                    }
                }
            }

            // New trigger input
            item {
                Column {
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        label = { Text("New trigger label") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                    Spacer(Modifier.height(8.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        Button(
                            onClick = {
                                val token = authState.accessToken ?: return@Button
                                val label = newLabel.trim()
                                if (label.isNotEmpty()) {
                                    vm.addNewToPool(token, label)
                                    newLabel = ""
                                }
                            },
                            enabled = newLabel.isNotBlank()
                        ) {
                            Icon(Icons.Default.Add, contentDescription = null)
                            Spacer(Modifier.width(8.dp))
                            Text("Add to list")
                        }
                    }
                }
            }

            // Frequent header
            item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }

            // Frequent items
            items(frequent, key = { it.id }) { pref ->
                Surface(
                    color = MaterialTheme.colorScheme.surface,
                    tonalElevation = 0.dp,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(pref.trigger?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: return@IconButton
                            vm.removeFromFrequent(token, pref.id)
                        }) {
                            Icon(Icons.Default.Delete, contentDescription = "Remove from Frequent")
                        }
                    }
                }
            }

            // All Triggers header
            item { Text("All Triggers", style = MaterialTheme.typography.titleMedium) }

            // All Triggers with swipe-to-delete
            val frequentIds = frequent.map { it.triggerId }.toSet()
            val remaining = pool.filter { it.id !in frequentIds }

            items(remaining, key = { it.id }) { trig ->
                val dismissState = rememberSwipeToDismissBoxState(
                    initialValue = Settled,
                    confirmValueChange = { value ->
                        if (value == EndToStart) {
                            val token = authState.accessToken ?: return@rememberSwipeToDismissBoxState false
                            vm.removeFromPool(token, trig.id)
                            true
                        } else false
                    }
                )

                SwipeToDismissBox(
                    state = dismissState,
                    enableDismissFromStartToEnd = false,
                    enableDismissFromEndToStart = true,
                    backgroundContent = {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(
                                    if (dismissState.targetValue == EndToStart)
                                        MaterialTheme.colorScheme.error
                                    else
                                        MaterialTheme.colorScheme.error.copy(alpha = 0.25f)
                                )
                                .padding(horizontal = 16.dp),
                            contentAlignment = Alignment.CenterEnd
                        ) {
                            Icon(
                                Icons.Default.Delete,
                                contentDescription = "Delete",
                                tint = Color.White
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Surface(
                        color = MaterialTheme.colorScheme.surface,
                        tonalElevation = 0.dp,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp, horizontal = 8.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(trig.label, style = MaterialTheme.typography.bodyLarge)
                            IconButton(onClick = {
                                val token = authState.accessToken ?: return@IconButton
                                vm.addToFrequent(token, trig.id)
                            }) {
                                Icon(Icons.Default.Add, contentDescription = "Add to Frequent")
                            }
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(24.dp)) }
        }
    }
}

title: AiCalibrationService.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.HttpClient
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject

/**
 * Two-call AI calibration service.
 *
 * CALL 1 — "The Neurologist":
 *   Receives the full user profile as a narrative + locked Layer 1 ratings.
 *   Returns: clinical_assessment (shown to user), trigger/prodrome adjustments,
 *   data warnings.
 *
 * CALL 2 — "The Gauge Calibrator":
 *   Receives the final trigger stats (counts, severity distribution, score ranges)
 *   plus the clinical assessment for context.
 *   Returns: gauge_thresholds, decay_weights, calibration_notes (shown to user),
 *   combined summary.
 *
 * Layer 1 (DeterministicMapper) ratings are FLOOR values — never lowered by AI.
 */
object AiCalibrationService {

    private const val TAG = "AiCalibration"

    // ═════════════════════════════════════════════════════════════════════
    // Intermediate data classes
    // ═════════════════════════════════════════════════════════════════════

    data class TriggerStats(
        val totalActive: Int,
        val countHigh: Int,
        val countMild: Int,
        val countLow: Int,
        val highLabels: List<String>,
        val mildLabels: List<String>,
        val lowLabels: List<String>,
    )

    data class Call1Result(
        val clinicalAssessment: String,
        val adjustments: List<Triple<String, String, String>>, // label, toSeverity, reason
        val dataWarnings: List<AiSetupService.AiDataWarning>,
    )

    data class Call2Result(
        val gauge: AiSetupService.AiGaugeThresholds,
        val decays: List<AiSetupService.AiDecayWeights>,
        val calibrationNotes: String,
        val summary: String,
    )

    // ═════════════════════════════════════════════════════════════════════
    // Main entry point
    // ═════════════════════════════════════════════════════════════════════

    suspend fun calibrate(
        context: Context,
        mapping: DeterministicMapper.MappingResult,
        items: AiSetupService.AvailableItems?,
        answers: DeterministicMapper.QuestionnaireAnswers? = null,
        dataContext: AiSetupService.DataContext? = null,
        onProgress: ((String) -> Unit)? = null,
    ): Result<AiSetupService.AiConfig> = withContext(Dispatchers.IO) {
        try {
            val appCtx = context.applicationContext
            val accessToken = SessionStore.getValidAccessToken(appCtx)
                ?: return@withContext Result.failure(Exception("Not authenticated"))

            // ── CALL 1: The Neurologist ──
            onProgress?.invoke("Analysing your migraine profile…")
            val call1Result = executeCall1(accessToken, mapping, items, answers, dataContext)

            // ── Merge Call 1 adjustments with Layer 1 ──
            onProgress?.invoke("Building your personalised configuration…")
            val mergedTriggers = applyAdjustments(mapping.triggers, call1Result.adjustments)

            // ── Classify triggers for Call 2 ──
            val classified = classifyTriggers(mergedTriggers, items?.autoTriggerLabels ?: emptySet())
            Log.d(TAG, "classifyTriggers: autoTriggerLabels size=${items?.autoTriggerLabels?.size}, mergedTriggers size=${mergedTriggers.size}")
            Log.d(TAG, "classifyTriggers result: auto=${classified.autoHigh.size + classified.autoMild.size + classified.autoLow.size} (H=${classified.autoHigh.size},M=${classified.autoMild.size},L=${classified.autoLow.size}), manual=${classified.manualHigh.size + classified.manualMild.size + classified.manualLow.size}")
            val prodromeStats = calculateProdromeStats(mapping.prodromes)

            // ── CALL 2: The Statistician ──
            onProgress?.invoke("Calibrating your risk gauge…")
            val call2Result = executeCall2(
                accessToken, mapping.profileContext,
                call1Result.clinicalAssessment,
                classified, prodromeStats, dataContext
            )

            // ── Merge everything into final AiConfig ──
            val config = buildFinalConfig(
                mapping, mergedTriggers, call1Result, call2Result,
                autoTriggerLabels = items?.autoTriggerLabels ?: emptySet(),
                autoProdromeLabels = items?.autoProdromeLabels ?: emptySet(),
            )

            Log.d(TAG, "Two-call calibration complete: ${config.triggers.size} triggers, " +
                    "${config.prodromes.size} prodromes, gauge=${config.gaugeThresholds.low}/${config.gaugeThresholds.mild}/${config.gaugeThresholds.high}")
            Result.success(config)

        } catch (e: Exception) {
            Log.e(TAG, "Calibration failed", e)
            // Fallback: deterministic mapping alone with safe defaults
            try {
                val fallback = buildFallbackConfig(
                    mapping,
                    autoTriggerLabels = items?.autoTriggerLabels ?: emptySet(),
                    autoProdromeLabels = items?.autoProdromeLabels ?: emptySet(),
                )
                Result.success(fallback)
            } catch (e2: Exception) {
                Result.failure(e)
            }
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // CALL 1 — The Neurologist
    // ═════════════════════════════════════════════════════════════════════

    private val CALL1_SYSTEM_PROMPT = """
You are a neurologist and migraine specialist assessing a new patient's profile to configure a migraine prediction app.

You will receive:
1. The patient's questionnaire answers as a narrative profile
2. LOCKED trigger/prodrome ratings from their direct answers (these are FLOOR values — NEVER lower them)
3. Their connected data sources and enabled metrics
4. Available trigger and prodrome labels you may reference

YOUR TASK — Two steps:

STEP 1 — CLINICAL ASSESSMENT:
Analyse this patient as a neurologist would. Write 2-3 short paragraphs covering:
- Key patterns you see in their profile
- Interactions between lifestyle factors (e.g. poor sleep + high stress + caffeine)
- Triggers or risks they may be underestimating based on the overall picture
- What their trajectory and experience tell you about their migraine evolution
Write this for the PATIENT to read — warm, clear, insightful. No medical jargon. Address them as "you/your". Keep it concise but meaningful.

STEP 2 — SEVERITY ADJUSTMENTS:
Based on your clinical assessment, identify triggers and prodromes that should be ELEVATED or ACTIVATED.

RULES:
- NEVER lower a LOCKED rating — these are the user's own reported experience
- You may ELEVATE locked ratings (LOW → MILD, MILD → HIGH) if clinical evidence supports it
- You may ACTIVATE triggers currently rated NONE if the profile strongly suggests them — but be conservative
- Use ONLY exact label strings from the AVAILABLE ITEMS lists
- For each adjustment, provide clear reasoning tied to your clinical assessment
- Limit adjustments to genuinely meaningful ones (typically 3-8, not dozens)

Also generate data_warnings where a HIGH or MILD trigger lacks the relevant data source.

Respond with ONLY valid JSON (no markdown fences):
{
  "clinical_assessment": "Your 2-3 paragraph assessment for the patient...",
  "adjustments": [
    {"label": "exact label from pool", "from": "CURRENT_SEVERITY", "to": "NEW_SEVERITY", "reasoning": "brief clinical justification"}
  ],
  "data_warnings": [
    {"type": "missing_data|missing_connection|suggestion", "message": "user-facing message", "metric": "metric_name|null", "severity": "high|medium|low"}
  ]
}
""".trimIndent()

    private fun buildCall1UserMessage(
        mapping: DeterministicMapper.MappingResult,
        items: AiSetupService.AvailableItems?,
        answers: DeterministicMapper.QuestionnaireAnswers?,
        dataContext: AiSetupService.DataContext?,
    ): String = buildString {
        val p = mapping.profileContext

        // ── Narrative profile ──
        appendLine("=== PATIENT PROFILE ===")
        appendLine()
        appendLine("This is a ${p.gender ?: "unknown gender"}, ${p.ageRange ?: "unknown age"} patient who has been experiencing migraines for ${p.experience ?: "an unknown period"}.")
        appendLine("They currently get migraines ${p.frequency ?: "at unknown frequency"} lasting ${p.duration ?: "unknown duration"}, and report the pattern is ${p.trajectory ?: "unknown"}.")
        appendLine("They ${p.warningSignsBefore ?: "have unknown warning sign status"} get warning signs before an attack.")
        appendLine("After a trigger exposure, migraines typically come ${p.triggerDelay ?: "at unknown delay"}.")
        appendLine("They work ${p.dailyRoutine ?: "an unknown schedule"} and ${p.seasonalPattern ?: "have no known seasonal pattern"}.")
        appendLine()

        // ── Lifestyle detail from answers ──
        if (answers != null) {
            appendLine("LIFESTYLE DETAIL:")
            answers.sleepHours?.let { appendLine("- Sleep: $it per night") }
            answers.sleepQuality?.let { appendLine("- Sleep quality: $it") }
            if (answers.sleepIssues.isNotEmpty()) appendLine("- Sleep issues: ${answers.sleepIssues.joinToString(", ")}")
            answers.stressLevel?.let { appendLine("- Stress level: $it") }
            answers.screenTimeDaily?.let { appendLine("- Screen time: $it daily") }
            answers.caffeineIntake?.let { appendLine("- Caffeine: $it") }
            answers.caffeineDirection?.let { appendLine("- Caffeine pattern: $it") }
            answers.alcoholFrequency?.let { appendLine("- Alcohol: $it") }
            if (answers.specificDrinks.isNotEmpty()) appendLine("- Problematic drinks: ${answers.specificDrinks.joinToString(", ")}")
            answers.waterIntake?.let { appendLine("- Water intake: $it") }
            answers.exerciseFrequency?.let { appendLine("- Exercise: $it") }
            if (answers.exercisePattern.isNotEmpty()) appendLine("- Exercise pattern: ${answers.exercisePattern.joinToString(", ")}")
            answers.tracksCycle?.let { appendLine("- Tracks menstrual cycle: $it") }
            answers.usesContraception?.let { appendLine("- Contraception: $it") }
            answers.contraceptionEffect?.let { appendLine("- Contraception effect on migraines: $it") }
            answers.glutenSensitivity?.let { appendLine("- Gluten sensitivity: $it") }
            answers.tracksNutrition?.let { appendLine("- Tracks nutrition: $it") }
            answers.freeText?.let {
                if (it.isNotBlank()) {
                    appendLine()
                    appendLine("PATIENT'S OWN NOTES:")
                    appendLine(it)
                }
            }
            appendLine()
        }

        // ── Locked trigger ratings (Layer 1) ──
        val high = mapping.triggers.filter { it.value.severity == "HIGH" }
        val mild = mapping.triggers.filter { it.value.severity == "MILD" }
        val low = mapping.triggers.filter { it.value.severity == "LOW" }
        val none = mapping.triggers.filter { it.value.severity == "NONE" }

        appendLine("=== LOCKED TRIGGER RATINGS (from patient's direct answers — NEVER lower these) ===")
        appendLine("HIGH (${high.size}): ${high.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine("MILD (${mild.size}): ${mild.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine("LOW (${low.size}): ${low.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine("NONE (${none.size}): ${none.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine()

        // ── Locked prodrome ratings ──
        val prHigh = mapping.prodromes.filter { it.value.severity == "HIGH" }
        val prMild = mapping.prodromes.filter { it.value.severity == "MILD" }
        val prLow = mapping.prodromes.filter { it.value.severity == "LOW" }

        appendLine("=== LOCKED PRODROME RATINGS ===")
        appendLine("HIGH: ${prHigh.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine("MILD: ${prMild.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine("LOW: ${prLow.keys.joinToString(", ").ifEmpty { "none" }}")
        appendLine()

        // ── Connected data ──
        if (dataContext != null) {
            appendLine("=== CONNECTED DATA SOURCES ===")
            appendLine("WHOOP: ${if (dataContext.whoopConnected) "connected" else "not connected"}")
            appendLine("Health Connect: ${if (dataContext.healthConnectConnected) "connected" else "not connected"}")
            appendLine("Enabled metrics: ${dataContext.enabledMetrics.filter { it.value }.keys.joinToString(", ").ifEmpty { "none" }}")
            appendLine("Disabled metrics: ${dataContext.enabledMetrics.filter { !it.value }.keys.joinToString(", ").ifEmpty { "none" }}")
            appendLine()
        }

        // ── Available items (for adjustments) ──
        if (items != null) {
            appendLine("=== AVAILABLE TRIGGER LABELS (use EXACT labels for adjustments) ===")
            items.triggers.groupBy { it.category ?: "Other" }.forEach { (cat, list) ->
                appendLine("  [$cat] ${list.joinToString(", ") { it.label }}")
            }
            appendLine()
            appendLine("=== AVAILABLE PRODROME LABELS ===")
            items.prodromes.groupBy { it.category ?: "Other" }.forEach { (cat, list) ->
                appendLine("  [$cat] ${list.joinToString(", ") { it.label }}")
            }
        }
    }

    private suspend fun executeCall1(
        accessToken: String,
        mapping: DeterministicMapper.MappingResult,
        items: AiSetupService.AvailableItems?,
        answers: DeterministicMapper.QuestionnaireAnswers?,
        dataContext: AiSetupService.DataContext?,
    ): Call1Result {
        val userMessage = buildCall1UserMessage(mapping, items, answers, dataContext)
        Log.d(TAG, "Call 1 user message: ${userMessage.length} chars")

        val responseJson = callEdgeFunction(accessToken, CALL1_SYSTEM_PROMPT, userMessage)
        return parseCall1Response(responseJson)
    }

    private fun parseCall1Response(json: String): Call1Result {
        Log.d(TAG, "Call 1 raw response: ${json.take(500)}")
        return try {
            val obj = JSONObject(json)

            val assessment = obj.optString("clinical_assessment", "")
            Log.d(TAG, "Call 1 clinical_assessment length: ${assessment.length}, blank: ${assessment.isBlank()}")

            val adjustments = mutableListOf<Triple<String, String, String>>()
            val adjArr = obj.optJSONArray("adjustments")
            if (adjArr != null) {
                for (i in 0 until adjArr.length()) {
                    val a = adjArr.getJSONObject(i)
                    adjustments.add(Triple(
                        a.optString("label", ""),
                        a.optString("to", a.optString("severity", "")),
                        a.optString("reasoning", ""),
                    ))
                }
            }

            val warnings = mutableListOf<AiSetupService.AiDataWarning>()
            val warnArr = obj.optJSONArray("data_warnings")
            if (warnArr != null) {
                for (i in 0 until warnArr.length()) {
                    val w = warnArr.getJSONObject(i)
                    warnings.add(AiSetupService.AiDataWarning(
                        type = w.optString("type", "suggestion"),
                        message = w.optString("message", ""),
                        metric = w.optString("metric", null),
                        severity = w.optString("severity", "medium"),
                    ))
                }
            }

            Call1Result(assessment, adjustments, warnings)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse Call 1 response", e)
            Call1Result("", emptyList(), emptyList())
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // Merge Call 1 adjustments with Layer 1 (only elevations)
    // ═════════════════════════════════════════════════════════════════════

    private val SEVERITY_RANK = mapOf("NONE" to 0, "LOW" to 1, "MILD" to 2, "HIGH" to 3)

    private fun applyAdjustments(
        triggers: Map<String, DeterministicMapper.TriggerSetting>,
        adjustments: List<Triple<String, String, String>>,
    ): Map<String, DeterministicMapper.TriggerSetting> {
        val merged = triggers.toMutableMap()
        for ((label, toSev, _) in adjustments) {
            val existing = merged[label]
            if (existing != null) {
                val currentRank = SEVERITY_RANK[existing.severity] ?: 0
                val newRank = SEVERITY_RANK[toSev] ?: 0
                // Only elevate, never lower
                if (newRank > currentRank) {
                    merged[label] = existing.copy(severity = toSev)
                    Log.d(TAG, "Elevated '$label': ${existing.severity} → $toSev")
                }
            } else if (toSev != "NONE") {
                // AI activated a trigger that was NONE/missing — add it
                merged[label] = DeterministicMapper.TriggerSetting(
                    label = label, severity = toSev, favorite = false
                )
                Log.d(TAG, "Activated '$label': NONE → $toSev")
            }
        }
        return merged
    }

    // ═════════════════════════════════════════════════════════════════════
    // Prodrome stats for Call 2
    // ═════════════════════════════════════════════════════════════════════

    private fun calculateProdromeStats(
        prodromes: Map<String, DeterministicMapper.ProdromeSetting>
    ): TriggerStats {
        val active = prodromes.filter { it.value.severity != "NONE" }
        val high = active.filter { it.value.severity == "HIGH" }
        val mild = active.filter { it.value.severity == "MILD" }
        val low = active.filter { it.value.severity == "LOW" }
        return TriggerStats(
            totalActive = active.size,
            countHigh = high.size,
            countMild = mild.size,
            countLow = low.size,
            highLabels = high.keys.toList(),
            mildLabels = mild.keys.toList(),
            lowLabels = low.keys.toList(),
        )
    }

    // ═════════════════════════════════════════════════════════════════════
    // Classify triggers: auto-detected vs manual (from Supabase pool data)
    // ═════════════════════════════════════════════════════════════════════

    data class ClassifiedTriggers(
        val autoHigh: List<String>,
        val autoMild: List<String>,
        val autoLow: List<String>,
        val manualHigh: List<String>,
        val manualMild: List<String>,
        val manualLow: List<String>,
        val totalActive: Int,
    )

    /**
     * Classifies active triggers into auto-detected vs manual.
     * Auto-detected = has a numeric threshold (created by trigHigh/trigLow in DeterministicMapper).
     * Manual = no threshold (created by trigManual).
     * This is the source of truth — no Supabase lookup needed.
     */
    private fun classifyTriggers(
        triggers: Map<String, DeterministicMapper.TriggerSetting>,
        autoTriggerLabels: Set<String>,
    ): ClassifiedTriggers {
        val autoHigh = mutableListOf<String>()
        val autoMild = mutableListOf<String>()
        val autoLow = mutableListOf<String>()
        val manualHigh = mutableListOf<String>()
        val manualMild = mutableListOf<String>()
        val manualLow = mutableListOf<String>()

        for ((_, trigger) in triggers) {
            if (trigger.severity == "NONE") continue
            val isAuto = trigger.label.lowercase() in autoTriggerLabels
            val list = when {
                isAuto && trigger.severity == "HIGH" -> autoHigh
                isAuto && trigger.severity == "MILD" -> autoMild
                isAuto && trigger.severity == "LOW" -> autoLow
                !isAuto && trigger.severity == "HIGH" -> manualHigh
                !isAuto && trigger.severity == "MILD" -> manualMild
                !isAuto && trigger.severity == "LOW" -> manualLow
                else -> manualLow
            }
            list.add(trigger.label)
        }

        return ClassifiedTriggers(
            autoHigh = autoHigh, autoMild = autoMild, autoLow = autoLow,
            manualHigh = manualHigh, manualMild = manualMild, manualLow = manualLow,
            totalActive = autoHigh.size + autoMild.size + autoLow.size +
                    manualHigh.size + manualMild.size + manualLow.size,
        )
    }

    // ═════════════════════════════════════════════════════════════════════
    // CALL 2 — The Statistician
    // ═════════════════════════════════════════════════════════════════════

    private val CALL2_SYSTEM_PROMPT = """
You are a biostatistician calibrating a migraine risk gauge. You need to understand exactly how this app's scoring engine works, then set thresholds that make sense for this specific patient.

=== HOW THE SCORING ENGINE WORKS ===

Every day, the app calculates a RISK SCORE by looking at all trigger events from the last 7 days.

For each event, the score contribution = decay_weight[severity][days_ago].
Default decay weights:
  HIGH:  day0=10, day1=5, day2=2.5, day3=1, day4=0, day5=0, day6=0
  MILD:  day0=6,  day1=3, day2=1.5, day3=0.5, day4=0, day5=0, day6=0
  LOW:   day0=3,  day1=1.5, day2=0, day3=0, day4=0, day5=0, day6=0

The daily score = SUM of all event contributions.

Example: If today the user has 1 HIGH trigger (10pts) + 1 MILD trigger (6pts) + yesterday had 1 HIGH (5pts decay), today's score = 21.

The gauge zones are:
  score >= HIGH threshold → RED (genuine warning)
  score >= MILD threshold → YELLOW (building risk)
  score >= LOW threshold  → AMBER (worth noticing)
  score < LOW threshold   → GREEN (normal)

=== TWO TYPES OF TRIGGERS ===

AUTO-DETECTED triggers fire automatically when connected data (wearables, weather, nutrition tracking) crosses a threshold. These can fire EVERY DAY without the user doing anything. Examples: sleep duration, weather pressure, HRV, screen time.

MANUAL triggers are logged by the user when they experience them. These fire occasionally. Examples: stress, alcohol, skipped meals, strong smells.

This distinction is CRITICAL for calibration:
- A user with many auto-detected triggers will have a higher BASELINE score every day
- The thresholds must sit ABOVE that baseline, otherwise the gauge is permanently yellow/red
- Manual triggers stacking ON TOP of the auto baseline is what should push into warning zones

=== YOUR TASK ===

Given this patient's clinical profile, their trigger list (auto vs manual, with severities), and their migraine frequency:

1. THINK about what a normal day looks like for this patient score-wise:
   - How many auto triggers will realistically fire on a typical day? (Not all of them — only when metrics cross thresholds)
   - What's the baseline score from auto-detect alone?

2. THINK about what a pre-migraine buildup looks like:
   - They get migraines at [frequency]. So most days should be GREEN.
   - A few days per month should climb into yellow/red as triggers stack up before an attack.
   - Manual triggers (stress, alcohol, etc.) piling onto a bad auto day is what creates real risk.

3. SET THRESHOLDS so that:
   - Normal days (just routine auto-detect) → GREEN
   - A few extra triggers stacking → AMBER (LOW threshold)
   - Genuine buildup with multiple triggers converging → YELLOW (MILD threshold)  
   - Serious warning with many triggers + decay stacking from previous days → RED (HIGH threshold)
   - Someone who gets migraines "1-3 per month" should NOT be in red every day. Maybe 2-4 days/month.

4. SET DECAY CURVES:
   - Frequent migraines: steeper curves (triggers hit hard, fade fast)
   - Infrequent migraines: flatter curves (cumulative buildup matters more)

5. WRITE calibration_notes for the patient (2-3 paragraphs, warm, no jargon, address as "you/your"):
   - What their trigger setup looks like (auto vs manual breakdown)
   - How the gauge will behave for them day-to-day
   - What pushing into yellow/red actually means for them

6. WRITE a combined summary (2-3 sentences) covering the clinical insight + gauge setup.

Respond with ONLY valid JSON (no markdown fences):
{
  "gauge_thresholds": {"low": N, "mild": N, "high": N, "reasoning": "brief technical reasoning"},
  "decay_weights": [
    {"severity": "HIGH", "day0": N, "day1": N, "day2": N, "day3": N, "day4": N, "day5": N, "day6": N, "reasoning": "..."},
    {"severity": "MILD", "day0": N, "day1": N, "day2": N, "day3": N, "day4": N, "day5": N, "day6": N, "reasoning": "..."},
    {"severity": "LOW", "day0": N, "day1": N, "day2": N, "day3": N, "day4": N, "day5": N, "day6": N, "reasoning": "..."}
  ],
  "calibration_notes": "Your 2-3 paragraph explanation for the patient...",
  "summary": "2-3 sentence combined summary"
}
""".trimIndent()

    private fun buildCall2UserMessage(
        profile: DeterministicMapper.ProfileContext,
        clinicalAssessment: String,
        classified: ClassifiedTriggers,
        prodromeStats: TriggerStats,
        dataContext: AiSetupService.DataContext?,
    ): String = buildString {
        appendLine("=== PATIENT SUMMARY ===")
        appendLine("${profile.gender ?: "Unknown"}, ${profile.ageRange ?: "unknown age"}")
        appendLine("Migraines: ${profile.frequency ?: "unknown frequency"}, lasting ${profile.duration ?: "unknown"}")
        appendLine("Experience: ${profile.experience ?: "unknown"}, trajectory: ${profile.trajectory ?: "unknown"}")
        appendLine("Routine: ${profile.dailyRoutine ?: "unknown"}, seasonal: ${profile.seasonalPattern ?: "none"}")
        appendLine("Trigger delay: ${profile.triggerDelay ?: "unknown"}")
        appendLine()

        appendLine("=== CLINICAL ASSESSMENT (from neurologist) ===")
        appendLine(clinicalAssessment.ifBlank { "No clinical assessment available." })
        appendLine()

        appendLine("=== CONNECTED DATA SOURCES ===")
        if (dataContext != null) {
            appendLine("WHOOP: ${if (dataContext.whoopConnected) "YES (provides sleep, HRV, recovery, strain)" else "NO"}")
            appendLine("Health Connect: ${if (dataContext.healthConnectConnected) "YES (provides steps, sleep, heart rate)" else "NO"}")
            val enabled = dataContext.enabledMetrics.filter { it.value }.keys
            val disabled = dataContext.enabledMetrics.filter { !it.value }.keys
            if (enabled.isNotEmpty()) appendLine("Enabled metrics: ${enabled.joinToString(", ")}")
            if (disabled.isNotEmpty()) appendLine("Disabled metrics: ${disabled.joinToString(", ")}")
        } else {
            appendLine("No data source information available.")
        }
        appendLine()

        appendLine("=== AUTO-DETECTED TRIGGERS (fire automatically from data streams) ===")
        appendLine("These triggers fire when a connected metric crosses its threshold.")
        appendLine("Not all will fire every day — only when the value is abnormal for this user.")
        appendLine()
        appendLine("AUTO HIGH (${classified.autoHigh.size}): ${classified.autoHigh.joinToString(", ").ifEmpty { "none" }}")
        appendLine("AUTO MILD (${classified.autoMild.size}): ${classified.autoMild.joinToString(", ").ifEmpty { "none" }}")
        appendLine("AUTO LOW (${classified.autoLow.size}): ${classified.autoLow.joinToString(", ").ifEmpty { "none" }}")
        appendLine()

        appendLine("=== MANUAL TRIGGERS (user logs these when they occur) ===")
        appendLine("These only fire when the user actively logs them.")
        appendLine()
        appendLine("MANUAL HIGH (${classified.manualHigh.size}): ${classified.manualHigh.joinToString(", ").ifEmpty { "none" }}")
        appendLine("MANUAL MILD (${classified.manualMild.size}): ${classified.manualMild.joinToString(", ").ifEmpty { "none" }}")
        appendLine("MANUAL LOW (${classified.manualLow.size}): ${classified.manualLow.joinToString(", ").ifEmpty { "none" }}")
        appendLine()

        appendLine("=== PRODROMES ===")
        appendLine("HIGH (${prodromeStats.countHigh}): ${prodromeStats.highLabels.joinToString(", ").ifEmpty { "none" }}")
        appendLine("MILD (${prodromeStats.countMild}): ${prodromeStats.mildLabels.joinToString(", ").ifEmpty { "none" }}")
        appendLine("LOW (${prodromeStats.countLow}): ${prodromeStats.lowLabels.joinToString(", ").ifEmpty { "none" }}")
        appendLine()

        appendLine("=== TOTAL ACTIVE: ${classified.totalActive} triggers + ${prodromeStats.totalActive} prodromes ===")
        appendLine()
        appendLine("Remember: this patient gets migraines ${profile.frequency ?: "at unknown frequency"}. Most days should be GREEN. The gauge should only climb to warning levels when a genuine trigger buildup is happening.")
    }

    private suspend fun executeCall2(
        accessToken: String,
        profile: DeterministicMapper.ProfileContext,
        clinicalAssessment: String,
        classified: ClassifiedTriggers,
        prodromeStats: TriggerStats,
        dataContext: AiSetupService.DataContext?,
    ): Call2Result {
        val userMessage = buildCall2UserMessage(
            profile, clinicalAssessment, classified, prodromeStats, dataContext
        )
        Log.d(TAG, "Call 2 user message: ${userMessage.length} chars")

        val responseJson = callEdgeFunction(accessToken, CALL2_SYSTEM_PROMPT, userMessage)
        return parseCall2Response(responseJson)
    }

    private fun parseCall2Response(json: String): Call2Result {
        return try {
            val obj = JSONObject(json)

            val gauge = obj.optJSONObject("gauge_thresholds")?.let { g ->
                AiSetupService.AiGaugeThresholds(
                    low = g.optInt("low", 3),
                    mild = g.optInt("mild", 8),
                    high = g.optInt("high", 15),
                    reasoning = g.optString("reasoning", ""),
                )
            } ?: AiSetupService.AiGaugeThresholds()

            val decays = mutableListOf<AiSetupService.AiDecayWeights>()
            val arr = obj.optJSONArray("decay_weights")
            if (arr != null) {
                for (i in 0 until arr.length()) {
                    val d = arr.getJSONObject(i)
                    decays.add(AiSetupService.AiDecayWeights(
                        severity = d.optString("severity", "MILD"),
                        day0 = d.optDouble("day0", 0.0),
                        day1 = d.optDouble("day1", 0.0),
                        day2 = d.optDouble("day2", 0.0),
                        day3 = d.optDouble("day3", 0.0),
                        day4 = d.optDouble("day4", 0.0),
                        day5 = d.optDouble("day5", 0.0),
                        day6 = d.optDouble("day6", 0.0),
                        reasoning = d.optString("reasoning", ""),
                    ))
                }
            }

            Call2Result(
                gauge = gauge,
                decays = decays,
                calibrationNotes = obj.optString("calibration_notes", ""),
                summary = obj.optString("summary", "Your migraine setup has been configured."),
            )
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse Call 2 response", e)
            Call2Result(
                gauge = AiSetupService.AiGaugeThresholds(),
                decays = emptyList(),
                calibrationNotes = "",
                summary = "Your migraine setup has been configured.",
            )
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // Shared edge function caller
    // ═════════════════════════════════════════════════════════════════════

    private suspend fun callEdgeFunction(
        accessToken: String,
        systemPrompt: String,
        userMessage: String,
    ): String {
        val requestBody = JSONObject().apply {
            put("system_prompt", systemPrompt)
            put("user_message", userMessage)
        }

        val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/ai-setup"

        val client = HttpClient(io.ktor.client.engine.android.Android)
        try {
            val response: HttpResponse = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                contentType(ContentType.Application.Json)
                setBody(requestBody.toString())
            }

            val responseText = response.bodyAsText()
            Log.d(TAG, "Edge function response status: ${response.status}")

            if (!response.status.isSuccess()) {
                Log.e(TAG, "Edge function error: $responseText")
                throw Exception("AI call failed (${response.status}): $responseText")
            }

            return responseText
                .replace("```json", "").replace("```", "")
                .trim()
        } finally {
            client.close()
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // Build final AiConfig
    // ═════════════════════════════════════════════════════════════════════

    private fun buildFinalConfig(
        mapping: DeterministicMapper.MappingResult,
        mergedTriggers: Map<String, DeterministicMapper.TriggerSetting>,
        call1: Call1Result,
        call2: Call2Result,
        autoTriggerLabels: Set<String> = emptySet(),
        autoProdromeLabels: Set<String> = emptySet(),
    ): AiSetupService.AiConfig {

        // Build adjustment reasoning lookup
        val adjustmentReasons = call1.adjustments.associate { (label, _, reason) ->
            label.lowercase() to reason
        }

        val triggerRecs = mergedTriggers.values.filter { it.severity != "NONE" }.map { t ->
            val isAuto = t.label.lowercase() in autoTriggerLabels
            AiSetupService.AiTriggerRec(
                label = t.label,
                severity = t.severity,
                decayDays = when (t.severity) { "HIGH" -> 3; "MILD" -> 2; else -> 1 },
                favorite = if (isAuto) false else (t.favorite || t.severity != "NONE"),
                reasoning = adjustmentReasons[t.label.lowercase()] ?: "",
                defaultThreshold = t.threshold,
            )
        }

        val prodromeRecs = mapping.prodromes.values.filter { it.severity != "NONE" }.map { p ->
            val isAuto = p.label.lowercase() in autoProdromeLabels
            AiSetupService.AiProdromeRec(
                label = p.label,
                severity = p.severity,
                favorite = if (isAuto) false else (p.favorite || p.severity != "NONE"),
                reasoning = "",
                defaultThreshold = p.threshold,
            )
        }

        val toFav = { labels: List<String> ->
            labels.map { label -> AiSetupService.AiFavoriteRec(label = label, favorite = true) }
        }

        return AiSetupService.AiConfig(
            triggers = triggerRecs,
            prodromes = prodromeRecs,
            symptoms = toFav(mapping.favorites.symptoms),
            medicines = toFav(mapping.favorites.medicines),
            reliefs = toFav(mapping.favorites.reliefs),
            activities = toFav(mapping.favorites.activities),
            missedActivities = toFav(mapping.favorites.missedActivities),
            gaugeThresholds = call2.gauge,
            decayWeights = call2.decays,
            dataWarnings = call1.dataWarnings,
            summary = call2.summary,
            clinicalAssessment = call1.clinicalAssessment,
            calibrationNotes = call2.calibrationNotes,
        )
    }

    private fun buildFallbackConfig(
        mapping: DeterministicMapper.MappingResult,
        autoTriggerLabels: Set<String> = emptySet(),
        autoProdromeLabels: Set<String> = emptySet(),
    ): AiSetupService.AiConfig {
        val triggerRecs = mapping.triggers.values.filter { it.severity != "NONE" }.map { t ->
            val isAuto = t.label.lowercase() in autoTriggerLabels
            AiSetupService.AiTriggerRec(
                label = t.label, severity = t.severity,
                decayDays = when (t.severity) { "HIGH" -> 3; "MILD" -> 2; else -> 1 },
                favorite = if (isAuto) false else (t.favorite || t.severity != "NONE"),
                reasoning = "",
                defaultThreshold = t.threshold,
            )
        }

        val prodromeRecs = mapping.prodromes.values.filter { it.severity != "NONE" }.map { p ->
            val isAuto = p.label.lowercase() in autoProdromeLabels
            AiSetupService.AiProdromeRec(
                label = p.label, severity = p.severity,
                favorite = if (isAuto) false else (p.favorite || p.severity != "NONE"),
                reasoning = "",
                defaultThreshold = p.threshold,
            )
        }

        val toFav = { labels: List<String> ->
            labels.map { label -> AiSetupService.AiFavoriteRec(label = label, favorite = true) }
        }

        // Smart fallback gauge based on trigger count
        val activeCount = mapping.triggers.count { it.value.severity != "NONE" }
        val highCount = mapping.triggers.count { it.value.severity == "HIGH" }
        val fallbackGauge = when {
            activeCount > 30 -> AiSetupService.AiGaugeThresholds(low = 12, mild = 25, high = 40, reasoning = "Fallback: high trigger count ($activeCount active)")
            activeCount > 15 -> AiSetupService.AiGaugeThresholds(low = 8, mild = 18, high = 30, reasoning = "Fallback: moderate trigger count ($activeCount active)")
            else -> AiSetupService.AiGaugeThresholds(low = 5, mild = 12, high = 20, reasoning = "Fallback: low trigger count ($activeCount active)")
        }

        return AiSetupService.AiConfig(
            triggers = triggerRecs,
            prodromes = prodromeRecs,
            symptoms = toFav(mapping.favorites.symptoms),
            medicines = toFav(mapping.favorites.medicines),
            reliefs = toFav(mapping.favorites.reliefs),
            activities = toFav(mapping.favorites.activities),
            missedActivities = toFav(mapping.favorites.missedActivities),
            gaugeThresholds = fallbackGauge,
            decayWeights = listOf(
                AiSetupService.AiDecayWeights("HIGH", 10.0, 5.0, 2.5, 1.0, 0.0, 0.0, 0.0, "Fallback defaults"),
                AiSetupService.AiDecayWeights("MILD", 6.0, 3.0, 1.5, 0.5, 0.0, 0.0, 0.0, "Fallback defaults"),
                AiSetupService.AiDecayWeights("LOW", 3.0, 1.5, 0.0, 0.0, 0.0, 0.0, 0.0, "Fallback defaults"),
            ),
            dataWarnings = emptyList(),
            summary = "Your migraine triggers and warning signs have been configured based on your answers.",
            clinicalAssessment = "",
            calibrationNotes = "",
        )
    }
}


title: AiSetupApplier.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Applies the AI-generated configuration to the user's Supabase data:
 * - Trigger/prodrome severities (prediction_value)
 * - Favorites (trigger_preferences, medicine_preferences, etc.)
 * - Gauge thresholds (risk_gauge_thresholds)
 *
 * Reports progress via callback so the UI can show a progress bar.
 */
object AiSetupApplier {

    private const val TAG = "AiSetupApplier"

    data class ApplyProgress(
        val current: Int,
        val total: Int,
        val label: String,
    )

    suspend fun applyConfig(
        context: Context,
        config: AiSetupService.AiConfig,
        onProgress: (ApplyProgress) -> Unit = {},
    ): Result<Unit> = withContext(Dispatchers.IO) {
        val appCtx = context.applicationContext
        val accessToken = SessionStore.getValidAccessToken(appCtx)
            ?: return@withContext Result.failure(Exception("Not authenticated"))
        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
        val edge = EdgeFunctionsService()

        val totalOps = config.triggers.count { it.severity != "NONE" } +
                config.prodromes.count { it.severity != "NONE" } +
                config.triggers.count { it.favorite } +
                config.prodromes.count { it.favorite } +
                config.symptoms.count { it.favorite } +
                config.medicines.count { it.favorite } +
                config.reliefs.count { it.favorite } +
                config.activities.count { it.favorite } +
                config.missedActivities.count { it.favorite } +
                3 + // gauge thresholds
                config.decayWeights.size // decay weight curves
        var done = 0

        fun progress(label: String) {
            done++
            onProgress(ApplyProgress(done, totalOps, label))
        }

        try {
            // ── Fetch current pools to get IDs ──
            val triggerPool = db.getAllTriggerPool(accessToken)
            val prodromePool = db.getAllProdromePool(accessToken)
            val symptomPool = db.getAllSymptomPool(accessToken)
            val medicinePool = db.getAllMedicinePool(accessToken)
            val reliefPool = db.getAllReliefPool(accessToken)
            val activityPool = db.getAllActivityPool(accessToken)
            val missedActivityPool = db.getAllMissedActivityPool(accessToken)

            val triggerIdMap = triggerPool.associate { it.label.lowercase() to it.id }
            val prodromeIdMap = prodromePool.associate { it.label.lowercase() to it.id }
            val symptomIdMap = symptomPool.associate { it.label.lowercase() to it.id }
            val medicineIdMap = medicinePool.associate { it.label.lowercase() to it.id }
            val reliefIdMap = reliefPool.associate { it.label.lowercase() to it.id }
            val activityIdMap = activityPool.associate { it.label.lowercase() to it.id }
            val missedActivityIdMap = missedActivityPool.associate { it.label.lowercase() to it.id }

            Log.d(TAG, "Pools loaded: ${triggerPool.size}T ${prodromePool.size}P ${medicinePool.size}M ${reliefPool.size}R ${activityPool.size}A ${missedActivityPool.size}MA")

            // ── Trigger severities (group-aware) ──
            val triggerGroupMembers: Map<String, List<String>> = triggerPool
                .filter { it.displayGroup != null }
                .groupBy { it.displayGroup!!.lowercase() }
                .mapValues { entry -> entry.value.map { it.id } }

            for (rec in config.triggers) {
                if (rec.severity == "NONE") continue
                val groupIds = triggerGroupMembers[rec.label.lowercase()]
                if (groupIds != null) {
                    for (memberId in groupIds) {
                        runCatching { db.updateTriggerPoolItem(accessToken, memberId, predictionValue = rec.severity, defaultThreshold = rec.defaultThreshold) }
                            .onFailure { Log.w(TAG, "Failed trigger group '${rec.label}': ${it.message}") }
                    }
                } else {
                    val id = triggerIdMap[rec.label.lowercase()]
                    if (id != null) {
                        runCatching { db.updateTriggerPoolItem(accessToken, id, predictionValue = rec.severity, defaultThreshold = rec.defaultThreshold) }
                            .onFailure { Log.w(TAG, "Failed trigger '${rec.label}': ${it.message}") }
                    } else Log.w(TAG, "Trigger not found: '${rec.label}'")
                }
                progress("Trigger: ${rec.label}")
            }

            // ── Prodrome severities (group-aware) ──
            val prodromeGroupMembers: Map<String, List<String>> = prodromePool
                .filter { it.displayGroup != null }
                .groupBy { it.displayGroup!!.lowercase() }
                .mapValues { entry -> entry.value.map { it.id } }

            for (rec in config.prodromes) {
                if (rec.severity == "NONE") continue
                val groupIds = prodromeGroupMembers[rec.label.lowercase()]
                if (groupIds != null) {
                    for (memberId in groupIds) {
                        runCatching { db.updateProdromePoolItem(accessToken, memberId, predictionValue = rec.severity, defaultThreshold = rec.defaultThreshold) }
                            .onFailure { Log.w(TAG, "Failed prodrome group '${rec.label}': ${it.message}") }
                    }
                } else {
                    val id = prodromeIdMap[rec.label.lowercase()]
                    if (id != null) {
                        runCatching { db.updateProdromePoolItem(accessToken, id, predictionValue = rec.severity, defaultThreshold = rec.defaultThreshold) }
                            .onFailure { Log.w(TAG, "Failed prodrome '${rec.label}': ${it.message}") }
                    } else Log.w(TAG, "Prodrome not found: '${rec.label}'")
                }
                progress("Prodrome: ${rec.label}")
            }

            // ── Trigger favorites (group-aware: use first member as representative) ──
            // Build group name → first member ID lookup
            val triggerGroupFirstId: Map<String, String> = triggerPool
                .filter { it.displayGroup != null }
                .groupBy { it.displayGroup!!.lowercase() }
                .mapValues { entry -> entry.value.first().id }

            var pos = 0
            for (rec in config.triggers.filter { it.favorite }) {
                val id = triggerIdMap[rec.label.lowercase()]
                    ?: triggerGroupFirstId[rec.label.lowercase()]
                if (id != null) {
                    runCatching { db.insertTriggerPref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed trigger fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Prodrome favorites (group-aware) ──
            val prodromeGroupFirstId: Map<String, String> = prodromePool
                .filter { it.displayGroup != null }
                .groupBy { it.displayGroup!!.lowercase() }
                .mapValues { entry -> entry.value.first().id }

            pos = 0
            for (rec in config.prodromes.filter { it.favorite }) {
                val id = prodromeIdMap[rec.label.lowercase()]
                    ?: prodromeGroupFirstId[rec.label.lowercase()]
                if (id != null) {
                    runCatching { db.insertProdromePref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed prodrome fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Medicine favorites ──
            pos = 0
            for (rec in config.medicines.filter { it.favorite }) {
                medicineIdMap[rec.label.lowercase()]?.let { id ->
                    runCatching { db.insertMedicinePref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed medicine fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Symptom favorites ──
            pos = 0
            for (rec in config.symptoms.filter { it.favorite }) {
                symptomIdMap[rec.label.lowercase()]?.let { id ->
                    runCatching { db.insertSymptomPref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed symptom fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Relief favorites ──
            pos = 0
            for (rec in config.reliefs.filter { it.favorite }) {
                reliefIdMap[rec.label.lowercase()]?.let { id ->
                    runCatching { db.insertReliefPref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed relief fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Activity favorites ──
            pos = 0
            for (rec in config.activities.filter { it.favorite }) {
                activityIdMap[rec.label.lowercase()]?.let { id ->
                    runCatching { db.insertActivityPref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed activity fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Missed activity favorites ──
            pos = 0
            for (rec in config.missedActivities.filter { it.favorite }) {
                missedActivityIdMap[rec.label.lowercase()]?.let { id ->
                    runCatching { db.insertMissedActivityPref(accessToken, id, pos++, "frequent") }
                        .onFailure { Log.w(TAG, "Failed missed fav '${rec.label}': ${it.message}") }
                }
                progress("★ ${rec.label}")
            }

            // ── Gauge thresholds ──
            val t = config.gaugeThresholds
            runCatching {
                edge.upsertRiskGaugeThreshold(appCtx, "LOW", t.low.toDouble())
                progress("Gauge: LOW")
                edge.upsertRiskGaugeThreshold(appCtx, "MILD", t.mild.toDouble())
                progress("Gauge: MILD")
                edge.upsertRiskGaugeThreshold(appCtx, "HIGH", t.high.toDouble())
                progress("Gauge: HIGH")
            }.onFailure { Log.w(TAG, "Failed gauge thresholds: ${it.message}") }

            // ── Decay weights ──
            for (dw in config.decayWeights) {
                runCatching {
                    edge.upsertRiskDecayWeight(appCtx, dw.severity, dw.day0, dw.day1, dw.day2, dw.day3, dw.day4, dw.day5, dw.day6)
                    Log.d(TAG, "Decay weight ${dw.severity}: ${dw.day0}/${dw.day1}/${dw.day2}/${dw.day3}/${dw.day4}/${dw.day5}/${dw.day6}")
                }.onFailure { Log.w(TAG, "Failed decay weight ${dw.severity}: ${it.message}") }
                progress("Decay: ${dw.severity}")
            }

            Log.d(TAG, "AI config applied. $done/$totalOps operations.")
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "Apply failed", e)
            Result.failure(e)
        }
    }
}


title: AiSetupProfileStore.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.*

/**
 * Persists the AI setup questionnaire answers + AI-generated config to Supabase.
 * Used later for community matching, article recommendations, cohort analysis, etc.
 */
object AiSetupProfileStore {

    private const val TAG = "AiSetupProfileStore"

    private val json = Json {
        ignoreUnknownKeys = true
        encodeDefaults = true
        explicitNulls = false
    }

    /**
     * Upserts the user's questionnaire answers + AI config to ai_setup_profiles.
     * Call this right after AiSetupApplier.applyConfig() succeeds.
     */
    suspend fun save(
        context: Context,
        answers: DeterministicMapper.QuestionnaireAnswers,
        config: AiSetupService.AiConfig,
    ): Result<Unit> = withContext(Dispatchers.IO) {
        val appCtx = context.applicationContext
        val accessToken = SessionStore.getValidAccessToken(appCtx)
            ?: return@withContext Result.failure(Exception("Not authenticated"))
        val userId = SessionStore.readUserId(appCtx)
            ?: return@withContext Result.failure(Exception("No user ID"))

        val answersJson = buildAnswersJson(answers)
        val configJson = json.encodeToString(config)

        val body = buildJsonObject {
            put("user_id", userId)
            put("answers", json.parseToJsonElement(answersJson))
            put("ai_config", json.parseToJsonElement(configJson))

            // Extracted fields for easy querying
            put("gender", answers.gender)
            put("age_range", answers.ageRange)
            put("frequency", answers.frequency)
            put("duration", answers.duration)
            put("experience", answers.experience)
            put("trajectory", answers.trajectory)
            put("seasonal_pattern", answers.seasonalPattern)
            put("tracks_cycle", answers.tracksCycle == "Yes")
            put("clinical_assessment", config.clinicalAssessment)
            put("summary", config.summary)

            // trigger_areas as JSON array for the text[] column
            val areas = buildTriggerAreas(answers)
            put("trigger_areas", JsonArray(areas.map { JsonPrimitive(it) }))
        }

        val client = HttpClient(io.ktor.client.engine.android.Android) {
            install(ContentNegotiation) { json(json) }
        }

        try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/ai_setup_profiles"
            val response = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("Prefer", "resolution=merge-duplicates")  // upsert
                contentType(ContentType.Application.Json)
                setBody(body.toString())
            }

            if (response.status.value in 200..299) {
                Log.d(TAG, "AI setup profile saved successfully")
                Result.success(Unit)
            } else {
                val err = response.bodyAsText()
                Log.e(TAG, "Failed to save AI setup profile: ${response.status} $err")
                Result.failure(Exception("Save failed: ${response.status}"))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error saving AI setup profile", e)
            Result.failure(e)
        } finally {
            client.close()
        }
    }

    // ── Build a JSON representation of all questionnaire answers ──

    private fun buildAnswersJson(a: DeterministicMapper.QuestionnaireAnswers): String {
        val obj = buildJsonObject {
            // Page 1
            put("gender", a.gender)
            put("age_range", a.ageRange)
            put("frequency", a.frequency)
            put("duration", a.duration)
            put("experience", a.experience)
            put("trajectory", a.trajectory)
            put("warning_signs_before", a.warningSignsBefore)
            put("trigger_delay", a.triggerDelay)
            put("daily_routine", a.dailyRoutine)
            put("seasonal_pattern", a.seasonalPattern)

            // Page 2
            put("sleep_hours", a.sleepHours)
            put("sleep_quality", a.sleepQuality)
            put("poor_sleep_quality_triggers", a.poorSleepQualityTriggers.name)
            put("too_little_sleep_triggers", a.tooLittleSleepTriggers.name)
            put("oversleep_triggers", a.oversleepTriggers.name)
            put("sleep_issues", JsonArray(a.sleepIssues.map { JsonPrimitive(it) }))

            // Page 3
            put("stress_level", a.stressLevel)
            put("stress_change_triggers", a.stressChangeTriggers.name)
            put("emotional_patterns", certaintyMapToJson(a.emotionalPatterns))
            put("screen_time_daily", a.screenTimeDaily)
            put("screen_time_triggers", a.screenTimeTriggers.name)
            put("late_screen_triggers", a.lateScreenTriggers.name)

            // Page 4
            put("caffeine_intake", a.caffeineIntake)
            put("caffeine_direction", a.caffeineDirection)
            put("caffeine_certainty", a.caffeineCertainty.name)
            put("alcohol_frequency", a.alcoholFrequency)
            put("alcohol_triggers", a.alcoholTriggers.name)
            put("specific_drinks", JsonArray(a.specificDrinks.map { JsonPrimitive(it) }))
            put("tyramine_foods", certaintyMapToJson(a.tyramineFoods))
            put("gluten_sensitivity", a.glutenSensitivity)
            put("gluten_triggers", a.glutenTriggers.name)
            put("eating_patterns", certaintyMapToJson(a.eatingPatterns))
            put("water_intake", a.waterIntake)
            put("tracks_nutrition", a.tracksNutrition)

            // Page 5
            put("weather_triggers", a.weatherTriggers.name)
            put("specific_weather", certaintyMapToJson(a.specificWeather))
            put("environment_sensitivities", certaintyMapToJson(a.environmentSensitivities))
            put("physical_factors", certaintyMapToJson(a.physicalFactors))

            // Page 6
            put("exercise_frequency", a.exerciseFrequency)
            put("exercise_triggers", a.exerciseTriggers.name)
            put("exercise_pattern", JsonArray(a.exercisePattern.map { JsonPrimitive(it) }))
            put("tracks_cycle", a.tracksCycle)
            put("cycle_patterns", certaintyMapToJson(a.cyclePatterns))
            put("uses_contraception", a.usesContraception)
            put("contraception_effect", a.contraceptionEffect)

            // Page 7
            put("physical_prodromes", certaintyMapToJson(a.physicalProdromes))
            put("mood_prodromes", certaintyMapToJson(a.moodProdromes))
            put("sensory_prodromes", certaintyMapToJson(a.sensoryProdromes))

            // Page 8
            put("selected_symptoms", JsonArray(a.selectedSymptoms.map { JsonPrimitive(it) }))
            put("selected_medicines", JsonArray(a.selectedMedicines.map { JsonPrimitive(it) }))
            put("selected_reliefs", JsonArray(a.selectedReliefs.map { JsonPrimitive(it) }))
            put("selected_activities", JsonArray(a.selectedActivities.map { JsonPrimitive(it) }))
            put("selected_missed_activities", JsonArray(a.selectedMissedActivities.map { JsonPrimitive(it) }))
            put("free_text", a.freeText)
        }
        return obj.toString()
    }

    private fun certaintyMapToJson(map: Map<String, DeterministicMapper.Certainty>): JsonObject {
        return buildJsonObject {
            map.forEach { (key, certainty) -> put(key, certainty.name) }
        }
    }

    /**
     * Derive trigger area tags from the questionnaire answers.
     * These are the high-level categories useful for community matching.
     */
    private fun buildTriggerAreas(a: DeterministicMapper.QuestionnaireAnswers): List<String> {
        val areas = mutableListOf<String>()
        if (a.poorSleepQualityTriggers != DeterministicMapper.Certainty.NO ||
            a.tooLittleSleepTriggers != DeterministicMapper.Certainty.NO ||
            a.oversleepTriggers != DeterministicMapper.Certainty.NO) areas.add("Sleep")
        if (a.stressChangeTriggers != DeterministicMapper.Certainty.NO ||
            a.emotionalPatterns.isNotEmpty()) areas.add("Stress")
        if (a.screenTimeTriggers != DeterministicMapper.Certainty.NO ||
            a.lateScreenTriggers != DeterministicMapper.Certainty.NO) areas.add("Screen time")
        if (a.weatherTriggers != DeterministicMapper.Certainty.NO) areas.add("Weather")
        if (a.alcoholTriggers != DeterministicMapper.Certainty.NO ||
            a.caffeineCertainty != DeterministicMapper.Certainty.NO ||
            a.glutenTriggers != DeterministicMapper.Certainty.NO ||
            a.eatingPatterns.isNotEmpty() ||
            a.tyramineFoods.isNotEmpty()) areas.add("Diet")
        if (a.exerciseTriggers != DeterministicMapper.Certainty.NO) areas.add("Exercise")
        if (a.tracksCycle == "Yes" && a.cyclePatterns.isNotEmpty()) areas.add("Hormones")
        if (a.environmentSensitivities.isNotEmpty()) areas.add("Environment")
        if (a.physicalFactors.isNotEmpty()) areas.add("Physical")
        return areas
    }
}

title: AiSetupQuestions.kt
text:
package com.migraineme

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

// ═══════════════════════════════════════════════════════════════════════════
// Private helpers (copies from v1 — keeps old file untouched)
// ═══════════════════════════════════════════════════════════════════════════

@Composable
private fun QPageHeader(icon: ImageVector, title: String, subtitle: String, pageNum: Int, totalPages: Int) {
    Column(Modifier.fillMaxWidth().padding(horizontal = 8.dp), horizontalAlignment = Alignment.CenterHorizontally) {
        Box(Modifier.size(48.dp).background(Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), AppTheme.AccentPink.copy(alpha = 0.2f))), RoundedCornerShape(14.dp)), contentAlignment = Alignment.Center) {
            Icon(icon, null, tint = Color.White, modifier = Modifier.size(24.dp))
        }
        Spacer(Modifier.height(12.dp))
        Text(title, color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
        Spacer(Modifier.height(4.dp))
        Text(subtitle, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center)
        Spacer(Modifier.height(4.dp))
        Text("Question page $pageNum of $totalPages", color = AppTheme.SubtleTextColor.copy(alpha = 0.5f), style = MaterialTheme.typography.labelSmall)
        Spacer(Modifier.height(16.dp))
    }
}

@Composable
private fun QCard(label: String, icon: ImageVector? = null, subtitle: String? = null, content: @Composable ColumnScope.() -> Unit) {
    Card(colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer), shape = RoundedCornerShape(16.dp), modifier = Modifier.fillMaxWidth()) {
        Column(Modifier.padding(16.dp)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                if (icon != null) { Icon(icon, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(18.dp)); Spacer(Modifier.width(8.dp)) }
                Text(label, color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
            }
            if (subtitle != null) { Spacer(Modifier.height(4.dp)); Text(subtitle, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall) }
            Spacer(Modifier.height(12.dp))
            content()
        }
    }
}

@Composable
private fun QSingleChips(options: List<String>, selected: String?, onSelect: (String) -> Unit) {
    val rows = options.chunked(3)
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        for (row in rows) {
            Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {
                for (option in row) {
                    val sel = option == selected
                    Box(Modifier.weight(1f).clip(RoundedCornerShape(10.dp)).background(if (sel) AppTheme.AccentPurple.copy(alpha = 0.3f) else AppTheme.TrackColor.copy(alpha = 0.3f)).border(1.dp, if (sel) AppTheme.AccentPurple else Color.Transparent, RoundedCornerShape(10.dp)).clickable { onSelect(option) }.padding(vertical = 10.dp, horizontal = 8.dp), contentAlignment = Alignment.Center) {
                        Text(option, color = if (sel) Color.White else AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium, textAlign = TextAlign.Center, maxLines = 2)
                    }
                }
                repeat(3 - row.size) { Spacer(Modifier.weight(1f)) }
            }
        }
    }
}

@Composable
private fun QMultiChips(options: List<String>, selected: Set<String>, onToggle: (String) -> Unit) {
    val rows = options.chunked(3)
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        for (row in rows) {
            Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {
                for (option in row) {
                    val sel = option in selected
                    Box(Modifier.weight(1f).clip(RoundedCornerShape(10.dp)).background(if (sel) AppTheme.AccentPink.copy(alpha = 0.25f) else AppTheme.TrackColor.copy(alpha = 0.3f)).border(1.dp, if (sel) AppTheme.AccentPink else Color.Transparent, RoundedCornerShape(10.dp)).clickable { onToggle(option) }.padding(vertical = 10.dp, horizontal = 8.dp), contentAlignment = Alignment.Center) {
                        Text(option, color = if (sel) Color.White else AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium, textAlign = TextAlign.Center, maxLines = 2)
                    }
                }
                repeat(3 - row.size) { Spacer(Modifier.weight(1f)) }
            }
        }
    }
}

@Composable
private fun QPoolMultiSelect(items: List<AiSetupService.PoolLabel>, selected: Set<String>, onToggle: (String) -> Unit, accentColor: Color = AppTheme.AccentPink) {
    val grouped: Map<String, List<AiSetupService.PoolLabel>> = items.groupBy { item -> item.category ?: "Other" }
    Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
        for ((category, poolItems) in grouped) {
            Text(category, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
            val rows = poolItems.chunked(2)
            for (row in rows) {
                Row(horizontalArrangement = Arrangement.spacedBy(6.dp), modifier = Modifier.fillMaxWidth()) {
                    for (item in row) {
                        val sel = item.label in selected
                        Row(Modifier.weight(1f).clip(RoundedCornerShape(8.dp)).background(if (sel) accentColor.copy(alpha = 0.25f) else AppTheme.TrackColor.copy(alpha = 0.25f)).border(1.dp, if (sel) accentColor else Color.Transparent, RoundedCornerShape(8.dp)).clickable { onToggle(item.label) }.padding(vertical = 8.dp, horizontal = 8.dp), verticalAlignment = Alignment.CenterVertically) {
                            Text(item.label, color = if (sel) Color.White else AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, maxLines = 1, modifier = Modifier.weight(1f))
                        }
                    }
                    repeat(2 - row.size) { Spacer(Modifier.weight(1f)) }
                }
            }
        }
    }
}

@Composable
private fun QFreeText(value: String, onValueChange: (String) -> Unit, hint: String) {
    var text by remember { mutableStateOf(value) }
    LaunchedEffect(value) { if (value != text) text = value }

    val context = androidx.compose.ui.platform.LocalContext.current

    // Speech recogniser launcher (same pattern as daily NotePage)
    val speechLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
        contract = androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == android.app.Activity.RESULT_OK) {
            val spoken = result.data
                ?.getStringArrayListExtra(android.speech.RecognizerIntent.EXTRA_RESULTS)
                ?.firstOrNull()
            if (!spoken.isNullOrBlank()) {
                val updated = if (text.isBlank()) spoken else "$text, $spoken"
                text = updated
                onValueChange(updated)
            }
        }
    }

    fun launchVoice() {
        val intent = android.content.Intent(android.speech.RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(android.speech.RecognizerIntent.EXTRA_LANGUAGE_MODEL, android.speech.RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(android.speech.RecognizerIntent.EXTRA_PROMPT, "Tell us about your migraines…")
        }
        try { speechLauncher.launch(intent) } catch (_: Exception) {
            android.widget.Toast.makeText(context, "Voice input not available", android.widget.Toast.LENGTH_SHORT).show()
        }
    }

    OutlinedTextField(
        value = text, onValueChange = { text = it; onValueChange(it) },
        placeholder = { Text(hint, color = AppTheme.SubtleTextColor.copy(alpha = 0.5f), style = MaterialTheme.typography.bodySmall) },
        textStyle = MaterialTheme.typography.bodySmall.copy(color = Color.White),
        colors = OutlinedTextFieldDefaults.colors(unfocusedBorderColor = AppTheme.TrackColor, focusedBorderColor = AppTheme.AccentPurple, cursorColor = AppTheme.AccentPurple, unfocusedContainerColor = AppTheme.TrackColor.copy(alpha = 0.3f), focusedContainerColor = AppTheme.TrackColor.copy(alpha = 0.3f)),
        shape = RoundedCornerShape(10.dp), modifier = Modifier.fillMaxWidth(),
        minLines = 3, maxLines = 6,
    )
    Spacer(Modifier.height(8.dp))
    OutlinedButton(
        onClick = { launchVoice() },
        modifier = Modifier.height(40.dp),
        shape = RoundedCornerShape(10.dp),
        colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple),
        border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f))
    ) {
        Icon(Icons.Outlined.Mic, null, Modifier.size(18.dp))
        Spacer(Modifier.width(4.dp))
        Text("Voice", style = MaterialTheme.typography.bodySmall)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 1 — Migraine Profile (8 questions)
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage1(
    gender: String?, onGender: (String) -> Unit,
    ageRange: String?, onAgeRange: (String) -> Unit,
    frequency: String?, onFrequency: (String) -> Unit,
    duration: String?, onDuration: (String) -> Unit,
    experience: String?, onExperience: (String) -> Unit,
    trajectory: String?, onTrajectory: (String) -> Unit,
    warningBefore: String?, onWarningBefore: (String) -> Unit,
    triggerDelay: String?, onTriggerDelay: (String) -> Unit,
    dailyRoutine: String?, onDailyRoutine: (String) -> Unit,
    seasonalPattern: String?, onSeasonalPattern: (String) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.Psychology, "About You & Your Migraines", "Help us personalise your experience", 1, 8)
        QCard("What is your gender?", Icons.Outlined.Person, "Used to personalise thresholds (e.g. nutrition, body composition)") { QSingleChips(listOf("Female", "Male", "Prefer not to say"), gender, onGender) }
        QCard("What is your age range?", Icons.Outlined.Cake) { QSingleChips(listOf("18-25", "26-35", "36-45", "46-55", "56+"), ageRange, onAgeRange) }
        QCard("How often do you get migraines?", Icons.Outlined.CalendarMonth) {
            QSingleChips(listOf("A few per year", "Every 1-2 months", "1-3 per month", "Weekly", "Chronic"), frequency, onFrequency)
        }
        QCard("How long do they usually last?", Icons.Outlined.Timer) {
            QSingleChips(listOf("< 4 hours", "4-12 hours", "12-24 hours", "1-3 days", "3+ days"), duration, onDuration)
        }
        QCard("How long have you been getting migraines?", Icons.Outlined.History) {
            QSingleChips(listOf("New / recent", "1-5 years", "5-10 years", "10+ years"), experience, onExperience)
        }
        QCard("Have they been getting better, worse, or the same?", Icons.Outlined.TrendingUp) {
            QSingleChips(listOf("Getting worse", "Getting better", "About the same", "Just started"), trajectory, onTrajectory)
        }
        QCard("Do you get warning signs before a migraine?", Icons.Outlined.Sensors) {
            QSingleChips(listOf("Yes, always", "Sometimes", "Rarely", "Never"), warningBefore, onWarningBefore)
        }
        QCard("After a trigger, how quickly does the migraine come?", Icons.Outlined.Speed) {
            QSingleChips(listOf("Within hours", "Next day", "Within 2-3 days", "Up to a week", "Not sure"), triggerDelay, onTriggerDelay)
        }
        QCard("What best describes your daily routine?", Icons.Outlined.Work) {
            QSingleChips(listOf("Regular 9-5", "Shift work / rotating", "Irregular / freelance", "Student", "Stay at home"), dailyRoutine, onDailyRoutine)
        }
        QCard("Do your migraines follow a seasonal pattern?", Icons.Outlined.WbSunny) {
            QSingleChips(listOf("Worse in winter", "Worse in summer", "Worse in spring", "No pattern", "Not sure"), seasonalPattern, onSeasonalPattern)
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 2 — Sleep
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage2(
    sleepHours: String?, onSleepHours: (String) -> Unit,
    sleepQuality: String?, onSleepQuality: (String) -> Unit,
    poorQualityTriggers: DeterministicMapper.Certainty?, onPoorQualityTriggers: (DeterministicMapper.Certainty) -> Unit,
    tooLittleSleepTriggers: DeterministicMapper.Certainty?, onTooLittleSleepTriggers: (DeterministicMapper.Certainty) -> Unit,
    oversleepTriggers: DeterministicMapper.Certainty?, onOversleepTriggers: (DeterministicMapper.Certainty) -> Unit,
    sleepIssues: Set<String>, onToggleSleepIssue: (String) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.Bedtime, "Sleep", "Sleep is one of the most common migraine triggers", 2, 8)
        QCard("How many hours do you usually sleep?", Icons.Outlined.Schedule) { QSingleChips(listOf("< 5h", "5-6h", "6-7h", "7-8h", "8-9h", "9+h"), sleepHours, onSleepHours) }
        QCard("How would you rate your sleep quality?", Icons.Outlined.NightsStay) { QSingleChips(listOf("Good", "OK", "Poor", "Varies a lot"), sleepQuality, onSleepQuality) }
        QCard("Does POOR QUALITY sleep trigger a migraine?", Icons.Outlined.Bolt, "Restless, waking up, light sleep") { SingleCertaintySelect(poorQualityTriggers, onPoorQualityTriggers) }
        QCard("Does TOO LITTLE sleep trigger a migraine?", Icons.Outlined.Bolt, "Not enough hours") { SingleCertaintySelect(tooLittleSleepTriggers, onTooLittleSleepTriggers) }
        QCard("Does TOO MUCH sleep trigger a migraine?", Icons.Outlined.HotelClass) { SingleCertaintySelect(oversleepTriggers, onOversleepTriggers) }
        val anySleepTrigger = listOf(poorQualityTriggers, tooLittleSleepTriggers, oversleepTriggers).any { it != null && it != DeterministicMapper.Certainty.NO }
        AnimatedVisibility(visible = anySleepTrigger, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Any specific sleep issues?", Icons.Outlined.Warning, "Select all that apply") { QMultiChips(listOf("Irregular schedule", "Sleep apnea", "Jet lag", "None of these"), sleepIssues, onToggleSleepIssue) }
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 3 — Stress, Emotions & Screen
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage3(
    stressLevel: String?, onStressLevel: (String) -> Unit,
    stressChangeTriggers: DeterministicMapper.Certainty?, onStressChangeTriggers: (DeterministicMapper.Certainty) -> Unit,
    emotionalPatterns: Map<String, DeterministicMapper.Certainty>, onEmotionalPatterns: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    screenTimeDaily: String?, onScreenTimeDaily: (String) -> Unit,
    screenTimeTriggers: DeterministicMapper.Certainty?, onScreenTimeTriggers: (DeterministicMapper.Certainty) -> Unit,
    lateScreenTriggers: DeterministicMapper.Certainty?, onLateScreenTriggers: (DeterministicMapper.Certainty) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.Psychology, "Stress & Screen", "Emotional and cognitive triggers", 3, 8)
        QCard("How would you describe your general stress level?", Icons.Outlined.Whatshot) { QSingleChips(listOf("Low", "Moderate", "High", "Very high"), stressLevel, onStressLevel) }
        QCard("Does a CHANGE in your stress level trigger migraines?", Icons.Outlined.Bolt) { SingleCertaintySelect(stressChangeTriggers, onStressChangeTriggers) }
        AnimatedVisibility(visible = stressChangeTriggers != null && stressChangeTriggers != DeterministicMapper.Certainty.NO, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Which emotional patterns?", Icons.Outlined.Mood, "Select all, set certainty") {
                CertaintyMultiSelect(items = listOf(CertaintyItem("Spike in stress", "A spike in stress", "Work pressure, deadlines"), CertaintyItem("Anxiety", "Anxiety or worry"), CertaintyItem("Anger", "Anger or frustration"), CertaintyItem("Let-down", "After stress ENDS", "Weekend/holiday let-down"), CertaintyItem("Feeling low", "Feeling low or depressed")), selections = emotionalPatterns, onSelectionChanged = onEmotionalPatterns, showNoneOption = false)
            }
        }
        QCard("How much screen time do you have daily?", Icons.Outlined.PhoneAndroid) { QSingleChips(listOf("< 2h", "2-4h", "4-8h", "8-12h", "12h+"), screenTimeDaily, onScreenTimeDaily) }
        QCard("Does screen time trigger migraines?", Icons.Outlined.Bolt) { SingleCertaintySelect(screenTimeTriggers, onScreenTimeTriggers) }
        AnimatedVisibility(visible = screenTimeTriggers != null && screenTimeTriggers != DeterministicMapper.Certainty.NO, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Does late-night screen use make it worse?", Icons.Outlined.DarkMode) { SingleCertaintySelect(lateScreenTriggers, onLateScreenTriggers) }
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 4 — Diet & Substances
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage4(
    caffeineIntake: String?, onCaffeineIntake: (String) -> Unit,
    caffeineDirection: String?, onCaffeineDirection: (String) -> Unit,
    caffeineCertainty: DeterministicMapper.Certainty?, onCaffeineCertainty: (DeterministicMapper.Certainty) -> Unit,
    alcoholFrequency: String?, onAlcoholFrequency: (String) -> Unit,
    alcoholTriggers: DeterministicMapper.Certainty?, onAlcoholTriggers: (DeterministicMapper.Certainty) -> Unit,
    specificDrinks: Set<String>, onToggleDrink: (String) -> Unit,
    tyramineFoods: Map<String, DeterministicMapper.Certainty>, onTyramineFoods: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    glutenSensitivity: String?, onGlutenSensitivity: (String) -> Unit,
    glutenTriggers: DeterministicMapper.Certainty?, onGlutenTriggers: (DeterministicMapper.Certainty) -> Unit,
    eatingPatterns: Map<String, DeterministicMapper.Certainty>, onEatingPatterns: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    waterIntake: String?, onWaterIntake: (String) -> Unit,
    tracksNutrition: String?, onTracksNutrition: (String) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.Restaurant, "Diet & Substances", "Food, drink, and nutrition triggers", 4, 8)
        QCard("How much caffeine do you have daily?", Icons.Outlined.LocalCafe) { QSingleChips(listOf("None", "1-2 cups", "3-4 cups", "5+ cups"), caffeineIntake, onCaffeineIntake) }
        QCard("Does caffeine affect your migraines?", Icons.Outlined.Bolt) { QSingleChips(listOf("Too much triggers it", "Missing caffeine triggers it", "Both ways", "Not sure", "No"), caffeineDirection, onCaffeineDirection) }
        AnimatedVisibility(visible = caffeineDirection != null && caffeineDirection != "No", enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("How certain about the caffeine link?", Icons.Outlined.TrendingUp) { SingleCertaintySelect(caffeineCertainty, onCaffeineCertainty) }
        }
        QCard("How often do you drink alcohol?", Icons.Outlined.LocalBar) { QSingleChips(listOf("Never", "Occasionally", "Weekly", "Daily"), alcoholFrequency, onAlcoholFrequency) }
        AnimatedVisibility(visible = alcoholFrequency != null && alcoholFrequency != "Never", enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                QCard("Does alcohol trigger migraines?", Icons.Outlined.Bolt) { SingleCertaintySelect(alcoholTriggers, onAlcoholTriggers) }
                AnimatedVisibility(visible = alcoholTriggers != null && alcoholTriggers != DeterministicMapper.Certainty.NO, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
                    QCard("Are specific drinks worse?", Icons.Outlined.WineBar, "Select all that apply") { QMultiChips(listOf("Red wine", "Beer", "White wine", "Spirits", "Any alcohol"), specificDrinks, onToggleDrink) }
                }
            }
        }
        QCard("Do any of these foods trigger migraines?", Icons.Outlined.Fastfood, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Aged cheese", "Aged cheese", "Parmesan, brie, blue cheese"), CertaintyItem("Chocolate", "Chocolate"), CertaintyItem("Cured meats", "Cured or processed meats", "Salami, bacon, hot dogs"), CertaintyItem("Fermented foods", "Fermented foods", "Soy sauce, kimchi, miso")), selections = tyramineFoods, onSelectionChanged = onTyramineFoods)
        }
        QCard("Are you sensitive to gluten?", Icons.Outlined.SetMeal) { QSingleChips(listOf("Yes, diagnosed", "I suspect so", "No", "Not sure"), glutenSensitivity, onGlutenSensitivity) }
        AnimatedVisibility(visible = glutenSensitivity == "Yes, diagnosed" || glutenSensitivity == "I suspect so", enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Does eating gluten trigger migraines?", Icons.Outlined.Bolt) { SingleCertaintySelect(glutenTriggers, onGlutenTriggers) }
        }
        QCard("Do any eating patterns trigger migraines?", Icons.Outlined.NoMeals, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Skipping meals", "Skipping meals or fasting"), CertaintyItem("Sugar", "Eating too much sugar"), CertaintyItem("Salty food", "Eating very salty food"), CertaintyItem("Overeating", "Overeating"), CertaintyItem("Dehydration", "Dehydration / not drinking enough")), selections = eatingPatterns, onSelectionChanged = onEatingPatterns)
        }
        QCard("How much water do you drink daily?", Icons.Outlined.WaterDrop) { QSingleChips(listOf("< 1L", "1-2L", "2-3L", "3L+"), waterIntake, onWaterIntake) }
        QCard("Do you track your nutrition?", Icons.Outlined.Inventory, "Food diary, MyFitnessPal, etc.") { QSingleChips(listOf("Yes, regularly", "Sometimes", "No"), tracksNutrition, onTracksNutrition) }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 5 — Weather, Environment & Physical
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage5(
    weatherTriggers: DeterministicMapper.Certainty?, onWeatherTriggers: (DeterministicMapper.Certainty) -> Unit,
    specificWeather: Map<String, DeterministicMapper.Certainty>, onSpecificWeather: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    environmentSensitivities: Map<String, DeterministicMapper.Certainty>, onEnvironmentSensitivities: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    physicalFactors: Map<String, DeterministicMapper.Certainty>, onPhysicalFactors: (Map<String, DeterministicMapper.Certainty>) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.Cloud, "Weather, Environment & Physical", "External and physical triggers", 5, 8)
        QCard("Does weather affect your migraines?", Icons.Outlined.Thunderstorm) { SingleCertaintySelect(weatherTriggers, onWeatherTriggers) }
        AnimatedVisibility(visible = weatherTriggers != null && weatherTriggers != DeterministicMapper.Certainty.NO, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Which weather changes?", Icons.Outlined.Air, "Select all, set certainty") {
                CertaintyMultiSelect(items = listOf(CertaintyItem("Pressure changes", "Pressure/barometric changes", "Before storms"), CertaintyItem("Hot weather", "Hot weather or heat waves"), CertaintyItem("Cold weather", "Cold weather"), CertaintyItem("Humidity", "Humid or muggy weather"), CertaintyItem("Dry air", "Dry air"), CertaintyItem("Wind", "Strong wind"), CertaintyItem("Sunshine", "Bright sunshine / strong UV"), CertaintyItem("Thunderstorms", "Thunderstorms / electrical storms"), CertaintyItem("Not sure which", "Not sure — weather just affects me")), selections = specificWeather, onSelectionChanged = onSpecificWeather, showNoneOption = false)
            }
        }
        QCard("Are you sensitive to any of these?", Icons.Outlined.Visibility, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Fluorescent lights", "Bright or fluorescent lights"), CertaintyItem("Strong smells", "Strong smells (perfume, cleaning products)"), CertaintyItem("Loud noise", "Loud noise or sudden sounds"), CertaintyItem("Smoke", "Smoke or fumes"), CertaintyItem("Altitude", "High altitude or altitude changes")), selections = environmentSensitivities, onSelectionChanged = onEnvironmentSensitivities)
        }
        QCard("Do any physical factors trigger migraines?", Icons.Outlined.Healing, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Allergies", "Allergies or hayfever"), CertaintyItem("Being ill", "Being ill (cold, flu, infection)"), CertaintyItem("Low blood sugar", "Low blood sugar (shaky, faint)"), CertaintyItem("Medication change", "Changing or missing medication"), CertaintyItem("Motion sickness", "Motion sickness or travel"), CertaintyItem("Tobacco", "Tobacco or nicotine"), CertaintyItem("Sexual activity", "Sexual activity")), selections = physicalFactors, onSelectionChanged = onPhysicalFactors)
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 6 — Exercise & Hormones
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage6(
    exerciseFrequency: String?, onExerciseFrequency: (String) -> Unit,
    exerciseTriggers: DeterministicMapper.Certainty?, onExerciseTriggers: (DeterministicMapper.Certainty) -> Unit,
    exercisePattern: Set<String>, onToggleExercisePattern: (String) -> Unit,
    tracksCycle: String?, onTracksCycle: (String) -> Unit,
    cyclePatterns: Map<String, DeterministicMapper.Certainty>, onCyclePatterns: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    usesContraception: String?, onUsesContraception: (String) -> Unit,
    contraceptionEffect: String?, onContraceptionEffect: (String) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.FitnessCenter, "Exercise & Hormones", "Physical activity and hormonal triggers", 6, 8)
        QCard("How often do you exercise?", Icons.Outlined.DirectionsRun) { QSingleChips(listOf("Daily", "Few times/week", "Weekly", "Rarely", "Never"), exerciseFrequency, onExerciseFrequency) }
        QCard("Does exercise trigger migraines?", Icons.Outlined.Bolt) { SingleCertaintySelect(exerciseTriggers, onExerciseTriggers) }
        AnimatedVisibility(visible = exerciseTriggers != null && exerciseTriggers != DeterministicMapper.Certainty.NO, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Which pattern?", Icons.Outlined.Loop, "Select all that apply") { QMultiChips(listOf("During or after intense exercise", "When I haven't exercised"), exercisePattern, onToggleExercisePattern) }
        }
        QCard("Do you track your menstrual cycle?", Icons.Outlined.Female) { QSingleChips(listOf("Yes", "No", "Not applicable"), tracksCycle, onTracksCycle) }
        AnimatedVisibility(visible = tracksCycle == "Yes", enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            QCard("Do migraines relate to your cycle?", Icons.Outlined.Loop, "Select all, set certainty") {
                CertaintyMultiSelect(items = listOf(CertaintyItem("Around my period", "Around my period"), CertaintyItem("Around ovulation", "Around ovulation (mid-cycle)")), selections = cyclePatterns, onSelectionChanged = onCyclePatterns, showNoneOption = true)
            }
        }
        AnimatedVisibility(visible = tracksCycle != "Not applicable" && tracksCycle != null, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                QCard("Do you use hormonal contraception?", Icons.Outlined.Medication) { QSingleChips(listOf("Yes", "No"), usesContraception, onUsesContraception) }
                AnimatedVisibility(visible = usesContraception == "Yes", enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
                    QCard("Has contraception affected your migraines?", Icons.Outlined.Bolt) { QSingleChips(listOf("Worse — every time", "Worse — sometimes", "No change", "Actually helps"), contraceptionEffect, onContraceptionEffect) }
                }
            }
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 7 — Warning Signs (Prodromes)
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage7(
    physicalProdromes: Map<String, DeterministicMapper.Certainty>, onPhysicalProdromes: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    moodProdromes: Map<String, DeterministicMapper.Certainty>, onMoodProdromes: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    sensoryProdromes: Map<String, DeterministicMapper.Certainty>, onSensoryProdromes: (Map<String, DeterministicMapper.Certainty>) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.Sensors, "Warning Signs", "Subtle changes before a migraine can help predict attacks", 7, 8)
        QCard("Before a migraine, do you notice physical changes?", Icons.Outlined.AccessibilityNew, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Neck stiffness", "Neck stiffness or tension"), CertaintyItem("Yawning", "Excessive yawning"), CertaintyItem("Urination", "Frequent need to urinate"), CertaintyItem("Stuffy nose", "Stuffy or runny nose"), CertaintyItem("Watery eyes", "Watery eyes"), CertaintyItem("Muscle tension", "General muscle tension (shoulders, jaw)")), selections = physicalProdromes, onSelectionChanged = onPhysicalProdromes)
        }
        QCard("Mood or thinking changes?", Icons.Outlined.Mood, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Concentrating", "Difficulty concentrating"), CertaintyItem("Words", "Can't find the right words"), CertaintyItem("Irritability", "Irritability or short temper"), CertaintyItem("Mood swings", "Mood swings"), CertaintyItem("Feeling low", "Feeling unusually low or sad"), CertaintyItem("Unusually happy", "Unusually happy or energetic"), CertaintyItem("Food cravings", "Intense food cravings"), CertaintyItem("Loss of appetite", "Loss of appetite")), selections = moodProdromes, onSelectionChanged = onMoodProdromes)
        }
        QCard("Sensory changes?", Icons.Outlined.Visibility, "Select all, set certainty") {
            CertaintyMultiSelect(items = listOf(CertaintyItem("Light", "Sensitivity to light"), CertaintyItem("Sound", "Sensitivity to sound"), CertaintyItem("Smell", "Sensitivity to smell"), CertaintyItem("Tingling", "Tingling or pins and needles"), CertaintyItem("Numbness", "Numbness")), selections = sensoryProdromes, onSelectionChanged = onSensoryProdromes)
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page 8 — Symptoms, Medicines & More
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiQuestionsPage8(
    symptomPool: List<AiSetupService.PoolLabel>,
    medicinePool: List<AiSetupService.PoolLabel>,
    reliefPool: List<AiSetupService.PoolLabel>,
    activityPool: List<AiSetupService.PoolLabel>,
    missedActivityPool: List<AiSetupService.PoolLabel>,
    selectedSymptoms: Set<String>, onToggleSymptom: (String) -> Unit,
    selectedMedicines: Set<String>, onToggleMedicine: (String) -> Unit,
    selectedReliefs: Set<String>, onToggleRelief: (String) -> Unit,
    selectedActivities: Set<String>, onToggleActivity: (String) -> Unit,
    selectedMissedActivities: Set<String>, onToggleMissed: (String) -> Unit,
    additionalNotes: String?, onAdditionalNotes: (String) -> Unit,
) {
    Column(Modifier.fillMaxSize().verticalScroll(rememberScrollState()).padding(horizontal = 20.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        QPageHeader(Icons.Outlined.MedicalServices, "Symptoms, Medicines & More", "Select what you experience and use", 8, 8)
        QCard("What symptoms do you experience?", Icons.Outlined.Healing, "Tap all that apply") { QPoolMultiSelect(symptomPool, selectedSymptoms, onToggleSymptom, AppTheme.AccentPink) }
        QCard("What medicines do you take?", Icons.Outlined.Medication, "Tap all that apply") { QPoolMultiSelect(medicinePool, selectedMedicines, onToggleMedicine, Color(0xFF4FC3F7)) }
        QCard("What helps relieve your migraines?", Icons.Outlined.Spa, "Tap all that apply") { QPoolMultiSelect(reliefPool, selectedReliefs, onToggleRelief, Color(0xFF81C784)) }
        QCard("What are you usually doing when migraines hit?", Icons.Outlined.DirectionsRun, "Tap all that apply") { QPoolMultiSelect(activityPool, selectedActivities, onToggleActivity, Color(0xFFFF8A65)) }
        QCard("What do you miss because of migraines?", Icons.Outlined.EventBusy, "Tap all that apply") { QPoolMultiSelect(missedActivityPool, selectedMissedActivities, onToggleMissed, Color(0xFFEF9A9A)) }
        QCard("Anything else we should know?", Icons.Outlined.Mic, "Type or speak — helps AI understand you better") { QFreeText(additionalNotes ?: "", onAdditionalNotes, "e.g. chocolate is really bad, I work night shifts, migraines always come after flying...") }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Processing Page
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiProcessingPage(isLoading: Boolean, error: String?, onRetry: () -> Unit) {
    Column(Modifier.fillMaxSize().padding(horizontal = 32.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center) {
        Box(Modifier.size(80.dp).background(
            Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), AppTheme.AccentPink.copy(alpha = 0.2f))),
            RoundedCornerShape(24.dp)), contentAlignment = Alignment.Center) {
            Icon(Icons.Outlined.AutoAwesome, null, tint = Color.White, modifier = Modifier.size(40.dp))
        }
        Spacer(Modifier.height(24.dp))
        if (isLoading) {
            Text("Personalising your app...", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
            Spacer(Modifier.height(8.dp))
            Text("AI is analysing your migraine profile to configure everything.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
            Spacer(Modifier.height(32.dp))
            LinearProgressIndicator(modifier = Modifier.fillMaxWidth(0.6f).height(4.dp).clip(RoundedCornerShape(2.dp)), color = AppTheme.AccentPink, trackColor = AppTheme.TrackColor)
            Spacer(Modifier.height(12.dp))
            Text("This takes about 5 seconds", color = AppTheme.SubtleTextColor.copy(alpha = 0.5f), style = MaterialTheme.typography.labelSmall)
        }
        if (error != null) {
            Text("Something went wrong", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
            Spacer(Modifier.height(8.dp))
            Text(error, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center)
            Spacer(Modifier.height(24.dp))
            Button(onClick = onRetry, colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple), shape = RoundedCornerShape(12.dp)) { Text("Try Again") }
            Spacer(Modifier.height(8.dp))
            Text("Or press Next to skip AI setup", color = AppTheme.SubtleTextColor.copy(alpha = 0.5f), style = MaterialTheme.typography.labelSmall)
        }
    }
}

title: AiSetupResultsScreen.kt
text:
package com.migraineme

import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp

// ═══════════════════════════════════════════════════════════════════════════
// Results Review Screen
// ═══════════════════════════════════════════════════════════════════════════

@Composable
fun AiSetupResultsScreen(
    config: AiSetupService.AiConfig,
    availableItems: AiSetupService.AvailableItems?,
    onApply: () -> Unit,
    onSkip: () -> Unit,
    isApplying: Boolean = false,
    applyProgress: AiSetupApplier.ApplyProgress? = null,
) {
    val scrollState = rememberScrollState()

    // Build icon lookup maps from pool items
    val triggerIconMap = remember(availableItems) {
        availableItems?.triggers?.associate { it.label.lowercase() to it.iconKey } ?: emptyMap()
    }
    val prodromeIconMap = remember(availableItems) {
        availableItems?.prodromes?.associate { it.label.lowercase() to it.iconKey } ?: emptyMap()
    }

    fun triggerIcon(label: String): ImageVector? = triggerIconMap[label.lowercase()]?.let { TriggerIcons.forKey(it) }
    fun prodromeIcon(label: String): ImageVector? = prodromeIconMap[label.lowercase()]?.let { ProdromeIcons.forKey(it) }

    LaunchedEffect(scrollState.value) {
        if (TourManager.isActive() && TourManager.currentPhase() == CoachPhase.SETUP) {
            SetupScrollState.scrollPosition = scrollState.value
        }
    }

    Column(
        Modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(horizontal = 20.dp)
            .padding(top = 16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // ── Header ──
        Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {
            Box(
                Modifier.size(48.dp).background(
                    Brush.linearGradient(listOf(AppTheme.AccentPink.copy(alpha = 0.3f), AppTheme.AccentPurple.copy(alpha = 0.2f))),
                    RoundedCornerShape(14.dp)
                ), contentAlignment = Alignment.Center
            ) { Icon(Icons.Outlined.AutoAwesome, null, tint = Color.White, modifier = Modifier.size(24.dp)) }
            Spacer(Modifier.height(12.dp))
            Text("Your Personalised Setup", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
            Spacer(Modifier.height(4.dp))
            Text("Review what AI recommends. You can always adjust these later in Manage Items and Settings.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center)
        }

        // ── Summary ──
        if (config.summary.isNotBlank()) {
            Card(colors = CardDefaults.cardColors(containerColor = AppTheme.AccentPurple.copy(alpha = 0.15f)), shape = RoundedCornerShape(16.dp)) {
                Row(Modifier.padding(16.dp), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    Icon(Icons.Outlined.AutoAwesome, null, tint = AppTheme.AccentPink, modifier = Modifier.size(20.dp))
                    Text(config.summary, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }
        }

        // ── Clinical Assessment — "What Our AI Found" ──
        if (config.clinicalAssessment.isNotBlank()) {
            var assessmentExpanded by remember { mutableStateOf(true) }
            Card(
                colors = CardDefaults.cardColors(containerColor = Color(0xFF1A1A2E).copy(alpha = 0.9f)),
                shape = RoundedCornerShape(16.dp),
                modifier = Modifier.border(1.dp, Brush.linearGradient(listOf(AppTheme.AccentPink.copy(alpha = 0.3f), AppTheme.AccentPurple.copy(alpha = 0.3f))), RoundedCornerShape(16.dp))
            ) {
                Column(Modifier.padding(16.dp)) {
                    Row(Modifier.fillMaxWidth().clickable { assessmentExpanded = !assessmentExpanded }, verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        Box(Modifier.size(32.dp).background(AppTheme.AccentPink.copy(alpha = 0.15f), RoundedCornerShape(10.dp)), contentAlignment = Alignment.Center) {
                            Icon(Icons.Outlined.Psychology, null, tint = AppTheme.AccentPink, modifier = Modifier.size(18.dp))
                        }
                        Column(Modifier.weight(1f)) {
                            Text("What Our AI Found", color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                            Text("Clinical assessment of your profile", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        }
                        Icon(if (assessmentExpanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore, null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(20.dp))
                    }
                    AnimatedVisibility(visible = assessmentExpanded) {
                        Text(config.clinicalAssessment, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall, modifier = Modifier.padding(top = 12.dp))
                    }
                }
            }
        }

        // ── Gauge Calibration Notes — "How We Calibrated Your Gauge" ──
        if (config.calibrationNotes.isNotBlank()) {
            var calibrationExpanded by remember { mutableStateOf(true) }
            Card(
                colors = CardDefaults.cardColors(containerColor = Color(0xFF1A1A2E).copy(alpha = 0.9f)),
                shape = RoundedCornerShape(16.dp),
                modifier = Modifier.border(1.dp, Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), Color(0xFF4FC3F7).copy(alpha = 0.3f))), RoundedCornerShape(16.dp))
            ) {
                Column(Modifier.padding(16.dp)) {
                    Row(Modifier.fillMaxWidth().clickable { calibrationExpanded = !calibrationExpanded }, verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        Box(Modifier.size(32.dp).background(AppTheme.AccentPurple.copy(alpha = 0.15f), RoundedCornerShape(10.dp)), contentAlignment = Alignment.Center) {
                            Icon(Icons.Outlined.Analytics, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(18.dp))
                        }
                        Column(Modifier.weight(1f)) {
                            Text("How We Calibrated Your Gauge", color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                            Text("Why your thresholds are set where they are", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        }
                        Icon(if (calibrationExpanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore, null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(20.dp))
                    }
                    AnimatedVisibility(visible = calibrationExpanded) {
                        Text(config.calibrationNotes, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall, modifier = Modifier.padding(top = 12.dp))
                    }
                }
            }
        }

        // ── Data Warnings ──
        config.dataWarnings.forEach { warning ->
            val (bgColor, borderColor, icon) = when (warning.severity) {
                "high" -> Triple(Color(0xFF4A1010), Color(0xFFEF5350), Icons.Outlined.Warning)
                "medium" -> Triple(Color(0xFF4A3A10), Color(0xFFFFB74D), Icons.Outlined.Info)
                else -> Triple(Color(0xFF1A2A1A), Color(0xFF81C784), Icons.Outlined.Lightbulb)
            }
            Card(colors = CardDefaults.cardColors(containerColor = bgColor), shape = RoundedCornerShape(12.dp),
                modifier = Modifier.border(1.dp, borderColor.copy(alpha = 0.3f), RoundedCornerShape(12.dp))) {
                Row(Modifier.padding(12.dp), horizontalArrangement = Arrangement.spacedBy(10.dp), verticalAlignment = Alignment.Top) {
                    Icon(icon, null, tint = borderColor, modifier = Modifier.size(18.dp))
                    Text(warning.message, color = Color.White, style = MaterialTheme.typography.bodySmall)
                }
            }
        }

        // ── Triggers ──
        val highT = config.triggers.filter { it.severity == "HIGH" }
        val mildT = config.triggers.filter { it.severity == "MILD" }
        val lowT = config.triggers.filter { it.severity == "LOW" }

        if (highT.isNotEmpty() || mildT.isNotEmpty() || lowT.isNotEmpty()) {
            CollapsibleSection("Triggers", Icons.Outlined.Bolt, Color(0xFFFFB74D), "${highT.size} high, ${mildT.size} mild, ${lowT.size} low") {
                if (highT.isNotEmpty()) SeverityGroup("HIGH", Color(0xFFEF5350), highT.map { TDI(it.label, it.favorite, it.reasoning, it.defaultThreshold) }) { label -> triggerIcon(label) }
                if (mildT.isNotEmpty()) { Spacer(Modifier.height(8.dp)); SeverityGroup("MILD", Color(0xFFFFB74D), mildT.map { TDI(it.label, it.favorite, it.reasoning, it.defaultThreshold) }) { label -> triggerIcon(label) } }
                if (lowT.isNotEmpty()) { Spacer(Modifier.height(8.dp)); SeverityGroup("LOW", Color(0xFF81C784), lowT.map { TDI(it.label, it.favorite, it.reasoning, it.defaultThreshold) }) { label -> triggerIcon(label) } }
            }
        }

        // ── Prodromes ──
        val activeP = config.prodromes.filter { it.severity != "NONE" }
        val highP = activeP.filter { it.severity == "HIGH" }
        val mildP = activeP.filter { it.severity == "MILD" }
        val lowP = activeP.filter { it.severity == "LOW" }

        if (activeP.isNotEmpty()) {
            CollapsibleSection("Warning Signs", Icons.Outlined.Sensors, Color(0xFFCE93D8), "${highP.size} high, ${mildP.size} mild, ${lowP.size} low") {
                if (highP.isNotEmpty()) SeverityGroup("HIGH", Color(0xFFEF5350), highP.map { TDI(it.label, it.favorite, it.reasoning, it.defaultThreshold) }) { label -> prodromeIcon(label) }
                if (mildP.isNotEmpty()) { Spacer(Modifier.height(8.dp)); SeverityGroup("MILD", Color(0xFFFFB74D), mildP.map { TDI(it.label, it.favorite, it.reasoning, it.defaultThreshold) }) { label -> prodromeIcon(label) } }
                if (lowP.isNotEmpty()) { Spacer(Modifier.height(8.dp)); SeverityGroup("LOW", Color(0xFF81C784), lowP.map { TDI(it.label, it.favorite, it.reasoning, it.defaultThreshold) }) { label -> prodromeIcon(label) } }
            }
        }

        // ── Medicines ──
        if (config.medicines.isNotEmpty()) {
            CollapsibleSection("Medicines", Icons.Outlined.Medication, Color(0xFF4FC3F7), "${config.medicines.size} in quick-log") {
                config.medicines.forEach { FavoriteChip(it.label, it.reasoning) }
            }
        }

        // ── Symptoms ──
        if (config.symptoms.isNotEmpty()) {
            CollapsibleSection("Symptoms", Icons.Outlined.Healing, AppTheme.AccentPink, "${config.symptoms.size} in quick-log") {
                config.symptoms.forEach { FavoriteChip(it.label, it.reasoning) }
            }
        }

        // ── Reliefs ──
        if (config.reliefs.isNotEmpty()) {
            CollapsibleSection("Reliefs", Icons.Outlined.Spa, Color(0xFF81C784), "${config.reliefs.size} in quick-log") {
                config.reliefs.forEach { FavoriteChip(it.label, it.reasoning) }
            }
        }

        // ── Activities ──
        if (config.activities.isNotEmpty()) {
            CollapsibleSection("Activities", Icons.Outlined.DirectionsRun, Color(0xFFFF8A65), "${config.activities.size} in quick-log") {
                config.activities.forEach { FavoriteChip(it.label, it.reasoning) }
            }
        }

        // ── Missed Activities ──
        if (config.missedActivities.isNotEmpty()) {
            CollapsibleSection("Missed Activities", Icons.Outlined.EventBusy, Color(0xFFEF9A9A), "${config.missedActivities.size} in quick-log") {
                config.missedActivities.forEach { FavoriteChip(it.label, it.reasoning) }
            }
        }

        // ── Gauge Thresholds ──
        Card(colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer), shape = RoundedCornerShape(16.dp)) {
            Column(Modifier.padding(16.dp)) {
                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    Icon(Icons.Outlined.Speed, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(18.dp))
                    Text("Risk Gauge Thresholds", color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                }
                Spacer(Modifier.height(12.dp))
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                    ThresholdBadge("Low", config.gaugeThresholds.low, Color(0xFF81C784))
                    ThresholdBadge("Mild", config.gaugeThresholds.mild, Color(0xFFFFB74D))
                    ThresholdBadge("High", config.gaugeThresholds.high, Color(0xFFEF5350))
                }
                if (config.gaugeThresholds.reasoning.isNotBlank()) {
                    Spacer(Modifier.height(8.dp))
                    Text(config.gaugeThresholds.reasoning, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
        }

        // ── Decay Weights ──
        if (config.decayWeights.isNotEmpty()) {
            Card(colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer), shape = RoundedCornerShape(16.dp)) {
                Column(Modifier.padding(16.dp)) {
                    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        Icon(Icons.Outlined.TrendingDown, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(18.dp))
                        Text("Decay Curves", color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    }
                    Spacer(Modifier.height(4.dp))
                    Text("How quickly trigger risk fades over days", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    Spacer(Modifier.height(12.dp))
                    config.decayWeights.forEach { dw ->
                        val color = when (dw.severity) { "HIGH" -> Color(0xFFEF5350); "MILD" -> Color(0xFFFFB74D); else -> Color(0xFF81C784) }
                        Row(Modifier.fillMaxWidth().clip(RoundedCornerShape(8.dp)).background(color.copy(alpha = 0.08f)).padding(horizontal = 10.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                            Text(dw.severity, color = color, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold), modifier = Modifier.width(40.dp))
                            listOf(dw.day0, dw.day1, dw.day2, dw.day3, dw.day4, dw.day5, dw.day6).forEachIndexed { i, v ->
                                Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.weight(1f)) {
                                    Text("${"%.1f".format(v)}", color = Color.White, style = MaterialTheme.typography.labelSmall)
                                    Text("d$i", color = AppTheme.SubtleTextColor.copy(alpha = 0.5f), style = MaterialTheme.typography.labelSmall)
                                }
                            }
                        }
                        if (dw.reasoning.isNotBlank()) {
                            Text(dw.reasoning, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, modifier = Modifier.padding(start = 4.dp, top = 2.dp, bottom = 6.dp))
                        }
                        Spacer(Modifier.height(4.dp))
                    }
                }
            }
        }

        // ── Apply / Progress ──
        Spacer(Modifier.height(8.dp))
        if (isApplying && applyProgress != null) {
            Card(colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer), shape = RoundedCornerShape(16.dp)) {
                Column(Modifier.padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("Applying configuration...", color = Color.White, style = MaterialTheme.typography.titleSmall)
                    Spacer(Modifier.height(8.dp))
                    LinearProgressIndicator(
                        progress = { applyProgress.current.toFloat() / applyProgress.total.coerceAtLeast(1) },
                        modifier = Modifier.fillMaxWidth().height(4.dp).clip(RoundedCornerShape(2.dp)),
                        color = AppTheme.AccentPink, trackColor = AppTheme.TrackColor
                    )
                    Spacer(Modifier.height(4.dp))
                    Text("${applyProgress.current}/${applyProgress.total} — ${applyProgress.label}", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
        } else {
            Button(onClick = onApply, modifier = Modifier.fillMaxWidth().height(52.dp),
                colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink), shape = RoundedCornerShape(14.dp)) {
                Icon(Icons.Filled.Check, null, modifier = Modifier.size(20.dp))
                Spacer(Modifier.width(8.dp))
                Text("Apply Configuration", style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
            }
            TextButton(onClick = onSkip, modifier = Modifier.fillMaxWidth()) {
                Text("Skip — I'll configure manually in Settings", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium)
            }
        }

        // Reassurance card
        Card(colors = CardDefaults.cardColors(containerColor = AppTheme.AccentPurple.copy(alpha = 0.1f)), shape = RoundedCornerShape(12.dp)) {
            Row(Modifier.padding(12.dp), horizontalArrangement = Arrangement.spacedBy(10.dp), verticalAlignment = Alignment.Top) {
                Icon(Icons.Outlined.Tune, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(18.dp))
                Text("Everything here can be changed later. Go to Manage Items to adjust triggers, medicines, and reliefs. Go to Settings → Risk Model to tweak gauge thresholds.",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
            }
        }
        Spacer(Modifier.height(32.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Components
// ═══════════════════════════════════════════════════════════════════════════

@Composable
private fun CollapsibleSection(title: String, icon: ImageVector, iconColor: Color, badge: String, content: @Composable ColumnScope.() -> Unit) {
    var expanded by remember { mutableStateOf(true) }
    Card(colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer), shape = RoundedCornerShape(16.dp)) {
        Column(Modifier.padding(16.dp)) {
            Row(Modifier.fillMaxWidth().clickable { expanded = !expanded }, verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                Icon(icon, null, tint = iconColor, modifier = Modifier.size(18.dp))
                Text(title, color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold), modifier = Modifier.weight(1f))
                Text(badge, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                Icon(if (expanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore, null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(20.dp))
            }
            AnimatedVisibility(visible = expanded) {
                Column(Modifier.padding(top = 12.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) { content() }
            }
        }
    }
}

private data class TDI(val label: String, val favorite: Boolean, val reasoning: String, val threshold: Double? = null)

@Composable
private fun SeverityGroup(severity: String, color: Color, items: List<TDI>, iconResolver: ((String) -> ImageVector?)? = null) {
    Text(severity, color = color, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold))
    Spacer(Modifier.height(4.dp))
    items.forEach { item ->
        val icon = iconResolver?.invoke(item.label)
        Row(Modifier.fillMaxWidth().clip(RoundedCornerShape(8.dp)).background(color.copy(alpha = 0.08f)).padding(horizontal = 10.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            if (icon != null) {
                Icon(icon, null, tint = color.copy(alpha = 0.7f), modifier = Modifier.size(16.dp))
            }
            if (item.favorite) Text("★", color = Color(0xFFFFD54F), style = MaterialTheme.typography.labelMedium)
            Column(Modifier.weight(1f)) {
                Text(item.label, color = Color.White, style = MaterialTheme.typography.bodySmall, maxLines = 1, overflow = TextOverflow.Ellipsis)
                if (item.reasoning.isNotBlank()) Text(item.reasoning, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, maxLines = 2, overflow = TextOverflow.Ellipsis)
            }
            if (item.threshold != null) {
                Text("⚡${String.format("%.1f", item.threshold)}", color = color.copy(alpha = 0.7f), style = MaterialTheme.typography.labelSmall)
            }
        }
    }
}

@Composable
private fun ItemChip(label: String, severity: String, isFavorite: Boolean, reasoning: String, icon: ImageVector? = null) {
    val color = when (severity) { "HIGH" -> Color(0xFFEF5350); "MILD" -> Color(0xFFFFB74D); else -> Color(0xFF81C784) }
    Row(Modifier.fillMaxWidth().clip(RoundedCornerShape(8.dp)).background(color.copy(alpha = 0.08f)).padding(horizontal = 10.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
        if (icon != null) {
            Icon(icon, null, tint = color.copy(alpha = 0.7f), modifier = Modifier.size(16.dp))
        }
        if (isFavorite) Text("★", color = Color(0xFFFFD54F), style = MaterialTheme.typography.labelMedium)
        Column(Modifier.weight(1f)) {
            Text(label, color = Color.White, style = MaterialTheme.typography.bodySmall)
            if (reasoning.isNotBlank()) Text(reasoning, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, maxLines = 2)
        }
        Box(Modifier.background(color.copy(alpha = 0.2f), RoundedCornerShape(4.dp)).padding(horizontal = 6.dp, vertical = 2.dp)) {
            Text(severity, color = color, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold))
        }
    }
}

@Composable
private fun FavoriteChip(label: String, reasoning: String) {
    Row(Modifier.fillMaxWidth().clip(RoundedCornerShape(8.dp)).background(AppTheme.AccentPurple.copy(alpha = 0.08f)).padding(horizontal = 10.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
        Text("★", color = Color(0xFFFFD54F), style = MaterialTheme.typography.labelMedium)
        Column(Modifier.weight(1f)) {
            Text(label, color = Color.White, style = MaterialTheme.typography.bodySmall)
            if (reasoning.isNotBlank()) Text(reasoning, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, maxLines = 2)
        }
    }
}

@Composable
private fun ThresholdBadge(label: String, value: Int, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Box(Modifier.size(48.dp).background(color.copy(alpha = 0.15f), CircleShape).border(2.dp, color.copy(alpha = 0.4f), CircleShape), contentAlignment = Alignment.Center) {
            Text("$value", color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        }
        Spacer(Modifier.height(4.dp))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
    }
}

title: AiSetupScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.outlined.AutoAwesome
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

private enum class AiPage { Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, PROCESSING, RESULTS }

@Composable
fun AiSetupScreen(
    onComplete: () -> Unit,
    onSkip: () -> Unit,
) {
    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext
    val scope = rememberCoroutineScope()

    var currentPage by remember { mutableStateOf(AiPage.Q1) }

    // ── Load pool items + data context on launch ──
    var availableItems by remember { mutableStateOf<AiSetupService.AvailableItems?>(null) }
    var dataContext by remember { mutableStateOf<AiSetupService.DataContext?>(null) }

    LaunchedEffect(Unit) {
        withContext(Dispatchers.IO) {
            try {
                availableItems = AiSetupService.buildAvailableItems(appCtx)
                dataContext = AiSetupService.buildDataContext(appCtx)
            } catch (e: Exception) {
                Log.e("AiSetup", "Failed to load pools", e)
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // Page 1 — Demographics & Migraine Profile
    // ═══════════════════════════════════════════════════════════════
    var gender by remember { mutableStateOf<String?>(null) }
    var ageRange by remember { mutableStateOf<String?>(null) }
    var frequency by remember { mutableStateOf<String?>(null) }
    var duration by remember { mutableStateOf<String?>(null) }
    var experience by remember { mutableStateOf<String?>(null) }
    var trajectory by remember { mutableStateOf<String?>(null) }
    var warningBefore by remember { mutableStateOf<String?>(null) }
    var triggerDelay by remember { mutableStateOf<String?>(null) }
    var dailyRoutine by remember { mutableStateOf<String?>(null) }
    var seasonalPattern by remember { mutableStateOf<String?>(null) }

    // Page 2 — Sleep
    var sleepHours by remember { mutableStateOf<String?>(null) }
    var sleepQuality by remember { mutableStateOf<String?>(null) }
    var poorQualityTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var tooLittleSleepTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var oversleepTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var sleepIssues by remember { mutableStateOf(setOf<String>()) }

    // Page 3 — Stress & Screen
    var stressLevel by remember { mutableStateOf<String?>(null) }
    var stressChangeTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var emotionalPatterns by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var screenTimeDaily by remember { mutableStateOf<String?>(null) }
    var screenTimeTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var lateScreenTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }

    // Page 4 — Diet
    var caffeineIntake by remember { mutableStateOf<String?>(null) }
    var caffeineDirection by remember { mutableStateOf<String?>(null) }
    var caffeineCertainty by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var alcoholFrequency by remember { mutableStateOf<String?>(null) }
    var alcoholTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var specificDrinks by remember { mutableStateOf(setOf<String>()) }
    var tyramineFoods by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var glutenSensitivity by remember { mutableStateOf<String?>(null) }
    var glutenTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var eatingPatterns by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var waterIntake by remember { mutableStateOf<String?>(null) }
    var tracksNutrition by remember { mutableStateOf<String?>(null) }

    // Page 5 — Weather, Environment, Physical
    var weatherTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var specificWeather by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var environmentSensitivities by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var physicalFactors by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }

    // Page 6 — Exercise & Hormones
    var exerciseFrequency by remember { mutableStateOf<String?>(null) }
    var exerciseTriggers by remember { mutableStateOf<DeterministicMapper.Certainty?>(null) }
    var exercisePattern by remember { mutableStateOf(setOf<String>()) }
    var tracksCycle by remember { mutableStateOf<String?>(null) }
    var cyclePatterns by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var usesContraception by remember { mutableStateOf<String?>(null) }
    var contraceptionEffect by remember { mutableStateOf<String?>(null) }

    // Page 7 — Prodromes
    var physicalProdromes by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var moodProdromes by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }
    var sensoryProdromes by remember { mutableStateOf(mapOf<String, DeterministicMapper.Certainty>()) }

    // Page 8
    var selectedSymptoms by remember { mutableStateOf(setOf<String>()) }
    var selectedMedicines by remember { mutableStateOf(setOf<String>()) }
    var selectedReliefs by remember { mutableStateOf(setOf<String>()) }
    var selectedActivities by remember { mutableStateOf(setOf<String>()) }
    var selectedMissedActivities by remember { mutableStateOf(setOf<String>()) }
    var additionalNotes by remember { mutableStateOf<String?>(null) }

    // AI state
    var isProcessing by remember { mutableStateOf(false) }
    var aiError by remember { mutableStateOf<String?>(null) }
    var aiConfig by remember { mutableStateOf<AiSetupService.AiConfig?>(null) }
    var isApplying by remember { mutableStateOf(false) }
    var applyProgress by remember { mutableStateOf<AiSetupApplier.ApplyProgress?>(null) }

    // ═══════════════════════════════════════════════════════════════
    // Build QuestionnaireAnswers from all state
    // ═══════════════════════════════════════════════════════════════
    fun buildAnswers() = DeterministicMapper.QuestionnaireAnswers(
        gender = gender, ageRange = ageRange,
        frequency = frequency, duration = duration, experience = experience,
        trajectory = trajectory, warningSignsBefore = warningBefore,
        triggerDelay = triggerDelay, dailyRoutine = dailyRoutine, seasonalPattern = seasonalPattern,
        sleepHours = sleepHours, sleepQuality = sleepQuality,
        poorSleepQualityTriggers = poorQualityTriggers ?: DeterministicMapper.Certainty.NO,
        tooLittleSleepTriggers = tooLittleSleepTriggers ?: DeterministicMapper.Certainty.NO,
        oversleepTriggers = oversleepTriggers ?: DeterministicMapper.Certainty.NO,
        sleepIssues = sleepIssues,
        stressLevel = stressLevel,
        stressChangeTriggers = stressChangeTriggers ?: DeterministicMapper.Certainty.NO,
        emotionalPatterns = emotionalPatterns,
        screenTimeDaily = screenTimeDaily,
        screenTimeTriggers = screenTimeTriggers ?: DeterministicMapper.Certainty.NO,
        lateScreenTriggers = lateScreenTriggers ?: DeterministicMapper.Certainty.NO,
        caffeineIntake = caffeineIntake, caffeineDirection = caffeineDirection,
        caffeineCertainty = caffeineCertainty ?: DeterministicMapper.Certainty.NO,
        alcoholFrequency = alcoholFrequency,
        alcoholTriggers = alcoholTriggers ?: DeterministicMapper.Certainty.NO,
        specificDrinks = specificDrinks, tyramineFoods = tyramineFoods,
        glutenSensitivity = glutenSensitivity,
        glutenTriggers = glutenTriggers ?: DeterministicMapper.Certainty.NO,
        eatingPatterns = eatingPatterns, waterIntake = waterIntake, tracksNutrition = tracksNutrition,
        weatherTriggers = weatherTriggers ?: DeterministicMapper.Certainty.NO,
        specificWeather = specificWeather,
        environmentSensitivities = environmentSensitivities,
        physicalFactors = physicalFactors,
        exerciseFrequency = exerciseFrequency,
        exerciseTriggers = exerciseTriggers ?: DeterministicMapper.Certainty.NO,
        exercisePattern = exercisePattern,
        tracksCycle = tracksCycle, cyclePatterns = cyclePatterns,
        usesContraception = usesContraception, contraceptionEffect = contraceptionEffect,
        physicalProdromes = physicalProdromes, moodProdromes = moodProdromes, sensoryProdromes = sensoryProdromes,
        selectedSymptoms = selectedSymptoms, selectedMedicines = selectedMedicines,
        selectedReliefs = selectedReliefs, selectedActivities = selectedActivities,
        selectedMissedActivities = selectedMissedActivities,
        freeText = additionalNotes,
    )

    // ═══════════════════════════════════════════════════════════════
    // Process: deterministic mapping THEN AI calibration
    // ═══════════════════════════════════════════════════════════════
    fun process() {
        isProcessing = true
        aiError = null
        scope.launch {
            try {
                val answers = buildAnswers()
                val dc = dataContext ?: withContext(Dispatchers.IO) { AiSetupService.buildDataContext(appCtx) }
                val items = availableItems ?: withContext(Dispatchers.IO) { AiSetupService.buildAvailableItems(appCtx) }
                Log.d("AiSetup", "autoTriggerLabels(${items.autoTriggerLabels.size}): ${items.autoTriggerLabels.take(5)}")
                Log.d("AiSetup", "autoProdromeLabels(${items.autoProdromeLabels.size}): ${items.autoProdromeLabels.take(5)}")

                // Step 1: Deterministic mapping (pure Kotlin, instant)
                val mapping = DeterministicMapper.map(answers, dc.enabledMetrics)

                // Step 2: AI calibration — two-call architecture
                val result = AiCalibrationService.calibrate(
                    context = appCtx,
                    mapping = mapping,
                    items = items,
                    answers = answers,
                    dataContext = dc,
                )

                result.fold(
                    onSuccess = { config -> aiConfig = config; isProcessing = false; currentPage = AiPage.RESULTS },
                    onFailure = { e -> aiError = e.message ?: "Unknown error"; isProcessing = false; Log.e("AiSetup", "AI calibration failed", e) }
                )
            } catch (e: Exception) {
                aiError = e.message ?: "Unknown error"; isProcessing = false
                Log.e("AiSetup", "Processing exception", e)
            }
        }
    }

    fun applyConfig() {
        val config = aiConfig ?: return
        isApplying = true
        scope.launch {
            AiSetupApplier.applyConfig(appCtx, config) { progress -> applyProgress = progress }.fold(
                onSuccess = {
                    // Save answers + AI config to Supabase for community features
                    launch(Dispatchers.IO) {
                        runCatching { AiSetupProfileStore.save(appCtx, buildAnswers(), config) }
                            .onFailure { Log.w("AiSetup", "Profile store save failed (non-blocking)", it) }
                    }
                    isApplying = false; onComplete()
                },
                onFailure = {
                    // Still try to save even if apply partially failed
                    launch(Dispatchers.IO) {
                        runCatching { AiSetupProfileStore.save(appCtx, buildAnswers(), config) }
                            .onFailure { Log.w("AiSetup", "Profile store save failed (non-blocking)", it) }
                    }
                    isApplying = false; onComplete()
                }
            )
        }
    }

    LaunchedEffect(currentPage) {
        if (currentPage == AiPage.PROCESSING && !isProcessing && aiConfig == null) process()
    }

    // ═══════════════════════════════════════════════════════════════
    // UI
    // ═══════════════════════════════════════════════════════════════
    val totalPages = 10
    val pageNum = AiPage.entries.indexOf(currentPage) + 1
    val bgBrush = remember { Brush.verticalGradient(listOf(Color(0xFF1A0029), Color(0xFF2A003D), Color(0xFF1A0029))) }

    Box(Modifier.fillMaxSize().background(bgBrush)) {
        Column(Modifier.fillMaxSize()) {
            // Progress bar
            LinearProgressIndicator(
                progress = { pageNum.toFloat() / totalPages },
                modifier = Modifier.fillMaxWidth().padding(horizontal = 24.dp, vertical = 12.dp).height(4.dp).clip(RoundedCornerShape(2.dp)),
                color = AppTheme.AccentPink, trackColor = AppTheme.TrackColor,
            )
            Row(Modifier.padding(horizontal = 28.dp), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                Icon(Icons.Outlined.AutoAwesome, null, tint = AppTheme.AccentPink, modifier = Modifier.size(14.dp))
                Text("AI Setup — $pageNum of $totalPages", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
            }
            Spacer(Modifier.height(8.dp))

            // Page content
            Box(Modifier.weight(1f).fillMaxWidth()) {
                AnimatedContent(
                    targetState = currentPage,
                    transitionSpec = {
                        if (targetState.ordinal > initialState.ordinal)
                            slideInHorizontally { it } + fadeIn() togetherWith slideOutHorizontally { -it } + fadeOut()
                        else
                            slideInHorizontally { -it } + fadeIn() togetherWith slideOutHorizontally { it } + fadeOut()
                    }, label = "aiPage",
                ) { page ->
                    when (page) {
                        AiPage.Q1 -> AiQuestionsPage1(gender, { gender = it }, ageRange, { ageRange = it }, frequency, { frequency = it }, duration, { duration = it }, experience, { experience = it }, trajectory, { trajectory = it }, warningBefore, { warningBefore = it }, triggerDelay, { triggerDelay = it }, dailyRoutine, { dailyRoutine = it }, seasonalPattern, { seasonalPattern = it })
                        AiPage.Q2 -> AiQuestionsPage2(sleepHours, { sleepHours = it }, sleepQuality, { sleepQuality = it }, poorQualityTriggers, { poorQualityTriggers = it }, tooLittleSleepTriggers, { tooLittleSleepTriggers = it }, oversleepTriggers, { oversleepTriggers = it }, sleepIssues, { i -> sleepIssues = if (i in sleepIssues) sleepIssues - i else sleepIssues + i })
                        AiPage.Q3 -> AiQuestionsPage3(stressLevel, { stressLevel = it }, stressChangeTriggers, { stressChangeTriggers = it }, emotionalPatterns, { emotionalPatterns = it }, screenTimeDaily, { screenTimeDaily = it }, screenTimeTriggers, { screenTimeTriggers = it }, lateScreenTriggers, { lateScreenTriggers = it })
                        AiPage.Q4 -> AiQuestionsPage4(caffeineIntake, { caffeineIntake = it }, caffeineDirection, { caffeineDirection = it }, caffeineCertainty, { caffeineCertainty = it }, alcoholFrequency, { alcoholFrequency = it }, alcoholTriggers, { alcoholTriggers = it }, specificDrinks, { d -> specificDrinks = if (d in specificDrinks) specificDrinks - d else specificDrinks + d }, tyramineFoods, { tyramineFoods = it }, glutenSensitivity, { glutenSensitivity = it }, glutenTriggers, { glutenTriggers = it }, eatingPatterns, { eatingPatterns = it }, waterIntake, { waterIntake = it }, tracksNutrition, { tracksNutrition = it })
                        AiPage.Q5 -> AiQuestionsPage5(weatherTriggers, { weatherTriggers = it }, specificWeather, { specificWeather = it }, environmentSensitivities, { environmentSensitivities = it }, physicalFactors, { physicalFactors = it })
                        AiPage.Q6 -> AiQuestionsPage6(exerciseFrequency, { exerciseFrequency = it }, exerciseTriggers, { exerciseTriggers = it }, exercisePattern, { p -> exercisePattern = if (p in exercisePattern) exercisePattern - p else exercisePattern + p }, tracksCycle, { tracksCycle = it }, cyclePatterns, { cyclePatterns = it }, usesContraception, { usesContraception = it }, contraceptionEffect, { contraceptionEffect = it })
                        AiPage.Q7 -> AiQuestionsPage7(physicalProdromes, { physicalProdromes = it }, moodProdromes, { moodProdromes = it }, sensoryProdromes, { sensoryProdromes = it })
                        AiPage.Q8 -> AiQuestionsPage8(
                            symptomPool = availableItems?.symptoms ?: emptyList(),
                            medicinePool = availableItems?.medicines ?: emptyList(),
                            reliefPool = availableItems?.reliefs ?: emptyList(),
                            activityPool = availableItems?.activities ?: emptyList(),
                            missedActivityPool = availableItems?.missedActivities ?: emptyList(),
                            selectedSymptoms, { s -> selectedSymptoms = if (s in selectedSymptoms) selectedSymptoms - s else selectedSymptoms + s },
                            selectedMedicines, { m -> selectedMedicines = if (m in selectedMedicines) selectedMedicines - m else selectedMedicines + m },
                            selectedReliefs, { r -> selectedReliefs = if (r in selectedReliefs) selectedReliefs - r else selectedReliefs + r },
                            selectedActivities, { a -> selectedActivities = if (a in selectedActivities) selectedActivities - a else selectedActivities + a },
                            selectedMissedActivities, { ma -> selectedMissedActivities = if (ma in selectedMissedActivities) selectedMissedActivities - ma else selectedMissedActivities + ma },
                            additionalNotes, { additionalNotes = it },
                        )
                        AiPage.PROCESSING -> AiProcessingPage(isProcessing, aiError, onRetry = { aiError = null; process() })
                        AiPage.RESULTS -> aiConfig?.let { config ->
                            AiSetupResultsScreen(config = config, availableItems = availableItems, onApply = { applyConfig() }, onSkip = onSkip, isApplying = isApplying, applyProgress = applyProgress)
                        }
                    }
                }
            }

            // Bottom navigation
            if (currentPage != AiPage.PROCESSING && currentPage != AiPage.RESULTS) {
                Row(Modifier.fillMaxWidth().padding(horizontal = 24.dp, vertical = 16.dp), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    if (currentPage == AiPage.Q1) {
                        TextButton(onClick = onSkip) { Text("Skip AI Setup", color = AppTheme.SubtleTextColor) }
                    } else {
                        TextButton(onClick = { val prev = AiPage.entries.getOrNull(currentPage.ordinal - 1); if (prev != null) currentPage = prev }) { Text("Back", color = AppTheme.SubtleTextColor) }
                    }
                    if (currentPage == AiPage.Q8) {
                        Button(onClick = { currentPage = AiPage.PROCESSING }, colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink), shape = RoundedCornerShape(12.dp)) {
                            Icon(Icons.Outlined.AutoAwesome, null, modifier = Modifier.size(18.dp)); Spacer(Modifier.width(6.dp)); Text("Analyse & Configure")
                        }
                    } else {
                        Button(onClick = { val next = AiPage.entries.getOrNull(currentPage.ordinal + 1); if (next != null) currentPage = next }, colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple), shape = RoundedCornerShape(12.dp)) {
                            Text("Next"); Spacer(Modifier.width(4.dp)); Icon(Icons.AutoMirrored.Filled.ArrowForward, null, modifier = Modifier.size(18.dp))
                        }
                    }
                }
            }
            if (currentPage == AiPage.PROCESSING && !isProcessing && aiError != null) {
                Row(Modifier.fillMaxWidth().padding(horizontal = 24.dp, vertical = 16.dp), horizontalArrangement = Arrangement.SpaceBetween) {
                    TextButton(onClick = { currentPage = AiPage.Q8 }) { Text("Back", color = AppTheme.SubtleTextColor) }
                    TextButton(onClick = onSkip) { Text("Skip AI Setup", color = AppTheme.SubtleTextColor) }
                }
            }
        }
    }
}

title: AiSetupService.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.*
import io.ktor.client.engine.android.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.*
import org.json.JSONArray

/**
 * AI-powered full app configuration via GPT-4o-mini, proxied through Supabase Edge Function.
 * The OpenAI API key lives server-side in Supabase vault — never touches the client.
 * Cost: ~$0.003 per call.
 *
 * Collects: questionnaire answers + connected data sources + available pool items
 * Returns:  trigger/prodrome severities, favorites, decay weights, gauge thresholds,
 *           medicine/relief/activity favorites, and data gap warnings.
 */
object AiSetupService {

    private const val TAG = "AiSetupService"

    // ═══════════════════════════════════════════════════════════════════════
    // Input data classes
    // ═══════════════════════════════════════════════════════════════════════

    data class UserAnswers(
        // Page 1 — Migraine Basics
        val frequency: String? = null,
        val avgDuration: String? = null,
        val avgSeverity: String? = null,
        val usualTiming: String? = null,
        val warningBefore: String? = null,
        val familyHistory: String? = null,

        // Page 2 — Triggers & Lifestyle
        val knownTriggerAreas: Set<String> = emptySet(),
        val knownSpecificTriggers: String? = null,
        val warningSignsExperienced: List<String> = emptyList(),
        val typicalSleepHours: String? = null,
        val sleepQuality: String? = null,
        val screenTimeDaily: String? = null,
        val caffeineIntake: String? = null,
        val alcoholIntake: String? = null,
        val exerciseFrequency: String? = null,
        val stressLevel: String? = null,
        val trackCycle: String? = null,
        val cycleRelated: String? = null,
        val waterIntake: String? = null,

        // Page 3 — Medicines, Reliefs & Activities
        val selectedSymptoms: String? = null,
        val currentMedicines: String? = null,
        val preventiveMedicines: String? = null,
        val helpfulReliefs: String? = null,
        val activitiesDuringMigraine: String? = null,
        val missedActivities: String? = null,
        val additionalNotes: String? = null,
    )

    data class DataContext(
        val whoopConnected: Boolean,
        val healthConnectConnected: Boolean,
        val enabledMetrics: Map<String, Boolean>,   // metric name → enabled
    )

    data class AvailableItems(
        val triggers: List<PoolLabel>,
        val prodromes: List<PoolLabel>,
        val symptoms: List<PoolLabel>,
        val medicines: List<PoolLabel>,
        val reliefs: List<PoolLabel>,
        val activities: List<PoolLabel>,
        val missedActivities: List<PoolLabel>,
        /** Individual trigger labels (pre-group-collapse) that have a metric_table in Supabase = auto-detected */
        val autoTriggerLabels: Set<String> = emptySet(),
        /** Individual prodrome labels that have a metric_table = auto-detected */
        val autoProdromeLabels: Set<String> = emptySet(),
    )

    data class PoolLabel(val label: String, val category: String? = null, val iconKey: String? = null, val isAuto: Boolean = false)

    // ═══════════════════════════════════════════════════════════════════════
    // Output data classes
    // ═══════════════════════════════════════════════════════════════════════

    @Serializable
    data class AiDecayWeights(
        val severity: String = "",
        val day0: Double = 0.0,
        val day1: Double = 0.0,
        val day2: Double = 0.0,
        val day3: Double = 0.0,
        val day4: Double = 0.0,
        val day5: Double = 0.0,
        val day6: Double = 0.0,
        val reasoning: String = "",
    )

    @Serializable
    data class AiConfig(
        val triggers: List<AiTriggerRec> = emptyList(),
        val prodromes: List<AiProdromeRec> = emptyList(),
        val symptoms: List<AiFavoriteRec> = emptyList(),
        val medicines: List<AiFavoriteRec> = emptyList(),
        val reliefs: List<AiFavoriteRec> = emptyList(),
        val activities: List<AiFavoriteRec> = emptyList(),
        @SerialName("missed_activities") val missedActivities: List<AiFavoriteRec> = emptyList(),
        @SerialName("gauge_thresholds") val gaugeThresholds: AiGaugeThresholds = AiGaugeThresholds(),
        @SerialName("decay_weights") val decayWeights: List<AiDecayWeights> = emptyList(),
        @SerialName("data_warnings") val dataWarnings: List<AiDataWarning> = emptyList(),
        val summary: String = "",
        @SerialName("clinical_assessment") val clinicalAssessment: String = "",
        @SerialName("calibration_notes") val calibrationNotes: String = "",
    )

    @Serializable
    data class AiTriggerRec(
        val label: String,
        val severity: String,
        @SerialName("decay_days") val decayDays: Int = 1,
        val favorite: Boolean = false,
        val reasoning: String = "",
        @SerialName("default_threshold") val defaultThreshold: Double? = null,
    )

    @Serializable
    data class AiProdromeRec(
        val label: String,
        val severity: String,
        val favorite: Boolean = false,
        val reasoning: String = "",
        @SerialName("default_threshold") val defaultThreshold: Double? = null,
    )

    @Serializable
    data class AiFavoriteRec(
        val label: String,
        val favorite: Boolean = true,
        val reasoning: String = "",
    )

    @Serializable
    data class AiGaugeThresholds(
        val low: Int = 3,
        val mild: Int = 8,
        val high: Int = 15,
        val reasoning: String = "",
    )

    @Serializable
    data class AiDataWarning(
        val type: String = "",        // "missing_data", "missing_connection", "suggestion"
        val message: String = "",
        val metric: String? = null,   // which metric to enable
        val severity: String = "medium",  // "high", "medium", "low"
    )

    // ═══════════════════════════════════════════════════════════════════════
    // System prompt
    // ═══════════════════════════════════════════════════════════════════════

    private fun buildSystemPrompt(): String = """
You are a migraine specialist AI configuring the MigraineMe app for a new user.

RULES:
1. Use ONLY exact label strings from the AVAILABLE ITEMS lists provided. Never invent labels.
2. Rate EVERY trigger and prodrome — use "NONE" for irrelevant ones.
3. Mark 5-8 most relevant items per category as favorite=true (these go in the quick-log bar).
4. For medicines/reliefs/activities/missed_activities: ONLY include items the user mentioned or that are clearly relevant. Set favorite=true for those.
5. Be conservative — start with fewer HIGH ratings. Users can adjust up.
6. Decay weights control how quickly a trigger's risk contribution fades over days (day0=today, day6=6 days ago).
   Return 3 rows: HIGH, MILD, LOW. Each has day0-day6 values.
   - Frequent migraines: steeper curves (high day0, rapid drop) — triggers hit hard but fade fast
   - Infrequent migraines: flatter curves (moderate day0, slower drop) — cumulative buildup matters more
   - Defaults: HIGH=10/5/2.5/1/0/0/0, MILD=6/3/1.5/0.5/0/0/0, LOW=3/1.5/0/0/0/0/0
7. NEVER set favorite=true on auto-detected triggers or prodromes (marked with [AUTO] in the items list). These are collected automatically from connected devices and do not need manual logging.

SEVERITY SCALING by migraine frequency:
- Daily → more HIGH ratings, tighter gauge thresholds (low:3, mild:8, high:15)
- Weekly → balanced mix, medium thresholds (low:4, mild:10, high:18)
- Monthly → more LOW ratings, wider thresholds (low:5, mild:12, high:22)
- Rarely → mostly NONE/LOW, widest thresholds (low:5, mild:15, high:25)

DECAY_DAYS (how many days a trigger stays active after occurring):
- Weather/barometric: 1 day (immediate effect)
- Diet/caffeine/alcohol: 1 day (immediate)
- Sleep quality/duration: 1-2 days (next-day effect)  
- Screen time/noise: 1 day (immediate)
- Physical exertion: 1-2 days (delayed onset)
- Stress/cognitive: 2-3 days (cumulative)
- Hormonal/menstrual: 3-4 days (lingering cycle effect)
- Dehydration: 1-2 days

DATA WARNINGS: Compare the user's trigger areas against their connected data sources and enabled metrics. Flag any mismatch where a trigger is rated HIGH or MILD but the relevant data isn't being collected. Also suggest connections that would improve predictions.

Respond with ONLY valid JSON (no markdown fences, no preamble). Use this exact schema:
{
  "triggers": [{"label":"...","severity":"HIGH|MILD|LOW|NONE","decay_days":1-4,"favorite":true/false,"reasoning":"..."}],
  "prodromes": [{"label":"...","severity":"HIGH|MILD|LOW|NONE","favorite":true/false,"reasoning":"..."}],
  "symptoms": [{"label":"...","favorite":true,"reasoning":"..."}],
  "medicines": [{"label":"...","favorite":true,"reasoning":"..."}],
  "reliefs": [{"label":"...","favorite":true,"reasoning":"..."}],
  "activities": [{"label":"...","favorite":true,"reasoning":"..."}],
  "missed_activities": [{"label":"...","favorite":true,"reasoning":"..."}],
  "gauge_thresholds": {"low":3-5,"mild":8-15,"high":15-30,"reasoning":"..."},
  "decay_weights": [
    {"severity":"HIGH","day0":10,"day1":5,"day2":2.5,"day3":1,"day4":0,"day5":0,"day6":0,"reasoning":"..."},
    {"severity":"MILD","day0":6,"day1":3,"day2":1.5,"day3":0.5,"day4":0,"day5":0,"day6":0,"reasoning":"..."},
    {"severity":"LOW","day0":3,"day1":1.5,"day2":0,"day3":0,"day4":0,"day5":0,"day6":0,"reasoning":"..."}
  ],
  "data_warnings": [{"type":"missing_data|missing_connection|suggestion","message":"...","metric":"...or null","severity":"high|medium|low"}],
  "summary": "2-3 sentence personalised summary of the configuration"
}
""".trimIndent()

    // ═══════════════════════════════════════════════════════════════════════
    // User message builder
    // ═══════════════════════════════════════════════════════════════════════

    private fun buildUserMessage(
        answers: UserAnswers,
        data: DataContext,
        items: AvailableItems
    ): String = buildString {
        appendLine("=== USER'S MIGRAINE PROFILE ===")
        appendLine()

        // Page 1
        appendLine("MIGRAINE BASICS:")
        answers.frequency?.let { appendLine("- Frequency: $it") }
        answers.avgDuration?.let { appendLine("- Average duration: $it") }
        answers.avgSeverity?.let { appendLine("- Average severity: $it") }
        answers.usualTiming?.let { appendLine("- Usual timing: $it") }
        answers.warningBefore?.let { appendLine("- Gets warning signs: $it") }
        answers.familyHistory?.let { appendLine("- Family history: $it") }
        appendLine()

        // Page 2
        appendLine("TRIGGERS & LIFESTYLE:")
        if (answers.knownTriggerAreas.isNotEmpty()) appendLine("- Known trigger areas: ${answers.knownTriggerAreas.joinToString(", ")}")
        answers.knownSpecificTriggers?.let { appendLine("- Specific known triggers: $it") }
        if (answers.warningSignsExperienced.isNotEmpty()) appendLine("- Warning signs experienced: ${answers.warningSignsExperienced.joinToString(", ")}")
        answers.typicalSleepHours?.let { appendLine("- Typical sleep: $it hours") }
        answers.sleepQuality?.let { appendLine("- Sleep quality: $it") }
        answers.screenTimeDaily?.let { appendLine("- Daily screen time: $it") }
        answers.caffeineIntake?.let { appendLine("- Caffeine: $it") }
        answers.alcoholIntake?.let { appendLine("- Alcohol: $it") }
        answers.exerciseFrequency?.let { appendLine("- Exercise: $it") }
        answers.stressLevel?.let { appendLine("- Stress level: $it") }
        answers.waterIntake?.let { appendLine("- Water intake: $it") }
        answers.trackCycle?.let { appendLine("- Tracks menstrual cycle: $it") }
        answers.cycleRelated?.let { appendLine("- Migraines cycle-related: $it") }
        appendLine()

        // Page 3
        appendLine("SYMPTOMS, MEDICINES & RELIEFS:")
        answers.selectedSymptoms?.let { appendLine("- Symptoms experienced: $it") }
        answers.currentMedicines?.let { appendLine("- Current medicines: $it") }
        answers.preventiveMedicines?.let { appendLine("- Preventive medicines: $it") }
        answers.helpfulReliefs?.let { appendLine("- What helps: $it") }
        answers.activitiesDuringMigraine?.let { appendLine("- Activities during migraines: $it") }
        answers.missedActivities?.let { appendLine("- Missed activities: $it") }
        answers.additionalNotes?.let {
            appendLine()
            appendLine("ADDITIONAL NOTES FROM USER:")
            appendLine(it)
        }
        appendLine()

        // Data context
        appendLine("=== CONNECTED DATA SOURCES ===")
        appendLine("WHOOP connected: ${data.whoopConnected}")
        appendLine("Health Connect connected: ${data.healthConnectConnected}")
        appendLine("Enabled metrics:")
        data.enabledMetrics.forEach { (metric, enabled) ->
            appendLine("  - $metric: ${if (enabled) "ON" else "OFF"}")
        }
        appendLine()

        // Available items
        appendLine("=== AVAILABLE ITEMS (use EXACT labels) ===")
        appendLine()
        appendLine("TRIGGERS:")
        items.triggers.groupBy { it.category ?: "Other" }.forEach { (cat, list) ->
            appendLine("  [$cat] ${list.joinToString(", ") { "${it.label}${if (it.isAuto) " [AUTO]" else ""}" }}")
        }
        appendLine()
        appendLine("PRODROMES:")
        items.prodromes.groupBy { it.category ?: "Other" }.forEach { (cat, list) ->
            appendLine("  [$cat] ${list.joinToString(", ") { "${it.label}${if (it.isAuto) " [AUTO]" else ""}" }}")
        }
        appendLine()
        appendLine("MEDICINES: ${items.medicines.joinToString(", ") { it.label }}")
        appendLine()
        appendLine("RELIEFS: ${items.reliefs.joinToString(", ") { it.label }}")
        appendLine()
        appendLine("SYMPTOMS: ${items.symptoms.joinToString(", ") { it.label }}")
        appendLine()
        appendLine("ACTIVITIES: ${items.activities.joinToString(", ") { it.label }}")
        appendLine()
        appendLine("MISSED ACTIVITIES: ${items.missedActivities.joinToString(", ") { it.label }}")
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Data context builder (reads from device state)
    // ═══════════════════════════════════════════════════════════════════════

    suspend fun buildDataContext(context: Context): DataContext = withContext(Dispatchers.IO) {
        val appCtx = context.applicationContext
        val whoopConnected = WhoopTokenStore(appCtx).load() != null

        // Check Health Connect permissions
        val hcConnected = try {
            val hc = androidx.health.connect.client.HealthConnectClient.getOrCreate(appCtx)
            hc.permissionController.getGrantedPermissions().isNotEmpty()
        } catch (_: Exception) { false }

        // Fetch metric settings
        val metrics = try {
            EdgeFunctionsService().getMetricSettings(appCtx)
                .associate { it.metric to it.enabled }
        } catch (_: Exception) { emptyMap() }

        DataContext(
            whoopConnected = whoopConnected,
            healthConnectConnected = hcConnected,
            enabledMetrics = metrics,
        )
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Available items builder (reads from Supabase)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Fetch auto-detect labels from the global template table (trigger_templates or prodrome_templates).
     * These are the source of truth for which labels have metric_table (= auto-detected).
     * Returns a Set of lowercase label strings.
     */
    private suspend fun fetchAutoLabelsFromTemplate(accessToken: String, table: String): Set<String> {
        val client = HttpClient(io.ktor.client.engine.android.Android)
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/$table?select=label&metric_table=not.is.null"
            val response = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $accessToken")
            }
            if (!response.status.isSuccess()) {
                Log.w(TAG, "Failed to fetch $table auto labels: ${response.status}")
                emptySet()
            } else {
                val body = response.bodyAsText()
                val arr = JSONArray(body)
                val labels = mutableSetOf<String>()
                for (i in 0 until arr.length()) {
                    val label = arr.getJSONObject(i).optString("label", "")
                    if (label.isNotBlank()) labels.add(label.lowercase())
                }
                Log.d(TAG, "Fetched ${labels.size} auto labels from $table")
                labels
            }
        } catch (e: Exception) {
            Log.w(TAG, "Error fetching auto labels from $table", e)
            emptySet()
        } finally {
            client.close()
        }
    }

    suspend fun buildAvailableItems(context: Context): AvailableItems = withContext(Dispatchers.IO) {
        val appCtx = context.applicationContext
        val accessToken = SessionStore.getValidAccessToken(appCtx)
            ?: throw IllegalStateException("No access token")
        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)

        // Collapse display_group items: GPT sees group names instead of individual labels
        val rawTriggers = db.getAllTriggerPool(accessToken)

        // Build auto-detect lookup from TEMPLATE tables (global source of truth)
        // user_triggers may not have metric_table populated — templates always do
        val autoTriggerLabels = fetchAutoLabelsFromTemplate(accessToken, "trigger_templates")
        val autoProdromeLabels = fetchAutoLabelsFromTemplate(accessToken, "prodrome_templates")

        val triggerStandalone = rawTriggers.filter { it.displayGroup == null }
            .map { PoolLabel(it.label, it.category, it.iconKey, isAuto = it.metricTable != null) }
        val triggerGrouped = rawTriggers.filter { it.displayGroup != null }
            .groupBy { it.displayGroup!! }
            .map { (groupName, members) ->
                PoolLabel(groupName, members.first().category, members.first().iconKey, isAuto = members.first().metricTable != null)
            }
        val triggers = triggerStandalone + triggerGrouped

        val rawProdromes = db.getAllProdromePool(accessToken)

        val prodromeStandalone = rawProdromes.filter { it.displayGroup == null }
            .map { PoolLabel(it.label, it.category, it.iconKey, isAuto = it.metricTable != null) }
        val prodromeGrouped = rawProdromes.filter { it.displayGroup != null }
            .groupBy { it.displayGroup!! }
            .map { (groupName, members) ->
                PoolLabel(groupName, members.first().category, members.first().iconKey, isAuto = members.first().metricTable != null)
            }
        val prodromes = prodromeStandalone + prodromeGrouped

        val symptoms = db.getAllSymptomPool(accessToken).map { PoolLabel(it.label, it.category, it.iconKey) }
        val medicines = db.getAllMedicinePool(accessToken).map { PoolLabel(it.label, it.category) }
        val reliefs = db.getAllReliefPool(accessToken).map { PoolLabel(it.label, it.category, it.iconKey) }
        val activities = db.getAllActivityPool(accessToken).map { PoolLabel(it.label, it.category, it.iconKey) }
        val missedActivities = db.getAllMissedActivityPool(accessToken).map { PoolLabel(it.label, it.category, it.iconKey) }

        AvailableItems(triggers, prodromes, symptoms, medicines, reliefs, activities, missedActivities, autoTriggerLabels, autoProdromeLabels)
    }

    // ═══════════════════════════════════════════════════════════════════════
    // API call (via Supabase Edge Function)
    // ═══════════════════════════════════════════════════════════════════════

    suspend fun generateConfig(
        context: Context,
        answers: UserAnswers,
        dataContext: DataContext,
        availableItems: AvailableItems,
    ): Result<AiConfig> = withContext(Dispatchers.IO) {
        val appCtx = context.applicationContext
        val accessToken = SessionStore.getValidAccessToken(appCtx)
            ?: return@withContext Result.failure(Exception("Not authenticated"))

        val systemPrompt = buildSystemPrompt()
        val userMessage = buildUserMessage(answers, dataContext, availableItems)

        Log.d(TAG, "Sending to ai-setup edge function. System: ${systemPrompt.length} chars, User: ${userMessage.length} chars")

        val requestBody = buildJsonObject {
            put("system_prompt", systemPrompt)
            put("user_message", userMessage)
        }

        val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/ai-setup"

        val client = HttpClient(io.ktor.client.engine.android.Android) {
            install(ContentNegotiation) {
                json(Json { ignoreUnknownKeys = true; encodeDefaults = true; explicitNulls = false })
            }
        }

        try {
            val response: HttpResponse = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                contentType(ContentType.Application.Json)
                setBody(requestBody.toString())
            }

            val responseText = response.bodyAsText()
            Log.d(TAG, "Edge function response status: ${response.status}")

            if (!response.status.isSuccess()) {
                Log.e(TAG, "Edge function error: $responseText")
                return@withContext Result.failure(Exception("AI setup failed (${response.status}): $responseText"))
            }

            // Edge function returns the AI config JSON directly
            val cleanJson = responseText
                .replace("```json", "").replace("```", "")
                .trim()

            val json = Json { ignoreUnknownKeys = true; coerceInputValues = true }
            val config = json.decodeFromString<AiConfig>(cleanJson)

            Log.d(TAG, "Parsed: ${config.triggers.size} triggers, ${config.prodromes.size} prodromes, " +
                    "${config.medicines.size} medicines, ${config.reliefs.size} reliefs, " +
                    "${config.dataWarnings.size} warnings")

            Result.success(config)

        } catch (e: Exception) {
            Log.e(TAG, "AI setup call failed", e)
            Result.failure(e)
        } finally {
            client.close()
        }
    }
}


title: AmbientNoisePrefs.kt
text:
package com.migraineme

import android.content.Context

/**
 * Local storage for ambient noise settings and last sample time.
 * Avoids network calls on every screen unlock.
 */
object AmbientNoisePrefs {
    private const val PREFS_NAME = "ambient_noise_prefs"
    private const val KEY_ENABLED = "enabled"
    private const val KEY_LAST_SUCCESSFUL_SAMPLE_TIME = "last_successful_sample_time"
    private const val KEY_LAST_SAMPLE_L_MEAN = "last_sample_l_mean"
    private const val KEY_LAST_SAMPLE_L_MAX = "last_sample_l_max"

    private fun prefs(context: Context) = 
        context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

    fun isEnabled(context: Context): Boolean {
        return prefs(context).getBoolean(KEY_ENABLED, false)
    }

    fun setEnabled(context: Context, enabled: Boolean) {
        prefs(context).edit().putBoolean(KEY_ENABLED, enabled).apply()
    }

    fun getLastSuccessfulSampleTime(context: Context): Long {
        return prefs(context).getLong(KEY_LAST_SUCCESSFUL_SAMPLE_TIME, 0L)
    }

    /**
     * Call this after a successful (non-zero) sample upload.
     */
    fun recordSuccessfulSample(context: Context, lMean: Double, lMax: Double) {
        prefs(context).edit()
            .putLong(KEY_LAST_SUCCESSFUL_SAMPLE_TIME, System.currentTimeMillis())
            .putFloat(KEY_LAST_SAMPLE_L_MEAN, lMean.toFloat())
            .putFloat(KEY_LAST_SAMPLE_L_MAX, lMax.toFloat())
            .apply()
    }

    /**
     * Get last sample values (for display purposes if needed)
     */
    fun getLastSampleValues(context: Context): Pair<Float, Float> {
        val p = prefs(context)
        return Pair(
            p.getFloat(KEY_LAST_SAMPLE_L_MEAN, 0f),
            p.getFloat(KEY_LAST_SAMPLE_L_MAX, 0f)
        )
    }
}

title: AmbientNoiseSampler.kt
text:
package com.migraineme

import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.util.Log
import android.os.Build
import kotlin.math.ln
import kotlin.math.sqrt

data class AmbientNoiseMetrics(
    val lMean: Double,
    val lP90: Double,
    val lMax: Double,
    val frames: Int
)

/**
 * Records short PCM audio and computes loudness metrics WITHOUT storing audio.
 *
 * We use log-RMS per frame:
 * - lMean = mean(logRms)
 * - lP90  = 90th percentile(logRms)
 * - lMax  = max(logRms)
 *
 * This is NOT calibrated dB SPL; it's a stable relative measure per device.
 */
object AmbientNoiseSampler {

    private const val TAG = "AmbientNoiseSampler"

    /**
     * Prefer an unprocessed microphone stream when available (avoids speech-focused DSP that can
     * suppress to zeros on some devices). Fallback to MIC, then (last resort) VOICE_RECOGNITION.
     */
    private fun createAudioRecord(
        sampleRate: Int,
        channelConfig: Int,
        audioFormat: Int,
        bufferSize: Int
    ): AudioRecord {
        val sources = buildList {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                add(MediaRecorder.AudioSource.UNPROCESSED)
            }
            add(MediaRecorder.AudioSource.MIC)
            // Last resort for devices that refuse MIC/UNPROCESSED.
            add(MediaRecorder.AudioSource.VOICE_RECOGNITION)
        }

        var lastErr: Throwable? = null
        for (src in sources) {
            try {
                val r = AudioRecord(src, sampleRate, channelConfig, audioFormat, bufferSize)
                if (r.state == AudioRecord.STATE_INITIALIZED) {
                    Log.d(TAG, "AudioRecord initialized with source=$src")
                    return r
                }
                Log.w(TAG, "AudioRecord not initialized with source=$src")
                runCatching { r.release() }
            } catch (t: Throwable) {
                lastErr = t
                Log.w(TAG, "AudioRecord failed with source=$src: ${t.message}")
            }
        }

        throw IllegalStateException("Unable to initialize AudioRecord with available sources", lastErr)
    }

    fun capture(durationMs: Long = 60_000L): AmbientNoiseMetrics {
        val sampleRate = 16_000
        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val audioFormat = AudioFormat.ENCODING_PCM_16BIT

        val minBuf = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)
        val bufferSize = maxOf(minBuf, sampleRate * 2) // ~1 second buffer (16-bit mono)

        var recorder: AudioRecord? = null

        try {
            recorder = createAudioRecord(
                sampleRate = sampleRate,
                channelConfig = channelConfig,
                audioFormat = audioFormat,
                bufferSize = bufferSize
            )

            if (recorder.state != AudioRecord.STATE_INITIALIZED) {
                Log.w(TAG, "AudioRecord failed to initialize")
                return AmbientNoiseMetrics(lMean = 0.0, lP90 = 0.0, lMax = 0.0, frames = 0)
            }

            val readBuf = ShortArray(bufferSize / 2)

            val frameMs = 200L
            val frameSamples = (sampleRate * frameMs / 1000).toInt()
            val frameBuf = ShortArray(frameSamples)
            var frameFill = 0

            val frameAcc = ArrayList<Double>(512)

            recorder.startRecording()
            val start = System.currentTimeMillis()

            var iterationCount = 0
            while (System.currentTimeMillis() - start < durationMs) {
                // Check for thread interruption
                if (Thread.currentThread().isInterrupted) {
                    Log.d(TAG, "Thread interrupted during capture")
                    break
                }

                val read = recorder.read(readBuf, 0, readBuf.size)
                if (read <= 0) {
                    iterationCount++
                    // If we consistently fail to read, don't loop forever
                    if (iterationCount > 100) {
                        Log.w(TAG, "Too many failed reads, aborting")
                        break
                    }
                    continue
                }

                iterationCount = 0 // Reset counter on successful read

                var i = 0
                while (i < read) {
                    val take = minOf(read - i, frameSamples - frameFill)
                    for (k in 0 until take) {
                        frameBuf[frameFill + k] = readBuf[i + k]
                    }
                    frameFill += take
                    i += take

                    if (frameFill == frameSamples) {
                        frameAcc.add(computeLogRms(frameBuf))
                        frameFill = 0
                    }
                }
            }

            if (frameAcc.isEmpty()) {
                Log.d(TAG, "No frames captured")
                return AmbientNoiseMetrics(lMean = 0.0, lP90 = 0.0, lMax = 0.0, frames = 0)
            }

            frameAcc.sort()
            val p90Index = ((frameAcc.size - 1) * 0.90).toInt().coerceIn(0, frameAcc.size - 1)

            val lP90 = frameAcc[p90Index]
            val lMax = frameAcc.last()
            val lMean = frameAcc.average()

            Log.d(TAG, "Captured ${frameAcc.size} frames successfully")
            return AmbientNoiseMetrics(lMean = lMean, lP90 = lP90, lMax = lMax, frames = frameAcc.size)

        } catch (e: SecurityException) {
            Log.e(TAG, "Security exception - microphone permission denied: ${e.message}")
            return AmbientNoiseMetrics(lMean = 0.0, lP90 = 0.0, lMax = 0.0, frames = 0)
        } catch (e: IllegalStateException) {
            Log.e(TAG, "IllegalStateException during recording: ${e.message}")
            return AmbientNoiseMetrics(lMean = 0.0, lP90 = 0.0, lMax = 0.0, frames = 0)
        } catch (e: Exception) {
            Log.e(TAG, "Unexpected error during capture: ${e.message}", e)
            return AmbientNoiseMetrics(lMean = 0.0, lP90 = 0.0, lMax = 0.0, frames = 0)
        } finally {
            // CRITICAL: Always release the recorder, regardless of how we exit
            recorder?.let {
                try {
                    // Only stop if we're still recording
                    if (it.recordingState == AudioRecord.RECORDSTATE_RECORDING) {
                        it.stop()
                    }
                } catch (e: IllegalStateException) {
                    Log.w(TAG, "Error stopping recorder: ${e.message}")
                }

                try {
                    it.release()
                } catch (e: Exception) {
                    Log.w(TAG, "Error releasing recorder: ${e.message}")
                }
            }
        }
    }

    private fun computeLogRms(frame: ShortArray): Double {
        var sumSq = 0.0
        for (s in frame) {
            val v = s.toDouble()
            sumSq += v * v
        }
        val meanSq = sumSq / frame.size.toDouble()
        val rms = sqrt(meanSq)

        // Avoid ln(0)
        val eps = 1.0
        return ln(rms + eps)
    }
}

title: AmbientNoiseSampleWorker.kt
text:
package com.migraineme

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.pm.PackageManager
import android.content.pm.ServiceInfo
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.ForegroundInfo
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.util.concurrent.TimeUnit

/**
 * Captures ~60 seconds of ambient loudness metrics and uploads numbers to Supabase.
 */
class AmbientNoiseSampleWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        val ctx = applicationContext

        Log.d(LOG_TAG, "Worker started - checking settings")

        // Check Supabase metric_settings for ambient noise enabled
        val enabled = try {
            val edge = EdgeFunctionsService()
            val settings = edge.getMetricSettings(ctx)
            val isEnabled = settings.find { it.metric == "ambient_noise_samples" }?.enabled ?: false
            // Cache locally for ScreenOnReceiver
            AmbientNoisePrefs.setEnabled(ctx, isEnabled)
            isEnabled
        } catch (e: Exception) {
            Log.w(LOG_TAG, "Failed to check Supabase settings: ${e.message}, assuming disabled")
            false
        }

        if (!enabled) {
            Log.d(LOG_TAG, "ambient_noise_samples disabled in Supabase — cancel loop")
            AmbientNoisePrefs.setEnabled(ctx, false)
            cancel(ctx)
            return@withContext Result.success()
        }

        try {
            val hasMicPerm =
                ContextCompat.checkSelfPermission(ctx, Manifest.permission.RECORD_AUDIO) ==
                        PackageManager.PERMISSION_GRANTED
            if (!hasMicPerm) {
                Log.d(LOG_TAG, "RECORD_AUDIO not granted — skip")
                return@withContext Result.success()
            }

            val access = SessionStore.getValidAccessToken(ctx)
            if (access == null) {
                Log.d(LOG_TAG, "No valid Supabase access token — skip")
                return@withContext Result.success()
            }

            val userId = SessionStore.readUserId(ctx)
                ?: runCatching { SupabaseAuthService.getUser(access).id }.getOrNull()
                ?: run {
                    Log.d(LOG_TAG, "userId unavailable — skip")
                    return@withContext Result.success()
                }

            try {
                setForeground(createForegroundInfo(ctx))
            } catch (t: Throwable) {
                Log.w(LOG_TAG, "Unable to start foreground execution for mic: ${t.message}")
                return@withContext Result.success()
            }

            val startTsIso = Instant.now().toString()
            val durationS = 60

            Log.d(LOG_TAG, "Starting capture for ${durationS}s")
            val metrics = AmbientNoiseSampler.capture(durationMs = durationS * 1000L)

            if (metrics.frames <= 0) {
                Log.d(LOG_TAG, "No frames captured — skip upload")
                return@withContext Result.success()
            }

            // Skip silent samples (screen off / mic blocked)
            if (metrics.lMean == 0.0 && metrics.lMax == 0.0) {
                Log.d(LOG_TAG, "Silent sample detected (likely screen off) — skip upload")
                return@withContext Result.success()
            }

            val flags = buildMap<String, String> {
                put("frames", metrics.frames.toString())
                put("source", "android")
            }

            SupabaseAmbientNoiseService().insertAmbientNoiseSample(
                accessToken = access,
                userId = userId,
                startTsIso = startTsIso,
                durationS = durationS,
                lMean = metrics.lMean,
                lP90 = metrics.lP90,
                lMax = metrics.lMax,
                qualityFlags = flags
            )

            // Record successful sample time locally for ScreenOnReceiver
            AmbientNoisePrefs.recordSuccessfulSample(ctx, metrics.lMean, metrics.lMax)

            Log.d(LOG_TAG, "Uploaded ambient noise sample frames=${metrics.frames}")
            Result.success()
        } catch (t: Throwable) {
            Log.w(LOG_TAG, "Worker error: ${t.message}", t)
            Result.success()
        } finally {
            scheduleNext(ctx)
        }
    }

    private fun createForegroundInfo(context: Context): ForegroundInfo {
        ensureChannel(context)

        val notif = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(android.R.drawable.ic_btn_speak_now)
            .setContentTitle("Measuring ambient sound level")
            .setContentText("MigraineMe is sampling loudness (no audio stored).")
            .setOngoing(true)
            .setOnlyAlertOnce(true)
            .build()

        val fgsType = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ServiceInfo.FOREGROUND_SERVICE_TYPE_MICROPHONE
        } else {
            0
        }

        return ForegroundInfo(FOREGROUND_NOTIF_ID, notif, fgsType)
    }

    private fun ensureChannel(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val nm =
                context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            val ch = NotificationChannel(
                CHANNEL_ID,
                "MigraineMe sensor sampling",
                NotificationManager.IMPORTANCE_LOW
            )
            nm.createNotificationChannel(ch)
        }
    }

    companion object {
        private const val LOG_TAG = "AmbientNoiseWorker"
        private const val UNIQUE = "ambient_noise_samples_loop"

        private const val CHANNEL_ID = "migraineme_sensor_sampling"
        private const val FOREGROUND_NOTIF_ID = 92001
        private const val LOOP_DELAY_MINUTES = 30L

        /**
         * Schedule worker to run soon (used by regular loop).
         * Uses KEEP policy - won't interrupt if already running/queued.
         */
        fun schedule(context: Context) {
            try {
                Log.d(LOG_TAG, "Scheduling ambient noise sampling worker")

                val req = OneTimeWorkRequestBuilder<AmbientNoiseSampleWorker>()
                    .build()

                WorkManager.getInstance(context).enqueueUniqueWork(
                    UNIQUE,
                    ExistingWorkPolicy.KEEP,
                    req
                )

                Log.d(LOG_TAG, "Worker scheduled successfully")
            } catch (e: Exception) {
                Log.e(LOG_TAG, "Error scheduling worker: ${e.message}", e)
            }
        }

        /**
         * Schedule worker to run immediately (used by ScreenOnReceiver).
         * Uses REPLACE policy - cancels any pending delayed work to run now.
         */
        fun scheduleImmediate(context: Context) {
            try {
                Log.d(LOG_TAG, "Scheduling IMMEDIATE ambient noise sampling")

                val req = OneTimeWorkRequestBuilder<AmbientNoiseSampleWorker>()
                    .build()

                WorkManager.getInstance(context).enqueueUniqueWork(
                    UNIQUE,
                    ExistingWorkPolicy.REPLACE,
                    req
                )

                Log.d(LOG_TAG, "Immediate worker scheduled")
            } catch (e: Exception) {
                Log.e(LOG_TAG, "Error scheduling immediate worker: ${e.message}", e)
            }
        }

        private fun scheduleNext(context: Context) {
            try {
                Log.d(LOG_TAG, "Scheduling next run in $LOOP_DELAY_MINUTES minutes")

                val req = OneTimeWorkRequestBuilder<AmbientNoiseSampleWorker>()
                    .setInitialDelay(LOOP_DELAY_MINUTES, TimeUnit.MINUTES)
                    .build()

                WorkManager.getInstance(context).enqueueUniqueWork(
                    UNIQUE,
                    ExistingWorkPolicy.KEEP,
                    req
                )
            } catch (e: Exception) {
                Log.e(LOG_TAG, "Error scheduling next worker: ${e.message}", e)
            }
        }

        fun cancel(context: Context) {
            try {
                Log.d(LOG_TAG, "Cancelling ambient noise sampling worker")
                WorkManager.getInstance(context).cancelUniqueWork(UNIQUE)
            } catch (e: Exception) {
                Log.e(LOG_TAG, "Error cancelling worker: ${e.message}", e)
            }
        }
    }
}

title: AmbientNoiseWatchdogWorker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.concurrent.TimeUnit

/**
 * Watchdog worker that periodically checks if ambient noise worker is scheduled,
 * and restarts it if needed.
 * 
 * Uses PeriodicWorkRequest which SURVIVES phone death/reboot automatically.
 * Android minimum is 15 minutes, so we use that.
 */
class AmbientNoiseWatchdogWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        Log.d(TAG, "Watchdog: Checking ambient noise worker status")
        
        try {
            // Check Supabase metric_settings for ambient noise enabled
            val enabled = try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(applicationContext)
                settings.find { it.metric == "ambient_noise_samples" }?.enabled ?: false
            } catch (e: Exception) {
                Log.w(TAG, "Failed to check Supabase settings: ${e.message}")
                false
            }
            
            if (!enabled) {
                Log.d(TAG, "Watchdog: Ambient noise disabled in Supabase - skipping check (watchdog stays alive)")
                return@withContext Result.success()
            }
            
            // Check if the worker is actually scheduled
            val workManager = WorkManager.getInstance(applicationContext)
            val workInfos = workManager
                .getWorkInfosForUniqueWork("ambient_noise_samples_loop")
                .get()
            
            val isScheduled = workInfos.isNotEmpty() && 
                              workInfos.any { 
                                  it.state == WorkInfo.State.ENQUEUED || 
                                  it.state == WorkInfo.State.RUNNING 
                              }
            
            if (!isScheduled) {
                Log.w(TAG, "⚠️ Watchdog: Ambient noise worker is NOT scheduled! Restarting...")
                AmbientNoiseSampleWorker.schedule(applicationContext)
                Log.d(TAG, "✅ Watchdog: Worker restarted successfully")
            } else {
                val state = workInfos.first().state
                Log.d(TAG, "✅ Watchdog: Worker is scheduled (state: $state)")
            }
            
            Result.success()
            
        } catch (e: Exception) {
            Log.e(TAG, "❌ Watchdog error: ${e.message}", e)
            Result.retry()
        }
    }

    companion object {
        private const val TAG = "NoiseWatchdog"
        private const val UNIQUE_NAME = "ambient_noise_watchdog"
        
        /**
         * Schedule the watchdog as PERIODIC work.
         * This survives phone death automatically - Android reschedules it after reboot.
         * 
         * Minimum interval is 15 minutes (Android restriction).
         */
        fun schedule(context: Context) {
            try {
                Log.d(TAG, "Scheduling watchdog worker (periodic, every 15 minutes)")
                
                val request = PeriodicWorkRequestBuilder<AmbientNoiseWatchdogWorker>(
                    repeatInterval = 15,
                    repeatIntervalTimeUnit = TimeUnit.MINUTES
                ).build()
                
                WorkManager.getInstance(context).enqueueUniquePeriodicWork(
                    UNIQUE_NAME,
                    ExistingPeriodicWorkPolicy.KEEP,
                    request
                )
                
                Log.d(TAG, "✅ Watchdog scheduled successfully (survives phone death)")
            } catch (e: Exception) {
                Log.e(TAG, "❌ Error scheduling watchdog: ${e.message}", e)
            }
        }
        
        fun cancel(context: Context) {
            try {
                Log.d(TAG, "Cancelling watchdog worker")
                WorkManager.getInstance(context).cancelUniqueWork(UNIQUE_NAME)
            } catch (e: Exception) {
                Log.e(TAG, "Error cancelling watchdog: ${e.message}", e)
            }
        }
    }
}

title: AppContext.kt
text:
// app/src/main/java/com/migraineme/AppContext.kt
package com.migraineme

import android.content.Context

object AppContext {
    lateinit var app: Context
        private set

    fun init(context: Context) {
        app = context.applicationContext
    }
}

title: AppDateTimePickers.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/**
 * Purple-themed Material3 DatePicker colors used across the app.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun appDatePickerColors(): DatePickerColors = DatePickerDefaults.colors(
    containerColor = Color(0xFF1E0A2E),
    titleContentColor = Color.White,
    headlineContentColor = Color.White,
    weekdayContentColor = AppTheme.SubtleTextColor,
    subheadContentColor = AppTheme.SubtleTextColor,
    navigationContentColor = Color.White,
    yearContentColor = AppTheme.BodyTextColor,
    currentYearContentColor = AppTheme.AccentPurple,
    selectedYearContentColor = Color.White,
    selectedYearContainerColor = AppTheme.AccentPurple,
    dayContentColor = AppTheme.BodyTextColor,
    selectedDayContentColor = Color.White,
    selectedDayContainerColor = AppTheme.AccentPurple,
    todayContentColor = AppTheme.AccentPurple,
    todayDateBorderColor = AppTheme.AccentPurple,
    dayInSelectionRangeContentColor = Color.White,
    dayInSelectionRangeContainerColor = AppTheme.AccentPurple.copy(alpha = 0.3f)
)

/**
 * Purple-themed Material3 TimePicker colors used across the app.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun appTimePickerColors(): TimePickerColors = TimePickerDefaults.colors(
    clockDialColor = Color(0xFF2A0C3C),
    clockDialSelectedContentColor = Color.White,
    clockDialUnselectedContentColor = AppTheme.BodyTextColor,
    selectorColor = AppTheme.AccentPurple,
    containerColor = Color(0xFF1E0A2E),
    periodSelectorBorderColor = AppTheme.AccentPurple.copy(alpha = 0.5f),
    periodSelectorSelectedContainerColor = AppTheme.AccentPurple,
    periodSelectorUnselectedContainerColor = Color.Transparent,
    periodSelectorSelectedContentColor = Color.White,
    periodSelectorUnselectedContentColor = AppTheme.SubtleTextColor,
    timeSelectorSelectedContainerColor = AppTheme.AccentPurple.copy(alpha = 0.3f),
    timeSelectorUnselectedContainerColor = Color(0xFF2A0C3C),
    timeSelectorSelectedContentColor = Color.White,
    timeSelectorUnselectedContentColor = AppTheme.BodyTextColor
)

/**
 * Themed DateTimePicker field — replaces the legacy Android DatePickerDialog.
 * Shows a Material3 DatePicker then TimePicker in our purple theme.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DateTimePickerField(
    label: String,
    onDateTimeSelected: (String) -> Unit
) {
    var showDatePicker by remember { mutableStateOf(false) }
    var showTimePicker by remember { mutableStateOf(false) }
    var pickedDate by remember { mutableStateOf<LocalDate?>(null) }
    var display by remember { mutableStateOf(label) }

    val datePickerState = rememberDatePickerState()
    val timePickerState = rememberTimePickerState(
        initialHour = LocalTime.now().hour,
        initialMinute = LocalTime.now().minute,
        is24Hour = true
    )

    // Date picker button
    OutlinedButton(
        onClick = { showDatePicker = true },
        modifier = Modifier.fillMaxWidth(),
        colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.BodyTextColor),
        border = androidx.compose.foundation.BorderStroke(1.dp, Color.White.copy(alpha = 0.15f))
    ) {
        Text(display, color = AppTheme.BodyTextColor)
    }

    // Date picker dialog
    if (showDatePicker) {
        DatePickerDialog(
            onDismissRequest = { showDatePicker = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let { millis ->
                            pickedDate = Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDate()
                            showDatePicker = false
                            showTimePicker = true
                        }
                    },
                    enabled = datePickerState.selectedDateMillis != null
                ) { Text("Next", color = if (datePickerState.selectedDateMillis != null) AppTheme.AccentPurple else AppTheme.SubtleTextColor) }
            },
            dismissButton = {
                TextButton(onClick = { showDatePicker = false }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            colors = DatePickerDefaults.colors(containerColor = Color(0xFF1E0A2E))
        ) {
            DatePicker(
                state = datePickerState,
                colors = appDatePickerColors(),
                title = { Text("Select date", color = Color.White, modifier = Modifier.padding(start = 24.dp, top = 16.dp)) },
                headline = null,
                showModeToggle = false
            )
        }
    }

    // Time picker dialog
    if (showTimePicker && pickedDate != null) {
        AlertDialog(
            onDismissRequest = { showTimePicker = false },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            confirmButton = {
                TextButton(
                    onClick = {
                        val iso = "%sT%02d:%02d:00Z".format(
                            pickedDate!!.format(DateTimeFormatter.ISO_LOCAL_DATE),
                            timePickerState.hour,
                            timePickerState.minute
                        )
                        display = iso
                        onDateTimeSelected(iso)
                        showTimePicker = false
                    }
                ) { Text("Done", color = AppTheme.AccentPurple) }
            },
            dismissButton = {
                TextButton(onClick = { showTimePicker = false }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            title = { Text("Select time") },
            text = {
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = androidx.compose.ui.Alignment.Center) {
                    TimePicker(
                        state = timePickerState,
                        colors = appTimePickerColors()
                    )
                }
            }
        )
    }
}

/**
 * Alias — some screens use this name.
 */
@Composable
fun AppDateTimePicker(
    label: String,
    onDateTimeSelected: (String) -> Unit
) {
    DateTimePickerField(label = label, onDateTimeSelected = onDateTimeSelected)
}

/**
 * Themed date-only picker for screens that need a styled date selector.
 * Note: MenstruationSettingsScreen has its own private AppDatePicker — use this for new screens.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ThemedDatePicker(
    isoDate: String,
    enabled: Boolean = true,
    onDateSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    var showPicker by remember { mutableStateOf(false) }

    val parsed = isoDate.trim().takeIf { it.isNotBlank() }?.let { raw ->
        runCatching { LocalDate.parse(raw, DateTimeFormatter.ISO_LOCAL_DATE) }.getOrNull()
    }
    val initial = parsed ?: LocalDate.now()
    val displayText = if (isoDate.isBlank()) "Select date" else isoDate

    val datePickerState = rememberDatePickerState(
        initialSelectedDateMillis = initial.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
    )

    OutlinedButton(
        onClick = { showPicker = true },
        enabled = enabled,
        modifier = modifier,
        colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.BodyTextColor),
        border = androidx.compose.foundation.BorderStroke(1.dp, Color.White.copy(alpha = 0.15f)),
        shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
    ) {
        Text(displayText, color = if (enabled) Color.White else AppTheme.SubtleTextColor)
    }

    if (showPicker) {
        DatePickerDialog(
            onDismissRequest = { showPicker = false },
            confirmButton = {
                TextButton(
                    onClick = {
                        datePickerState.selectedDateMillis?.let { millis ->
                            val picked = Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDate()
                            onDateSelected(picked.format(DateTimeFormatter.ISO_LOCAL_DATE))
                            showPicker = false
                        }
                    },
                    enabled = datePickerState.selectedDateMillis != null
                ) { Text("OK", color = if (datePickerState.selectedDateMillis != null) AppTheme.AccentPurple else AppTheme.SubtleTextColor) }
            },
            dismissButton = {
                TextButton(onClick = { showPicker = false }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            colors = DatePickerDefaults.colors(containerColor = Color(0xFF1E0A2E))
        ) {
            DatePicker(
                state = datePickerState,
                colors = appDatePickerColors(),
                title = null,
                headline = null,
                showModeToggle = false
            )
        }
    }
}

title: AppTheme.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

/**
 * Shared theme constants for Home, Insights, and other screens with the purple sky background.
 * Centralizes all the duplicated color/shape definitions.
 */
object AppTheme {
    
    // Card shapes
    val BaseCardShape = RoundedCornerShape(18.dp)
    val HeroCardShape = RoundedCornerShape(24.dp)
    
    // Card colors
    val BaseCardContainer = Color(0xFF2A0C3C).copy(alpha = 0.65f)
    val HeroCardContainer = Color(0xFF2A0C3C).copy(alpha = 0.78f)
    
    // Card border
    val BaseCardBorder = BorderStroke(1.dp, Color.White.copy(alpha = 0.08f))
    
    // Text colors
    val TitleColor = Color(0xFFDCCEFF)
    val BodyTextColor = Color.White.copy(alpha = 0.82f)
    val SubtleTextColor = Color.White.copy(alpha = 0.62f)
    
    // Accent colors
    val AccentPurple = Color(0xFFB97BFF)
    val AccentPink = Color(0xFFFF7BB0)
    
    // Track/progress colors
    val TrackColor = Color.White.copy(alpha = 0.12f)
    
    // Background fade
    val FadeColor = Color(0xFF2A003D)
    val FadeDistance = 220.dp
    
    // Logo reveal spacing (space at top of scrollable content to show background)
    val LogoRevealHeight = 220.dp
}

title: AuthViewModel.kt
text:
// FILE: app/src/main/java/com/migraineme/AuthViewModel.kt
package com.migraineme

import android.content.Context
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update

data class AuthState(
    val accessToken: String? = null,
    val userId: String? = null,
    val error: String? = null
)

class AuthViewModel : ViewModel() {
    private val _state = MutableStateFlow(AuthState())
    val state: StateFlow<AuthState> = _state

    fun setSession(accessToken: String?, userId: String?) {
        _state.update { it.copy(accessToken = accessToken, userId = userId, error = null) }
    }

    fun clearSession() {
        _state.update { AuthState() }
    }

    fun setError(message: String?) {
        _state.update { it.copy(error = message) }
    }

    /**
     * UI-safe token accessor.
     *
     * The core problem you hit is: workers refresh tokens via SessionStore.getValidAccessToken(),
     * but the UI continues using authVm.state.accessToken which may have expired.
     *
     * This method:
     *  - fetches a valid token (refreshing if needed),
     *  - ensures userId is persisted + present,
     *  - updates AuthViewModel state if token/userId changed.
     *
     * Use this for any UI fetch path (tables/cards/screens) that currently relies on authState.accessToken.
     */
    suspend fun getValidAccessToken(context: Context): String? {
        val appCtx = context.applicationContext

        val valid = SessionStore.getValidAccessToken(appCtx)
        if (valid.isNullOrBlank()) {
            // If we cannot refresh, reflect that to UI by clearing session.
            // (LogoutScreen already clears SessionStore; this mirrors that state.)
            _state.update { it.copy(accessToken = null, userId = null) }
            return null
        }

        // Ensure user id is present and stable.
        var uid = SessionStore.readUserId(appCtx)
        if (uid.isNullOrBlank()) {
            uid = JwtUtils.extractUserIdFromAccessToken(valid)
            if (!uid.isNullOrBlank()) {
                SessionStore.saveUserId(appCtx, uid)
            }
        }

        // If SessionStore refreshed/rotated the access token, push it into UI state.
        _state.update { st ->
            val tokenChanged = st.accessToken != valid
            val userChanged = (!uid.isNullOrBlank() && st.userId != uid)
            if (tokenChanged || userChanged) {
                st.copy(accessToken = valid, userId = uid, error = null)
            } else {
                st
            }
        }

        return valid
    }

    /**
     * Convenience: update state from persisted SessionStore without forcing an immediate refresh.
     * (Still uses getValidAccessToken under the hood so it stays correct if token is expired.)
     */
    suspend fun syncFromSessionStore(context: Context) {
        getValidAccessToken(context)
    }

    fun signOut() {
        // UI-only signout state. Callers already clear SessionStore explicitly (see LogoutScreen).
        clearSession()
    }
}

title: AutoTriggersTab.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@Composable
fun AutoTriggersTab() {
    val context = LocalContext.current.applicationContext
    val scrollState = rememberScrollState()
    val scope = rememberCoroutineScope()
    val edge = remember { EdgeFunctionsService() }

    val triggerSettingsMap = remember {
        mutableStateOf<Map<String, EdgeFunctionsService.TriggerSettingResponse>>(emptyMap())
    }

    LaunchedEffect(Unit) {
        withContext(Dispatchers.IO) {
            runCatching { edge.getTriggerSettings(context) }
                .onSuccess { list ->
                    triggerSettingsMap.value = list.associateBy { it.triggerType }
                }
                .onFailure { e ->
                    android.util.Log.e(
                        "TriggerSettings",
                        "Failed to load trigger settings: ${e.message}",
                        e
                    )
                }
        }
    }

    val sections = remember {
        listOf(
            TriggerSection(
                title = "Recovery",
                description = "Get notified when your recovery score indicates potential issues.",
                rows = listOf(
                    TriggerRow(
                        triggerType = "recovery_low",
                        label = "Low recovery",
                        description = "Recovery below 33%"
                    ),
                    TriggerRow(
                        triggerType = "recovery_unusually_low",
                        label = "Unusually low recovery",
                        description = "Recovery 2 standard deviations below your average"
                    )
                )
            )
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(16.dp)
    ) {
        ElevatedCard(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.elevatedCardColors()
        ) {
            Column(modifier = Modifier.padding(14.dp)) {
                Text(
                    "Automatic Triggers",
                    style = MaterialTheme.typography.titleMedium
                )
                Spacer(Modifier.height(6.dp))
                Text(
                    "Configure which health patterns should automatically create triggers. " +
                            "These triggers are checked daily at 9 AM your local time.",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }

        Spacer(Modifier.height(14.dp))

        for (section in sections) {
            ElevatedCard(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.elevatedCardColors()
            ) {
                Column(modifier = Modifier.padding(14.dp)) {
                    Text(section.title, style = MaterialTheme.typography.titleMedium)
                    if (section.description.isNotEmpty()) {
                        Spacer(Modifier.height(4.dp))
                        Text(
                            section.description,
                            style = MaterialTheme.typography.bodySmall,
                            modifier = Modifier.alpha(0.7f)
                        )
                    }
                    Spacer(Modifier.height(10.dp))

                    for ((idx, row) in section.rows.withIndex()) {
                        TriggerRowUi(
                            row = row,
                            triggerSettingsMap = triggerSettingsMap.value,
                            onToggle = { triggerType, enabled ->
                                scope.launch(Dispatchers.IO) {
                                    val ok = edge.upsertTriggerSetting(
                                        context = context,
                                        triggerType = triggerType,
                                        enabled = enabled
                                    )
                                    if (ok) {
                                        runCatching { edge.getTriggerSettings(context) }
                                            .onSuccess { list ->
                                                withContext(Dispatchers.Main) {
                                                    triggerSettingsMap.value =
                                                        list.associateBy { it.triggerType }
                                                }
                                            }
                                    }
                                }
                            }
                        )

                        if (idx != section.rows.lastIndex) {
                            Spacer(Modifier.height(10.dp))
                            Divider()
                        }
                    }
                }
            }

            Spacer(Modifier.height(14.dp))
        }
    }
}

@Composable
private fun TriggerRowUi(
    row: TriggerRow,
    triggerSettingsMap: Map<String, EdgeFunctionsService.TriggerSettingResponse>,
    onToggle: (String, Boolean) -> Unit
) {
    val setting = triggerSettingsMap[row.triggerType]
    val enabled = setting?.enabled ?: true

    Row(
        modifier = Modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(
            modifier = Modifier
                .weight(1f)
                .padding(end = 10.dp)
        ) {
            Text(row.label, style = MaterialTheme.typography.bodyMedium)
            if (row.description.isNotEmpty()) {
                Spacer(Modifier.height(2.dp))
                Text(
                    row.description,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.alpha(0.7f)
                )
            }
        }

        Spacer(Modifier.width(10.dp))

        Switch(
            checked = enabled,
            onCheckedChange = { newValue ->
                onToggle(row.triggerType, newValue)
            }
        )
    }
}

title: BackgroundLocationPermissionDialog.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.Settings
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext
import androidx.core.content.ContextCompat

/**
 * Helper object for background location permission handling.
 * 
 * On Android 10+ (API 29+), background location requires:
 * 1. First grant ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION
 * 2. Then separately grant ACCESS_BACKGROUND_LOCATION
 * 
 * The background permission CANNOT be requested via the normal permission dialog.
 * User must go to Settings and select "Allow all the time".
 */
object BackgroundLocationPermissionHelper {
    
    /**
     * Check if foreground location permission is granted
     */
    fun hasForegroundLocationPermission(context: Context): Boolean {
        val fine = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
        val coarse = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_COARSE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
        return fine || coarse
    }
    
    /**
     * Check if background location permission is granted
     */
    fun hasBackgroundLocationPermission(context: Context): Boolean {
        // Background location permission only exists on Android 10+
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_BACKGROUND_LOCATION
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            // On Android 9 and below, foreground permission is sufficient
            hasForegroundLocationPermission(context)
        }
    }
    
    /**
     * Check if we have both foreground and background location permissions
     */
    fun hasFullLocationPermission(context: Context): Boolean {
        return hasForegroundLocationPermission(context) && hasBackgroundLocationPermission(context)
    }
    
    /**
     * Open the app's settings page where user can change location permission to "Allow all the time"
     */
    fun openAppSettings(context: Context) {
        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = Uri.fromParts("package", context.packageName, null)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        context.startActivity(intent)
    }
    
    /**
     * Check if we need to show the background location dialog
     * (foreground granted but background not granted)
     */
    fun needsBackgroundPermissionPrompt(context: Context): Boolean {
        return hasForegroundLocationPermission(context) && !hasBackgroundLocationPermission(context)
    }
}

/**
 * Dialog explaining why background location is needed and directing user to Settings
 */
@Composable
fun BackgroundLocationPermissionDialog(
    onDismiss: () -> Unit,
    onOpenSettings: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Background Location Required") },
        text = {
            Text(
                "To track your location for weather data while the app is closed, " +
                "please select \"Allow all the time\" in Settings.\n\n" +
                "This allows the app to update your location hourly for accurate weather-based migraine insights."
            )
        },
        confirmButton = {
            TextButton(onClick = onOpenSettings) {
                Text("Open Settings")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Not Now")
            }
        }
    )
}

title: BatteryOptimizationDialog.kt
text:
package com.migraineme

import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable

/**
 * Dialog to explain battery optimization and request exemption.
 * 
 * Shows when user enables ambient noise and app is battery optimized.
 */
@Composable
fun BatteryOptimizationDialog(
    onDismiss: () -> Unit,
    onOpenSettings: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Battery Optimization") },
        text = {
            Text(
                "To ensure ambient noise sampling works reliably (even after phone restarts), " +
                "MigraineMe needs to be exempt from battery optimization.\n\n" +
                "This allows the app to run background tasks without being killed by Android.\n\n" +
                "You'll be taken to Settings where you can grant this permission."
            )
        },
        confirmButton = {
            TextButton(onClick = onOpenSettings) {
                Text("Open Settings")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Not Now")
            }
        }
    )
}

title: BatteryOptimizationHelper.kt
text:
package com.migraineme

import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.PowerManager
import android.provider.Settings
import android.util.Log

/**
 * Helper for managing battery optimization exemption.
 *
 * Battery optimization can kill background workers, causing ambient noise
 * sampling to stop. This helper requests exemption to keep workers running.
 */
object BatteryOptimizationHelper {

    private const val TAG = "BatteryOptimization"

    /**
     * Check if app is exempt from battery optimization.
     */
    fun isIgnoringBatteryOptimizations(context: Context): Boolean {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            return true // Not applicable on older versions
        }

        return try {
            val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
            val packageName = context.packageName
            powerManager.isIgnoringBatteryOptimizations(packageName)
        } catch (e: Exception) {
            Log.e(TAG, "Error checking battery optimization: ${e.message}", e)
            false
        }
    }

    /**
     * Open settings to request battery optimization exemption.
     * User must manually grant this - we can't do it programmatically.
     */
    fun requestBatteryOptimizationExemption(context: Context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            return // Not applicable
        }

        try {
            if (!isIgnoringBatteryOptimizations(context)) {
                Log.d(TAG, "Requesting battery optimization exemption")

                val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
                    data = Uri.parse("package:${context.packageName}")
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                }

                context.startActivity(intent)
            } else {
                Log.d(TAG, "Already exempt from battery optimization")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error requesting battery optimization exemption: ${e.message}", e)

            // Fallback: Open battery settings page
            try {
                val intent = Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS).apply {
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                }
                context.startActivity(intent)
            } catch (e2: Exception) {
                Log.e(TAG, "Error opening battery settings: ${e2.message}", e2)
            }
        }
    }

    /**
     * Check if we should show battery optimization dialog.
     * Returns true ONLY if:
     * - App is battery optimized (not exempt)
     * - We have NEVER asked before
     *
     * Once granted (or user dismisses), we never ask again.
     */
    fun shouldRequestBatteryOptimization(context: Context): Boolean {
        if (isIgnoringBatteryOptimizations(context)) {
            return false // Already granted - never ask again
        }

        // Check if we've EVER asked before
        val prefs = context.getSharedPreferences("battery_opt", Context.MODE_PRIVATE)
        val hasAskedBefore = prefs.getBoolean("has_asked_before", false)

        return !hasAskedBefore // Only ask if we've never asked
    }

    /**
     * Mark that we asked for battery optimization exemption.
     * After this, we NEVER ask again (even if user didn't grant).
     */
    fun markAsAsked(context: Context) {
        val prefs = context.getSharedPreferences("battery_opt", Context.MODE_PRIVATE)
        prefs.edit()
            .putBoolean("has_asked_before", true)
            .apply()
    }
}

title: BootReceiver.kt
text:
package com.migraineme

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

/**
 * Restarts workers after device boot/reboot or app update.
 *
 * NOTE: Location scheduling is now handled by FCM push notifications from the server.
 */
class BootReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent?) {
        val action = intent?.action ?: return
        Log.d(TAG, "Received broadcast: $action")

        when (action) {
            Intent.ACTION_BOOT_COMPLETED,
            Intent.ACTION_LOCKED_BOOT_COMPLETED,
            Intent.ACTION_MY_PACKAGE_REPLACED -> {
                rescheduleWorkersIfNeeded(context)
            }
        }
    }

    private fun rescheduleWorkersIfNeeded(context: Context) {
        val appContext = context.applicationContext

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(appContext)
                val settingsMap = settings.associateBy { it.metric }

                rescheduleAmbientNoiseSampling(appContext, settingsMap)
                rescheduleScreenTimeSync(appContext, settingsMap)
                reschedulePhoneSleepSync(appContext, settingsMap)
                // Location is handled by FCM - just run once to catch up
                runLocationSyncIfEnabled(appContext, settingsMap)

                Log.d(TAG, "Worker rescheduling complete")
            } catch (e: Exception) {
                Log.e(TAG, "Error fetching settings for rescheduling: ${e.message}", e)
                rescheduleAllFallback(appContext)
            }
        }
    }

    private fun rescheduleAmbientNoiseSampling(
        context: Context,
        settings: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ) {
        try {
            val enabled = settings["ambient_noise_samples"]?.enabled ?: false
            val hasMic = MicrophonePermissionHelper.hasPermission(context)
            val hasBattery = isBatteryOptimizationExempt(context)

            if (enabled && hasMic && hasBattery) {
                Log.d(TAG, "Ambient noise sampling is enabled - rescheduling worker")
                AmbientNoiseSampleWorker.schedule(context)
                AmbientNoiseWatchdogWorker.schedule(context)
            } else {
                Log.d(TAG, "Ambient noise sampling is disabled - cancelling")
                AmbientNoiseSampleWorker.cancel(context)
                AmbientNoiseWatchdogWorker.cancel(context)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error rescheduling ambient noise sampling: ${e.message}", e)
        }
    }

    private fun rescheduleScreenTimeSync(
        context: Context,
        settings: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ) {
        try {
            val enabled = settings["screen_time_daily"]?.enabled ?: false
            val hasPerm = ScreenTimePermissionHelper.hasPermission(context)

            if (enabled && hasPerm) {
                Log.d(TAG, "Screen time sync is enabled - rescheduling worker")
            } else {
                Log.d(TAG, "Screen time sync is disabled - cancelling")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error rescheduling screen time sync: ${e.message}", e)
        }
    }

    /**
     * Run phone sleep sync once on boot if enabled.
     * Checks if sleep_duration_daily is enabled with phone as source.
     */
    private fun reschedulePhoneSleepSync(
        context: Context,
        settings: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ) {
        try {
            val sleepSetting = settings["sleep_duration_daily"]
            val enabled = sleepSetting?.enabled ?: false
            val hasPerm = ScreenTimeCollector.hasUsageStatsPermission(context)

            val preferred = sleepSetting?.preferredSource?.lowercase() ?: ""
            val allowed = sleepSetting?.allowedSources?.map { it.lowercase() } ?: emptyList()
            val isPhoneSource = preferred == "phone" || allowed.contains("phone")

            if (enabled && hasPerm && isPhoneSource) {
                Log.d(TAG, "Phone sleep sync is enabled - running once to catch up")
                PhoneSleepSyncWorker.runOnce(context)
            } else {
                Log.d(TAG, "Phone sleep sync is disabled")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error rescheduling phone sleep sync: ${e.message}", e)
        }
    }

    /**
     * Run location sync once on boot if enabled (FCM handles regular scheduling)
     */
    private fun runLocationSyncIfEnabled(
        context: Context,
        settings: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ) {
        try {
            val enabled = settings["user_location_daily"]?.enabled ?: false

            if (enabled) {
                Log.d(TAG, "Location sync is enabled - running once to catch up")
                LocationDailySyncWorker.runOnceNow(context)
            } else {
                Log.d(TAG, "Location sync is disabled")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error running location sync: ${e.message}", e)
        }
    }

    private fun rescheduleAllFallback(context: Context) {
        Log.d(TAG, "Fallback: Scheduling workers that have permissions")

        if (MicrophonePermissionHelper.hasPermission(context) && isBatteryOptimizationExempt(context)) {
            AmbientNoiseSampleWorker.schedule(context)
            AmbientNoiseWatchdogWorker.schedule(context)
        }

        if (ScreenTimePermissionHelper.hasPermission(context)) {
        }

        // Phone sleep - run once on fallback if usage stats permission exists
        if (ScreenTimeCollector.hasUsageStatsPermission(context)) {
            PhoneSleepSyncWorker.runOnce(context)
        }

        // Location - run once, FCM handles scheduling
        LocationDailySyncWorker.runOnceNow(context)
    }

    companion object {
        private const val TAG = "BootReceiver"
    }
}

title: CertaintyMultiSelect.kt
text:
package com.migraineme

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

data class CertaintyItem(
    val key: String,
    val label: String,
    val description: String? = null,
)

@Composable
fun CertaintyMultiSelect(
    items: List<CertaintyItem>,
    selections: Map<String, DeterministicMapper.Certainty>,
    onSelectionChanged: (Map<String, DeterministicMapper.Certainty>) -> Unit,
    accentColor: Color = AppTheme.AccentPink,
    showNoneOption: Boolean = true,
) {
    Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
        for (item in items) {
            val isSelected = item.key in selections
            val certainty = selections[item.key]

            val bgColor = if (isSelected) accentColor.copy(alpha = 0.15f) else Color.White.copy(alpha = 0.05f)
            val borderColor = if (isSelected) accentColor.copy(alpha = 0.5f) else Color.Transparent

            Column(
                Modifier
                    .fillMaxWidth()
                    .clip(RoundedCornerShape(12.dp))
                    .background(bgColor)
                    .border(1.dp, borderColor, RoundedCornerShape(12.dp))
                    .clickable {
                        val updated = selections.toMutableMap()
                        if (isSelected) {
                            updated.remove(item.key)
                        } else {
                            updated[item.key] = DeterministicMapper.Certainty.OFTEN
                        }
                        onSelectionChanged(updated)
                    }
                    .padding(12.dp)
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(10.dp),
                ) {
                    Box(
                        modifier = Modifier
                            .size(22.dp)
                            .clip(RoundedCornerShape(6.dp))
                            .background(if (isSelected) accentColor else Color.White.copy(alpha = 0.1f)),
                        contentAlignment = Alignment.Center,
                    ) {
                        if (isSelected) {
                            Icon(Icons.Default.Check, contentDescription = null, tint = Color.White, modifier = Modifier.size(14.dp))
                        }
                    }

                    Column(Modifier.weight(1f)) {
                        Text(
                            item.label,
                            color = Color.White,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal,
                        )
                        if (item.description != null) {
                            Text(item.description, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        }
                    }
                }

                AnimatedVisibility(
                    visible = isSelected,
                    enter = expandVertically() + fadeIn(),
                    exit = shrinkVertically() + fadeOut(),
                ) {
                    CertaintySelector(
                        selected = certainty ?: DeterministicMapper.Certainty.OFTEN,
                        onSelected = { newCert ->
                            val updated = selections.toMutableMap()
                            updated[item.key] = newCert
                            onSelectionChanged(updated)
                        },
                        accentColor = accentColor,
                        modifier = Modifier.padding(top = 8.dp, start = 32.dp),
                    )
                }
            }
        }

        if (showNoneOption) {
            val noneSelected = selections.isEmpty()
            Row(
                Modifier
                    .fillMaxWidth()
                    .clip(RoundedCornerShape(12.dp))
                    .background(if (noneSelected) Color.White.copy(alpha = 0.1f) else Color.White.copy(alpha = 0.03f))
                    .clickable { onSelectionChanged(emptyMap()) }
                    .padding(12.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(10.dp),
            ) {
                Box(
                    modifier = Modifier.size(22.dp).clip(RoundedCornerShape(6.dp))
                        .background(if (noneSelected) AppTheme.SubtleTextColor else Color.White.copy(alpha = 0.1f)),
                    contentAlignment = Alignment.Center,
                ) {
                    if (noneSelected) {
                        Icon(Icons.Default.Check, null, tint = Color.White, modifier = Modifier.size(14.dp))
                    }
                }
                Text("None of these", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium)
            }
        }
    }
}

@Composable
private fun CertaintySelector(
    selected: DeterministicMapper.Certainty,
    onSelected: (DeterministicMapper.Certainty) -> Unit,
    accentColor: Color = AppTheme.AccentPink,
    modifier: Modifier = Modifier,
) {
    val options = listOf(
        DeterministicMapper.Certainty.EVERY_TIME to "Every time",
        DeterministicMapper.Certainty.OFTEN to "Often",
        DeterministicMapper.Certainty.SOMETIMES to "Sometimes",
    )

    Row(modifier = modifier, horizontalArrangement = Arrangement.spacedBy(6.dp)) {
        for ((certainty, label) in options) {
            val isSelected = selected == certainty
            val chipColor = when {
                isSelected && certainty == DeterministicMapper.Certainty.EVERY_TIME -> Color(0xFFE53935)
                isSelected && certainty == DeterministicMapper.Certainty.OFTEN -> Color(0xFFFFA726)
                isSelected && certainty == DeterministicMapper.Certainty.SOMETIMES -> Color(0xFFFFEE58)
                else -> Color.White.copy(alpha = 0.08f)
            }
            val textColor = when {
                isSelected && certainty == DeterministicMapper.Certainty.SOMETIMES -> Color.Black
                isSelected -> Color.White
                else -> AppTheme.SubtleTextColor
            }

            Box(
                Modifier
                    .clip(RoundedCornerShape(8.dp))
                    .background(chipColor)
                    .clickable { onSelected(certainty) }
                    .padding(horizontal = 10.dp, vertical = 6.dp),
            ) {
                Text(
                    label,
                    color = textColor,
                    style = MaterialTheme.typography.labelSmall,
                    fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
                )
            }
        }
    }
}

@Composable
fun SingleCertaintySelect(
    selected: DeterministicMapper.Certainty?,
    onSelected: (DeterministicMapper.Certainty) -> Unit,
    modifier: Modifier = Modifier,
) {
    val options = listOf(
        DeterministicMapper.Certainty.EVERY_TIME to "Every time",
        DeterministicMapper.Certainty.OFTEN to "Often",
        DeterministicMapper.Certainty.SOMETIMES to "Sometimes",
        DeterministicMapper.Certainty.RARELY to "Rarely/not sure",
        DeterministicMapper.Certainty.NO to "No",
    )

    Row(
        modifier = modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(4.dp),
    ) {
        for ((certainty, label) in options) {
            val isSelected = selected == certainty
            val chipColor = when {
                !isSelected -> Color.White.copy(alpha = 0.08f)
                certainty == DeterministicMapper.Certainty.EVERY_TIME -> Color(0xFFE53935)
                certainty == DeterministicMapper.Certainty.OFTEN -> Color(0xFFFFA726)
                certainty == DeterministicMapper.Certainty.SOMETIMES -> Color(0xFFFFEE58)
                certainty == DeterministicMapper.Certainty.RARELY -> Color(0xFF78909C)
                else -> Color(0xFF455A64)
            }
            val textColor = when {
                !isSelected -> AppTheme.SubtleTextColor
                certainty == DeterministicMapper.Certainty.SOMETIMES -> Color.Black
                else -> Color.White
            }

            Box(
                Modifier
                    .weight(1f)
                    .clip(RoundedCornerShape(8.dp))
                    .background(chipColor)
                    .clickable { onSelected(certainty) }
                    .padding(horizontal = 4.dp, vertical = 8.dp),
                contentAlignment = Alignment.Center,
            ) {
                Text(
                    label,
                    color = textColor,
                    style = MaterialTheme.typography.labelSmall,
                    fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal,
                    textAlign = TextAlign.Center,
                    maxLines = 1,
                )
            }
        }
    }
}

title: ChangePasswordScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@Composable
fun ChangePasswordScreen(
    authVm: AuthViewModel,
    onDone: () -> Unit
) {
    val auth by authVm.state.collectAsState()
    val scope = rememberCoroutineScope()

    val loading = remember { mutableStateOf(false) }
    val canUse = remember { mutableStateOf(false) }

    val currentPassword = remember { mutableStateOf("") }
    val newPassword = remember { mutableStateOf("") }
    val confirmPassword = remember { mutableStateOf("") }

    val errorDialog = remember { mutableStateOf<String?>(null) }
    val successDialog = remember { mutableStateOf(false) }

    LaunchedEffect(auth.accessToken) {
        val token = auth.accessToken
        if (token.isNullOrBlank()) {
            canUse.value = false
            return@LaunchedEffect
        }

        loading.value = true
        try {
            val user = withContext(Dispatchers.IO) { SupabaseAuthService.getUser(token) }
            canUse.value = user.identities?.any { it.provider == "email" } == true
        } catch (_: Throwable) {
            canUse.value = false
        } finally {
            loading.value = false
        }
    }

    fun validate(): String? {
        if (currentPassword.value.isBlank()) return "Please enter your current password."
        if (newPassword.value.isBlank() || confirmPassword.value.isBlank())
            return "Please fill in all password fields."
        if (newPassword.value != confirmPassword.value)
            return "New passwords do not match."
        if (newPassword.value.length < 8)
            return "Password must be at least 8 characters."
        return null
    }

    fun submit() {
        val token = auth.accessToken
        val userId = auth.userId

        if (token.isNullOrBlank() || userId.isNullOrBlank()) {
            errorDialog.value = "Not signed in."
            return
        }

        if (!canUse.value) {
            errorDialog.value = "Password changes are only available for email accounts."
            return
        }

        val v = validate()
        if (v != null) {
            errorDialog.value = v
            return
        }

        loading.value = true
        scope.launch {
            try {
                // 1) fetch email (authoritative)
                val email = withContext(Dispatchers.IO) {
                    SupabaseAuthService.getUser(token).email
                } ?: throw IllegalStateException("Could not determine email.")

                // 2) re-authenticate with current password
                val session = withContext(Dispatchers.IO) {
                    SupabaseAuthService.signInWithEmail(email, currentPassword.value)
                }

                val newAccessToken = session.accessToken
                    ?: throw IllegalStateException("Re-authentication failed.")

                // 3) change password using fresh token
                withContext(Dispatchers.IO) {
                    SupabaseAuthService.changePassword(newAccessToken, newPassword.value)
                }

                successDialog.value = true
            } catch (t: Throwable) {
                errorDialog.value = t.message ?: "Failed to change password."
            } finally {
                loading.value = false
            }
        }
    }

    errorDialog.value?.let { msg ->
        AlertDialog(
            onDismissRequest = { errorDialog.value = null },
            title = { Text("Error") },
            text = { Text(msg) },
            confirmButton = {
                TextButton(onClick = { errorDialog.value = null }) { Text("OK") }
            }
        )
    }

    if (successDialog.value) {
        AlertDialog(
            onDismissRequest = { },
            title = { Text("Password updated") },
            text = { Text("Your password has been changed.") },
            confirmButton = {
                TextButton(onClick = {
                    successDialog.value = false
                    onDone()
                }) { Text("Done") }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Change password", style = MaterialTheme.typography.titleLarge)
        Divider()

        OutlinedTextField(
            value = currentPassword.value,
            onValueChange = { currentPassword.value = it },
            label = { Text("Current password") },
            singleLine = true,
            enabled = !loading.value && canUse.value,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = newPassword.value,
            onValueChange = { newPassword.value = it },
            label = { Text("New password") },
            singleLine = true,
            enabled = !loading.value && canUse.value,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = confirmPassword.value,
            onValueChange = { confirmPassword.value = it },
            label = { Text("Confirm new password") },
            singleLine = true,
            enabled = !loading.value && canUse.value,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(Modifier.height(4.dp))

        Button(
            onClick = { submit() },
            enabled = !loading.value && canUse.value,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(if (loading.value) "Updating..." else "Update password")
        }
    }
}

title: CityWeatherViewModel.kt
text:
// FILE: C:\Users\verwe\Projects\MigraineMe\app\src\main\java\com\migraineme\CityWeatherViewModel.kt
package com.migraineme

import android.app.Application
import android.location.Location
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONArray
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

data class CityRow(
    val id: Long,
    val label: String,
    val lat: Double,
    val lon: Double,
    val timezone: String?
)

data class DailyRow(
    val day: String,
    val tempMeanC: Double?,
    val pressureMeanHpa: Double?,
    val humidityMeanPct: Double?
)

data class CityWeatherState(
    val loading: Boolean = false,
    val error: String? = null,
    val nearestCity: CityRow? = null,
    val days: List<DailyRow> = emptyList()
)

class CityWeatherViewModel(app: Application) : AndroidViewModel(app) {

    private val _state = MutableStateFlow(CityWeatherState(loading = false))
    val state: StateFlow<CityWeatherState> = _state

    private val supabaseUrl: String = BuildConfig.SUPABASE_URL
    private val supabaseKey: String = BuildConfig.SUPABASE_ANON_KEY

    /** Existing entry (kept): pulls around today (T−2..T+6, fallback to recent). */
    fun loadNearestAndDaily(location: Location?) {
        if (_state.value.loading) return
        _state.value = _state.value.copy(loading = true, error = null)
        viewModelScope.launch {
            try {
                val (refLat, refLon) = extractRefLatLonOrFallback(location)
                Log.d("CityWX", "Ref location lat=$refLat lon=$refLon")

                val cities: List<CityRow> = withContext(Dispatchers.IO) {
                    val nearby = fetchCitiesNear(refLat, refLon, 2.0)
                    if (nearby.isNotEmpty()) {
                        if (nearby.size < 5) mergeUnique(nearby, fetchAllCities()) else nearby
                    } else {
                        fetchAllCities()
                    }
                }
                if (cities.isEmpty()) {
                    _state.value = _state.value.copy(loading = false, error = "No cities available")
                    return@launch
                }

                val nearest = pickNearest(refLat, refLon, cities)
                val days = withContext(Dispatchers.IO) { fetchDaily(nearest.id) }

                _state.value = CityWeatherState(loading = false, error = null, nearestCity = nearest, days = days)
            } catch (e: Exception) {
                _state.value = _state.value.copy(loading = false, error = e.message ?: "Error")
            }
        }
    }

    /**
     * NEW: Range-aware loader.
     * Start = max( earliest user_location_daily (source=device), today−30d )
     * End   = today
     * If the ranged query is empty, fall back to the original window logic.
     */
    fun loadNearestAndDailyByUserHistory(
        accessToken: String,
        location: Location?
    ) {
        if (_state.value.loading) return
        _state.value = _state.value.copy(loading = true, error = null)
        viewModelScope.launch {
            try {
                val (refLat, refLon) = extractRefLatLonOrFallback(location)

                val personal = SupabasePersonalService(getApplication())
                val earliestStr = withContext(Dispatchers.IO) {
                    runCatching { personal.earliestUserLocationDate(accessToken, source = "device") }.getOrNull()
                }

                val today = LocalDate.now()
                val start = runCatching { earliestStr?.let { LocalDate.parse(it) } }.getOrNull()
                    ?.let { if (it.isAfter(today.minusDays(30))) it else today.minusDays(30) }
                    ?: today.minusDays(30)
                val fromIso = start.format(DateTimeFormatter.ISO_DATE)
                val toIso = today.format(DateTimeFormatter.ISO_DATE)

                Log.d("CityWX", "History range from=$fromIso to=$toIso (earliest=$earliestStr)")

                val cities: List<CityRow> = withContext(Dispatchers.IO) {
                    val nearby = fetchCitiesNear(refLat, refLon, 2.0)
                    if (nearby.isNotEmpty()) {
                        if (nearby.size < 5) mergeUnique(nearby, fetchAllCities()) else nearby
                    } else {
                        fetchAllCities()
                    }
                }
                if (cities.isEmpty()) {
                    _state.value = _state.value.copy(loading = false, error = "No cities available")
                    return@launch
                }

                val nearest = pickNearest(refLat, refLon, cities)
                val days = withContext(Dispatchers.IO) {
                    val ranged = fetchDailyRange(nearest.id, fromIso, toIso)
                    if (ranged.isNotEmpty()) ranged else fetchDaily(nearest.id)
                }

                _state.value = CityWeatherState(loading = false, error = null, nearestCity = nearest, days = days)
            } catch (e: Exception) {
                _state.value = _state.value.copy(loading = false, error = e.message ?: "Error")
            }
        }
    }

    /* ---------------- Internals ---------------- */

    private fun extractRefLatLonOrFallback(location: Location?): Pair<Double, Double> {
        return if (location != null) location.latitude to location.longitude else 51.5074 to -0.1278 // London fallback
    }

    /** GET /rest/v1/city?select=id,label:name,lat,lon,timezone&limit=5000 */
    private fun fetchAllCities(): List<CityRow> {
        val qp = "select=id,label:name,lat,lon,timezone&limit=5000"
        val (code, body) = httpGet("$supabaseUrl/rest/v1/city?$qp")
        if (code !in 200..299) {
            val msg = parseErrorMessage(body) ?: "HTTP $code loading city"
            throw IllegalStateException(msg)
        }
        return parseCities(body)
    }

    /**
     * Bounding-box query around device location to ensure local coverage.
     * GET /rest/v1/city?select=id,label:name,lat,lon,timezone&lat=gte.{minLat}&lat=lte.{maxLat}&lon=gte.{minLon}&lon=lte.{maxLon}
     */
    private fun fetchCitiesNear(lat: Double, lon: Double, deg: Double): List<CityRow> {
        val minLat = lat - deg
        val maxLat = lat + deg
        val minLon = lon - deg
        val maxLon = lon + deg
        val qp = buildString {
            append("select=id,label:name,lat,lon,timezone")
            append("&lat=gte.$minLat&lat=lte.$maxLat")
            append("&lon=gte.$minLon&lon=lte.$maxLon")
            append("&limit=5000")
        }
        val (code, body) = httpGet("$supabaseUrl/rest/v1/city?$qp")
        if (code !in 200..299) {
            val msg = parseErrorMessage(body) ?: "HTTP $code loading nearby city"
            throw IllegalStateException(msg)
        }
        return parseCities(body)
    }

    private fun parseCities(body: String): List<CityRow> {
        val arr = JSONArray(body)
        val out = ArrayList<CityRow>(arr.length())
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            out.add(
                CityRow(
                    id = o.getLong("id"),
                    label = o.optString("label", ""),
                    lat = o.getDouble("lat"),
                    lon = o.getDouble("lon"),
                    timezone = if (o.isNull("timezone")) null else o.getString("timezone")
                )
            )
        }
        return out
    }

    private fun mergeUnique(a: List<CityRow>, b: List<CityRow>): List<CityRow> {
        val seen = HashSet<Long>(a.size + b.size)
        val out = ArrayList<CityRow>(a.size + b.size)
        for (c in a) if (seen.add(c.id)) out.add(c)
        for (c in b) if (seen.add(c.id)) out.add(c)
        return out
    }

    /** Original: T−2..T+6 window with fallback to most recent rows. */
    private fun fetchDaily(cityId: Long): List<DailyRow> {
        val today = LocalDate.now()
        val from = today.minusDays(2).format(DateTimeFormatter.ISO_DATE)
        val to = today.plusDays(6).format(DateTimeFormatter.ISO_DATE)
        val base = "select=day,temp_c_mean,pressure_hpa_mean,humidity_pct_mean&city_id=eq.$cityId"

        val qpWindow = "$base&order=day.asc&day=gte.$from&day=lte.$to"
        val primary = parseDaily(httpGet("$supabaseUrl/rest/v1/city_weather_daily?$qpWindow"))
        if (primary.isNotEmpty()) return primary

        val qpRecent = "$base&order=day.desc&limit=9"
        val recentDesc = parseDaily(httpGet("$supabaseUrl/rest/v1/city_weather_daily?$qpRecent"))
        if (recentDesc.isNotEmpty()) return recentDesc.asReversed()

        return emptyList()
    }


    private fun fetchDailyRange(cityId: Long, fromIso: String, toIso: String): List<DailyRow> {
        val base = "select=day,temp_c_mean,pressure_hpa_mean,humidity_pct_mean&city_id=eq.$cityId"
        val qp = "$base&order=day.asc&day=gte.$fromIso&day=lte.$toIso"
        return parseDaily(httpGet("$supabaseUrl/rest/v1/city_weather_daily?$qp"))
    }

    private fun parseDaily(resp: Pair<Int, String>): List<DailyRow> {
        val (code, body) = resp
        if (code !in 200..299) {
            val msg = parseErrorMessage(body) ?: "HTTP $code loading city_weather_daily"
            throw IllegalStateException(msg)
        }
        val arr = JSONArray(body)
        val out = ArrayList<DailyRow>(arr.length())
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            out.add(
                DailyRow(
                    day = o.getString("day"),
                    tempMeanC = o.optDoubleOrNull("temp_c_mean"),
                    pressureMeanHpa = o.optDoubleOrNull("pressure_hpa_mean"),
                    humidityMeanPct = o.optDoubleOrNull("humidity_pct_mean")
                )
            )
        }
        return out
    }

    private fun applyHeaders(conn: HttpURLConnection) {
        conn.setRequestProperty("apikey", supabaseKey)
        conn.setRequestProperty("Authorization", "Bearer $supabaseKey")
    }

    private fun httpGet(urlStr: String): Pair<Int, String> {
        val url = URL(urlStr)
        val conn = (url.openConnection() as HttpURLConnection).apply {
            requestMethod = "GET"
            applyHeaders(this)
        }
        val code = conn.responseCode
        val stream = if (code in 200..299) conn.inputStream else conn.errorStream
        val body = BufferedReader(InputStreamReader(stream)).use { it.readText() }
        conn.disconnect()
        return code to body
    }

    private fun parseErrorMessage(body: String?): String? {
        if (body.isNullOrBlank()) return null
        return try {
            val o = JSONObject(body)
            val msg = o.optString("message", "")
            if (msg.isNotBlank()) msg else {
                val err = o.optString("error", "")
                if (err.isNotBlank()) err else null
            }
        } catch (_: Exception) {
            body.take(140)
        }
    }

    private fun JSONObject.optDoubleOrNull(name: String): Double? {
        return if (isNull(name)) null else try { getDouble(name) } catch (_: Exception) { null }
    }

    /** Haversine distance in km */
    private fun haversineKm(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371.0
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c
    }

    private fun pickNearest(refLat: Double, refLon: Double, cities: List<CityRow>): CityRow {
        return cities
            .asSequence()
            .map { c -> c to haversineKm(refLat, refLon, c.lat, c.lon) }
            .sortedBy { it.second }
            .first().first
    }
}

title: CommunityScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun CommunityScreen() {
    Column(Modifier.padding(16.dp)) {
        Text("Community", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(8.dp))
        Text("Coming soon")
    }
}

title: CustomizeTriggersScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@Composable
fun CustomizeTriggersScreen() {
    val context = LocalContext.current.applicationContext
    val scrollState = rememberScrollState()
    val scope = rememberCoroutineScope()
    val edge = remember { EdgeFunctionsService() }

    var triggerSettingsMap by remember {
        mutableStateOf<Map<String, EdgeFunctionsService.TriggerSettingResponse>>(emptyMap())
    }
    var definitions by remember {
        mutableStateOf<List<EdgeFunctionsService.TriggerDefinitionResponse>>(emptyList())
    }
    var isLoading by remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        withContext(Dispatchers.IO) {
            runCatching {
                val defs = edge.getTriggerDefinitions(context)
                val settings = edge.getTriggerSettings(context)
                defs to settings
            }.onSuccess { (defs, settings) ->
                withContext(Dispatchers.Main) {
                    definitions = defs
                    triggerSettingsMap = settings.associateBy { it.triggerType }
                    isLoading = false
                }
            }.onFailure { e ->
                android.util.Log.e(
                    "TriggerSettings",
                    "Failed to load trigger data: ${e.message}",
                    e
                )
                withContext(Dispatchers.Main) { isLoading = false }
            }
        }
    }

    // Group definitions by category (e.g. "sleep", "physical", "environment")
    val sections = remember(definitions) {
        definitions.groupBy { it.category }
            .map { (category, defs) ->
                val title = category.replaceFirstChar { it.uppercase() }
                title to defs.sortedBy { it.triggerType }
            }
            .sortedBy { it.first }
    }

    fun refreshSettings() {
        scope.launch(Dispatchers.IO) {
            runCatching { edge.getTriggerSettings(context) }
                .onSuccess { list ->
                    withContext(Dispatchers.Main) {
                        triggerSettingsMap = list.associateBy { it.triggerType }
                    }
                }
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Info Card
            HeroCard {
                Text(
                    "Automatic Triggers",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(6.dp))
                Text(
                    "Configure which health patterns should automatically create triggers. " +
                            "These triggers are checked every hour as new data arrives.",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
            }

            if (isLoading) {
                HeroCard {
                    Row(
                        Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator()
                    }
                }
            } else if (sections.isEmpty()) {
                HeroCard {
                    Text(
                        "No trigger definitions found.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            } else {
                for ((title, defs) in sections) {
                    HeroCard {
                        Text(
                            title,
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        Spacer(Modifier.height(16.dp))

                        for ((idx, def) in defs.withIndex()) {
                            CustomizeTriggerRowUi(
                                def = def,
                                setting = triggerSettingsMap[def.triggerType],
                                onToggle = { enabled ->
                                    val currentThreshold = triggerSettingsMap[def.triggerType]?.threshold
                                    scope.launch(Dispatchers.IO) {
                                        val ok = edge.upsertTriggerSetting(
                                            context = context,
                                            triggerType = def.triggerType,
                                            enabled = enabled,
                                            threshold = currentThreshold
                                        )
                                        if (ok) refreshSettings()
                                    }
                                },
                                onThresholdChange = { newThreshold ->
                                    val currentEnabled = triggerSettingsMap[def.triggerType]?.enabled
                                        ?: def.enabledByDefault
                                    scope.launch(Dispatchers.IO) {
                                        val ok = edge.upsertTriggerSetting(
                                            context = context,
                                            triggerType = def.triggerType,
                                            enabled = currentEnabled,
                                            threshold = newThreshold
                                        )
                                        if (ok) refreshSettings()
                                    }
                                }
                            )

                            if (idx != defs.lastIndex) {
                                Spacer(Modifier.height(16.dp))
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun CustomizeTriggerRowUi(
    def: EdgeFunctionsService.TriggerDefinitionResponse,
    setting: EdgeFunctionsService.TriggerSettingResponse?,
    onToggle: (Boolean) -> Unit,
    onThresholdChange: (Double?) -> Unit
) {
    val enabled = setting?.enabled ?: def.enabledByDefault
    val hasThreshold = def.direction == "below" || def.direction == "above"
    val effectiveThreshold = setting?.threshold ?: def.defaultThreshold

    Column(Modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    def.label,
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
                Spacer(Modifier.height(2.dp))
                Text(
                    def.description,
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            Spacer(Modifier.width(10.dp))

            Switch(
                checked = enabled,
                onCheckedChange = { newValue -> onToggle(newValue) }
            )
        }

        // Threshold input for absolute triggers (not 2SD)
        if (hasThreshold && enabled) {
            Spacer(Modifier.height(8.dp))

            var textValue by remember(effectiveThreshold) {
                mutableStateOf(effectiveThreshold?.let { formatThresholdDisplay(it, def.unit) } ?: "")
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    "Threshold:",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.width(80.dp)
                )
                OutlinedTextField(
                    value = textValue,
                    onValueChange = { newText ->
                        textValue = newText
                        val parsed = newText.toDoubleOrNull()
                        if (parsed != null) {
                            onThresholdChange(parsed)
                        }
                    },
                    modifier = Modifier.width(100.dp),
                    singleLine = true,
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                    textStyle = MaterialTheme.typography.bodySmall
                )
                Spacer(Modifier.width(8.dp))
                Text(
                    def.unit ?: "",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

private fun formatThresholdDisplay(value: Double, unit: String?): String {
    return when (unit) {
        "hours" -> String.format("%.1f", value)
        "%" -> String.format("%.0f", value)
        "count" -> String.format("%.0f", value)
        "time" -> String.format("%.0f", value)
        else -> String.format("%.1f", value)
    }
}

title: DataSettingsComponents.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Info
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

@Composable
fun DataSection(
    title: String,
    content: @Composable ColumnScope.() -> Unit
) {
    ElevatedCard(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(14.dp)
        ) {
            Text(
                text = title,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.SemiBold
            )
            Spacer(Modifier.height(10.dp))
            content()
        }
    }
    Spacer(Modifier.height(14.dp))
}

@Composable
fun MetricToggle(
    label: String,
    metric: String,
    source: String?,
    settings: Map<String, EdgeFunctionsService.MetricSettingResponse>,
    viewModel: DataSettingsViewModel,
    onToggle: ((Boolean) -> Unit)? = null
) {
    val scope = rememberCoroutineScope()
    val key = if (source != null) "${metric}_${source}" else "${metric}_null"
    val enabled = settings[key]?.enabled ?: true

    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = label,
            modifier = Modifier.weight(1f)
        )
        Switch(
            checked = enabled,
            onCheckedChange = { newValue ->
                onToggle?.invoke(newValue)
                scope.launch {
                    viewModel.toggleMetric(metric, newValue, source)
                }
            }
        )
    }
}

@Composable
fun MenstruationSection(
    settings: MenstruationSettings?,
    onSetup: () -> Unit,
    onEdit: () -> Unit
) {
    if (settings == null || settings.lastMenstruationDate == null) {
        TextButton(onClick = onSetup) {
            Text("Set up menstruation tracking")
        }
    } else {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    "Menstruation",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    "Last: ${settings.lastMenstruationDate}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
                Text(
                    "Cycle: ${settings.avgCycleLength} days",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            TextButton(onClick = onEdit) {
                Text("Edit")
            }
        }
    }
}

title: DataSettingsDialogs.kt
text:
package com.migraineme

import android.content.Context
import android.content.Intent
import android.net.Uri
import android.provider.Settings
import androidx.compose.material3.*
import androidx.compose.runtime.Composable

/**
 * Dialog components for DataSettings screen.
 *
 * NOTE: ScreenTimePermissionDialog and BatteryOptimizationDialog already exist
 * elsewhere in the codebase, so we just use those directly.
 * 
 * This file contains ONLY dialogs that don't exist elsewhere.
 */

// ─────────────────────────────────────────────────────────────────────────────
// Background Location Dialog
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun BackgroundLocationDialog(
    onDismiss: () -> Unit,
    onOpenSettings: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Background Location Required") },
        text = {
            Text(
                "You'll be taken to the app permissions page where you'll see all permissions (Location, Health Connect, etc.).\n\n" +
                "To enable background location:\n" +
                "1. Tap \"Permissions\"\n" +
                "2. Tap \"Location\"\n" +
                "3. Select \"Allow all the time\"\n\n" +
                "This allows hourly location updates for accurate weather-based migraine insights."
            )
        },
        confirmButton = {
            TextButton(onClick = onOpenSettings) {
                Text("Open Settings")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}

// ─────────────────────────────────────────────────────────────────────────────
// Microphone Permission Dialog (if not already defined elsewhere)
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun MicrophonePermissionDialog(
    onDismiss: () -> Unit,
    onOpenSettings: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Microphone Permission Required") },
        text = {
            Text(
                "To record ambient noise levels, MigraineMe needs microphone access.\n\n" +
                "The app only records noise levels (decibels), not conversations or identifiable audio."
            )
        },
        confirmButton = {
            TextButton(onClick = onOpenSettings) {
                Text("Open Settings")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}

// ─────────────────────────────────────────────────────────────────────────────
// Stress Index Dependency Dialog
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun StressDependencyDialog(
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Missing Dependencies") },
        text = {
            Text(
                "Stress Index requires both HRV and Resting Heart Rate to be enabled.\n\n" +
                "Please enable these metrics first, then you can enable Stress Index."
            )
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("OK")
            }
        }
    )
}

// ─────────────────────────────────────────────────────────────────────────────
// Generic Error Dialog
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun DataSettingsErrorDialog(
    title: String,
    message: String,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(title) },
        text = { Text(message) },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("OK")
            }
        }
    )
}

// ─────────────────────────────────────────────────────────────────────────────
// Dialog Actions Helper
// ─────────────────────────────────────────────────────────────────────────────

object DataSettingsDialogActions {

    fun openAppSettings(context: Context) {
        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = Uri.fromParts("package", context.packageName, null)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        context.startActivity(intent)
    }

    fun openUsageAccessSettings(context: Context) {
        ScreenTimePermissionHelper.openUsageAccessSettings(context)
    }

    fun requestBatteryOptimizationExemption(context: Context) {
        BatteryOptimizationHelper.requestBatteryOptimizationExemption(context)
    }
}

title: DataSettingsModels.kt
text:
package com.migraineme

import android.content.Context
import android.os.PowerManager

// ─────────────────────────────────────────────────────────────────────────────
// Enums
// ─────────────────────────────────────────────────────────────────────────────

enum class CollectedByKind {
    PHONE,
    WEARABLE,
    MANUAL,
    REFERENCE,
    PHONE_OR_WEARABLE,
    COMPUTED
}

enum class WearableSource(val key: String, val label: String) {
    WHOOP("whoop", "WHOOP"),
    HEALTH_CONNECT("health_connect", "Health Connect")
}

enum class PhoneSource(val key: String, val label: String) {
    PHONE("phone", "Phone"),
    HEALTH_CONNECT("health_connect", "Health Connect")
}

// ─────────────────────────────────────────────────────────────────────────────
// Data Classes
// ─────────────────────────────────────────────────────────────────────────────

data class DataSection(
    val title: String,
    val rows: List<DataRow>
)

data class DataRow(
    val table: String,
    val collectedByKind: CollectedByKind,
    val collectedByLabel: String,
    val defaultWearable: WearableSource? = null
)

data class TriggerSection(
    val title: String,
    val description: String,
    val rows: List<TriggerRow>
)

data class TriggerRow(
    val triggerType: String,
    val label: String,
    val description: String
)

// ─────────────────────────────────────────────────────────────────────────────
// Helper Functions
// ─────────────────────────────────────────────────────────────────────────────

fun wearableRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.WEARABLE,
        collectedByLabel = label,
        defaultWearable = WearableSource.WHOOP
    )

fun phoneRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.PHONE,
        collectedByLabel = label
    )

fun manualRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.MANUAL,
        collectedByLabel = label
    )

fun referenceRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.REFERENCE,
        collectedByLabel = label
    )

/**
 * Row that can be collected by either phone (usage stats) or wearable.
 * Never greyed out — phone is always a valid fallback source.
 * When wearable is connected, user can choose wearable or phone.
 * When no wearable, defaults to phone source.
 */
fun phoneOrWearableRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.PHONE_OR_WEARABLE,
        collectedByLabel = label,
        defaultWearable = WearableSource.WHOOP
    )

/**
 * Row for computed/derived metrics (e.g. stress index from HRV + resting HR).
 * Shows "Computed" label instead of a source selector.
 * May have dependency requirements on other metrics.
 */
fun computedRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.COMPUTED,
        collectedByLabel = label
    )

fun defaultActiveFor(row: DataRow): Boolean {
    return when (row.collectedByKind) {
        CollectedByKind.REFERENCE -> false
        else -> true
    }
}

fun isBatteryOptimizationExempt(context: Context): Boolean {
    return try {
        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        pm.isIgnoringBatteryOptimizations(context.packageName)
    } catch (_: Throwable) {
        false
    }
}

fun hasAskedMicPermission(context: Context): Boolean {
    return context.getSharedPreferences("data_settings", Context.MODE_PRIVATE)
        .getBoolean("mic_permission_asked", false)
}

fun markAskedMicPermission(context: Context) {
    context.getSharedPreferences("data_settings", Context.MODE_PRIVATE)
        .edit()
        .putBoolean("mic_permission_asked", true)
        .apply()
}

fun hasAskedLocationPermission(context: Context): Boolean {
    return context.getSharedPreferences("data_settings", Context.MODE_PRIVATE)
        .getBoolean("location_permission_asked", false)
}

fun markAskedLocationPermission(context: Context) {
    context.getSharedPreferences("data_settings", Context.MODE_PRIVATE)
        .edit()
        .putBoolean("location_permission_asked", true)
        .apply()
}

class DataSettingsStore(private val context: Context) {
    private val prefs = context.getSharedPreferences("data_settings", Context.MODE_PRIVATE)

    fun getActive(table: String, wearable: WearableSource?, defaultValue: Boolean): Boolean {
        return prefs.getBoolean(activeKey(table, wearable), defaultValue)
    }

    fun setActive(table: String, wearable: WearableSource?, value: Boolean) {
        prefs.edit().putBoolean(activeKey(table, wearable), value).apply()
    }

    private fun activeKey(table: String, wearable: WearableSource?): String {
        return if (wearable == null) {
            "data_active_$table"
        } else {
            "data_active_${table}_${wearable.key}"
        }
    }
}

title: DataSettingsPermissionHelper.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.os.PowerManager
import androidx.core.content.ContextCompat
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.HeartRateVariabilityRmssdRecord
import androidx.health.connect.client.records.RestingHeartRateRecord
import androidx.health.connect.client.records.SleepSessionRecord
import androidx.health.connect.client.records.StepsRecord
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Centralized permission checking for DataSettings.
 *
 * SINGLE SOURCE OF TRUTH for permission checks.
 * All permission logic should go through this helper.
 */
object DataSettingsPermissionHelper {

    // ─────────────────────────────────────────────────────────────────────────
    // Location Permissions
    // ─────────────────────────────────────────────────────────────────────────

    fun hasLocationPermission(context: Context): Boolean {
        val fine = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        val coarse = ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_COARSE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        return fine || coarse
    }

    fun hasBackgroundLocationPermission(context: Context): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_BACKGROUND_LOCATION
            ) == PackageManager.PERMISSION_GRANTED
        } else {
            true // Not needed on Android 9 and below
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Microphone Permission
    // ─────────────────────────────────────────────────────────────────────────

    fun hasMicrophonePermission(context: Context): Boolean {
        return MicrophonePermissionHelper.hasPermission(context)
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Battery Optimization
    // ─────────────────────────────────────────────────────────────────────────

    fun isBatteryOptimizationExempt(context: Context): Boolean {
        return try {
            val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager
            pm.isIgnoringBatteryOptimizations(context.packageName)
        } catch (_: Throwable) {
            false
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Screen Time Permission
    // ─────────────────────────────────────────────────────────────────────────

    fun hasScreenTimePermission(context: Context): Boolean {
        return ScreenTimePermissionHelper.hasPermission(context)
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Health Connect Permissions
    // ─────────────────────────────────────────────────────────────────────────

    suspend fun hasHealthConnectWearablesPermission(context: Context): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                if (HealthConnectClient.getSdkStatus(context) != HealthConnectClient.SDK_AVAILABLE) {
                    return@withContext false
                }
                val hc = HealthConnectClient.getOrCreate(context)
                val granted = hc.permissionController.getGrantedPermissions()
                val wearablePermissions = setOf(
                    HealthPermission.getReadPermission(SleepSessionRecord::class),
                    HealthPermission.getReadPermission(HeartRateVariabilityRmssdRecord::class),
                    HealthPermission.getReadPermission(RestingHeartRateRecord::class),
                    HealthPermission.getReadPermission(StepsRecord::class)
                )
                wearablePermissions.any { it in granted }
            } catch (e: Exception) {
                false
            }
        }
    }

    suspend fun hasHealthConnectNutritionPermission(context: Context): Boolean {
        return HealthConnectPermissionHelper.hasNutritionPermission(context)
    }

    suspend fun hasHealthConnectMenstruationPermission(context: Context): Boolean {
        return HealthConnectPermissionHelper.hasMenstruationPermission(context)
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Connected Wearables Helper
    // ─────────────────────────────────────────────────────────────────────────

    suspend fun getConnectedWearables(context: Context): List<WearableSource> {
        return buildList {
            // Check WHOOP
            if (WhoopTokenStore(context).load() != null) {
                add(WearableSource.WHOOP)
            }
            // Check Health Connect
            if (hasHealthConnectWearablesPermission(context)) {
                add(WearableSource.HEALTH_CONNECT)
            }
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Metric-specific permission checks
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Check if all required permissions are granted for a specific metric.
     * Returns true if the metric can be enabled.
     */
    fun canEnableMetric(context: Context, metric: String): Boolean {
        return when (metric) {
            "screen_time_daily" -> hasScreenTimePermission(context)
            "user_location_daily" -> hasLocationPermission(context)
            "ambient_noise_samples" -> hasMicrophonePermission(context) && isBatteryOptimizationExempt(context)
            else -> true
        }
    }

    /**
     * Get list of missing permissions for a metric.
     * Returns empty list if all permissions are granted.
     */
    fun getMissingPermissions(context: Context, metric: String): List<String> {
        return buildList {
            when (metric) {
                "screen_time_daily" -> {
                    if (!hasScreenTimePermission(context)) add("Usage access")
                }
                "user_location_daily" -> {
                    if (!hasLocationPermission(context)) add("Location")
                    if (!hasBackgroundLocationPermission(context)) add("Background location")
                }
                "ambient_noise_samples" -> {
                    if (!hasMicrophonePermission(context)) add("Microphone")
                    if (!isBatteryOptimizationExempt(context)) add("Battery optimization exemption")
                }
            }
        }
    }
}

title: DataSettingsRow.kt
text:
package com.migraineme

import android.Manifest
import android.content.pm.PackageManager
import android.os.Build
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat

/**
 * Individual data settings row component.
 *
 * Handles rendering of a single metric row including:
 * - Label and description
 * - Source selector (wearable, phone, hybrid, or computed)
 * - Toggle switch
 * - Permission sub-rows (for ambient noise, location, screen time, phone sleep)
 */
@Composable
fun DataSettingsRow(
    row: DataRow,
    metricSettings: Map<String, EdgeFunctionsService.MetricSettingResponse>,
    connectedWearables: List<WearableSource>,
    menstruationSettings: MenstruationSettings?,
    nutritionPermissionGranted: Boolean,
    menstruationPermissionGranted: Boolean,
    greyOut: Boolean,
    weatherMetrics: Set<String>,
    onToggle: (metric: String, enabled: Boolean, source: String?) -> Unit,
    onSourceChange: (metric: String, newSource: String, currentEnabled: Boolean) -> Unit,
    onRequestMicPermission: () -> Unit,
    onRequestBatteryExemption: () -> Unit,
    onRequestBackgroundLocation: () -> Unit,
    onRequestScreenTimePermission: () -> Unit,
    onRequestLocationPermission: () -> Unit
) {
    val context = LocalContext.current
    val appContext = context.applicationContext

    // Row type flags
    val isWearableRow = row.collectedByKind == CollectedByKind.WEARABLE
    val isPhoneOrWearableRow = row.collectedByKind == CollectedByKind.PHONE_OR_WEARABLE
    val isComputedRow = row.collectedByKind == CollectedByKind.COMPUTED
    val isScreenTimeRow = row.table == "screen_time_daily" && row.collectedByKind == CollectedByKind.PHONE
    val isLateNightScreenTimeRow = row.table == "screen_time_late_night" && row.collectedByKind == CollectedByKind.PHONE
    val isLocationRow = row.table == "user_location_daily" && row.collectedByKind == CollectedByKind.PHONE
    val isAmbientNoiseRow = row.table == "ambient_noise_samples" && row.collectedByKind == CollectedByKind.PHONE
    val isNutritionRow = row.table == "nutrition" && row.collectedByKind == CollectedByKind.PHONE
    val isMenstruationRow = row.table == "menstruation" && row.collectedByKind == CollectedByKind.PHONE
    val isStressRow = row.table == "stress_index_daily"

    // Permission states
    val screenTimePermissionGranted = remember(metricSettings) {
        if (isScreenTimeRow || isLateNightScreenTimeRow) DataSettingsPermissionHelper.hasScreenTimePermission(appContext) else true
    }
    val usageStatsPermissionGranted = remember(metricSettings) {
        if (isPhoneOrWearableRow) DataSettingsPermissionHelper.hasScreenTimePermission(appContext) else true
    }
    val locationPermissionGranted = remember(metricSettings) {
        DataSettingsPermissionHelper.hasLocationPermission(appContext)
    }
    val backgroundLocationGranted = remember(metricSettings) {
        DataSettingsPermissionHelper.hasBackgroundLocationPermission(appContext)
    }
    val micPermissionGranted = remember(metricSettings) {
        if (isAmbientNoiseRow) DataSettingsPermissionHelper.hasMicrophonePermission(appContext) else true
    }
    val batteryOptimizationExempt = remember(metricSettings) {
        if (isAmbientNoiseRow) DataSettingsPermissionHelper.isBatteryOptimizationExempt(appContext) else true
    }

    // Source selection state for standard wearable rows
    var selectedWearable by remember(row.table, metricSettings) {
        val supabaseSource = metricSettings[row.table]?.preferredSource
        val fromSupabase = supabaseSource?.let { key ->
            WearableSource.values().firstOrNull { it.key == key }
        }
        mutableStateOf(fromSupabase ?: row.defaultWearable ?: WearableSource.WHOOP)
    }

    // Source selection state for PHONE_OR_WEARABLE rows
    // Sources: "phone", "whoop", "health_connect"
    var selectedHybridSource by remember(row.table, metricSettings, connectedWearables) {
        val supabaseSource = metricSettings[row.table]?.preferredSource ?: "phone"
        mutableStateOf(supabaseSource)
    }

    val hybridSourceLabel = remember(selectedHybridSource) {
        when (selectedHybridSource) {
            "phone" -> "Phone"
            "whoop" -> "WHOOP"
            "health_connect" -> "Health Connect"
            else -> "Phone"
        }
    }

    val hybridSourceOptions = remember(connectedWearables, row.table) {
        buildList {
            add("phone" to "Phone")
            for (w in connectedWearables) {
                if (MetricSourceSupport.supportsMetric(w, row.table)) {
                    add(w.key to w.label)
                }
            }
        }
    }

    // Is the current hybrid source using phone?
    val isHybridPhoneSource = isPhoneOrWearableRow && selectedHybridSource == "phone"

    var selectedMenstruationSource by remember(row.table, metricSettings, menstruationPermissionGranted) {
        val supabaseSource = metricSettings["menstruation"]?.preferredSource
        val fromSupabase = supabaseSource?.let { key ->
            PhoneSource.values().firstOrNull { it.key == key }
        }
        val initial = when {
            fromSupabase == PhoneSource.HEALTH_CONNECT && !menstruationPermissionGranted -> PhoneSource.PHONE
            fromSupabase != null -> fromSupabase
            else -> PhoneSource.PHONE
        }
        mutableStateOf(initial)
    }

    var selectedNutritionSource by remember(row.table, metricSettings, nutritionPermissionGranted) {
        val supabaseSource = metricSettings["nutrition"]?.preferredSource
        val fromSupabase = supabaseSource?.let { key ->
            PhoneSource.values().firstOrNull { it.key == key }
        }
        val initial = when {
            fromSupabase == PhoneSource.HEALTH_CONNECT && !nutritionPermissionGranted -> PhoneSource.PHONE
            fromSupabase != null -> fromSupabase
            else -> PhoneSource.PHONE
        }
        mutableStateOf(initial)
    }

    // Enabled state from Supabase
    val enabledBySupabase = metricSettings[row.table]?.enabled ?: getDefaultEnabled(row)

    // Stress dependency check
    val depsOkForStress = if (isStressRow) {
        DataSettingsToggleHandler.areStressDependenciesMet(metricSettings)
    } else true

    // Effective grey out state
    // PHONE_OR_WEARABLE rows are NEVER greyed out (phone is always a valid fallback)
    // COMPUTED rows (stress) depend on their prerequisites
    val effectiveGreyOut = when {
        isPhoneOrWearableRow -> false
        isStressRow -> !depsOkForStress
        else -> greyOut
    }
    val alpha = if (effectiveGreyOut) 0.55f else 1.0f

    // Can toggle ambient noise
    val canToggleAmbient = !isAmbientNoiseRow ||
            (micPermissionGranted && batteryOptimizationExempt) ||
            !enabledBySupabase

    // Layout dimensions
    val providerColWidth = 120.dp
    val toggleColWidth = 56.dp

    // Provider options
    val menstruationProviderOptions = remember(menstruationPermissionGranted) {
        buildList {
            add(PhoneSource.PHONE)
            if (menstruationPermissionGranted) add(PhoneSource.HEALTH_CONNECT)
        }
    }

    val nutritionProviderOptions = remember(nutritionPermissionGranted) {
        buildList {
            add(PhoneSource.PHONE)
            if (nutritionPermissionGranted) add(PhoneSource.HEALTH_CONNECT)
        }
    }

    // Filter wearables to only sources that support this metric
    val allowedWearables = remember(connectedWearables, row.table) {
        connectedWearables.filter { source ->
            MetricSourceSupport.supportsMetric(source, row.table)
        }
    }

    Column {
        // Main row
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .alpha(alpha),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Label column
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(end = 10.dp)
            ) {
                Text(
                    row.collectedByLabel,
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )

                // Additional info based on row type
                if (isAmbientNoiseRow) {
                    Text(
                        "Phone",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }

                if (isMenstruationRow && enabledBySupabase && menstruationSettings?.lastMenstruationDate != null) {
                    Text(
                        "Last: ${menstruationSettings.lastMenstruationDate} • Avg: ${menstruationSettings.avgCycleLength} days",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }

                // Setup hint for menstruation
                if (isMenstruationRow && enabledBySupabase &&
                    (menstruationSettings == null || menstruationSettings.lastMenstruationDate == null)
                ) {
                    Text(
                        "Please go to Monitor to complete setup.",
                        style = MaterialTheme.typography.bodySmall,
                        color = AppTheme.AccentPurple
                    )
                }

                // Health Connect limitation note
                if (isMenstruationRow) {
                    Text(
                        "Note: Many apps no longer share menstruation data with Health Connect.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }

                // Stress dependency hint
                if (isStressRow && !depsOkForStress) {
                    Text(
                        "Enable HRV and Resting HR to use Stress.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }

                // Weather dependency hint
                if (row.table in weatherMetrics && effectiveGreyOut) {
                    Text(
                        "Enable Location to use weather data.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }

                // Phone sleep hint when phone source and no permission
                if (isHybridPhoneSource && !usageStatsPermissionGranted) {
                    Text(
                        "Usage access permission needed for phone sleep.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }

            // Source selector column
            Column(
                modifier = Modifier
                    .width(providerColWidth)
                    .padding(end = 10.dp),
                horizontalAlignment = Alignment.Start
            ) {
                when {
                    // COMPUTED rows — show "Computed" label, no selector
                    isComputedRow -> {
                        Text(
                            "Computed",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }

                    // PHONE_OR_WEARABLE rows — hybrid source selector
                    isPhoneOrWearableRow -> {
                        HybridSourceSelector(
                            options = hybridSourceOptions,
                            selectedKey = selectedHybridSource,
                            enabled = true,
                            onSelected = { newKey ->
                                if (newKey != selectedHybridSource) {
                                    selectedHybridSource = newKey
                                    onSourceChange(row.table, newKey, enabledBySupabase)
                                }
                            }
                        )
                    }

                    isWearableRow && allowedWearables.isNotEmpty() -> {
                        val currentSelection = if (allowedWearables.contains(selectedWearable)) {
                            selectedWearable
                        } else {
                            allowedWearables.first()
                        }

                        WearableSourceSelector(
                            options = allowedWearables,
                            selected = currentSelection,
                            enabled = !effectiveGreyOut,
                            onSelected = { newSel ->
                                if (newSel != selectedWearable) {
                                    selectedWearable = newSel
                                    onSourceChange(row.table, newSel.key, enabledBySupabase)
                                }
                            }
                        )
                    }

                    isWearableRow && allowedWearables.isEmpty() -> {
                        Text(
                            "Not available",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }

                    isMenstruationRow -> {
                        PhoneSourceSelector(
                            options = menstruationProviderOptions,
                            selected = selectedMenstruationSource,
                            enabled = !effectiveGreyOut,
                            onSelected = { newSel ->
                                if (newSel != selectedMenstruationSource) {
                                    selectedMenstruationSource = newSel
                                    onSourceChange("menstruation", newSel.key, enabledBySupabase)
                                }
                            }
                        )
                    }

                    isNutritionRow -> {
                        PhoneSourceSelector(
                            options = nutritionProviderOptions,
                            selected = selectedNutritionSource,
                            enabled = !effectiveGreyOut,
                            onSelected = { newSel ->
                                if (newSel != selectedNutritionSource) {
                                    selectedNutritionSource = newSel
                                    onSourceChange("nutrition", newSel.key, enabledBySupabase)
                                }
                            }
                        )
                    }

                    isAmbientNoiseRow -> {
                        // No selector for ambient noise
                    }

                    else -> {
                        val providerLabel = when (row.collectedByKind) {
                            CollectedByKind.PHONE -> "Phone"
                            CollectedByKind.MANUAL -> "Manual"
                            else -> ""
                        }
                        if (providerLabel.isNotEmpty()) {
                            Text(
                                providerLabel,
                                color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.bodySmall
                            )
                        }
                    }
                }
            }

            // Toggle column
            Column(
                modifier = Modifier.width(toggleColWidth),
                horizontalAlignment = Alignment.End
            ) {
                Switch(
                    checked = enabledBySupabase,
                    enabled = !effectiveGreyOut && canToggleAmbient,
                    onCheckedChange = { newValue ->
                        if (effectiveGreyOut) return@Switch
                        if (isStressRow && !depsOkForStress) return@Switch

                        // Permission checks that block toggle
                        if ((isScreenTimeRow || isLateNightScreenTimeRow) && newValue && !screenTimePermissionGranted) {
                            onRequestScreenTimePermission()
                            return@Switch
                        }

                        // Phone sleep with phone source needs usage stats permission
                        if (isPhoneOrWearableRow && newValue && selectedHybridSource == "phone" && !usageStatsPermissionGranted) {
                            onRequestScreenTimePermission()
                            return@Switch
                        }

                        if (isLocationRow && newValue && !locationPermissionGranted) {
                            onRequestLocationPermission()
                            return@Switch
                        }

                        if (isAmbientNoiseRow && newValue) {
                            if (!micPermissionGranted) {
                                onRequestMicPermission()
                                return@Switch
                            }
                            if (!batteryOptimizationExempt) {
                                onRequestBatteryExemption()
                                return@Switch
                            }
                        }

                        if (isNutritionRow && newValue &&
                            selectedNutritionSource == PhoneSource.HEALTH_CONNECT &&
                            !nutritionPermissionGranted
                        ) {
                            return@Switch
                        }

                        // Determine preferred source
                        val preferredSource = when {
                            isPhoneOrWearableRow -> selectedHybridSource
                            isWearableRow -> selectedWearable.key
                            isMenstruationRow -> selectedMenstruationSource.key
                            isNutritionRow -> selectedNutritionSource.key
                            else -> null
                        }

                        onToggle(row.table, newValue, preferredSource)
                    }
                )
            }
        }

        // Permission sub-rows
        if (isAmbientNoiseRow) {
            AmbientNoisePermissionRows(
                alpha = alpha,
                micPermissionGranted = micPermissionGranted,
                batteryOptimizationExempt = batteryOptimizationExempt,
                providerColWidth = providerColWidth,
                toggleColWidth = toggleColWidth,
                onRequestMicPermission = onRequestMicPermission,
                onRequestBatteryExemption = onRequestBatteryExemption
            )
        }

        if (isLocationRow) {
            LocationPermissionRow(
                alpha = alpha,
                backgroundLocationGranted = backgroundLocationGranted,
                providerColWidth = providerColWidth,
                toggleColWidth = toggleColWidth,
                onRequestBackgroundLocation = onRequestBackgroundLocation
            )
        }

        if (isScreenTimeRow || isLateNightScreenTimeRow) {
            ScreenTimePermissionRow(
                alpha = alpha,
                screenTimePermissionGranted = screenTimePermissionGranted,
                providerColWidth = providerColWidth,
                toggleColWidth = toggleColWidth,
                onRequestPermission = onRequestScreenTimePermission
            )
        }

        // Phone sleep permission sub-row (only when phone source is selected)
        if (isHybridPhoneSource) {
            ScreenTimePermissionRow(
                alpha = 1.0f,
                screenTimePermissionGranted = usageStatsPermissionGranted,
                providerColWidth = providerColWidth,
                toggleColWidth = toggleColWidth,
                onRequestPermission = onRequestScreenTimePermission
            )
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Helper
// ─────────────────────────────────────────────────────────────────────────────

private fun getDefaultEnabled(row: DataRow): Boolean {
    return when (row.table) {
        "screen_time_daily" -> false
        "screen_time_late_night" -> false
        "menstruation" -> false
        "nutrition" -> false
        else -> defaultActiveFor(row)
    }
}

title: DataSettingsRowComponents.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.provider.Settings
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Row components for DataSettings screen.
 *
 * Each row type is a separate composable for easier maintenance.
 */

// ─────────────────────────────────────────────────────────────────────────────
// Wearable Selector
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun WearableSourceSelector(
    options: List<WearableSource>,
    selected: WearableSource,
    enabled: Boolean,
    onSelected: (WearableSource) -> Unit
) {
    var expanded by remember(options, selected) { mutableStateOf(false) }

    Box {
        TextButton(
            onClick = { if (enabled && options.size > 1) expanded = true },
            enabled = enabled
        ) {
            Text(selected.label, style = MaterialTheme.typography.bodySmall)
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            options.forEach { opt ->
                DropdownMenuItem(
                    text = { Text(opt.label) },
                    onClick = {
                        expanded = false
                        onSelected(opt)
                    }
                )
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Phone Source Selector
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun PhoneSourceSelector(
    options: List<PhoneSource>,
    selected: PhoneSource,
    enabled: Boolean,
    onSelected: (PhoneSource) -> Unit
) {
    var expanded by remember(options, selected) { mutableStateOf(false) }

    Box {
        TextButton(
            onClick = { if (enabled && options.size > 1) expanded = true },
            enabled = enabled
        ) {
            Text(selected.label, style = MaterialTheme.typography.bodySmall)
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            options.forEach { opt ->
                DropdownMenuItem(
                    text = { Text(opt.label) },
                    onClick = {
                        expanded = false
                        onSelected(opt)
                    }
                )
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Hybrid Source Selector (Phone + Wearable options)
// Used by PHONE_OR_WEARABLE rows (e.g. sleep duration, fell asleep, woke up)
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun HybridSourceSelector(
    options: List<Pair<String, String>>,
    selectedKey: String,
    enabled: Boolean,
    onSelected: (String) -> Unit
) {
    var expanded by remember(options, selectedKey) { mutableStateOf(false) }

    val selectedLabel = options.firstOrNull { it.first == selectedKey }?.second ?: "Phone"

    Box {
        TextButton(
            onClick = { if (enabled && options.size > 1) expanded = true },
            enabled = enabled
        ) {
            Text(selectedLabel, style = MaterialTheme.typography.bodySmall)
        }

        DropdownMenu(
            expanded = expanded,
            onDismissRequest = { expanded = false }
        ) {
            options.forEach { (key: String, label: String) ->
                DropdownMenuItem(
                    text = { Text(label) },
                    onClick = {
                        expanded = false
                        onSelected(key)
                    }
                )
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Permission Sub-Row (for ambient noise, location, screen time)
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun PermissionSubRow(
    label: String,
    isGranted: Boolean,
    alpha: Float,
    providerColWidth: androidx.compose.ui.unit.Dp,
    toggleColWidth: androidx.compose.ui.unit.Dp,
    onRequestPermission: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .alpha(alpha),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(
            modifier = Modifier
                .weight(1f)
                .padding(end = 10.dp)
        ) {
            Text(
                label,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.alpha(0.75f)
            )
        }

        Column(
            modifier = Modifier
                .width(providerColWidth)
                .padding(end = 10.dp)
        ) {
            // Empty spacer column for alignment
        }

        Column(
            modifier = Modifier.width(toggleColWidth),
            horizontalAlignment = Alignment.End
        ) {
            Switch(
                checked = isGranted,
                onCheckedChange = { newVal ->
                    if (newVal && !isGranted) {
                        onRequestPermission()
                    }
                },
                enabled = !isGranted
            )
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Ambient Noise Permission Rows
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun AmbientNoisePermissionRows(
    alpha: Float,
    micPermissionGranted: Boolean,
    batteryOptimizationExempt: Boolean,
    providerColWidth: androidx.compose.ui.unit.Dp,
    toggleColWidth: androidx.compose.ui.unit.Dp,
    onRequestMicPermission: () -> Unit,
    onRequestBatteryExemption: () -> Unit
) {
    PermissionSubRow(
        label = "Microphone permission",
        isGranted = micPermissionGranted,
        alpha = alpha,
        providerColWidth = providerColWidth,
        toggleColWidth = toggleColWidth,
        onRequestPermission = onRequestMicPermission
    )

    PermissionSubRow(
        label = "Battery optimization exemption",
        isGranted = batteryOptimizationExempt,
        alpha = alpha,
        providerColWidth = providerColWidth,
        toggleColWidth = toggleColWidth,
        onRequestPermission = onRequestBatteryExemption
    )
}

// ─────────────────────────────────────────────────────────────────────────────
// Location Permission Row
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun LocationPermissionRow(
    alpha: Float,
    backgroundLocationGranted: Boolean,
    providerColWidth: androidx.compose.ui.unit.Dp,
    toggleColWidth: androidx.compose.ui.unit.Dp,
    onRequestBackgroundLocation: () -> Unit
) {
    PermissionSubRow(
        label = "Background location (Allow all the time)",
        isGranted = backgroundLocationGranted,
        alpha = alpha,
        providerColWidth = providerColWidth,
        toggleColWidth = toggleColWidth,
        onRequestPermission = onRequestBackgroundLocation
    )

    // Warning text when not granted
    if (!backgroundLocationGranted) {
        Text(
            "Required: Enable \"Allow all the time\" for the app to collect weather data and work properly in the background.",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.error,
            modifier = Modifier.padding(top = 4.dp)
        )
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Screen Time Permission Row
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun ScreenTimePermissionRow(
    alpha: Float,
    screenTimePermissionGranted: Boolean,
    providerColWidth: androidx.compose.ui.unit.Dp,
    toggleColWidth: androidx.compose.ui.unit.Dp,
    onRequestPermission: () -> Unit
) {
    PermissionSubRow(
        label = "Usage access permission",
        isGranted = screenTimePermissionGranted,
        alpha = alpha,
        providerColWidth = providerColWidth,
        toggleColWidth = toggleColWidth,
        onRequestPermission = onRequestPermission
    )
}

// ─────────────────────────────────────────────────────────────────────────────
// Menstruation Detail Card
// ─────────────────────────────────────────────────────────────────────────────

@Composable
fun MenstruationDetailCard(
    settings: MenstruationSettings,
    onEdit: () -> Unit,
    onAutoUpdateToggle: (Boolean) -> Unit
) {
    ElevatedCard(
        modifier = Modifier
            .fillMaxWidth()
            .padding(start = 8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(modifier = Modifier.padding(12.dp)) {
            // Last Period Row
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        "Last Period",
                        style = MaterialTheme.typography.labelMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        settings.lastMenstruationDate?.toString() ?: "Not set",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
                TextButton(onClick = onEdit) {
                    Text("Edit")
                }
            }

            Spacer(Modifier.height(8.dp))
            Divider()
            Spacer(Modifier.height(8.dp))

            // Average Cycle Row
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        "Average Cycle",
                        style = MaterialTheme.typography.labelMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        "${settings.avgCycleLength} days",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.primary
                    )
                    Text(
                        "Weighted average of last 6 cycles",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.alpha(0.7f)
                    )
                }
                TextButton(onClick = onEdit) {
                    Text("Edit")
                }
            }

            Spacer(Modifier.height(8.dp))
            Divider()
            Spacer(Modifier.height(8.dp))

            // Auto-update Row
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        "Auto-update average",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        "Recalculate when new periods logged",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.alpha(0.7f)
                    )
                }
                Switch(
                    checked = settings.autoUpdateAverage,
                    onCheckedChange = onAutoUpdateToggle
                )
            }

            Spacer(Modifier.height(8.dp))

            // Next expected (only show if lastMenstruationDate is not null)
            settings.lastMenstruationDate?.let { lastDate ->
                val nextPeriod = lastDate.plusDays(settings.avgCycleLength.toLong())
                Text(
                    "Next expected: $nextPeriod",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.secondary
                )
            }
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Helper: Open App Settings
// ─────────────────────────────────────────────────────────────────────────────

fun openAppSettings(context: android.content.Context) {
    val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
        data = Uri.fromParts("package", context.packageName, null)
        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    }
    context.startActivity(intent)
}

title: DataSettingsScreen.kt
text:
package com.migraineme

import android.Manifest
import android.app.Activity
import android.os.Build
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.core.app.ActivityCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Data Settings Screen - Data Collection settings only.
 *
 * This is the main entry point. It delegates to:
 * - DataSettingsState: manages all state
 * - DataSettingsSections: defines what rows appear
 * - DataSettingsToggleHandler: handles toggle logic
 * - DataSettingsRowComponents: UI components
 * - DataSettingsDialogs: dialog components
 */
@Composable
fun DataSettingsScreen(
    onOpenMenstruationSettings: () -> Unit
) {
    val context = LocalContext.current
    val appContext = context.applicationContext
    val activity = context as? Activity
    val scope = rememberCoroutineScope()
    val lifecycleOwner = LocalLifecycleOwner.current

    // State management
    val state = remember { DataSettingsState(appContext) }
    val metricSettings by state.metricSettings.collectAsState()
    val connectedWearables by state.connectedWearables.collectAsState()
    val menstruationSettings by state.menstruationSettings.collectAsState()
    val nutritionPermissionGranted by state.nutritionPermissionGranted.collectAsState()
    val menstruationPermissionGranted by state.menstruationPermissionGranted.collectAsState()

    // Dialog states
    var showScreenTimePermissionDialog by remember { mutableStateOf(false) }
    var showBatteryOptDialog by remember { mutableStateOf(false) }
    var showBackgroundLocationDialog by remember { mutableStateOf(false) }

    // Refresh trigger
    var refreshTick by remember { mutableIntStateOf(0) }

    // ─────────────────────────────────────────────────────────────────────────
    // Permission Launchers
    // ─────────────────────────────────────────────────────────────────────────

    val micPermissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { refreshTick++ }

    val backgroundLocationLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { refreshTick++ }

    val locationPermissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val fineGranted = permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true
        val coarseGranted = permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true

        if ((fineGranted || coarseGranted) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            if (!DataSettingsPermissionHelper.hasBackgroundLocationPermission(appContext)) {
                backgroundLocationLauncher.launch(Manifest.permission.ACCESS_BACKGROUND_LOCATION)
            }
        }
        refreshTick++
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Lifecycle & Initial Load
    // ─────────────────────────────────────────────────────────────────────────

    // Initial load
    LaunchedEffect(Unit) {
        state.loadAll()
    }

    // Refresh on resume
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_RESUME) {
                refreshTick++
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
    }

    // Handle refresh
    LaunchedEffect(refreshTick) {
        if (refreshTick > 0) {
            state.refreshMetricSettings()
            state.refreshWearableConnections()
            state.refreshHealthConnectPermissions()
            state.autoEnableScreenTimeIfPermissionGranted()

            // Sync workers and refresh if Supabase changed
            if (state.syncWorkers()) {
                state.refreshMetricSettings()
            }
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // UI
    // ─────────────────────────────────────────────────────────────────────────

    val scrollState = rememberScrollState()

    // Report scroll position for setup coach overlay
    LaunchedEffect(scrollState.value, scrollState.maxValue) {
        if (TourManager.isActive() && TourManager.currentPhase() == CoachPhase.SETUP) {
            if (scrollState.maxValue > 0 && scrollState.value >= scrollState.maxValue - 50) {
                SetupScrollState.scrollPosition = -1  // at bottom → expand coach card
            } else {
                SetupScrollState.scrollPosition = scrollState.value
            }
        }
    }
    val sections = remember { DataSettingsSections.getAllSections() }
    val weatherMetrics = remember { DataSettingsSections.weatherMetrics }
    val hasAnyWearable = connectedWearables.isNotEmpty()
    val locationEnabled = state.isLocationEnabled()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(16.dp)
    ) {
        // Info card
        HeroCard {
            Text(
                "Data Collection",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.height(6.dp))
            Text(
                "Connect WHOOP or Health Connect in the Connections section to enable wearable data. Some toggles require phone permissions.",
                color = AppTheme.BodyTextColor,
                style = MaterialTheme.typography.bodyMedium
            )
        }

        // Render sections
        for (section in sections) {
            HeroCard {
                Text(
                    section.title,
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(12.dp))

                for ((idx, row) in section.rows.withIndex()) {
                    val greyOutWearableRow = row.collectedByKind == CollectedByKind.WEARABLE && !hasAnyWearable
                    val greyOutWeatherRow = row.table in weatherMetrics && !locationEnabled

                    DataSettingsRow(
                        row = row,
                        metricSettings = metricSettings,
                        connectedWearables = connectedWearables,
                        menstruationSettings = menstruationSettings,
                        nutritionPermissionGranted = nutritionPermissionGranted,
                        menstruationPermissionGranted = menstruationPermissionGranted,
                        greyOut = greyOutWearableRow || greyOutWeatherRow,
                        weatherMetrics = weatherMetrics,
                        onToggle = { metric, enabled, source ->
                            scope.launch {
                                val result = DataSettingsToggleHandler.toggleMetric(
                                    context = appContext,
                                    metric = metric,
                                    enabled = enabled,
                                    preferredSource = source,
                                    metricSettingsMap = metricSettings
                                )
                                handleToggleResult(
                                    result = result,
                                    activity = activity,
                                    appContext = appContext,
                                    micPermissionLauncher = micPermissionLauncher,
                                    locationPermissionLauncher = locationPermissionLauncher,
                                    onShowScreenTimeDialog = { showScreenTimePermissionDialog = true },
                                    onShowBatteryDialog = { showBatteryOptDialog = true }
                                )
                                refreshTick++
                            }
                        },
                        onSourceChange = { metric, newSource, currentEnabled ->
                            scope.launch {
                                DataSettingsToggleHandler.changeMetricSource(
                                    context = appContext,
                                    metric = metric,
                                    newSource = newSource,
                                    currentEnabled = currentEnabled
                                )
                                refreshTick++
                            }
                        },
                        // Permission request handlers
                        onRequestMicPermission = {
                            requestMicPermission(activity, appContext, micPermissionLauncher)
                        },
                        onRequestBatteryExemption = { showBatteryOptDialog = true },
                        onRequestBackgroundLocation = {
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                                backgroundLocationLauncher.launch(Manifest.permission.ACCESS_BACKGROUND_LOCATION)
                            }
                        },
                        onRequestScreenTimePermission = {
                            ScreenTimePermissionHelper.openUsageAccessSettings(appContext)
                        },
                        onRequestLocationPermission = {
                            requestLocationPermission(activity, appContext, locationPermissionLauncher)
                        }
                    )

                    if (idx != section.rows.lastIndex) {
                        Spacer(Modifier.height(12.dp))
                        Divider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                        Spacer(Modifier.height(12.dp))
                    }
                }
            }
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Dialogs
    // ─────────────────────────────────────────────────────────────────────────

    if (showScreenTimePermissionDialog) {
        ScreenTimePermissionDialog(
            onDismiss = { showScreenTimePermissionDialog = false },
            onOpenSettings = {
                ScreenTimePermissionHelper.openUsageAccessSettings(appContext)
                showScreenTimePermissionDialog = false
            }
        )
    }

    if (showBatteryOptDialog) {
        BatteryOptimizationDialog(
            onDismiss = {
                showBatteryOptDialog = false
                BatteryOptimizationHelper.markAsAsked(appContext)
            },
            onOpenSettings = {
                BatteryOptimizationHelper.requestBatteryOptimizationExemption(appContext)
                BatteryOptimizationHelper.markAsAsked(appContext)
                showBatteryOptDialog = false
            }
        )
    }

    if (showBackgroundLocationDialog) {
        BackgroundLocationDialog(
            onDismiss = { showBackgroundLocationDialog = false },
            onOpenSettings = {
                showBackgroundLocationDialog = false
                openAppSettings(appContext)
            }
        )
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Helper Functions
// ─────────────────────────────────────────────────────────────────────────────

private fun handleToggleResult(
    result: DataSettingsToggleHandler.ToggleResult,
    activity: Activity?,
    appContext: android.content.Context,
    micPermissionLauncher: androidx.activity.result.ActivityResultLauncher<String>,
    locationPermissionLauncher: androidx.activity.result.ActivityResultLauncher<Array<String>>,
    onShowScreenTimeDialog: () -> Unit,
    onShowBatteryDialog: () -> Unit
) {
    when (result) {
        is DataSettingsToggleHandler.ToggleResult.Success -> { /* UI will refresh */ }
        is DataSettingsToggleHandler.ToggleResult.NeedsPermission -> {
            when (result.permissionType) {
                DataSettingsToggleHandler.PermissionType.SCREEN_TIME -> onShowScreenTimeDialog()
                DataSettingsToggleHandler.PermissionType.LOCATION -> {
                    requestLocationPermission(activity, appContext, locationPermissionLauncher)
                }
                DataSettingsToggleHandler.PermissionType.MICROPHONE -> {
                    requestMicPermission(activity, appContext, micPermissionLauncher)
                }
                DataSettingsToggleHandler.PermissionType.BATTERY_OPTIMIZATION -> onShowBatteryDialog()
                else -> { /* Handle other permission types */ }
            }
        }
        is DataSettingsToggleHandler.ToggleResult.Error -> {
            android.util.Log.e("DataSettings", "Toggle error: ${result.message}")
        }
    }
}

private fun requestMicPermission(
    activity: Activity?,
    appContext: android.content.Context,
    launcher: androidx.activity.result.ActivityResultLauncher<String>
) {
    val askedBefore = hasAskedMicPermission(appContext)
    val canRationale = activity?.let {
        ActivityCompat.shouldShowRequestPermissionRationale(it, Manifest.permission.RECORD_AUDIO)
    } ?: true

    if (askedBefore && !canRationale) {
        openAppSettings(appContext)
    } else {
        markAskedMicPermission(appContext)
        launcher.launch(Manifest.permission.RECORD_AUDIO)
    }
}

private fun requestLocationPermission(
    activity: Activity?,
    appContext: android.content.Context,
    launcher: androidx.activity.result.ActivityResultLauncher<Array<String>>
) {
    val askedBefore = hasAskedLocationPermission(appContext)
    val canRationale = activity?.let {
        ActivityCompat.shouldShowRequestPermissionRationale(it, Manifest.permission.ACCESS_FINE_LOCATION)
    } ?: true

    if (askedBefore && !canRationale) {
        openAppSettings(appContext)
    } else {
        markAskedLocationPermission(appContext)
        launcher.launch(
            arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.ACCESS_COARSE_LOCATION
            )
        )
    }
}


title: DataSettingsSections.kt
text:
package com.migraineme

/**
 * Defines the structure of DataSettings sections and rows.
 * 
 * SINGLE SOURCE OF TRUTH for what metrics appear in the UI.
 * Update this file when adding/removing/reordering metrics.
 */
object DataSettingsSections {

    /**
     * Weather metrics that depend on location being enabled.
     * These get greyed out when location is off.
     */
    val weatherMetrics = setOf(
        "temperature_daily",
        "pressure_daily",
        "humidity_daily",
        "wind_daily",
        "uv_daily",
        "thunderstorm_daily"
    )

    /**
     * All sections displayed in the Data Settings screen.
     */
    fun getAllSections(): List<DataSection> = listOf(
        DataSection(
            title = "Sleep",
            rows = listOf(
                phoneOrWearableRow("sleep_duration_daily", "Sleep duration"),
                wearableRow("sleep_score_daily", "Sleep score"),
                wearableRow("sleep_efficiency_daily", "Sleep efficiency"),
                wearableRow("sleep_stages_daily", "Sleep stages"),
                wearableRow("sleep_disturbances_daily", "Sleep disturbances"),
                phoneOrWearableRow("fell_asleep_time_daily", "Fell asleep time"),
                phoneOrWearableRow("woke_up_time_daily", "Woke up time")
            )
        ),
        DataSection(
            title = "Physical Health",
            rows = listOf(
                wearableRow("recovery_score_daily", "Recovery score"),
                wearableRow("resting_hr_daily", "Resting heart rate"),
                wearableRow("hrv_daily", "HRV"),
                wearableRow("skin_temp_daily", "Skin temperature"),
                wearableRow("spo2_daily", "Blood oxygen (SpO2)"),
                wearableRow("time_in_high_hr_zones_daily", "Time in high HR zones"),
                wearableRow("activity_hr_zones_sessions", "Workout HR zones"),
                wearableRow("steps_daily", "Steps"),
                wearableRow("strain_daily", "Strain")
            )
        ),
        DataSection(
            title = "Mental Health",
            rows = listOf(
                computedRow("stress_index_daily", "Stress index"),
                phoneRow("screen_time_daily", "Phone screen time tracking"),
                phoneRow("screen_time_late_night", "Late night screen time"),
                phoneRow("ambient_noise_samples", "Noise Sampling"),
                phoneRow("phone_brightness_daily", "Phone brightness"),
                phoneRow("phone_volume_daily", "Phone volume"),
                phoneRow("phone_dark_mode_daily", "Dark mode usage"),
                phoneRow("phone_unlock_daily", "Phone unlocks")
            )
        ),
        DataSection(
            title = "Environment",
            rows = listOf(
                phoneRow("user_location_daily", "Location"),
                referenceRow("temperature_daily", "Temperature"),
                referenceRow("pressure_daily", "Pressure"),
                referenceRow("humidity_daily", "Humidity"),
                referenceRow("wind_daily", "Wind"),
                referenceRow("uv_daily", "UV index"),
                referenceRow("thunderstorm_daily", "Thunderstorms")
            )
        ),
        DataSection(
            title = "Diet",
            rows = listOf(
                phoneRow("nutrition", "Nutrition")
            )
        ),
        DataSection(
            title = "Menstruation",
            rows = listOf(
                phoneRow("menstruation", "Menstruation")
            )
        )
    )
}

title: DataSettingsState.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.withContext

/**
 * Manages all state for the DataSettings screen.
 *
 * This class holds:
 * - Metric settings from Supabase
 * - Permission states
 * - Connected wearables
 * - Menstruation settings
 *
 * The UI layer observes these flows and reacts to changes.
 */
class DataSettingsState(private val context: Context) {

    private val appContext = context.applicationContext
    private val edge = EdgeFunctionsService()

    companion object {
        private const val TAG = "DataSettingsState"
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Metric Settings
    // ─────────────────────────────────────────────────────────────────────────

    private val _metricSettings = MutableStateFlow<Map<String, EdgeFunctionsService.MetricSettingResponse>>(emptyMap())
    val metricSettings: StateFlow<Map<String, EdgeFunctionsService.MetricSettingResponse>> = _metricSettings.asStateFlow()

    private val _isLoading = MutableStateFlow(true)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    // ─────────────────────────────────────────────────────────────────────────
    // Connected Wearables
    // ─────────────────────────────────────────────────────────────────────────

    private val _connectedWearables = MutableStateFlow<List<WearableSource>>(emptyList())
    val connectedWearables: StateFlow<List<WearableSource>> = _connectedWearables.asStateFlow()

    private val _whoopConnected = MutableStateFlow(false)
    val whoopConnected: StateFlow<Boolean> = _whoopConnected.asStateFlow()

    private val _healthConnectWearablesConnected = MutableStateFlow(false)
    val healthConnectWearablesConnected: StateFlow<Boolean> = _healthConnectWearablesConnected.asStateFlow()

    // ─────────────────────────────────────────────────────────────────────────
    // Health Connect Specific Permissions
    // ─────────────────────────────────────────────────────────────────────────

    private val _nutritionPermissionGranted = MutableStateFlow(false)
    val nutritionPermissionGranted: StateFlow<Boolean> = _nutritionPermissionGranted.asStateFlow()

    private val _menstruationPermissionGranted = MutableStateFlow(false)
    val menstruationPermissionGranted: StateFlow<Boolean> = _menstruationPermissionGranted.asStateFlow()

    // ─────────────────────────────────────────────────────────────────────────
    // Menstruation Settings
    // ─────────────────────────────────────────────────────────────────────────

    private val _menstruationSettings = MutableStateFlow<MenstruationSettings?>(null)
    val menstruationSettings: StateFlow<MenstruationSettings?> = _menstruationSettings.asStateFlow()

    // ─────────────────────────────────────────────────────────────────────────
    // Derived State
    // ─────────────────────────────────────────────────────────────────────────

    fun hasAnyWearable(): Boolean = _connectedWearables.value.isNotEmpty()

    /**
     * Check if location metric is enabled.
     * Looks up directly by metric name in the settings map.
     */
    fun isLocationEnabled(): Boolean {
        return _metricSettings.value["user_location_daily"]?.enabled ?: false
    }

    fun isMetricEnabled(metric: String): Boolean {
        return _metricSettings.value[metric]?.enabled ?: false
    }

    fun getPreferredSource(metric: String): String? {
        return _metricSettings.value[metric]?.preferredSource
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Data Loading
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Load all settings from Supabase and refresh permission states.
     */
    suspend fun loadAll() {
        _isLoading.value = true
        try {
            // Load in parallel
            loadMetricSettings()
            refreshWearableConnections()
            refreshHealthConnectPermissions()
            loadMenstruationSettings()
        } finally {
            _isLoading.value = false
        }
    }

    /**
     * Refresh only the metric settings from Supabase.
     */
    suspend fun refreshMetricSettings() {
        loadMetricSettings()
    }

    private suspend fun loadMetricSettings() {
        withContext(Dispatchers.IO) {
            try {
                val settings = edge.getMetricSettings(appContext)
                _metricSettings.value = settings.associateBy { it.metric }
                Log.d(TAG, "Loaded ${settings.size} metric settings")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load metric settings: ${e.message}", e)
            }
        }
    }

    /**
     * Refresh wearable connection states.
     */
    suspend fun refreshWearableConnections() {
        withContext(Dispatchers.IO) {
            // Check WHOOP
            _whoopConnected.value = WhoopTokenStore(appContext).load() != null

            // Check Health Connect wearables
            _healthConnectWearablesConnected.value =
                DataSettingsPermissionHelper.hasHealthConnectWearablesPermission(appContext)

            // Update combined list
            _connectedWearables.value = buildList {
                if (_whoopConnected.value) add(WearableSource.WHOOP)
                if (_healthConnectWearablesConnected.value) add(WearableSource.HEALTH_CONNECT)
            }
        }
    }

    /**
     * Refresh Health Connect specific permissions.
     */
    suspend fun refreshHealthConnectPermissions() {
        withContext(Dispatchers.IO) {
            _nutritionPermissionGranted.value =
                DataSettingsPermissionHelper.hasHealthConnectNutritionPermission(appContext)
            _menstruationPermissionGranted.value =
                DataSettingsPermissionHelper.hasHealthConnectMenstruationPermission(appContext)
        }
    }

    /**
     * Load menstruation settings from Supabase.
     */
    suspend fun loadMenstruationSettings() {
        withContext(Dispatchers.IO) {
            try {
                val accessToken = SessionStore.getValidAccessToken(appContext)
                if (accessToken != null) {
                    _menstruationSettings.value =
                        SupabaseMenstruationService(appContext).getSettings(accessToken)
                } else {
                    _menstruationSettings.value = null
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load menstruation settings: ${e.message}", e)
                _menstruationSettings.value = null
            }
        }
    }

    /**
     * Update menstruation settings (local state only - Supabase update handled separately).
     */
    fun updateMenstruationSettings(settings: MenstruationSettings) {
        _menstruationSettings.value = settings
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Worker Sync
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Sync workers with current Supabase settings.
     * Returns true if any Supabase settings were changed (requiring UI refresh).
     */
    suspend fun syncWorkers(): Boolean {
        return withContext(Dispatchers.IO) {
            val result = DataSettingsWorkerSyncHelper.syncFromSupabaseTruth(
                context = appContext,
                edge = edge,
                metricSettingsMap = _metricSettings.value
            )
            result.changedSupabase
        }
    }

    /**
     * Auto-enable screen time if permission was just granted.
     */
    suspend fun autoEnableScreenTimeIfPermissionGranted() {
        withContext(Dispatchers.IO) {
            if (DataSettingsPermissionHelper.hasScreenTimePermission(appContext)) {
                val screenTimeEnabled = _metricSettings.value["screen_time_daily"]?.enabled ?: false

                if (!screenTimeEnabled) {
                    Log.d(TAG, "Auto-enabling screen time after permission grant")
                    edge.upsertMetricSetting(
                        context = appContext,
                        metric = "screen_time_daily",
                        enabled = true
                    )
                    loadMetricSettings() // Refresh
                }
            }
        }
    }
}

title: DataSettingsToggleHandler.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Handles metric toggle logic for DataSettings.
 *
 * SINGLE SOURCE OF TRUTH for what happens when a metric is toggled.
 * Separates the toggle logic from the UI layer.
 */
object DataSettingsToggleHandler {

    private const val TAG = "DataSettingsToggle"

    /**
     * Metrics that support phone-based sleep tracking.
     * These can be sourced from either a wearable or phone usage stats.
     */
    private val phoneSleepMetrics = setOf(
        "sleep_duration_daily",
        "fell_asleep_time_daily",
        "woke_up_time_daily"
    )

    /**
     * Phone behavior metrics collected by PhoneBehaviorSyncWorker.
     * These are triggered via FCM sync_hourly — no dedicated worker scheduling needed.
     */
    private val phoneBehaviorMetrics = setOf(
        "phone_brightness_daily",
        "phone_volume_daily",
        "phone_dark_mode_daily",
        "phone_unlock_daily"
    )

    /**
     * Result of a toggle operation
     */
    sealed class ToggleResult {
        object Success : ToggleResult()
        data class NeedsPermission(val permissionType: PermissionType) : ToggleResult()
        data class Error(val message: String) : ToggleResult()
    }

    enum class PermissionType {
        SCREEN_TIME,
        LOCATION,
        BACKGROUND_LOCATION,
        MICROPHONE,
        BATTERY_OPTIMIZATION,
        HEALTH_CONNECT_NUTRITION,
        HEALTH_CONNECT_MENSTRUATION
    }

    /**
     * Toggle a metric on/off.
     *
     * This method:
     * 1. Checks permissions (returns NeedsPermission if missing)
     * 2. Updates Supabase via EdgeFunctionsService
     * 3. Schedules/cancels workers as needed
     * 4. Handles metric dependencies (e.g., stress requires HRV + resting HR)
     *
     * @return ToggleResult indicating success, permission needed, or error
     */
    suspend fun toggleMetric(
        context: Context,
        metric: String,
        enabled: Boolean,
        preferredSource: String?,
        metricSettingsMap: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ): ToggleResult = withContext(Dispatchers.IO) {
        val appContext = context.applicationContext
        val edge = EdgeFunctionsService()

        try {
            // Check permissions before enabling
            if (enabled) {
                val permissionResult = checkPermissionsForMetric(appContext, metric, preferredSource)
                if (permissionResult != null) {
                    return@withContext permissionResult
                }
            }

            // Handle metric-specific toggle logic
            when {
                metric == "menstruation" -> return@withContext toggleMenstruation(appContext, edge, enabled, preferredSource)
                metric == "nutrition" -> return@withContext toggleNutrition(appContext, edge, enabled, preferredSource)
                metric == "user_location_daily" -> return@withContext toggleLocation(appContext, edge, enabled)
                metric == "ambient_noise_samples" -> return@withContext toggleAmbientNoise(appContext, edge, enabled)
                metric == "screen_time_daily" -> return@withContext toggleScreenTime(appContext, edge, enabled)
                metric == "screen_time_late_night" -> return@withContext toggleScreenTimeLateNight(appContext, edge, enabled)
                metric in phoneBehaviorMetrics -> return@withContext togglePhoneBehavior(appContext, edge, metric, enabled)
                metric in phoneSleepMetrics -> return@withContext togglePhoneSleepMetric(appContext, edge, metric, enabled, preferredSource)
                else -> {
                    // Standard metric toggle
                    val success = edge.upsertMetricSetting(
                        context = appContext,
                        metric = metric,
                        enabled = enabled,
                        preferredSource = preferredSource
                    )

                    if (!success) {
                        return@withContext ToggleResult.Error("Failed to update setting")
                    }

                    // Handle stress index dependency
                    if (!enabled && (metric == "hrv_daily" || metric == "resting_hr_daily")) {
                        disableStressIfNeeded(appContext, edge, metricSettingsMap, preferredSource)
                    }

                    return@withContext ToggleResult.Success
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Toggle failed for $metric: ${e.message}", e)
            return@withContext ToggleResult.Error(e.message ?: "Unknown error")
        }
    }

    /**
     * Check if permissions are granted for enabling a metric.
     * Returns null if all permissions are granted, or ToggleResult.NeedsPermission if not.
     */
    private fun checkPermissionsForMetric(
        context: Context,
        metric: String,
        preferredSource: String?
    ): ToggleResult.NeedsPermission? {
        return when {
            metric == "screen_time_daily" || metric == "screen_time_late_night" -> {
                if (!DataSettingsPermissionHelper.hasScreenTimePermission(context)) {
                    ToggleResult.NeedsPermission(PermissionType.SCREEN_TIME)
                } else null
            }
            metric in phoneSleepMetrics && preferredSource == "phone" -> {
                if (!DataSettingsPermissionHelper.hasScreenTimePermission(context)) {
                    ToggleResult.NeedsPermission(PermissionType.SCREEN_TIME)
                } else null
            }
            // Phone unlock metric needs PACKAGE_USAGE_STATS (same as screen time)
            metric == "phone_unlock_daily" -> {
                if (!DataSettingsPermissionHelper.hasScreenTimePermission(context)) {
                    ToggleResult.NeedsPermission(PermissionType.SCREEN_TIME)
                } else null
            }
            metric == "user_location_daily" -> {
                if (!DataSettingsPermissionHelper.hasLocationPermission(context)) {
                    ToggleResult.NeedsPermission(PermissionType.LOCATION)
                } else null
            }
            metric == "ambient_noise_samples" -> {
                when {
                    !DataSettingsPermissionHelper.hasMicrophonePermission(context) ->
                        ToggleResult.NeedsPermission(PermissionType.MICROPHONE)
                    !DataSettingsPermissionHelper.isBatteryOptimizationExempt(context) ->
                        ToggleResult.NeedsPermission(PermissionType.BATTERY_OPTIMIZATION)
                    else -> null
                }
            }
            metric == "nutrition" -> {
                if (preferredSource == PhoneSource.HEALTH_CONNECT.key) {
                    // Will be checked asynchronously by caller
                    null
                } else null
            }
            else -> null
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Metric-specific toggle handlers
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Toggle a phone-or-wearable sleep metric.
     * When source is "phone", triggers PhoneSleepSyncWorker.
     * When source is a wearable, behaves like a standard wearable toggle.
     */
    private suspend fun togglePhoneSleepMetric(
        context: Context,
        edge: EdgeFunctionsService,
        metric: String,
        enabled: Boolean,
        preferredSource: String?
    ): ToggleResult {
        return try {
            val success = edge.upsertMetricSetting(
                context = context,
                metric = metric,
                enabled = enabled,
                preferredSource = preferredSource
            )

            if (!success) {
                return ToggleResult.Error("Failed to update setting")
            }

            // Trigger phone sleep worker when enabling with phone source
            if (enabled && preferredSource == "phone") {
                PhoneSleepSyncWorker.runOnce(context)
            }

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Phone sleep metric toggle failed for $metric: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle $metric")
        }
    }

    private suspend fun toggleMenstruation(
        context: Context,
        edge: EdgeFunctionsService,
        enabled: Boolean,
        preferredSource: String?
    ): ToggleResult {
        return try {
            if (enabled) {
                PredictedMenstruationHelper.ensureExists(context)
                MetricToggleHelper.toggle(context, "menstruation", true)
                MenstruationSyncScheduler.schedule(context)
            } else {
                PredictedMenstruationHelper.delete(context)
                MetricToggleHelper.toggle(context, "menstruation", false)
            }

            edge.upsertMetricSetting(
                context = context,
                metric = "menstruation",
                enabled = enabled,
                preferredSource = preferredSource
            )

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Menstruation toggle failed: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle menstruation")
        }
    }

    private suspend fun toggleNutrition(
        context: Context,
        edge: EdgeFunctionsService,
        enabled: Boolean,
        preferredSource: String?
    ): ToggleResult {
        return try {
            edge.upsertMetricSetting(
                context = context,
                metric = "nutrition",
                enabled = enabled,
                preferredSource = preferredSource
            )

            if (enabled) {
                MetricToggleHelper.toggle(context, "nutrition", true)
                if (preferredSource == PhoneSource.HEALTH_CONNECT.key) {
                    NutritionSyncScheduler.schedule(context)
                }
            } else {
                MetricToggleHelper.toggle(context, "nutrition", false)
                NutritionSyncScheduler.cancel(context)
            }

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Nutrition toggle failed: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle nutrition")
        }
    }

    private suspend fun toggleLocation(
        context: Context,
        edge: EdgeFunctionsService,
        enabled: Boolean
    ): ToggleResult {
        return try {
            edge.upsertMetricSetting(
                context = context,
                metric = "user_location_daily",
                enabled = enabled,
                preferredSource = null
            )

            if (enabled) {
                LocationDailySyncWorker.runOnce(context)
            }

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Location toggle failed: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle location")
        }
    }

    private suspend fun toggleAmbientNoise(
        context: Context,
        edge: EdgeFunctionsService,
        enabled: Boolean
    ): ToggleResult {
        return try {
            edge.upsertMetricSetting(
                context = context,
                metric = "ambient_noise_samples",
                enabled = enabled,
                preferredSource = null
            )

            MetricToggleHelper.toggle(context, "ambient_noise_samples", enabled)

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Ambient noise toggle failed: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle ambient noise")
        }
    }

    private suspend fun toggleScreenTime(
        context: Context,
        edge: EdgeFunctionsService,
        enabled: Boolean
    ): ToggleResult {
        return try {
            edge.upsertMetricSetting(
                context = context,
                metric = "screen_time_daily",
                enabled = enabled,
                preferredSource = null
            )

            MetricToggleHelper.toggle(context, "screen_time_daily", enabled)

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Screen time toggle failed: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle screen time")
        }
    }

    private suspend fun toggleScreenTimeLateNight(
        context: Context,
        edge: EdgeFunctionsService,
        enabled: Boolean
    ): ToggleResult {
        return try {
            edge.upsertMetricSetting(
                context = context,
                metric = "screen_time_late_night",
                enabled = enabled,
                preferredSource = null
            )

            MetricToggleHelper.toggle(context, "screen_time_late_night", enabled)

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Late night screen time toggle failed: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle late night screen time")
        }
    }

    /**
     * Toggle a phone behavior metric (brightness, volume, dark mode, unlocks).
     * These are collected by PhoneBehaviorSyncWorker which runs on FCM sync_hourly.
     * No dedicated worker scheduling needed — the worker checks metric_settings each run.
     */
    private suspend fun togglePhoneBehavior(
        context: Context,
        edge: EdgeFunctionsService,
        metric: String,
        enabled: Boolean
    ): ToggleResult {
        return try {
            edge.upsertMetricSetting(
                context = context,
                metric = metric,
                enabled = enabled,
                preferredSource = null
            )

            MetricToggleHelper.toggle(context, metric, enabled)

            ToggleResult.Success
        } catch (e: Exception) {
            Log.e(TAG, "Phone behavior toggle failed for $metric: ${e.message}", e)
            ToggleResult.Error(e.message ?: "Failed to toggle $metric")
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Dependency handlers
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Disable stress index if its dependencies (HRV or Resting HR) are disabled.
     */
    private suspend fun disableStressIfNeeded(
        context: Context,
        edge: EdgeFunctionsService,
        metricSettingsMap: Map<String, EdgeFunctionsService.MetricSettingResponse>,
        preferredSource: String?
    ) {
        val stressEnabled = metricSettingsMap["stress_index_daily"]?.enabled ?: false
        if (stressEnabled) {
            Log.d(TAG, "Auto-disabling stress_index_daily due to missing dependency")
            edge.upsertMetricSetting(
                context = context,
                metric = "stress_index_daily",
                enabled = false,
                preferredSource = preferredSource
            )
        }
    }

    /**
     * Check if stress index dependencies are met.
     */
    fun areStressDependenciesMet(
        metricSettingsMap: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ): Boolean {
        val hrvEnabled = metricSettingsMap["hrv_daily"]?.enabled ?: true
        val restingHrEnabled = metricSettingsMap["resting_hr_daily"]?.enabled ?: true
        return hrvEnabled && restingHrEnabled
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Source change handler
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Change the preferred source for a metric.
     */
    suspend fun changeMetricSource(
        context: Context,
        metric: String,
        newSource: String,
        currentEnabled: Boolean
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val success = EdgeFunctionsService().upsertMetricSetting(
                context = context,
                metric = metric,
                enabled = currentEnabled,
                preferredSource = newSource
            )

            // If switching to phone source and metric is enabled, trigger phone sleep worker
            if (success && currentEnabled && metric in phoneSleepMetrics && newSource == "phone") {
                PhoneSleepSyncWorker.runOnce(context)
            }

            success
        } catch (e: Exception) {
            Log.e(TAG, "Failed to change source for $metric: ${e.message}", e)
            false
        }
    }
}

title: DataSettingsViewModel.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

class DataSettingsViewModel(
    private val context: Context,
    private val edge: EdgeFunctionsService = EdgeFunctionsService()
) : ViewModel() {

    private val _metricSettings = MutableStateFlow<Map<String, EdgeFunctionsService.MetricSettingResponse>>(emptyMap())
    val metricSettings: StateFlow<Map<String, EdgeFunctionsService.MetricSettingResponse>> = _metricSettings.asStateFlow()

    private val _loading = MutableStateFlow(true)
    val loading: StateFlow<Boolean> = _loading.asStateFlow()

    init {
        loadSettings()
    }

    fun loadSettings() {
        viewModelScope.launch(Dispatchers.IO) {
            _loading.value = true
            try {
                val settings = edge.getMetricSettings(context)
                Log.d(TAG, "Loaded ${settings.size} settings from Supabase")

                // FIX: Key by metric name only, since Supabase has unique constraint on (user_id, metric)
                // The preferred_source is a column in that row, not part of the key
                _metricSettings.value = settings.associateBy { it.metric }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to load settings: ${e.message}", e)
            } finally {
                _loading.value = false
            }
        }
    }

    suspend fun toggleMetric(metric: String, enabled: Boolean, source: String?): Result<Unit> {
        return withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "Toggling $metric to $enabled (source: $source)")
                val success = edge.upsertMetricSetting(
                    context = context,
                    metric = metric,
                    enabled = enabled,
                    preferredSource = source
                )

                if (success) {
                    loadSettings() // Refresh
                    Result.success(Unit)
                } else {
                    Result.failure(Exception("Failed to update setting"))
                }
            } catch (e: Exception) {
                Log.e(TAG, "Toggle failed: ${e.message}", e)
                Result.failure(e)
            }
        }
    }

    companion object {
        private const val TAG = "DataSettingsVM"
    }
}

title: DataSettingsWorkerSyncHelper.kt
text:
package com.migraineme

import android.content.Context
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

object DataSettingsWorkerSyncHelper {

    data class SyncResult(
        val changedSupabase: Boolean
    )

    suspend fun syncFromSupabaseTruth(
        context: Context,
        edge: EdgeFunctionsService,
        metricSettingsMap: Map<String, EdgeFunctionsService.MetricSettingResponse>
    ): SyncResult = withContext(Dispatchers.IO) {

        // ===== Screen Time workers =====
        val screenTimeEnabled = MetricSettingsMapHelper.isEnabled(
            map = metricSettingsMap,
            metric = "screen_time_daily",
            preferredSource = null,
            defaultValue = true
        )

        val hasUsageAccess = ScreenTimePermissionHelper.hasPermission(context)

        if (screenTimeEnabled && hasUsageAccess) {

        } else {

        }

        // ===== Ambient Noise workers =====
        val ambientEnabled = MetricSettingsMapHelper.isEnabled(
            map = metricSettingsMap,
            metric = "ambient_noise_samples",
            preferredSource = null,
            defaultValue = true
        )

        val micGranted = MicrophonePermissionHelper.hasPermission(context)
        val batteryExempt = BatteryOptimizationExemptHelper.isExempt(context)

        if (ambientEnabled && micGranted && batteryExempt) {
            AmbientNoiseSampleWorker.schedule(context)
            AmbientNoiseWatchdogWorker.schedule(context)
        } else {
            AmbientNoiseSampleWorker.cancel(context)
            AmbientNoiseWatchdogWorker.cancel(context)
        }

        // ===== Stress dependency enforcement =====
        // stress_index_daily is treated as WHOOP-derived/computed in your settings model.
        val whoopKey = "whoop"

        val stressEnabled = MetricSettingsMapHelper.isEnabled(
            map = metricSettingsMap,
            metric = "stress_index_daily",
            preferredSource = whoopKey,
            defaultValue = true
        )

        val hrvEnabled = MetricSettingsMapHelper.isEnabled(
            map = metricSettingsMap,
            metric = "hrv_daily",
            preferredSource = whoopKey,
            defaultValue = true
        )

        val restingHrEnabled = MetricSettingsMapHelper.isEnabled(
            map = metricSettingsMap,
            metric = "resting_hr_daily",
            preferredSource = whoopKey,
            defaultValue = true
        )

        var changedSupabase = false

        if (stressEnabled && (!hrvEnabled || !restingHrEnabled)) {
            // Auto-disable stress in Supabase since it cannot compute without both inputs.
            runCatching {
                edge.upsertMetricSetting(
                    context = context,
                    metric = "stress_index_daily",
                    enabled = false,
                    preferredSource = whoopKey
                )
                changedSupabase = true
            }
        }

        SyncResult(changedSupabase = changedSupabase)
    }
}

/**
 * Kept as a tiny helper so we don't spread battery-exemption details across screens.
 * Uses existing platform logic only (no Supabase changes).
 */
object BatteryOptimizationExemptHelper {
    fun isExempt(context: Context): Boolean {
        return runCatching {
            val pm = context.getSystemService(Context.POWER_SERVICE) as android.os.PowerManager
            pm.isIgnoringBatteryOptimizations(context.packageName)
        }.getOrDefault(false)
    }
}

title: DemoDataSeeder.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.*
import java.time.LocalDate
import java.time.ZoneId
import kotlin.math.roundToInt
import kotlin.random.Random

object DemoDataSeeder {

    private const val TAG = "DemoSeeder"
    private const val SOURCE = "demo"
    private const val DAYS = 14

    data class SeedProgress(val phase: String = "", val fraction: Float = 0f, val isComplete: Boolean = false)
    private val _progress = MutableStateFlow(SeedProgress())
    val progress: StateFlow<SeedProgress> = _progress
    private val _dataReady = MutableStateFlow(false)
    val dataReady: StateFlow<Boolean> = _dataReady
    private fun prog(phase: String, f: Float) { _progress.value = SeedProgress(phase, f.coerceIn(0f, 1f)) }

    private const val PREFS = "demo_seeder"
    private fun isDemoCleared(c: Context) = c.getSharedPreferences(PREFS, Context.MODE_PRIVATE).getBoolean("cleared", false)
    private fun markCleared(c: Context) { c.getSharedPreferences(PREFS, Context.MODE_PRIVATE).edit().putBoolean("cleared", true).apply() }

    // ── Helpers ──────────────────────────────────────────────────────────────

    private suspend fun upsertRow(client: HttpClient, url: String, token: String, apiKey: String, onConflict: String, body: JsonObject): Boolean {
        val tableName = url.substringAfterLast("/")
        return try {
            val resp = client.post(url) {
                header("Authorization", "Bearer $token"); header("apikey", apiKey)
                header("Prefer", "resolution=merge-duplicates,return=minimal")
                parameter("on_conflict", onConflict)
                contentType(ContentType.Application.Json)
                setBody(JsonArray(listOf(body)).toString())
            }
            if (!resp.status.isSuccess()) {
                Log.e(TAG, "✗ $tableName: ${resp.status} — ${resp.bodyAsText().take(400)}")
                false
            } else true
        } catch (e: Exception) { Log.e(TAG, "✗ $tableName exception: ${e.message}"); false }
    }

    private suspend fun insertRow(client: HttpClient, url: String, token: String, apiKey: String, body: JsonObject): Boolean {
        val tableName = url.substringAfterLast("/")
        return try {
            val resp = client.post(url) {
                header("Authorization", "Bearer $token"); header("apikey", apiKey)
                header("Prefer", "return=minimal")
                contentType(ContentType.Application.Json)
                setBody(JsonArray(listOf(body)).toString())
            }
            if (!resp.status.isSuccess()) {
                Log.e(TAG, "✗ $tableName: ${resp.status} — ${resp.bodyAsText().take(400)}")
                false
            } else true
        } catch (e: Exception) { Log.e(TAG, "✗ $tableName exception: ${e.message}"); false }
    }

    // ── Migraine pattern: days-ago when migraines happen ──────────────────

    // Migraine pattern within 14 days: Pair(daysAgo, severity)
    private val MIGRAINE_DAYS = listOf(
        1 to 7, 3 to 5, 5 to 8, 8 to 6, 10 to 4, 13 to 7
    )
    private val MIGRAINE_DAYS_SET = MIGRAINE_DAYS.map { it.first }.toSet()
    private val PRE_MIGRAINE_DAYS = MIGRAINE_DAYS.map { it.first + 1 }.toSet()
    private fun isBadDay(daysAgo: Int) = daysAgo in MIGRAINE_DAYS_SET || daysAgo in PRE_MIGRAINE_DAYS

    // ── Main seed ───────────────────────────────────────────────────────────

    suspend fun seedDemoData(context: Context) {
        val ctx = context.applicationContext
        Log.d(TAG, "═══ seedDemoData START (30 days) ═══")
        val token = SessionStore.getValidAccessToken(ctx) ?: run { Log.e(TAG, "No token"); return }
        val userId = SessionStore.readUserId(ctx) ?: JwtUtils.extractUserIdFromAccessToken(token)
        Log.d(TAG, "userId=$userId")
        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
        val metrics = SupabaseMetricsService(ctx)
        val physical = SupabasePhysicalHealthService(ctx)
        val personal = SupabasePersonalService(ctx)
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val key = BuildConfig.SUPABASE_ANON_KEY
        val today = LocalDate.now(ZoneId.systemDefault())

        withContext(Dispatchers.IO) {
            try {
                prog("Seeding sleep data…", 0.05f)
                seedSleep(token, metrics, today);            Log.d(TAG, "✓ Sleep done")
                prog("Seeding physical data…", 0.15f)
                seedPhysical(token, physical, today);        Log.d(TAG, "✓ Physical done")
                prog("Seeding screen time…", 0.22f)
                seedScreenTime(token, personal, today);      Log.d(TAG, "✓ Screen time done")
                prog("Seeding mental health…", 0.30f)
                seedMental(token, userId, base, key, today); Log.d(TAG, "✓ Mental done")
                prog("Seeding weather…", 0.42f)
                seedWeather(token, userId, base, key, today);Log.d(TAG, "✓ Weather done")
                prog("Seeding nutrition…", 0.55f)
                seedNutrition(token, userId, base, key, today);Log.d(TAG, "✓ Nutrition done")
                prog("Seeding migraines…", 0.70f)
                seedMigraines(token, userId, db, base, key, today); Log.d(TAG, "✓ Migraines done")
                prog("Setting risk score…", 0.85f)
                seedRiskScoreLive(token, userId, today)
                prog("All set!", 1.0f)
                _progress.value = SeedProgress("Ready!", 1f, true)
                _dataReady.value = true
                Log.d(TAG, "═══ seedDemoData COMPLETE ═══")
            } catch (e: Exception) {
                Log.e(TAG, "seedDemoData FAILED: ${e.message}", e)
                _progress.value = SeedProgress("Ready!", 1f, true)
                _dataReady.value = true
            }
        }
    }

    // ── Sleep: 30 days, bad sleep before migraines ───────────────────────

    private suspend fun seedSleep(token: String, m: SupabaseMetricsService, today: LocalDate) {
        for (i in 0 until DAYS) {
            val d = today.minusDays(i.toLong()).toString()
            val bad = isBadDay(i)
            try {
                val dur = if (bad) 4.0 + Random.nextDouble(1.5) else 6.5 + Random.nextDouble(2.0)
                val score = if (bad) 30.0 + Random.nextDouble(25.0) else 65.0 + Random.nextDouble(30.0)
                val eff = if (bad) 60.0 + Random.nextDouble(15.0) else 80.0 + Random.nextDouble(18.0)
                val dist = if (bad) 4 + Random.nextInt(5) else Random.nextInt(3)
                m.upsertSleepDurationDaily(token, d, dur, SOURCE, "$SOURCE-$i")
                m.upsertSleepScoreDaily(token, d, score, SOURCE, "$SOURCE-$i")
                m.upsertSleepEfficiencyDaily(token, d, eff, SOURCE, "$SOURCE-$i")
                m.upsertSleepDisturbancesDaily(token, d, dist, SOURCE, "$SOURCE-$i")
                val bH = if (bad) 0 + Random.nextInt(2) else 22 + Random.nextInt(1)
                val bM = Random.nextInt(60)
                val wH = if (bad) 5 + Random.nextInt(1) else 6 + Random.nextInt(2)
                val wM = Random.nextInt(60)
                m.upsertFellAsleepTimeDaily(token, d, "${d}T${bH.toString().padStart(2,'0')}:${bM.toString().padStart(2,'0')}:00", SOURCE, "$SOURCE-$i")
                m.upsertWokeUpTimeDaily(token, d, "${d}T${wH.toString().padStart(2,'0')}:${wM.toString().padStart(2,'0')}:00", SOURCE, "$SOURCE-$i")
            } catch (e: Exception) { Log.w(TAG, "Sleep $i: ${e.message}") }
        }
    }

    // ── Physical: 30 days, degraded HRV/recovery before migraines ────────

    private suspend fun seedPhysical(token: String, p: SupabasePhysicalHealthService, today: LocalDate) {
        for (i in 0 until DAYS) {
            val d = today.minusDays(i.toLong()).toString()
            val bad = isBadDay(i)
            try {
                p.upsertRecoveryScoreDaily(token, d, if (bad) 20.0+Random.nextDouble(25.0) else 55.0+Random.nextDouble(40.0), SOURCE, "$SOURCE-$i")
                p.upsertRestingHrDaily(token, d, if (bad) 62.0+Random.nextDouble(12.0) else 52.0+Random.nextDouble(10.0), SOURCE, "$SOURCE-$i")
                p.upsertHrvDaily(token, d, if (bad) 20.0+Random.nextDouble(20.0) else 45.0+Random.nextDouble(45.0), SOURCE, "$SOURCE-$i")
                p.upsertSpo2Daily(token, d, if (bad) 93.0+Random.nextDouble(3.0) else 96.0+Random.nextDouble(3.0), SOURCE, "$SOURCE-$i")
                p.upsertSkinTempDaily(token, d, if (bad) 34.0+Random.nextDouble(1.5) else 33.0+Random.nextDouble(1.0), SOURCE, "$SOURCE-$i")
            } catch (e: Exception) { Log.w(TAG, "Phys $i: ${e.message}") }
        }
    }

    // ── Screen time: 30 days, high screen on bad days ───────────────────

    private suspend fun seedScreenTime(token: String, p: SupabasePersonalService, today: LocalDate) {
        for (i in 0 until DAYS) {
            val d = today.minusDays(i.toLong()).toString()
            val bad = isBadDay(i)
            try { p.upsertScreenTimeDaily(token, d, if (bad) 6.0+Random.nextDouble(4.0) else 2.0+Random.nextDouble(3.0), SOURCE) }
            catch (e: Exception) { Log.w(TAG, "Screen $i: ${e.message}") }
        }
    }

    // ── Mental: stress, noise, phone metrics — 30 days ──────────────────

    private suspend fun seedMental(token: String, userId: String?, base: String, key: String, today: LocalDate) {
        if (userId.isNullOrBlank()) { Log.e(TAG, "No userId for mental"); return }
        val client = HttpClient()
        Log.d(TAG, "── seedMental: 30 days ──")
        try {
            for (i in 0 until DAYS) {
                val d = today.minusDays(i.toLong()).toString()
                val bad = isBadDay(i)
                upsertRow(client, "$base/rest/v1/stress_index_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId)
                        put("value", if (bad) 60.0+Random.nextDouble(35.0) else 15.0+Random.nextDouble(35.0))
                        put("hrv_z", if (bad) -2.0+Random.nextDouble(1.0) else -0.5+Random.nextDouble(2.0))
                        put("rhr_z", if (bad) 0.5+Random.nextDouble(1.5) else -1.0+Random.nextDouble(1.5))
                        put("baseline_window_days", 14)
                    })
                upsertRow(client, "$base/rest/v1/ambient_noise_index_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId); put("source",SOURCE)
                        put("value_index_pct", if (bad) 55.0+Random.nextDouble(40.0) else 10.0+Random.nextDouble(35.0))
                        put("samples_count", 10+Random.nextInt(50)); put("baseline_days", 14)
                        put("day_mean_lmean", if (bad) 50.0+Random.nextDouble(30.0) else 25.0+Random.nextDouble(25.0))
                    })
                upsertRow(client, "$base/rest/v1/screen_time_late_night", token, key, "user_id,date,source",
                    buildJsonObject {
                        put("date",d); put("user_id",userId); put("source",SOURCE)
                        put("value_hours", if (bad) 1.5+Random.nextDouble(2.5) else Random.nextDouble(1.0))
                    })
                upsertRow(client, "$base/rest/v1/phone_unlock_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId)
                        put("value_count", if (bad) 80+Random.nextInt(80) else 20+Random.nextInt(50))
                    })
                upsertRow(client, "$base/rest/v1/phone_brightness_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId)
                        put("value_mean", if (bad) 60.0+Random.nextDouble(35.0) else 25.0+Random.nextDouble(35.0))
                    })
                upsertRow(client, "$base/rest/v1/phone_volume_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId)
                        put("value_mean_pct", if (bad) 55.0+Random.nextDouble(40.0) else 15.0+Random.nextDouble(35.0))
                    })
                upsertRow(client, "$base/rest/v1/phone_dark_mode_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId)
                        put("value_hours", if (bad) 2.0+Random.nextDouble(4.0) else 8.0+Random.nextDouble(8.0))
                    })
            }
        } finally { client.close() }
    }

    // ── Weather: 30 days, pressure drops before migraines ───────────────

    private suspend fun seedWeather(token: String, userId: String?, base: String, key: String, today: LocalDate) {
        if (userId.isNullOrBlank()) { Log.e(TAG, "No userId for weather"); return }
        val client = HttpClient()
        Log.d(TAG, "── seedWeather: 30 days ──")
        try {
            // Delete existing to avoid RLS USING conflict
            try { client.delete("$base/rest/v1/user_weather_daily") {
                header("Authorization","Bearer $token"); header("apikey",key)
                parameter("user_id","eq.$userId")
            } } catch (_: Exception) {}

            for (i in 0 until DAYS) {
                val d = today.minusDays(i.toLong()).toString()
                val bad = isBadDay(i)
                upsertRow(client, "$base/rest/v1/user_weather_daily", token, key, "user_id,date",
                    buildJsonObject {
                        put("date",d); put("user_id",userId)
                        // Low pressure on bad days (classic migraine trigger)
                        put("temp_c_mean", if (bad) 5.0+Random.nextDouble(8.0) else 12.0+Random.nextDouble(12.0))
                        put("pressure_hpa_mean", if (bad) (980+Random.nextInt(15)).toDouble() else (1010+Random.nextInt(20)).toDouble())
                        put("humidity_pct_mean", if (bad) 75.0+Random.nextDouble(20.0) else 35.0+Random.nextDouble(30.0))
                        put("wind_speed_mps_mean", if (bad) 8.0+Random.nextDouble(10.0) else 1.0+Random.nextDouble(6.0))
                        put("uv_index_max", if (bad) 1.0+Random.nextDouble(2.0) else 3.0+Random.nextDouble(6.0))
                        put("weather_code", if (bad) listOf(45,61,63,80,95).random() else listOf(0,1,2,3).random())
                        put("is_thunderstorm_day", bad && Random.nextFloat() < 0.3f)
                    })
            }
        } finally { client.close() }
    }

    // ── Nutrition: 30-day daily + today records ──────────────────────────

    private suspend fun seedNutrition(token: String, userId: String?, base: String, key: String, today: LocalDate) {
        if (userId.isNullOrBlank()) { Log.e(TAG, "No userId for nutrition"); return }
        val client = HttpClient()
        Log.d(TAG, "── seedNutrition: 30 days ──")
        try {
            for (i in 0 until DAYS) {
                val d = today.minusDays(i.toLong()).toString()
                val bad = isBadDay(i)
                upsertRow(client, "$base/rest/v1/nutrition_daily", token, key, "user_id,source,date",
                    buildJsonObject {
                        put("date",d); put("source",SOURCE); put("user_id",userId)
                        put("total_calories", if (bad) 1200.0+Random.nextDouble(600.0) else 1800.0+Random.nextDouble(800.0))
                        put("total_protein_g", if (bad) 30.0+Random.nextDouble(30.0) else 60.0+Random.nextDouble(50.0))
                        put("total_carbs_g", if (bad) 200.0+Random.nextDouble(150.0) else 150.0+Random.nextDouble(100.0))
                        put("total_fat_g", if (bad) 50.0+Random.nextDouble(40.0) else 40.0+Random.nextDouble(30.0))
                        put("total_fiber_g", if (bad) 5.0+Random.nextDouble(8.0) else 15.0+Random.nextDouble(15.0))
                        put("total_sugar_g", if (bad) 60.0+Random.nextDouble(50.0) else 20.0+Random.nextDouble(30.0))
                        put("total_sodium_mg", if (bad) 2500.0+Random.nextDouble(1500.0) else 1000.0+Random.nextDouble(1000.0))
                        put("total_caffeine_mg", if (bad) 350.0+Random.nextDouble(200.0) else 50.0+Random.nextDouble(150.0))
                        put("total_saturated_fat_g",(80+Random.nextInt(200))/10.0)
                        put("total_unsaturated_fat_g",(150+Random.nextInt(350))/10.0)
                        put("total_trans_fat_g",Random.nextInt(30)/10.0)
                        put("total_cholesterol_mg",(100+Random.nextInt(300)).toDouble())
                        put("total_potassium_mg",(1500+Random.nextInt(3000)).toDouble())
                        put("total_calcium_mg",(400+Random.nextInt(800)).toDouble())
                        put("total_iron_mg",(50+Random.nextInt(150))/10.0)
                        put("total_magnesium_mg", if (bad) 80.0+Random.nextDouble(60.0) else 200.0+Random.nextDouble(200.0))
                        put("total_zinc_mg",(30+Random.nextInt(120))/10.0)
                        put("total_phosphorus_mg",(400+Random.nextInt(1000)).toDouble())
                        put("total_copper_mg",(3+Random.nextInt(15))/10.0)
                        put("total_manganese_mg",(5+Random.nextInt(40))/10.0)
                        put("total_selenium_mcg",(20+Random.nextInt(60)).toDouble())
                        put("total_vitamin_a_mcg",(200+Random.nextInt(1000)).toDouble())
                        put("total_vitamin_c_mg",(20+Random.nextInt(150)).toDouble())
                        put("total_vitamin_d_mcg",(20+Random.nextInt(300))/10.0)
                        put("total_vitamin_e_mg",(30+Random.nextInt(120))/10.0)
                        put("total_vitamin_k_mcg",(20+Random.nextInt(150)).toDouble())
                        put("total_vitamin_b6_mg",(5+Random.nextInt(40))/10.0)
                        put("total_vitamin_b12_mcg",(5+Random.nextInt(40))/10.0)
                        put("total_folate_mcg",(100+Random.nextInt(300)).toDouble())
                        put("total_niacin_mg",(50+Random.nextInt(250))/10.0)
                        put("total_riboflavin_mg",(3+Random.nextInt(25))/10.0)
                        put("total_thiamin_mg",(3+Random.nextInt(20))/10.0)
                        put("total_pantothenic_acid_mg",(10+Random.nextInt(80))/10.0)
                        put("total_biotin_mcg",(10+Random.nextInt(80)).toDouble())
                        put("max_tyramine_exposure", if (bad) 1+Random.nextInt(2) else 0)
                        put("max_gluten_exposure", if (bad) 1+Random.nextInt(2) else 0)
                    })
            }
            // Today's nutrition_records for Monitor card
            val meals = listOf(
                Triple("Oatmeal with berries", "breakfast", "08:00:00Z"),
                Triple("Grilled chicken salad", "lunch", "12:30:00Z"),
                Triple("Salmon with vegetables", "dinner", "19:00:00Z")
            )
            val cals = listOf(350.0, 520.0, 680.0)
            val prot = listOf(12.0, 35.0, 42.0)
            val carb = listOf(55.0, 30.0, 25.0)
            val fat = listOf(8.0, 18.0, 28.0)
            for (idx in meals.indices) {
                val (name, meal, time) = meals[idx]
                insertRow(client, "$base/rest/v1/nutrition_records", token, key,
                    buildJsonObject {
                        put("user_id", userId); put("food_name", name); put("meal_type", meal)
                        put("timestamp", "${today}T$time"); put("date", today.toString()); put("source", SOURCE)
                        put("calories", cals[idx]); put("protein", prot[idx])
                        put("total_carbohydrate", carb[idx]); put("total_fat", fat[idx])
                        put("dietary_fiber", 3.0+Random.nextDouble(8.0))
                        put("sugar", 5.0+Random.nextDouble(20.0))
                        put("sodium", 200.0+Random.nextDouble(600.0))
                        put("caffeine", if (idx==0) 95.0 else 0.0)
                        put("cholesterol", 20.0+Random.nextDouble(80.0))
                        put("potassium", 200.0+Random.nextDouble(500.0))
                        put("calcium", 50.0+Random.nextDouble(200.0))
                        put("iron", 1.0+Random.nextDouble(5.0))
                        put("magnesium", 20.0+Random.nextDouble(80.0))
                        put("vitamin_c", 5.0+Random.nextDouble(40.0))
                    })
            }
        } finally { client.close() }
    }

    // ── Migraines: 11 episodes with linked triggers, meds, reliefs ──────

    private suspend fun seedMigraines(token: String, userId: String?, db: SupabaseDbService, base: String, key: String, today: LocalDate) {
        if (userId.isNullOrBlank()) { Log.e(TAG, "No userId for migraines"); return }
        // Pre-delete all demo entries so triggers get proper migraine_id on re-run
        val client = HttpClient()
        try {
            for (t in listOf("triggers","medicines","reliefs","migraines")) {
                try { client.delete("$base/rest/v1/$t") {
                    header("Authorization","Bearer $token"); header("apikey",key)
                    parameter("notes","like.*[demo]*")
                } } catch (_: Exception) {}
            }
            Log.d(TAG, "✓ Cleared old demo migraines/triggers/medicines/reliefs")
        } catch (_: Exception) {}

        val types = listOf("migraine_with_aura","migraine_without_aura","tension_type")
        val triggerTypes = listOf(
            "Sleep duration low", "Pressure low", "Screen time high",
            "Stress high", "Caffeine high", "Humidity high", "Late screen time high"
        )

        for ((idx, entry) in MIGRAINE_DAYS.withIndex()) {
            val (daysAgo, severity) = entry
            val day = today.minusDays(daysAgo.toLong())
            val h = listOf(7,9,11,14,16,18).random()
            val dur = listOf(4,6,8,10,12).random()
            try {
                val m = db.insertMigraine(token, types[idx % types.size], severity,
                    "${day}T${h.toString().padStart(2,'0')}:00:00Z",
                    "${day}T${(h+dur).coerceAtMost(23).toString().padStart(2,'0')}:00:00Z",
                    "[demo] Episode ${idx+1}",
                    listOf("right_temple","behind_right_eye","forehead","left_temple").shuffled().take(2))

                // Link 2-3 triggers to each migraine (source=system so metrics auto-select on chart)
                val linked = triggerTypes.shuffled().take(2 + Random.nextInt(2))
                for (trig in linked) {
                    try {
                        upsertRow(client, "$base/rest/v1/triggers", token, key, "user_id,start_at,type",
                            buildJsonObject {
                                put("user_id", userId); put("type", trig); put("migraine_id", m.id)
                                put("start_at", "${day}T${(h-2).coerceAtLeast(4).toString().padStart(2,'0')}:00:00Z")
                                put("notes", "[demo]"); put("source", "system")
                            })
                    } catch (_: Exception) {}
                }

                // Medication for most migraines
                if (Random.nextFloat() < 0.8f) {
                    try { db.insertMedicine(token, m.id, null, null,
                        "${day}T${h.toString().padStart(2,'0')}:30:00Z", "[demo] Ibuprofen 400mg") } catch (_: Exception) {}
                }

                // Relief for some
                if (Random.nextFloat() < 0.6f) {
                    try { db.insertRelief(token, m.id, null,
                        "${day}T${(h+1).toString().padStart(2,'0')}:00:00Z", "[demo] Dark room + cold compress") } catch (_: Exception) {}
                }

                Log.d(TAG, "✓ Migraine ${idx+1}/${MIGRAINE_DAYS.size} on $day (sev=$severity)")
            } catch (e: Exception) { Log.w(TAG, "Migraine $idx: ${e.message}") }
        }

        // Standalone trigger observations on bad days
        for (i in 0 until DAYS) {
            val d = today.minusDays(i.toLong())
            if (isBadDay(i)) {
                val trig = triggerTypes.random()
                try { upsertRow(client, "$base/rest/v1/triggers", token, key, "user_id,start_at,type",
                    buildJsonObject {
                        put("user_id", userId); put("type", trig)
                        put("start_at", "${d}T12:00:00Z")
                        put("notes", "[demo]"); put("source", "system")
                    }) } catch (_: Exception) {}
            }
        }
        client.close()
    }

    // ── Risk score live ──────────────────────────────────────────────────

    private suspend fun seedRiskScoreLive(token: String, userId: String?, today: LocalDate) {
        if (userId.isNullOrBlank()) { Log.e(TAG, "No userId for risk"); return }
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val key = BuildConfig.SUPABASE_ANON_KEY
        val client = HttpClient()
        try {
            val trigs = buildJsonArray {
                add(buildJsonObject { put("name","Sleep duration low"); put("score",4); put("severity","HIGH"); put("daysActive",5) })
                add(buildJsonObject { put("name","Pressure low"); put("score",3); put("severity","MILD"); put("daysActive",4) })
                add(buildJsonObject { put("name","Screen time high"); put("score",2); put("severity","MILD"); put("daysActive",3) })
                add(buildJsonObject { put("name","Caffeine high"); put("score",2); put("severity","MILD"); put("daysActive",2) })
            }
            val pcts = listOf(52,40,30,45,35,25,20)
            val forecast = buildJsonArray { pcts.forEach { add(it) } }
            val dayRisks = buildJsonArray {
                for (i in 0 until 7) {
                    val d = today.plusDays(i.toLong()); val p = pcts[i]
                    val z = when { p>=60->"HIGH"; p>=30->"MILD"; p>=10->"LOW"; else->"NONE" }
                    add(buildJsonObject { put("date",d.toString()); put("score",p/10.0); put("zone",z); put("percent",p); put("top_triggers",trigs) })
                }
            }
            val payload = buildJsonObject {
                put("user_id", userId); put("score",5.2); put("zone","MILD"); put("percent",52)
                put("top_triggers",trigs); put("forecast",forecast); put("day_risks",dayRisks)
                put("updated_at", java.time.Instant.now().toString())
            }
            val r = client.post("$base/rest/v1/risk_score_live") {
                header("Authorization","Bearer $token"); header("apikey",key)
                header("Prefer","resolution=merge-duplicates,return=representation")
                parameter("on_conflict","user_id")
                contentType(ContentType.Application.Json)
                setBody(JsonArray(listOf(payload)).toString())
            }
            val body = r.bodyAsText()
            Log.d(TAG, "risk_score_live: ${r.status} → ${body.take(200)}")
            if (r.status.isSuccess() && body != "[]") Log.d(TAG, "✓ Risk score set")
            else Log.e(TAG, "✗ Risk score failed or empty")
        } catch (e: Exception) { Log.e(TAG, "risk: ${e.message}", e) }
        finally { client.close() }
    }

    // ── Clear ALL ───────────────────────────────────────────────────────

    suspend fun clearDemoData(context: Context) {
        val ctx = context.applicationContext
        val token = SessionStore.getValidAccessToken(ctx) ?: return
        val base = BuildConfig.SUPABASE_URL.trimEnd('/'); val key = BuildConfig.SUPABASE_ANON_KEY
        val userId = SessionStore.readUserId(ctx) ?: JwtUtils.extractUserIdFromAccessToken(token)
        Log.d(TAG, "═══ clearDemoData START ═══")
        val sourceTables = listOf("sleep_duration_daily","sleep_score_daily","sleep_efficiency_daily","sleep_disturbances_daily","fell_asleep_time_daily","woke_up_time_daily","recovery_score_daily","resting_hr_daily","hrv_daily","spo2_daily","skin_temp_daily","screen_time_daily","nutrition_daily","nutrition_records")
        val userIdTables = listOf("stress_index_daily","ambient_noise_index_daily","screen_time_late_night","phone_unlock_daily","phone_brightness_daily","phone_volume_daily","phone_dark_mode_daily","user_weather_daily")
        val notesTables = listOf("migraines","medicines","reliefs","triggers")
        withContext(Dispatchers.IO) {
            val client = HttpClient()
            try {
                for (t in sourceTables) { try { client.delete("$base/rest/v1/$t") { header("Authorization","Bearer $token"); header("apikey",key); parameter("source","eq.$SOURCE") } } catch (_: Exception) {} }
                // userIdTables: ambient_noise & screen_time_late_night have source column; rest are app-only sensors (no WHOOP data)
                val userIdWithSource = listOf("ambient_noise_index_daily","screen_time_late_night")
                val userIdNoSource = listOf("stress_index_daily","phone_unlock_daily","phone_brightness_daily","phone_volume_daily","phone_dark_mode_daily","user_weather_daily")
                for (t in userIdWithSource) { try { client.delete("$base/rest/v1/$t") { header("Authorization","Bearer $token"); header("apikey",key); parameter("source","eq.$SOURCE") } } catch (_: Exception) {} }
                for (t in userIdNoSource) { try { client.delete("$base/rest/v1/$t") { header("Authorization","Bearer $token"); header("apikey",key); parameter("user_id","eq.$userId") } } catch (_: Exception) {} }
                for (t in notesTables) { try { client.delete("$base/rest/v1/$t") { header("Authorization","Bearer $token"); header("apikey",key); parameter("notes","like.*[demo]*") } } catch (_: Exception) {} }
                // Also delete auto-generated system triggers/prodromes (created by edge function from demo metrics)
                try { client.delete("$base/rest/v1/triggers") { header("Authorization","Bearer $token"); header("apikey",key); parameter("source","eq.system") } } catch (_: Exception) {}
                try { client.delete("$base/rest/v1/prodromes") { header("Authorization","Bearer $token"); header("apikey",key); parameter("source","eq.system") } } catch (_: Exception) {}
                if (!userId.isNullOrBlank()) { try {
                    val payload = buildJsonObject { put("user_id",userId); put("score",0); put("zone","NONE"); put("percent",0); put("top_triggers",JsonNull); put("forecast",JsonNull); put("day_risks",JsonNull); put("updated_at",java.time.Instant.now().toString()) }
                    client.post("$base/rest/v1/risk_score_live") { header("Authorization","Bearer $token"); header("apikey",key); header("Prefer","resolution=merge-duplicates,return=minimal"); parameter("on_conflict","user_id"); contentType(ContentType.Application.Json); setBody(JsonArray(listOf(payload)).toString()) }
                } catch (_: Exception) {} }
                Log.d(TAG, "═══ clearDemoData COMPLETE ═══")
                markCleared(ctx); _dataReady.value = false; _progress.value = SeedProgress()
            } finally { client.close() }
        }
    }

    suspend fun ensureDemoCleared(context: Context) {
        if (isDemoCleared(context.applicationContext)) return
        clearDemoData(context)
    }
}

title: DeterministicMapper.kt
text:
package com.migraineme

/**
 * DeterministicMapper — Maps questionnaire answers to trigger/prodrome
 * severities AND personalized thresholds. Pure logic, no network, fully testable.
 *
 * Flow:
 *   1. Template defaults define CENTER and DELTA for each paired metric
 *   2. Demographics shift the CENTER (gender × age)
 *   3. Questionnaire answers override specific centers
 *   4. Certainty multipliers tighten/loosen the DELTA (sensitivity)
 *   5. Thresholds: low = center - delta, high = center + delta
 *   6. Certainty → severity (Every time→HIGH, Often→MILD, Sometimes→LOW)
 *
 * Band-based threshold generation guarantees low < high always.
 */
object DeterministicMapper {

    // ═════════════════════════════════════════════════════════════════════
    // Certainty Scale
    // ═════════════════════════════════════════════════════════════════════

    enum class Certainty { EVERY_TIME, OFTEN, SOMETIMES, RARELY, NO }

    fun certaintyToSeverity(c: Certainty): String = when (c) {
        Certainty.EVERY_TIME -> "HIGH"
        Certainty.OFTEN      -> "MILD"
        Certainty.SOMETIMES  -> "LOW"
        Certainty.RARELY     -> "LOW"
        Certainty.NO         -> "NONE"
    }

    fun downgrade(c: Certainty): Certainty = when (c) {
        Certainty.EVERY_TIME -> Certainty.OFTEN
        Certainty.OFTEN      -> Certainty.SOMETIMES
        Certainty.SOMETIMES  -> Certainty.RARELY
        Certainty.RARELY     -> Certainty.NO
        Certainty.NO         -> Certainty.NO
    }

    // ═════════════════════════════════════════════════════════════════════
    // Certainty → Delta Multiplier (sensitivity)
    // ═════════════════════════════════════════════════════════════════════

    /**
     * Controls how wide the band is around "normal".
     * EVERY_TIME → 0.60 (narrow band = fires sooner, more sensitive)
     * NO         → 1.40 (wide band = fires later, less sensitive)
     *
     * This multiplier is applied to the delta (half-range), NOT to the
     * threshold itself. This prevents threshold crossing.
     */
    fun sensitivityDeltaMultiplier(c: Certainty): Double = when (c) {
        Certainty.EVERY_TIME -> 0.60
        Certainty.OFTEN      -> 0.80
        Certainty.SOMETIMES  -> 1.00
        Certainty.RARELY     -> 1.20
        Certainty.NO         -> 1.40
    }

    /** Exposure triggers: 1=fires at low+, 2=medium+, 3=high only */
    fun exposureThreshold(c: Certainty): Int = when (c) {
        Certainty.EVERY_TIME -> 1; Certainty.OFTEN -> 1
        Certainty.SOMETIMES  -> 2; Certainty.RARELY -> 3; Certainty.NO -> 4
    }

    // ═════════════════════════════════════════════════════════════════════
    // TEMPLATE DEFAULTS — exact values from trigger_templates DB
    // These define the DEFAULT band endpoints.
    // Center = (high + low) / 2, Delta = (high - low) / 2
    // ═════════════════════════════════════════════════════════════════════

    private val TEMPLATE_DEFAULTS = mapOf(
        // Body
        "Blood glucose high" to 180.0, "Blood glucose low" to 70.0,
        "Blood pressure high" to 140.0, "Blood pressure low" to 90.0,
        "Body fat high" to 35.0, "Body fat low" to 8.0,
        "High HR zones high" to 120.0, "High HR zones low" to 5.0,
        "Recovery high" to 85.0, "Recovery low" to 33.0,
        "Steps high" to 25000.0, "Steps low" to 3000.0,
        "Stress high" to 75.0, "Stress low" to 10.0,
        "Weight high" to 120.0, "Weight low" to 45.0,
        // Cognitive
        "Late screen time high" to 2.0, "Late screen time low" to 0.0,
        "Noise high" to 75.0, "Noise low" to 30.0,
        "Screen time high" to 8.0, "Screen time low" to 0.5,
        // Diet
        "Alcohol exposure high" to 1.0, "Alcohol exposure low" to 0.0,
        "Biotin high" to 100.0, "Biotin low" to 10.0,
        "Caffeine high" to 400.0, "Caffeine low" to 50.0,
        "Calcium high" to 1500.0, "Calcium low" to 300.0,
        "Calories high" to 3000.0, "Calories low" to 1200.0,
        "Carbs high" to 400.0, "Carbs low" to 100.0,
        "Cholesterol high" to 400.0, "Cholesterol low" to 100.0,
        "Copper high" to 2.0, "Copper low" to 0.3,
        "Fat high" to 120.0, "Fat low" to 30.0,
        "Fibre high" to 50.0, "Fibre low" to 10.0,
        "Folate high" to 600.0, "Folate low" to 100.0,
        "Gluten exposure high" to 1.0, "Gluten exposure low" to 0.0,
        "Iron high" to 25.0, "Iron low" to 5.0,
        "Magnesium high" to 500.0, "Magnesium low" to 100.0,
        "Manganese high" to 5.0, "Manganese low" to 0.5,
        "Niacin high" to 30.0, "Niacin low" to 5.0,
        "Pantothenic acid high" to 10.0, "Pantothenic acid low" to 1.0,
        "Phosphorus high" to 1500.0, "Phosphorus low" to 300.0,
        "Potassium high" to 5000.0, "Potassium low" to 1000.0,
        "Protein high" to 150.0, "Protein low" to 30.0,
        "Riboflavin high" to 3.0, "Riboflavin low" to 0.3,
        "Saturated fat high" to 25.0, "Saturated fat low" to 5.0,
        "Selenium high" to 100.0, "Selenium low" to 20.0,
        "Sodium high" to 3000.0, "Sodium low" to 500.0,
        "Sugar high" to 80.0, "Sugar low" to 10.0,
        "Thiamin high" to 3.0, "Thiamin low" to 0.3,
        "Trans fat high" to 3.0, "Trans fat low" to 0.0,
        "Tyramine exposure high" to 1.0, "Tyramine exposure low" to 0.0,
        "Unsaturated fat high" to 80.0, "Unsaturated fat low" to 10.0,
        "Vitamin A high" to 1500.0, "Vitamin A low" to 200.0,
        "Vitamin B12 high" to 5.0, "Vitamin B12 low" to 0.5,
        "Vitamin B6 high" to 5.0, "Vitamin B6 low" to 0.5,
        "Vitamin C high" to 200.0, "Vitamin C low" to 20.0,
        "Vitamin D high" to 50.0, "Vitamin D low" to 5.0,
        "Vitamin E high" to 20.0, "Vitamin E low" to 3.0,
        "Vitamin K high" to 200.0, "Vitamin K low" to 20.0,
        "Zinc high" to 15.0, "Zinc low" to 3.0,
        // Environment
        "Altitude change high" to 500.0, "Altitude change low" to 0.0,
        "Altitude high" to 2500.0, "Altitude low" to 0.0,
        "Humidity high" to 80.0, "Humidity low" to 20.0,
        "Pressure high" to 1030.0, "Pressure low" to 990.0,
        "Temperature high" to 35.0, "Temperature low" to 5.0,
        "UV index high" to 8.0, "UV index low" to 1.0,
        "Wind speed high" to 15.0, "Wind speed low" to 1.0,
        // Sleep
        "Bedtime early" to 21.0, "Bedtime late" to 1.0,
        "Deep sleep high" to 3.0, "Deep sleep low" to 0.5,
        "Light sleep high" to 5.0, "Light sleep low" to 1.0,
        "REM sleep high" to 3.5, "REM sleep low" to 0.5,
        "Sleep disturbances high" to 5.0, "Sleep disturbances low" to 1.0,
        "Sleep duration high" to 10.0, "Sleep duration low" to 6.0,
        "Sleep efficiency high" to 98.0, "Sleep efficiency low" to 80.0,
        "Sleep score high" to 95.0, "Sleep score low" to 60.0,
        "Wake time early" to 5.0, "Wake time late" to 10.0,
    )

    /** Prodrome template defaults from prodrome_templates DB */
    private val PRODROME_DEFAULTS = mapOf(
        // Physical
        "HRV high" to 150.0, "HRV low" to 20.0,
        "Resting HR high" to 100.0, "Resting HR low" to 40.0,
        "Resp rate high" to 22.0, "Resp rate low" to 10.0,
        "Skin temp high" to 38.0, "Skin temp low" to 35.0,
        "SpO2 high" to 100.0, "SpO2 low" to 95.0,
        // Sensory (phone)
        "Brightness high" to 80.0, "Brightness low" to 20.0,
        "Dark mode high" to 14.0, "Dark mode low" to 2.0,
        "Phone unlocks high" to 150.0, "Phone unlocks low" to 10.0,
        "Volume high" to 80.0, "Volume low" to 20.0,
    )

    // ═════════════════════════════════════════════════════════════════════
    // Band Calculation — Center + Delta
    // ═════════════════════════════════════════════════════════════════════

    /**
     * Given the current (possibly personalized) defaults map, extract the
     * center and delta for a metric base name.
     *
     * E.g. for baseName="Pressure":
     *   highDefault = d["Pressure high"] = 1030
     *   lowDefault  = d["Pressure low"]  = 990
     *   center = 1010, delta = 20
     */
    private data class Band(val center: Double, val delta: Double)

    private fun bandFor(baseName: String, d: Map<String, Double>): Band? {
        val hi = d["$baseName high"] ?: return null
        val lo = d["$baseName low"] ?: return null
        val center = (hi + lo) / 2.0
        val delta = (hi - lo) / 2.0
        return Band(center, delta.coerceAtLeast(0.01)) // delta must be positive
    }

    /**
     * Compute threshold for the "high" direction using band approach.
     * high_threshold = center + delta * sensitivityMultiplier
     *
     * More certain → smaller multiplier → tighter band → fires sooner
     */
    private fun bandHigh(baseName: String, d: Map<String, Double>, cert: Certainty): Double? {
        val band = bandFor(baseName, d) ?: return d["$baseName high"]
        return band.center + band.delta * sensitivityDeltaMultiplier(cert)
    }

    /**
     * Compute threshold for the "low" direction using band approach.
     * low_threshold = center - delta * sensitivityMultiplier
     *
     * More certain → smaller multiplier → tighter band → fires sooner
     */
    private fun bandLow(baseName: String, d: Map<String, Double>, cert: Certainty): Double? {
        val band = bandFor(baseName, d) ?: return d["$baseName low"]
        return band.center - band.delta * sensitivityDeltaMultiplier(cert)
    }

    /**
     * For metrics that only have a "high" trigger (no paired low), or only
     * a "low" trigger, we can still use band-based if a pair exists.
     * Falls back to the old default value if no pair found.
     */
    private fun singleHigh(label: String, d: Map<String, Double>, cert: Certainty): Double? {
        val baseName = label.removeSuffix(" high")
        return bandHigh(baseName, d, cert)
    }

    private fun singleLow(label: String, d: Map<String, Double>, cert: Certainty): Double? {
        val baseName = label.removeSuffix(" low")
        return bandLow(baseName, d, cert)
    }

    // ═════════════════════════════════════════════════════════════════════
    // DEMOGRAPHIC PERSONALIZATION — shifts CENTER
    // ═════════════════════════════════════════════════════════════════════

    private fun personalizeDefaults(gender: String?, ageRange: String?): MutableMap<String, Double> {
        val d = TEMPLATE_DEFAULTS.toMutableMap()

        // ── Gender — shifts the center of what's "normal" ──
        when (gender) {
            "Female" -> {
                // Metabolism & body composition
                d["Calories high"] = 2200.0
                d["Calories low"] = 1400.0
                d["Protein high"] = 110.0
                d["Fat high"] = 90.0
                d["Saturated fat high"] = 20.0
                d["Carbs high"] = 320.0
                d["Sodium high"] = 2300.0
                // Body
                d["Weight high"] = 90.0
                d["Weight low"] = 48.0
                d["Body fat low"] = 18.0
                d["Blood pressure high"] = 130.0
                d["Steps high"] = 20000.0
                d["High HR zones high"] = 100.0
                // Micronutrients
                d["Iron low"] = 8.0
                d["Folate low"] = 150.0
                d["Calcium low"] = 400.0
                // Caffeine
                d["Caffeine high"] = 300.0
            }
            "Male" -> {
                d["Body fat high"] = 28.0
                d["Iron high"] = 20.0
            }
        }

        // ── Age — shifts the center of what's "normal" ──
        when (ageRange) {
            "18-25" -> {
                adjustBothEndpoints(d, "Calories", highMul = 1.10, lowMul = 1.05)
                adjustBothEndpoints(d, "Steps", highMul = 1.10)
                adjustBothEndpoints(d, "Protein", highMul = 1.05)
                adjustBothEndpoints(d, "Blood pressure", highMul = 0.93, lowMul = 0.95)
                d["Sleep duration low"] = 6.5
                d["Bedtime late"] = 2.0
                d["Wake time late"] = 11.0
                adjustBothEndpoints(d, "Caffeine", highMul = 0.90)
            }
            "26-35" -> {
                adjustBothEndpoints(d, "Calories", highMul = 1.03)
                adjustBothEndpoints(d, "Steps", highMul = 1.05)
            }
            "46-55" -> {
                adjustBothEndpoints(d, "Calories", highMul = 0.93)
                adjustBothEndpoints(d, "Steps", highMul = 0.85)
                adjustBothEndpoints(d, "Blood pressure", highMul = 1.04)
                adjustBothEndpoints(d, "Caffeine", highMul = 0.85)
                d["Recovery low"] = 30.0
                d["Sleep duration low"] = 5.5
                d["Bedtime late"] = 0.5
                if (gender == "Female") {
                    d["Iron low"] = 5.0
                    d["Folate low"] = 100.0
                }
            }
            "56+" -> {
                adjustBothEndpoints(d, "Calories", highMul = 0.85, lowMul = 0.95)
                adjustBothEndpoints(d, "Steps", highMul = 0.70)
                adjustBothEndpoints(d, "Blood pressure", highMul = 1.07)
                adjustBothEndpoints(d, "Caffeine", highMul = 0.75)
                d["Recovery low"] = 28.0
                d["Sleep duration low"] = 5.5
                d["Sleep duration high"] = 9.0
                d["Bedtime late"] = 0.0
                d["Bedtime early"] = 20.0
                d["Wake time early"] = 4.5
                adjustBothEndpoints(d, "High HR zones", highMul = 0.75)
                if (gender == "Female") {
                    d["Iron low"] = 5.0
                    d["Folate low"] = 100.0
                    d["Calcium low"] = 500.0
                    d["Vitamin D low"] = 10.0
                }
            }
        }

        return d
    }

    /**
     * Helper: when demographics shift a metric, we adjust the band endpoints
     * symmetrically so the CENTER moves but the relative range stays coherent.
     *
     * If only highMul is given, we shift the high endpoint.
     * If only lowMul is given, we shift the low endpoint.
     * Both can be provided.
     *
     * This keeps the defaults map in the same format (keyed by "X high"/"X low")
     * while ensuring the demographic adjustment shifts center, not just one side.
     */
    private fun adjustBothEndpoints(d: MutableMap<String, Double>, baseName: String, highMul: Double? = null, lowMul: Double? = null) {
        highMul?.let { d["$baseName high"] = d["$baseName high"]!! * it }
        lowMul?.let { d["$baseName low"] = d["$baseName low"]!! * it }
    }

    /** Adjusts prodrome template defaults for demographics — shifts CENTER */
    private fun personalizeProdromeDefaults(gender: String?, ageRange: String?): MutableMap<String, Double> {
        val pd = PRODROME_DEFAULTS.toMutableMap()

        // ── Gender — HRV and resting HR differ ──
        when (gender) {
            "Female" -> {
                pd["HRV low"] = 22.0           // slightly higher baseline HRV
                pd["Resting HR high"] = 95.0   // slightly lower ceiling
            }
            "Male" -> {
                pd["HRV low"] = 18.0           // slightly lower baseline
                pd["Resting HR low"] = 38.0    // athletes can be lower
            }
        }

        // ── Age — HRV decreases significantly, HR increases ──
        when (ageRange) {
            "18-25" -> {
                pd["HRV high"] = 180.0         // young adults have high HRV
                pd["HRV low"] = pd["HRV low"]!! * 1.20   // higher floor
                pd["Resting HR high"] = 95.0   // slightly lower
                pd["Resting HR low"] = 45.0    // higher floor
            }
            "26-35" -> {
                pd["HRV high"] = 160.0
                pd["HRV low"] = pd["HRV low"]!! * 1.10
            }
            "46-55" -> {
                pd["HRV high"] = 120.0         // HRV declines
                pd["HRV low"] = pd["HRV low"]!! * 0.85
                pd["Resting HR high"] = 95.0
                pd["SpO2 low"] = 94.0          // slightly lower OK
            }
            "56+" -> {
                pd["HRV high"] = 100.0         // significant decline
                pd["HRV low"] = pd["HRV low"]!! * 0.75
                pd["Resting HR high"] = 90.0   // lower ceiling
                pd["SpO2 low"] = 93.0          // age-adjusted
                pd["Resp rate high"] = 20.0    // slightly tighter
            }
        }

        return pd
    }

    // ═════════════════════════════════════════════════════════════════════
    // Data Classes
    // ═════════════════════════════════════════════════════════════════════

    data class QuestionnaireAnswers(
        // Page 1 — Demographics & Migraine Profile
        val gender: String? = null,
        val ageRange: String? = null,
        val frequency: String? = null,
        val duration: String? = null,
        val experience: String? = null,
        val trajectory: String? = null,
        val warningSignsBefore: String? = null,
        val triggerDelay: String? = null,
        val dailyRoutine: String? = null,
        val seasonalPattern: String? = null,
        // Page 2 — Sleep
        val sleepHours: String? = null,
        val sleepQuality: String? = null,
        val poorSleepQualityTriggers: Certainty = Certainty.NO,
        val tooLittleSleepTriggers: Certainty = Certainty.NO,
        val oversleepTriggers: Certainty = Certainty.NO,
        val sleepIssues: Set<String> = emptySet(),
        // Page 3 — Stress & Screen
        val stressLevel: String? = null,
        val stressChangeTriggers: Certainty = Certainty.NO,
        val emotionalPatterns: Map<String, Certainty> = emptyMap(),
        val screenTimeDaily: String? = null,
        val screenTimeTriggers: Certainty = Certainty.NO,
        val lateScreenTriggers: Certainty = Certainty.NO,
        // Page 4 — Diet
        val caffeineIntake: String? = null,
        val caffeineDirection: String? = null,
        val caffeineCertainty: Certainty = Certainty.NO,
        val alcoholFrequency: String? = null,
        val alcoholTriggers: Certainty = Certainty.NO,
        val specificDrinks: Set<String> = emptySet(),
        val tyramineFoods: Map<String, Certainty> = emptyMap(),
        val glutenSensitivity: String? = null,
        val glutenTriggers: Certainty = Certainty.NO,
        val eatingPatterns: Map<String, Certainty> = emptyMap(),
        val waterIntake: String? = null,
        val tracksNutrition: String? = null,
        // Page 5 — Weather, Environment, Physical
        val weatherTriggers: Certainty = Certainty.NO,
        val specificWeather: Map<String, Certainty> = emptyMap(),
        val environmentSensitivities: Map<String, Certainty> = emptyMap(),
        val physicalFactors: Map<String, Certainty> = emptyMap(),
        // Page 6 — Exercise & Hormones
        val exerciseFrequency: String? = null,
        val exerciseTriggers: Certainty = Certainty.NO,
        val exercisePattern: Set<String> = emptySet(),
        val tracksCycle: String? = null,
        val cyclePatterns: Map<String, Certainty> = emptyMap(),
        val usesContraception: String? = null,
        val contraceptionEffect: String? = null,
        // Page 7 — Prodromes
        val physicalProdromes: Map<String, Certainty> = emptyMap(),
        val moodProdromes: Map<String, Certainty> = emptyMap(),
        val sensoryProdromes: Map<String, Certainty> = emptyMap(),
        // Page 8
        val selectedMigraineTypes: Set<String> = emptySet(),
        val selectedSymptoms: Set<String> = emptySet(),
        val selectedMedicines: Set<String> = emptySet(),
        val selectedReliefs: Set<String> = emptySet(),
        val selectedActivities: Set<String> = emptySet(),
        val selectedMissedActivities: Set<String> = emptySet(),
        val freeText: String? = null,
    )

    data class TriggerSetting(
        val label: String,
        val severity: String,
        val threshold: Double? = null,
        val exposureLevel: Int? = null,
        val favorite: Boolean = false,
    )

    data class ProdromeSetting(val label: String, val severity: String, val threshold: Double? = null, val favorite: Boolean = false)

    data class MappingResult(
        val triggers: Map<String, TriggerSetting>,
        val prodromes: Map<String, ProdromeSetting>,
        val favorites: Favorites,
        val profileContext: ProfileContext,
    )

    data class Favorites(
        val triggers: List<String>, val prodromes: List<String>,
        val symptoms: List<String>, val medicines: List<String>,
        val reliefs: List<String>, val activities: List<String>,
        val missedActivities: List<String>,
    )

    data class ProfileContext(
        val gender: String?, val ageRange: String?,
        val frequency: String?, val duration: String?,
        val experience: String?, val trajectory: String?,
        val warningSignsBefore: String?, val triggerDelay: String?,
        val dailyRoutine: String?, val seasonalPattern: String?,
    )

    // ═════════════════════════════════════════════════════════════════════
    // Questionnaire → Override baselines (shifts CENTER)
    // ═════════════════════════════════════════════════════════════════════

    private fun sleepDurationCenter(hours: String?): Double? = when (hours) {
        "< 5h" -> 4.5; "5-6h" -> 5.5; "6-7h" -> 6.5
        "7-8h" -> 7.5; "8-9h" -> 8.5; "9+h" -> 9.5; else -> null
    }
    private fun caffeineMgCenter(intake: String?): Double? = when (intake) {
        "None" -> 30.0; "1-2 cups" -> 175.0; "3-4 cups" -> 350.0; "5+ cups" -> 500.0; else -> null
    }
    private fun screenTimeHoursCenter(daily: String?): Double? = when (daily) {
        "< 2h" -> 1.5; "2-4h" -> 3.0; "4-8h" -> 6.0; "8-12h" -> 10.0; "12h+" -> 13.0; else -> null
    }
    private fun stressIndexCenter(level: String?): Double? = when (level) {
        "Low" -> 25.0; "Moderate" -> 50.0; "High" -> 70.0; "Very high" -> 85.0; else -> null
    }
    private fun stepsCenter(frequency: String?): Double? = when (frequency) {
        "Daily" -> 12000.0; "Few times/week" -> 8000.0; "Weekly" -> 6000.0
        "Rarely" -> 4000.0; "Never" -> 2000.0; else -> null
    }

    /**
     * Override defaults for a metric pair by shifting the CENTER while
     * preserving the default delta (half-range).
     *
     * E.g. if user sleeps 5-6h (center=5.5), and template has
     * Sleep duration high=10, low=6 → default delta=2.0
     * New: high = 5.5 + 2.0 = 7.5, low = 5.5 - 2.0 = 3.5
     */
    private fun overrideCenterPreserveDelta(d: MutableMap<String, Double>, baseName: String, newCenter: Double) {
        val hi = d["$baseName high"] ?: return
        val lo = d["$baseName low"] ?: return
        val delta = (hi - lo) / 2.0
        d["$baseName high"] = newCenter + delta
        d["$baseName low"] = newCenter - delta
    }

    /**
     * For metrics where the user-reported value IS the relevant threshold
     * (e.g. caffeine intake — the threshold is near their normal intake),
     * we set both endpoints relative to that value with a reasonable range.
     */
    private fun overrideCenterWithRange(d: MutableMap<String, Double>, baseName: String, newCenter: Double, halfRange: Double) {
        d["$baseName high"] = newCenter + halfRange
        d["$baseName low"] = newCenter - halfRange
    }

    // ═════════════════════════════════════════════════════════════════════
    // MAIN ENTRY POINT
    // ═════════════════════════════════════════════════════════════════════

    fun map(answers: QuestionnaireAnswers, enabledMetrics: Map<String, Boolean> = emptyMap()): MappingResult {
        // 1) Personalize defaults for demographics (shifts CENTER)
        val d = personalizeDefaults(answers.gender, answers.ageRange)
        val pd = personalizeProdromeDefaults(answers.gender, answers.ageRange)

        // 2) Override with user-reported specifics (shifts CENTER)
        sleepDurationCenter(answers.sleepHours)?.let {
            overrideCenterPreserveDelta(d, "Sleep duration", it)
        }
        caffeineMgCenter(answers.caffeineIntake)?.let {
            // Caffeine: center at their intake, ±30% range
            overrideCenterWithRange(d, "Caffeine", it, it * 0.30)
        }
        screenTimeHoursCenter(answers.screenTimeDaily)?.let {
            // Screen time: center at their usage, ±2h range
            overrideCenterWithRange(d, "Screen time", it, 2.0)
        }
        stressIndexCenter(answers.stressLevel)?.let {
            // Stress: center at their level, ±20 range
            overrideCenterWithRange(d, "Stress", it, 20.0)
        }
        stepsCenter(answers.exerciseFrequency)?.let {
            // Steps: center at their typical, ±40% range
            overrideCenterWithRange(d, "Steps", it, it * 0.40)
        }

        // 3) Map everything
        val triggers = mutableMapOf<String, TriggerSetting>()
        val prodromes = mutableMapOf<String, ProdromeSetting>()

        mapSleep(answers, d, triggers)
        mapStressAndScreen(answers, d, triggers)
        mapDiet(answers, d, triggers)
        mapEnvironment(answers, d, triggers)
        mapPhysical(answers, triggers)
        mapExercise(answers, d, triggers)
        mapHormones(answers, triggers)
        mapConnectedMetrics(enabledMetrics, d, pd, triggers, prodromes)
        mapProdromes(answers, pd, prodromes)

        return MappingResult(
            triggers, prodromes, buildFavorites(answers, triggers, prodromes),
            ProfileContext(answers.gender, answers.ageRange, answers.frequency, answers.duration,
                answers.experience, answers.trajectory, answers.warningSignsBefore,
                answers.triggerDelay, answers.dailyRoutine, answers.seasonalPattern),
        )
    }

    // ═════════════════════════════════════════════════════════════════════
    // Threshold helpers: high/low/manual — NOW BAND-BASED
    // ═════════════════════════════════════════════════════════════════════

    /**
     * Create a "high" trigger with band-based threshold.
     * The label is expected to end in " high" (e.g. "Pressure high").
     */
    private fun trigHigh(label: String, sev: String, d: Map<String, Double>, cert: Certainty, fav: Boolean = false) =
        TriggerSetting(label, sev, singleHigh(label, d, cert), favorite = fav)

    /**
     * Create a "low" trigger with band-based threshold.
     * The label is expected to end in " low" (e.g. "Pressure low").
     */
    private fun trigLow(label: String, sev: String, d: Map<String, Double>, cert: Certainty, fav: Boolean = false) =
        TriggerSetting(label, sev, singleLow(label, d, cert), favorite = fav)

    private fun trigManual(label: String, sev: String, fav: Boolean = false) =
        TriggerSetting(label, sev, favorite = fav)

    /**
     * Create a "high" prodrome with band-based threshold.
     */
    private fun prodHigh(label: String, sev: String, pd: Map<String, Double>, cert: Certainty, fav: Boolean = false) =
        ProdromeSetting(label, sev, singleHigh(label, pd, cert), favorite = fav)

    /**
     * Create a "low" prodrome with band-based threshold.
     */
    private fun prodLow(label: String, sev: String, pd: Map<String, Double>, cert: Certainty, fav: Boolean = false) =
        ProdromeSetting(label, sev, singleLow(label, pd, cert), favorite = fav)

    private fun prodManual(label: String, sev: String, fav: Boolean = false) =
        ProdromeSetting(label, sev, favorite = fav)

    // ═════════════════════════════════════════════════════════════════════
    // SLEEP (Page 2)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapSleep(a: QuestionnaireAnswers, d: Map<String, Double>, out: MutableMap<String, TriggerSetting>) {
        val qualityCert = a.poorSleepQualityTriggers
        if (qualityCert != Certainty.NO) {
            val sev = certaintyToSeverity(qualityCert)
            out["Sleep score low"] = trigLow("Sleep score low", sev, d, qualityCert, fav = true)
            out["Sleep efficiency low"] = trigLow("Sleep efficiency low", sev, d, qualityCert)
            out["Sleep disturbances high"] = trigHigh("Sleep disturbances high", sev, d, qualityCert)
            out["Deep sleep low"] = trigLow("Deep sleep low", sev, d, qualityCert)
            out["REM sleep low"] = trigLow("REM sleep low", sev, d, qualityCert)
            out["Light sleep high"] = trigHigh("Light sleep high", sev, d, qualityCert)
        }

        val littleCert = a.tooLittleSleepTriggers
        if (littleCert != Certainty.NO) {
            val sev = certaintyToSeverity(littleCert)
            out["Sleep duration low"] = trigLow("Sleep duration low", sev, d, littleCert, fav = true)
        }

        if (a.oversleepTriggers != Certainty.NO) {
            val osev = certaintyToSeverity(a.oversleepTriggers)
            val oc = a.oversleepTriggers
            out["Sleep duration high"] = trigHigh("Sleep duration high", osev, d, oc, fav = true)
            out["Sleep score high"] = trigHigh("Sleep score high", osev, d, oc)
            out["Sleep efficiency high"] = trigHigh("Sleep efficiency high", osev, d, oc)
            out["Sleep disturbances low"] = trigLow("Sleep disturbances low", osev, d, oc)
            out["Deep sleep high"] = trigHigh("Deep sleep high", osev, d, oc)
            out["REM sleep high"] = trigHigh("REM sleep high", osev, d, oc)
        }

        val bestSleepCert = listOf(qualityCert, littleCert).maxByOrNull { it.ordinal } ?: Certainty.NO
        if (bestSleepCert != Certainty.NO) {
            val irregCert = if (a.sleepQuality == "Varies a lot") bestSleepCert else downgrade(bestSleepCert)
            val irregSev = certaintyToSeverity(irregCert)
            out["Bedtime late"] = trigHigh("Bedtime late", irregSev, d, irregCert)
            out["Bedtime early"] = trigLow("Bedtime early", irregSev, d, irregCert)
            out["Wake time late"] = trigHigh("Wake time late", irregSev, d, irregCert)
            out["Wake time early"] = trigLow("Wake time early", irregSev, d, irregCert)
        }

        if ("Irregular schedule" in a.sleepIssues && bestSleepCert != Certainty.NO) {
            val sameLevel = certaintyToSeverity(bestSleepCert)
            for (l in listOf("Bedtime late", "Bedtime early", "Wake time late", "Wake time early")) {
                out[l] = out[l]?.copy(severity = sameLevel) ?: TriggerSetting(l, sameLevel, d[l])
            }
        }
        if ("Sleep apnea" in a.sleepIssues) out["Sleep apnea"] = trigManual("Sleep apnea", certaintyToSeverity(bestSleepCert))
        if ("Jet lag" in a.sleepIssues) out["Jet lag"] = trigManual("Jet lag", "LOW")
    }

    // ═════════════════════════════════════════════════════════════════════
    // STRESS & SCREEN (Page 3)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapStressAndScreen(a: QuestionnaireAnswers, d: Map<String, Double>, out: MutableMap<String, TriggerSetting>) {
        for ((pattern, cert) in a.emotionalPatterns) {
            if (cert == Certainty.NO) continue
            val sev = certaintyToSeverity(cert)
            when (pattern) {
                "Spike in stress" -> { out["Stress"] = trigManual("Stress", sev); out["Stress high"] = trigHigh("Stress high", sev, d, cert) }
                "Anxiety"    -> out["Anxiety"] = trigManual("Anxiety", sev)
                "Anger"      -> out["Anger"] = trigManual("Anger", sev)
                "Let-down"   -> { out["Let-down"] = trigManual("Let-down", sev); out["Stress low"] = trigLow("Stress low", sev, d, cert) }
                "Feeling low" -> out["Depression"] = trigManual("Depression", sev)
            }
        }
        if (a.screenTimeTriggers != Certainty.NO) {
            val sev = certaintyToSeverity(a.screenTimeTriggers)
            out["Screen time high"] = trigHigh("Screen time high", sev, d, a.screenTimeTriggers)
            out["Computer/screen"] = trigManual("Computer/screen", sev)
        }
        if (a.lateScreenTriggers != Certainty.NO) {
            out["Late screen time high"] = trigHigh("Late screen time high", certaintyToSeverity(a.lateScreenTriggers), d, a.lateScreenTriggers)
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // DIET (Page 4)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapDiet(a: QuestionnaireAnswers, d: Map<String, Double>, out: MutableMap<String, TriggerSetting>) {
        if (a.caffeineCertainty != Certainty.NO && a.caffeineDirection != "No") {
            val sev = certaintyToSeverity(a.caffeineCertainty)
            val cc = a.caffeineCertainty
            when (a.caffeineDirection) {
                "Too much" -> out["Caffeine high"] = trigHigh("Caffeine high", sev, d, cc, fav = true)
                "Missing"  -> out["Caffeine low"] = trigLow("Caffeine low", sev, d, cc, fav = true)
                "Both" -> {
                    out["Caffeine high"] = trigHigh("Caffeine high", sev, d, cc, fav = true)
                    out["Caffeine low"] = trigLow("Caffeine low", sev, d, cc, fav = true)
                }
                "Not sure" -> {
                    out["Caffeine high"] = TriggerSetting("Caffeine high", "LOW", d["Caffeine high"])
                    out["Caffeine low"] = TriggerSetting("Caffeine low", "LOW", d["Caffeine low"])
                }
            }
        }

        if (a.alcoholTriggers != Certainty.NO) {
            out["Alcohol exposure high"] = TriggerSetting("Alcohol exposure high",
                certaintyToSeverity(a.alcoholTriggers), exposureLevel = exposureThreshold(a.alcoholTriggers), favorite = true)
        }

        val maxTyrCert = a.tyramineFoods.values.maxByOrNull { it.ordinal }
        if (maxTyrCert != null && maxTyrCert != Certainty.NO) {
            val rwFloor = if ("Red wine" in a.specificDrinks) Certainty.SOMETIMES else Certainty.NO
            val fc = if (rwFloor.ordinal < maxTyrCert.ordinal) rwFloor else maxTyrCert
            out["Tyramine exposure high"] = TriggerSetting("Tyramine exposure high",
                certaintyToSeverity(fc), exposureLevel = exposureThreshold(fc), favorite = true)
        } else if ("Red wine" in a.specificDrinks) {
            out["Tyramine exposure high"] = TriggerSetting("Tyramine exposure high", "LOW", exposureLevel = 2)
        }

        if (a.glutenTriggers != Certainty.NO) {
            out["Gluten exposure high"] = TriggerSetting("Gluten exposure high",
                certaintyToSeverity(a.glutenTriggers), exposureLevel = exposureThreshold(a.glutenTriggers), favorite = true)
        }

        for ((pattern, cert) in a.eatingPatterns) {
            if (cert == Certainty.NO) continue
            val sev = certaintyToSeverity(cert)
            when (pattern) {
                "Skipping meals" -> { out["Skipped meals"] = trigManual("Skipped meals", sev, fav = true); out["Calories low"] = trigLow("Calories low", sev, d, cert) }
                "Sugar"       -> out["Sugar high"] = trigHigh("Sugar high", sev, d, cert)
                "Salty food"  -> out["Sodium high"] = trigHigh("Sodium high", sev, d, cert)
                "Overeating"  -> out["Calories high"] = trigHigh("Calories high", sev, d, cert)
                "Dehydration" -> out["Dehydration"] = trigManual("Dehydration", sev, fav = true)
            }
        }

        when (a.tracksNutrition) {
            "Yes, regularly" -> {
                out["Magnesium low"] = out.getOrDefault("Magnesium low", TriggerSetting("Magnesium low", "MILD", d["Magnesium low"]))
                out["Riboflavin low"] = TriggerSetting("Riboflavin low", "MILD", d["Riboflavin low"])
                out["Vitamin D low"] = TriggerSetting("Vitamin D low", "MILD", d["Vitamin D low"])
                out["Iron low"] = TriggerSetting("Iron low", "MILD", d["Iron low"])
                val allNutrition = listOf(
                    "Protein high", "Protein low", "Carbs high", "Carbs low", "Fat high", "Fat low",
                    "Fibre high", "Fibre low", "Cholesterol high", "Cholesterol low",
                    "Saturated fat high", "Saturated fat low", "Unsaturated fat high", "Unsaturated fat low",
                    "Trans fat high", "Trans fat low", "Calcium high", "Calcium low",
                    "Potassium high", "Potassium low", "Zinc high", "Zinc low",
                    "Selenium high", "Selenium low", "Phosphorus high", "Phosphorus low",
                    "Copper high", "Copper low", "Manganese high", "Manganese low",
                    "Biotin high", "Biotin low", "Folate high", "Folate low",
                    "Niacin high", "Niacin low", "Pantothenic acid high", "Pantothenic acid low",
                    "Thiamin high", "Thiamin low", "Vitamin A high", "Vitamin A low",
                    "Vitamin B6 high", "Vitamin B6 low", "Vitamin B12 high", "Vitamin B12 low",
                    "Vitamin C high", "Vitamin C low", "Vitamin E high", "Vitamin E low",
                    "Vitamin K high", "Vitamin K low",
                )
                for (label in allNutrition) { if (label !in out) out[label] = TriggerSetting(label, "LOW", d[label]) }
            }
            "Sometimes" -> {
                out["Magnesium low"] = out.getOrDefault("Magnesium low", TriggerSetting("Magnesium low", "LOW", d["Magnesium low"]))
                out["Riboflavin low"] = TriggerSetting("Riboflavin low", "LOW", d["Riboflavin low"])
                out["Vitamin D low"] = TriggerSetting("Vitamin D low", "LOW", d["Vitamin D low"])
                out["Iron low"] = TriggerSetting("Iron low", "LOW", d["Iron low"])
            }
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // WEATHER & ENVIRONMENT (Page 5)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapEnvironment(a: QuestionnaireAnswers, d: Map<String, Double>, out: MutableMap<String, TriggerSetting>) {
        if ("Not sure which" in a.specificWeather) {
            for (l in listOf("Pressure high", "Pressure low", "Temperature high", "Temperature low",
                "Humidity high", "Humidity low", "Wind speed high", "UV index high")) {
                out[l] = TriggerSetting(l, "LOW", d[l])
            }
        } else {
            for ((weather, cert) in a.specificWeather) {
                if (cert == Certainty.NO) continue
                val sev = certaintyToSeverity(cert)
                when (weather) {
                    "Pressure changes" -> {
                        out["Pressure high"] = trigHigh("Pressure high", sev, d, cert, fav = true)
                        out["Pressure low"] = trigLow("Pressure low", sev, d, cert, fav = true)
                    }
                    "Hot weather"   -> out["Temperature high"] = trigHigh("Temperature high", sev, d, cert)
                    "Cold weather"  -> out["Temperature low"] = trigLow("Temperature low", sev, d, cert)
                    "Humidity"      -> out["Humidity high"] = trigHigh("Humidity high", sev, d, cert)
                    "Dry air"       -> out["Humidity low"] = trigLow("Humidity low", sev, d, cert)
                    "Wind"          -> out["Wind speed high"] = trigHigh("Wind speed high", sev, d, cert)
                    "Sunshine"      -> out["UV index high"] = trigHigh("UV index high", sev, d, cert)
                    "Thunderstorms" -> {
                        out["Pressure low"] = trigLow("Pressure low", sev, d, cert, fav = true)
                        out["Humidity high"] = trigHigh("Humidity high", sev, d, cert)
                    }
                }
            }
        }

        for ((env, cert) in a.environmentSensitivities) {
            if (cert == Certainty.NO) continue
            val sev = certaintyToSeverity(cert)
            when (env) {
                "Fluorescent lights" -> out["Fluorescent light"] = trigManual("Fluorescent light", sev, fav = true)
                "Strong smells"      -> out["Strong smell"] = trigManual("Strong smell", sev)
                "Loud noise"         -> out["Noise high"] = trigHigh("Noise high", sev, d, cert)
                "Smoke"              -> out["Smoke"] = trigManual("Smoke", sev)
                "Altitude"           -> {
                    out["Altitude high"] = trigHigh("Altitude high", sev, d, cert)
                    out["Altitude change high"] = trigHigh("Altitude change high", sev, d, cert)
                    out["Altitude low"] = TriggerSetting("Altitude low", "LOW", d["Altitude low"])
                    out["Altitude change low"] = TriggerSetting("Altitude change low", "LOW", d["Altitude change low"])
                }
            }
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // PHYSICAL (Page 5)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapPhysical(a: QuestionnaireAnswers, out: MutableMap<String, TriggerSetting>) {
        for ((factor, cert) in a.physicalFactors) {
            if (cert == Certainty.NO) continue
            val sev = certaintyToSeverity(cert)
            when (factor) {
                "Allergies"         -> out["Allergies"] = trigManual("Allergies", sev)
                "Being ill"         -> out["Illness"] = trigManual("Illness", sev)
                "Low blood sugar"   -> out["Low blood sugar"] = trigManual("Low blood sugar", sev)
                "Medication change" -> out["Medication change"] = trigManual("Medication change", sev)
                "Motion sickness"   -> { out["Motion sickness"] = trigManual("Motion sickness", sev); out["Travel"] = trigManual("Travel", sev) }
                "Tobacco"           -> out["Tobacco"] = trigManual("Tobacco", sev)
                "Sexual activity"   -> out["Sexual activity"] = trigManual("Sexual activity", sev)
            }
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // EXERCISE (Page 6)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapExercise(a: QuestionnaireAnswers, d: Map<String, Double>, out: MutableMap<String, TriggerSetting>) {
        if (a.exerciseTriggers == Certainty.NO) return
        val sev = certaintyToSeverity(a.exerciseTriggers)
        if ("Intense exercise" in a.exercisePattern) {
            out["High HR zones high"] = trigHigh("High HR zones high", sev, d, a.exerciseTriggers, fav = true)
            out["Steps high"] = trigHigh("Steps high", sev, d, a.exerciseTriggers)
        }
        if ("When inactive" in a.exercisePattern) {
            out["Steps low"] = trigLow("Steps low", sev, d, a.exerciseTriggers)
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // HORMONES (Page 6)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapHormones(a: QuestionnaireAnswers, out: MutableMap<String, TriggerSetting>) {
        for ((pattern, cert) in a.cyclePatterns) {
            if (cert == Certainty.NO) continue
            val sev = certaintyToSeverity(cert)
            when (pattern) {
                "Around my period"  -> out["Menstruation"] = trigManual("Menstruation", sev, fav = true)
                "Around ovulation"  -> out["Ovulation"] = trigManual("Ovulation", sev)
            }
        }
        when (a.contraceptionEffect) {
            "Made them worse — every time" -> out["Contraceptive"] = trigManual("Contraceptive", "HIGH")
            "Made them worse — sometimes"  -> out["Contraceptive"] = trigManual("Contraceptive", "MILD")
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // CONNECTED METRICS
    // ═════════════════════════════════════════════════════════════════════

    private fun mapConnectedMetrics(em: Map<String, Boolean>, d: Map<String, Double>, pd: Map<String, Double>, t: MutableMap<String, TriggerSetting>, p: MutableMap<String, ProdromeSetting>) {
        fun enT(metric: String, vararg labels: String) { if (em[metric] == true) for (l in labels) if (l !in t) t[l] = TriggerSetting(l, "LOW", d[l]) }
        fun enP(metric: String, vararg labels: String) { if (em[metric] == true) for (l in labels) if (l !in p) p[l] = ProdromeSetting(l, "LOW", pd[l]) }

        enT("recovery_score_daily", "Recovery high", "Recovery low")
        enT("stress_index_daily", "Stress high", "Stress low")
        enT("steps_daily", "Steps high", "Steps low")
        enT("time_in_high_hr_zones_daily", "High HR zones high", "High HR zones low")
        enT("blood_pressure_daily", "Blood pressure high", "Blood pressure low")
        enT("blood_glucose_daily", "Blood glucose high", "Blood glucose low")
        enT("body_fat_daily", "Body fat high", "Body fat low")
        enT("weight_daily", "Weight high", "Weight low")

        enP("hrv_daily", "HRV high", "HRV low")
        enP("resting_hr_daily", "Resting HR high", "Resting HR low")
        enP("spo2_daily", "SpO2 high", "SpO2 low")
        enP("skin_temp_daily", "Skin temp high", "Skin temp low")
        enP("respiratory_rate_daily", "Resp rate high", "Resp rate low")
        enP("phone_brightness_daily", "Brightness high", "Brightness low")
        enP("phone_dark_mode_daily", "Dark mode high", "Dark mode low")
        enP("phone_volume_daily", "Volume high", "Volume low")
        enP("phone_unlock_daily", "Phone unlocks high", "Phone unlocks low")
    }

    // ═════════════════════════════════════════════════════════════════════
    // PRODROMES (Page 7)
    // ═════════════════════════════════════════════════════════════════════

    private fun mapProdromes(a: QuestionnaireAnswers, pd: Map<String, Double>, out: MutableMap<String, ProdromeSetting>) {
        for ((s, c) in a.physicalProdromes) {
            if (c == Certainty.NO) continue; val sev = certaintyToSeverity(c)
            when (s) {
                "Neck stiffness" -> out["Muscle tension"] = prodManual("Muscle tension", sev, fav = true)
                "Yawning"        -> out["Yawning"] = prodManual("Yawning", sev, fav = true)
                "Urination"      -> out["Frequent urination"] = prodManual("Frequent urination", sev)
                "Stuffy nose"    -> out["Nasal congestion"] = prodManual("Nasal congestion", sev)
                "Watery eyes"    -> out["Tearing"] = prodManual("Tearing", sev)
                "Muscle tension" -> {
                    val ex = out["Muscle tension"]
                    if (ex == null || severityRank(sev) > severityRank(ex.severity))
                        out["Muscle tension"] = prodManual("Muscle tension", sev, fav = true)
                }
            }
        }
        for ((s, c) in a.moodProdromes) {
            if (c == Certainty.NO) continue; val sev = certaintyToSeverity(c)
            when (s) {
                "Concentrating"    -> out["Difficulty focusing"] = prodManual("Difficulty focusing", sev)
                "Words"            -> out["Word-finding trouble"] = prodManual("Word-finding trouble", sev)
                "Irritability"     -> out["Irritability"] = prodManual("Irritability", sev, fav = true)
                "Mood swings"      -> out["Mood change"] = prodManual("Mood change", sev)
                "Feeling low"      -> out["Depression"] = prodManual("Depression", sev)
                "Unusually happy"  -> out["Euphoria"] = prodManual("Euphoria", sev)
                "Food cravings"    -> out["Food cravings"] = prodManual("Food cravings", sev)
                "Loss of appetite" -> out["Loss of appetite"] = prodManual("Loss of appetite", sev)
            }
        }
        for ((s, c) in a.sensoryProdromes) {
            if (c == Certainty.NO) continue; val sev = certaintyToSeverity(c)
            val dc = downgrade(c); val ds = certaintyToSeverity(dc)
            when (s) {
                "Light" -> {
                    out["Sensitivity to light"] = prodManual("Sensitivity to light", sev, fav = true)
                    if ("Brightness low" !in out) out["Brightness low"] = prodLow("Brightness low", ds, pd, dc)
                    if ("Dark mode high" !in out) out["Dark mode high"] = prodHigh("Dark mode high", ds, pd, dc)
                }
                "Sound"    -> out["Sensitivity to sound"] = prodManual("Sensitivity to sound", sev, fav = true)
                "Smell"    -> out["Sensitivity to smell"] = prodManual("Sensitivity to smell", sev)
                "Tingling" -> out["Tingling"] = prodManual("Tingling", sev)
                "Numbness" -> out["Numbness"] = prodManual("Numbness", sev)
            }
        }
    }

    // ═════════════════════════════════════════════════════════════════════
    // FAVORITES & HELPERS
    // ═════════════════════════════════════════════════════════════════════

    private fun buildFavorites(a: QuestionnaireAnswers, t: Map<String, TriggerSetting>, p: Map<String, ProdromeSetting>) = Favorites(
        triggers = t.filter { it.value.severity != "NONE" }.map { it.key },
        prodromes = p.filter { it.value.severity != "NONE" }.map { it.key },
        symptoms = a.selectedSymptoms.toList(), medicines = a.selectedMedicines.toList(),
        reliefs = a.selectedReliefs.toList(), activities = a.selectedActivities.toList(),
        missedActivities = a.selectedMissedActivities.toList(),
    )

    private fun severityRank(sev: String): Int = when (sev) { "HIGH" -> 3; "MILD" -> 2; "LOW" -> 1; else -> 0 }
}

title: EdgeFunctionsService.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.Instant

class EdgeFunctionsService {

    @Serializable
    private data class WhoopTokenUpsertBody(
        @SerialName("access_token") val accessToken: String,
        @SerialName("refresh_token") val refreshToken: String,
        @SerialName("token_type") val tokenType: String,
        @SerialName("expires_at") val expiresAtIso: String? = null
    )

    @Serializable
    private data class MetricSettingUpsertBody(
        @SerialName("user_id") val userId: String,
        val metric: String,
        val enabled: Boolean,
        @SerialName("preferred_source") val preferredSource: String? = null,
        @SerialName("updated_at") val updatedAtIso: String
    )

    @Serializable
    data class MetricSettingResponse(
        @SerialName("user_id") val userId: String,
        val metric: String,
        val enabled: Boolean,
        @SerialName("preferred_source") val preferredSource: String? = null,
        @SerialName("allowed_sources") val allowedSources: List<String>? = null,
        @SerialName("updated_at") val updatedAt: String
    )

    @Serializable
    private data class TriggerSettingUpsertBody(
        @SerialName("user_id") val userId: String,
        @SerialName("trigger_type") val triggerType: String,
        val enabled: Boolean,
        val threshold: Double? = null,
        @SerialName("updated_at") val updatedAtIso: String
    )

    @Serializable
    data class TriggerSettingResponse(
        @SerialName("user_id") val userId: String,
        @SerialName("trigger_type") val triggerType: String,
        val enabled: Boolean,
        val threshold: Double? = null,
        @SerialName("updated_at") val updatedAt: String
    )

    @Serializable
    data class TriggerDefinitionResponse(
        @SerialName("trigger_type") val triggerType: String,
        val category: String,
        val label: String,
        val description: String,
        @SerialName("metric_table") val metricTable: String,
        @SerialName("metric_column") val metricColumn: String,
        val direction: String,
        @SerialName("default_threshold") val defaultThreshold: Double? = null,
        val unit: String? = null,
        @SerialName("baseline_days") val baselineDays: Int = 14,
        @SerialName("enabled_by_default") val enabledByDefault: Boolean = false
    )

    @Serializable
    private data class ProdromeSettingUpsertBody(
        @SerialName("user_id") val userId: String,
        @SerialName("prodrome_type") val prodromeType: String,
        val enabled: Boolean,
        val threshold: Double? = null,
        @SerialName("updated_at") val updatedAtIso: String
    )

    @Serializable
    data class ProdromeSettingResponse(
        @SerialName("user_id") val userId: String,
        @SerialName("prodrome_type") val prodromeType: String,
        val enabled: Boolean,
        val threshold: Double? = null,
        @SerialName("updated_at") val updatedAt: String
    )

    @OptIn(kotlinx.serialization.ExperimentalSerializationApi::class)
    private fun buildClient(): HttpClient {
        return HttpClient(Android) {
            install(ContentNegotiation) {
                json(
                    Json {
                        ignoreUnknownKeys = true
                        encodeDefaults = true
                        explicitNulls = false
                    }
                )
            }
        }
    }

    suspend fun upsertWhoopTokenToSupabase(context: Context, token: WhoopToken): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val expiresIso = token.expiresAtMillis
            .takeIf { it > 0L }
            ?.let { Instant.ofEpochMilli(it).toString() }

        val body = WhoopTokenUpsertBody(
            accessToken = token.accessToken,
            refreshToken = token.refreshToken,
            tokenType = token.tokenType.ifBlank { "Bearer" },
            expiresAtIso = expiresIso
        )

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/upsert-whoop-token"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                val bodyText = runCatching { res.bodyAsText() }.getOrDefault("")
                Log.e("EdgeFunctionsService", "upsertWhoopToken failed: ${res.status.value} $bodyText")
            }
            ok
        } catch (t: Throwable) {
            Log.e("EdgeFunctionsService", "upsertWhoopToken exception", t)
            false
        } finally {
            client.close()
        }
    }

    suspend fun enqueueLoginBackfill(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/enqueue-login-backfill"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e("EdgeFunctionsService", "enqueueLoginBackfill failed: ${res.status.value}")
            }
            ok
        } catch (t: Throwable) {
            Log.e("EdgeFunctionsService", "enqueueLoginBackfill exception", t)
            false
        } finally {
            client.close()
        }
    }

    suspend fun enqueueLoginBackfillGuaranteed(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/enqueue-login-backfill"
            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header(HttpHeaders.ContentType, "application/json")
                setBody("{}")
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                val bodyText = runCatching { res.bodyAsText() }.getOrDefault("")
                Log.w("EdgeFunctionsService", "enqueue-login-backfill failed: ${res.status.value} $bodyText")
            }
            ok
        } catch (t: Throwable) {
            Log.w("EdgeFunctionsService", "enqueue-login-backfill exception", t)
            false
        } finally {
            client.close()
        }
    }

    suspend fun upsertMetricSetting(
        context: Context,
        metric: String,
        enabled: Boolean,
        preferredSource: String? = null
    ): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val body = MetricSettingUpsertBody(
            userId = userId,
            metric = metric,
            enabled = enabled,
            preferredSource = preferredSource,
            updatedAtIso = Instant.now().toString()
        )

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/metric_settings?on_conflict=user_id,metric"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header("Prefer", "resolution=merge-duplicates")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e(
                    "EdgeFunctionsService",
                    "upsertMetricSetting failed: ${res.status} - ${res.bodyAsText()}"
                )
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "upsertMetricSetting exception", e)
            false
        } finally {
            client.close()
        }
    }

    suspend fun getMetricSettings(context: Context): List<MetricSettingResponse> {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return emptyList()
        val userId = SessionStore.readUserId(appCtx) ?: return emptyList()

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/metric_settings?user_id=eq.$userId&select=*"

            val res = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
            }

            if (res.status.value in 200..299) {
                res.body<List<MetricSettingResponse>>()
            } else {
                Log.e("EdgeFunctionsService", "getMetricSettings failed: ${res.status}")
                emptyList()
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "getMetricSettings error: ${e.message}", e)
            emptyList()
        } finally {
            client.close()
        }
    }

    suspend fun enableDefaultWhoopMetricSettings(context: Context): Boolean {
        val appCtx = context.applicationContext
        val whoopKey = "whoop"

        val metrics = listOf(
            "sleep_duration_daily",
            "sleep_score_daily",
            "sleep_efficiency_daily",
            "sleep_stages_daily",
            "sleep_disturbances_daily",
            "fell_asleep_time_daily",
            "woke_up_time_daily",
            "recovery_score_daily",
            "resting_hr_daily",
            "hrv_daily",
            "skin_temp_daily",
            "spo2_daily",
            "time_in_high_hr_zones_daily",
            "activity_hr_zones_sessions",
            "steps_daily",
            "stress_index_daily",
            "strain_daily"
        )

        var allOk = true
        for (metric in metrics) {
            val ok = runCatching {
                upsertMetricSetting(
                    context = appCtx,
                    metric = metric,
                    enabled = true,
                    preferredSource = whoopKey
                )
            }.getOrDefault(false)

            if (!ok) {
                allOk = false
                Log.w("EdgeFunctionsService", "Failed to enable WHOOP metric setting: $metric")
            }
        }
        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Health Connect Metric Settings
    // ─────────────────────────────────────────────────────────────────────────

    suspend fun enableDefaultHealthConnectMetricSettings(context: Context): Boolean {
        val appCtx = context.applicationContext
        val hcKey = "health_connect"

        val metrics = listOf(
            "sleep_duration_daily",
            "sleep_stages_daily",
            "fell_asleep_time_daily",
            "woke_up_time_daily",
            "resting_hr_daily",
            "hrv_daily",
            "spo2_daily",
            "skin_temp_daily",
            "steps_daily",
            "time_in_high_hr_zones_daily",
            "weight_daily",
            "body_fat_daily",
            "hydration_daily",
            "blood_pressure_daily",
            "blood_glucose_daily",
            "respiratory_rate_daily",
            "stress_index_daily"
        )

        var allOk = true
        for (metric in metrics) {
            val ok = runCatching {
                upsertMetricSetting(
                    context = appCtx,
                    metric = metric,
                    enabled = true,
                    preferredSource = hcKey
                )
            }.getOrDefault(false)

            if (!ok) {
                allOk = false
                Log.w("EdgeFunctionsService", "Failed to enable Health Connect metric: $metric")
            }
        }
        return allOk
    }

    suspend fun disableHealthConnectMetricSettings(context: Context): Boolean {
        val appCtx = context.applicationContext

        val metrics = listOf(
            "sleep_duration_daily",
            "sleep_stages_daily",
            "fell_asleep_time_daily",
            "woke_up_time_daily",
            "resting_hr_daily",
            "hrv_daily",
            "spo2_daily",
            "skin_temp_daily",
            "steps_daily",
            "time_in_high_hr_zones_daily",
            "weight_daily",
            "body_fat_daily",
            "hydration_daily",
            "blood_pressure_daily",
            "blood_glucose_daily",
            "respiratory_rate_daily",
            "stress_index_daily"
        )

        var allOk = true
        for (metric in metrics) {
            val ok = runCatching {
                upsertMetricSetting(
                    context = appCtx,
                    metric = metric,
                    enabled = false,
                    preferredSource = null
                )
            }.getOrDefault(false)

            if (!ok) allOk = false
        }
        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────

    suspend fun hasAnyMetricData(
        context: Context,
        metric: String
    ): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/has-metric-data"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
                setBody(mapOf("metric" to metric))
            }

            if (res.status.value in 200..299) {
                val body = res.body<Map<String, Boolean>>()
                body["hasData"] == true
            } else {
                false
            }
        } catch (_: Throwable) {
            false
        } finally {
            client.close()
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Trigger Settings
    // ─────────────────────────────────────────────────────────────────────────

    suspend fun getTriggerSettings(context: Context): List<TriggerSettingResponse> {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return emptyList()
        val userId = SessionStore.readUserId(appCtx) ?: return emptyList()

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/trigger_settings?user_id=eq.$userId&select=*"

            val res = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
            }

            if (res.status.value in 200..299) {
                res.body<List<TriggerSettingResponse>>()
            } else {
                Log.e("EdgeFunctionsService", "getTriggerSettings failed: ${res.status}")
                emptyList()
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "getTriggerSettings error: ${e.message}", e)
            emptyList()
        } finally {
            client.close()
        }
    }

    suspend fun getTriggerDefinitions(context: Context): List<TriggerDefinitionResponse> {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return emptyList()

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/trigger_definitions?select=*&order=category,trigger_type"

            val res = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
            }

            if (res.status.value in 200..299) {
                res.body<List<TriggerDefinitionResponse>>()
            } else {
                Log.e("EdgeFunctionsService", "getTriggerDefinitions failed: ${res.status}")
                emptyList()
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "getTriggerDefinitions error: ${e.message}", e)
            emptyList()
        } finally {
            client.close()
        }
    }

    suspend fun upsertTriggerSetting(
        context: Context,
        triggerType: String,
        enabled: Boolean,
        threshold: Double? = null
    ): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val body = TriggerSettingUpsertBody(
            userId = userId,
            triggerType = triggerType,
            enabled = enabled,
            threshold = threshold,
            updatedAtIso = Instant.now().toString()
        )

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/trigger_settings?on_conflict=user_id,trigger_type"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header("Prefer", "resolution=merge-duplicates")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e(
                    "EdgeFunctionsService",
                    "upsertTriggerSetting failed: ${res.status} - ${res.bodyAsText()}"
                )
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "upsertTriggerSetting exception", e)
            false
        } finally {
            client.close()
        }
    }

    suspend fun seedDefaultTriggerSettings(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val defaultTriggers = listOf(
            "recovery_low" to true,
            "recovery_unusually_low" to true
        )

        val client = buildClient()
        var allOk = true

        try {
            for ((triggerType, enabled) in defaultTriggers) {
                val body = TriggerSettingUpsertBody(
                    userId = userId,
                    triggerType = triggerType,
                    enabled = enabled,
                    updatedAtIso = Instant.now().toString()
                )

                val url =
                    "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/trigger_settings?on_conflict=user_id,trigger_type"

                val res = client.post(url) {
                    header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                    header("Prefer", "resolution=ignore-duplicates")
                    contentType(ContentType.Application.Json)
                    setBody(body)
                }

                val ok = res.status.value in 200..299
                if (!ok) {
                    allOk = false
                    Log.w("EdgeFunctionsService", "Failed to seed trigger setting: $triggerType")
                }
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "seedDefaultTriggerSettings exception", e)
            allOk = false
        } finally {
            client.close()
        }

        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Prodrome Settings
    // ─────────────────────────────────────────────────────────────────────────

    suspend fun getProdromeSettings(context: Context): List<ProdromeSettingResponse> {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return emptyList()
        val userId = SessionStore.readUserId(appCtx) ?: return emptyList()

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/prodrome_settings?user_id=eq.$userId&select=*"

            val res = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
            }

            if (res.status.value in 200..299) {
                res.body<List<ProdromeSettingResponse>>()
            } else {
                Log.e("EdgeFunctionsService", "getProdromeSettings failed: ${res.status}")
                emptyList()
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "getProdromeSettings error: ${e.message}", e)
            emptyList()
        } finally {
            client.close()
        }
    }

    suspend fun upsertProdromeSetting(
        context: Context,
        prodromeType: String,
        enabled: Boolean,
        threshold: Double? = null
    ): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val body = ProdromeSettingUpsertBody(
            userId = userId,
            prodromeType = prodromeType,
            enabled = enabled,
            threshold = threshold,
            updatedAtIso = Instant.now().toString()
        )

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/prodrome_settings?on_conflict=user_id,prodrome_type"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header("Prefer", "resolution=merge-duplicates")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e(
                    "EdgeFunctionsService",
                    "upsertProdromeSetting failed: ${res.status} - ${res.bodyAsText()}"
                )
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "upsertProdromeSetting exception", e)
            false
        } finally {
            client.close()
        }
    }

    suspend fun seedDefaultProdromeSettings(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val defaultProdromes = listOf(
            "fatigue_yawning" to false,
            "neck_stiffness" to false,
            "mood_changes" to false
        )

        val client = buildClient()
        var allOk = true

        try {
            for ((prodromeType, enabled) in defaultProdromes) {
                val body = ProdromeSettingUpsertBody(
                    userId = userId,
                    prodromeType = prodromeType,
                    enabled = enabled,
                    updatedAtIso = Instant.now().toString()
                )

                val url =
                    "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/prodrome_settings?on_conflict=user_id,prodrome_type"

                val res = client.post(url) {
                    header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                    header("Prefer", "resolution=ignore-duplicates")
                    contentType(ContentType.Application.Json)
                    setBody(body)
                }

                val ok = res.status.value in 200..299
                if (!ok) {
                    allOk = false
                    Log.w("EdgeFunctionsService", "Failed to seed prodrome setting: $prodromeType")
                }
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "seedDefaultProdromeSettings exception", e)
            allOk = false
        } finally {
            client.close()
        }

        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Metric Settings Seeding
    // ─────────────────────────────────────────────────────────────────────────

    suspend fun seedDefaultMetricSettings(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val metrics = listOf(
            "sleep_duration_daily",
            "sleep_score_daily",
            "sleep_efficiency_daily",
            "sleep_stages_daily",
            "sleep_disturbances_daily",
            "fell_asleep_time_daily",
            "woke_up_time_daily",
            "recovery_score_daily",
            "resting_hr_daily",
            "hrv_daily",
            "skin_temp_daily",
            "spo2_daily",
            "time_in_high_hr_zones_daily",
            "activity_hr_zones_sessions",
            "steps_daily",
            "strain_daily",
            "stress_index_daily",
            "screen_time_daily",
            "user_location_daily",
            "ambient_noise_samples",
            "ambient_noise_index_daily",
            "screen_time_late_night",
            "phone_brightness_daily",
            "phone_volume_daily",
            "phone_dark_mode_daily",
            "phone_unlock_daily",
            "nutrition",
            "menstruation",
            "temperature_daily",
            "pressure_daily",
            "humidity_daily",
            "wind_daily",
            "uv_daily",
            "thunderstorm_daily"
        )

        val client = buildClient()
        var allOk = true

        try {
            for (metric in metrics) {
                val body = MetricSettingUpsertBody(
                    userId = userId,
                    metric = metric,
                    enabled = false,
                    preferredSource = null,
                    updatedAtIso = Instant.now().toString()
                )

                val url =
                    "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/metric_settings?on_conflict=user_id,metric"

                val res = client.post(url) {
                    header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                    header("Prefer", "resolution=ignore-duplicates")
                    contentType(ContentType.Application.Json)
                    setBody(body)
                }

                val ok = res.status.value in 200..299
                if (!ok) {
                    allOk = false
                    Log.w("EdgeFunctionsService", "Failed to seed metric setting: $metric")
                }
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "seedDefaultMetricSettings exception", e)
            allOk = false
        } finally {
            client.close()
        }

        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Risk Decay Weights
    // ─────────────────────────────────────────────────────────────────────────

    @Serializable
    data class RiskDecayWeightResponse(
        val id: String,
        @SerialName("user_id") val userId: String,
        val severity: String,
        @SerialName("day_0") val day0: Double,
        @SerialName("day_1") val day1: Double,
        @SerialName("day_2") val day2: Double,
        @SerialName("day_3") val day3: Double,
        @SerialName("day_4") val day4: Double,
        @SerialName("day_5") val day5: Double,
        @SerialName("day_6") val day6: Double,
        @SerialName("updated_at") val updatedAt: String
    )

    @Serializable
    private data class RiskDecayWeightUpsertBody(
        @SerialName("user_id") val userId: String,
        val severity: String,
        @SerialName("day_0") val day0: Double,
        @SerialName("day_1") val day1: Double,
        @SerialName("day_2") val day2: Double,
        @SerialName("day_3") val day3: Double,
        @SerialName("day_4") val day4: Double,
        @SerialName("day_5") val day5: Double,
        @SerialName("day_6") val day6: Double,
        @SerialName("updated_at") val updatedAtIso: String
    )

    suspend fun getRiskDecayWeights(context: Context): List<RiskDecayWeightResponse> {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return emptyList()
        val userId = SessionStore.readUserId(appCtx) ?: return emptyList()

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/risk_decay_weights?user_id=eq.$userId&select=*&order=severity.asc"

            val res = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
            }

            if (res.status.value in 200..299) {
                res.body<List<RiskDecayWeightResponse>>()
            } else {
                Log.e("EdgeFunctionsService", "getRiskDecayWeights failed: ${res.status}")
                emptyList()
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "getRiskDecayWeights error: ${e.message}", e)
            emptyList()
        } finally {
            client.close()
        }
    }

    suspend fun upsertRiskDecayWeight(
        context: Context,
        severity: String,
        day0: Double,
        day1: Double,
        day2: Double,
        day3: Double,
        day4: Double,
        day5: Double,
        day6: Double
    ): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val body = RiskDecayWeightUpsertBody(
            userId = userId,
            severity = severity,
            day0 = day0, day1 = day1, day2 = day2,
            day3 = day3, day4 = day4, day5 = day5, day6 = day6,
            updatedAtIso = Instant.now().toString()
        )

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/risk_decay_weights?on_conflict=user_id,severity"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header("Prefer", "resolution=merge-duplicates")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e("EdgeFunctionsService", "upsertRiskDecayWeight failed: ${res.status} - ${res.bodyAsText()}")
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "upsertRiskDecayWeight exception", e)
            false
        } finally {
            client.close()
        }
    }

    suspend fun seedDefaultRiskDecayWeights(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        data class Default(val severity: String, val d0: Double, val d1: Double, val d2: Double)

        val defaults = listOf(
            Default("HIGH", 10.0, 5.0, 2.5),
            Default("MILD", 6.0, 3.0, 1.5),
            Default("LOW", 3.0, 1.5, 0.0)
        )

        val client = buildClient()
        var allOk = true

        try {
            for (d in defaults) {
                val body = RiskDecayWeightUpsertBody(
                    userId = userId,
                    severity = d.severity,
                    day0 = d.d0, day1 = d.d1, day2 = d.d2,
                    day3 = 0.0, day4 = 0.0, day5 = 0.0, day6 = 0.0,
                    updatedAtIso = Instant.now().toString()
                )

                val url =
                    "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/risk_decay_weights?on_conflict=user_id,severity"

                val res = client.post(url) {
                    header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                    header("Prefer", "resolution=ignore-duplicates")
                    contentType(ContentType.Application.Json)
                    setBody(body)
                }

                val ok = res.status.value in 200..299
                if (!ok) {
                    allOk = false
                    Log.w("EdgeFunctionsService", "Failed to seed risk decay weight: ${d.severity}")
                }
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "seedDefaultRiskDecayWeights exception", e)
            allOk = false
        } finally {
            client.close()
        }

        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Risk Gauge Thresholds
    // ─────────────────────────────────────────────────────────────────────────

    @Serializable
    data class RiskGaugeThresholdResponse(
        val id: String,
        @SerialName("user_id") val userId: String,
        val zone: String,              // NONE | LOW | MILD | HIGH
        @SerialName("min_value") val minValue: Double,
        @SerialName("updated_at") val updatedAt: String
    )

    @Serializable
    private data class RiskGaugeThresholdUpsertBody(
        @SerialName("user_id") val userId: String,
        val zone: String,
        @SerialName("min_value") val minValue: Double,
        @SerialName("updated_at") val updatedAtIso: String
    )

    suspend fun getRiskGaugeThresholds(context: Context): List<RiskGaugeThresholdResponse> {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return emptyList()
        val userId = SessionStore.readUserId(appCtx) ?: return emptyList()

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/risk_gauge_thresholds?user_id=eq.$userId&select=*&order=min_value.asc"

            val res = client.get(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
            }

            if (res.status.value in 200..299) {
                res.body<List<RiskGaugeThresholdResponse>>()
            } else {
                Log.e("EdgeFunctionsService", "getRiskGaugeThresholds failed: ${res.status}")
                emptyList()
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "getRiskGaugeThresholds error: ${e.message}", e)
            emptyList()
        } finally {
            client.close()
        }
    }

    suspend fun upsertRiskGaugeThreshold(
        context: Context,
        zone: String,
        minValue: Double
    ): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val body = RiskGaugeThresholdUpsertBody(
            userId = userId,
            zone = zone,
            minValue = minValue,
            updatedAtIso = Instant.now().toString()
        )

        val client = buildClient()
        return try {
            val url =
                "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/risk_gauge_thresholds?on_conflict=user_id,zone"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header("Prefer", "resolution=merge-duplicates")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e("EdgeFunctionsService", "upsertRiskGaugeThreshold failed: ${res.status} - ${res.bodyAsText()}")
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "upsertRiskGaugeThreshold exception", e)
            false
        } finally {
            client.close()
        }
    }

    suspend fun seedDefaultRiskGaugeThresholds(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val defaults = listOf(
            "NONE" to 0.0,
            "LOW" to 3.0,
            "MILD" to 5.0,
            "HIGH" to 10.0
        )

        val client = buildClient()
        var allOk = true

        try {
            for ((zone, minVal) in defaults) {
                val body = RiskGaugeThresholdUpsertBody(
                    userId = userId,
                    zone = zone,
                    minValue = minVal,
                    updatedAtIso = Instant.now().toString()
                )

                val url =
                    "${BuildConfig.SUPABASE_URL.trimEnd('/')}/rest/v1/risk_gauge_thresholds?on_conflict=user_id,zone"

                val res = client.post(url) {
                    header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                    header("Prefer", "resolution=ignore-duplicates")
                    contentType(ContentType.Application.Json)
                    setBody(body)
                }

                val ok = res.status.value in 200..299
                if (!ok) {
                    allOk = false
                    Log.w("EdgeFunctionsService", "Failed to seed risk gauge threshold: $zone")
                }
            }
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "seedDefaultRiskGaugeThresholds exception", e)
            allOk = false
        } finally {
            client.close()
        }

        return allOk
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Risk Score Calculation (on-demand)
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Trigger on-demand risk score calculation via edge function.
     * Called when risk_score_live is missing or stale (>2h).
     * The edge function recalculates and writes to risk_score_live + risk_score_daily.
     */
    suspend fun triggerRiskCalculation(context: Context, userId: String): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/calculate-risk-score"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
                setBody("""{"user_id":"$userId"}""")
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e("EdgeFunctionsService", "triggerRiskCalculation failed: ${res.status} - ${res.bodyAsText()}")
            } else {
                Log.d("EdgeFunctionsService", "triggerRiskCalculation success for $userId")
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "triggerRiskCalculation exception", e)
            false
        } finally {
            client.close()
        }
    }

    // Recalc Triggers + Prodromes + Risk Score
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Trigger a full recalculation of system triggers, prodromes, and risk scores.
     * Called after the user saves changes to prediction values or thresholds on
     * the Manage Triggers / Manage Prodromes screens.
     *
     * The edge function:
     *   1. Deletes all source='system' triggers + prodromes for the last 7 days
     *   2. Re-evaluates definitions against existing metric data (threshold + 2SD)
     *   3. Recalculates risk_score_daily + risk_score_live (gauge)
     */
    suspend fun triggerRecalc(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/recalc-user-triggers"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
                setBody("""{"user_id":"$userId"}""")
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e("EdgeFunctionsService", "triggerRecalc failed: ${res.status} - ${res.bodyAsText()}")
            } else {
                Log.d("EdgeFunctionsService", "triggerRecalc success for $userId")
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "triggerRecalc exception", e)
            false
        } finally {
            client.close()
        }
    }

    /**
     * Recalculate risk scores only (no trigger/prodrome re-evaluation).
     * Called after the user saves gauge thresholds or decay weights in Risk Model settings.
     */
    suspend fun triggerRecalcRiskScores(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false
        val userId = SessionStore.readUserId(appCtx) ?: return false

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/recalc-risk-scores"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
                setBody("""{"user_id":"$userId"}""")
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                Log.e("EdgeFunctionsService", "triggerRecalcRiskScores failed: ${res.status} - ${res.bodyAsText()}")
            } else {
                Log.d("EdgeFunctionsService", "triggerRecalcRiskScores success for $userId")
            }
            ok
        } catch (e: Exception) {
            Log.e("EdgeFunctionsService", "triggerRecalcRiskScores exception", e)
            false
        } finally {
            client.close()
        }
    }
}

title: EditMedicineScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun EditMedicineScreen(
    navController: NavHostController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken, id) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) {
            vm.loadMedicineById(token, id)
            vm.loadMedicineOptions(token)
            vm.loadMigraines(token)
        }
    }

    val row by vm.editMedicine.collectAsState()
    val frequent by vm.medicineOptionsFrequent.collectAsState()
    val all by vm.medicineOptionsAll.collectAsState()
    val migraines by vm.migraines.collectAsState()

    var name by rememberSaveable(row?.id) { mutableStateOf(row?.name ?: "") }
    var amount by rememberSaveable(row?.id) { mutableStateOf(row?.amount ?: "") }
    var startAt by rememberSaveable(row?.id) { mutableStateOf(row?.startAt ?: "") }
    var notes by rememberSaveable(row?.id) { mutableStateOf(row?.notes ?: "") }
    var migraineId by rememberSaveable(row?.id) { mutableStateOf(row?.migraineId ?: "") }

    var nameMenuOpen by rememberSaveable { mutableStateOf(false) }
    var migraineMenuOpen by rememberSaveable { mutableStateOf(false) }

    fun labelForMigraine(startIso: String?): String {
        if (startIso.isNullOrBlank()) return "Unknown"
        return try {
            val odt = runCatching { OffsetDateTime.parse(startIso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(startIso)
            ldt.format(DateTimeFormatter.ofPattern("EEE, dd MMM yyyy • HH:mm"))
        } catch (_: Exception) { "Unknown" }
    }
    val selectedMigraineLabel = migraines
        .firstOrNull { it.id == migraineId }
        ?.let { labelForMigraine(it.startAt) }
        ?: "None"

    fun formatIsoDdMmHm(iso: String?): String {
        if (iso.isNullOrBlank()) return "Not set"
        return try {
            val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
            ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
        } catch (_: Exception) { "Not set" }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Edit Medicine")

        // Name dropdown with Frequent / All
        if (frequent.isNotEmpty() || all.isNotEmpty()) {
            Box(modifier = Modifier.fillMaxWidth()) {
                OutlinedTextField(
                    value = name,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Name") },
                    trailingIcon = {
                        IconButton(onClick = { nameMenuOpen = true }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose medicine")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(
                    expanded = nameMenuOpen,
                    onDismissRequest = { nameMenuOpen = false }
                ) {
                    if (frequent.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        frequent.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    name = opt
                                    nameMenuOpen = false
                                }
                            )
                        }
                        if (all.isNotEmpty()) Divider()
                    }
                    if (all.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("All", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        all.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    name = opt
                                    nameMenuOpen = false
                                }
                            )
                        }
                    }
                }
            }
        } else {
            OutlinedTextField(
                value = name,
                onValueChange = { name = it },
                label = { Text("Name") },
                modifier = Modifier.fillMaxWidth()
            )
        }

        OutlinedTextField(
            value = amount,
            onValueChange = { amount = it },
            label = { Text("Amount") },
            modifier = Modifier.fillMaxWidth()
        )

        // Start time using shared picker
        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
            Text("Start time: ${formatIsoDdMmHm(startAt)}")
            AppDateTimePicker(
                label = "Select time",
                onDateTimeSelected = { iso -> startAt = iso ?: "" }
            )
        }

        OutlinedTextField(
            value = notes,
            onValueChange = { notes = it },
            label = { Text("Notes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Linked Migraine dropdown with time/day labels
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedMigraineLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Linked Migraine") },
                trailingIcon = {
                    IconButton(onClick = { migraineMenuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = migraineMenuOpen,
                onDismissRequest = { migraineMenuOpen = false }
            ) {
                DropdownMenuItem(
                    text = { Text("None") },
                    onClick = {
                        migraineId = ""
                        migraineMenuOpen = false
                    }
                )
                migraines
                    .sortedByDescending { it.startAt }
                    .forEach { m ->
                        val label = labelForMigraine(m.startAt)
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                migraineId = m.id
                                migraineMenuOpen = false
                            }
                        )
                    }
            }
        }

        Spacer(Modifier.height(8.dp))

        Button(
            onClick = {
                val token = authState.accessToken
                if (!token.isNullOrBlank()) {
                    vm.updateMedicine(
                        accessToken = token,
                        id = id,
                        name = name.ifBlank { null },
                        amount = amount.ifBlank { null },
                        startAt = startAt.ifBlank { null },
                        notes = notes.ifBlank { null },
                        migraineId = migraineId.ifBlank { null }
                    )
                    navController.popBackStack()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save")
        }

        TextButton(
            onClick = { navController.popBackStack() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancel")
        }
    }
}

title: EditMigraineScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.AssistChip
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow

/* ---------- Top-level types ---------- */

private enum class Step { CORE, TRIGGERS, MEDICINES, RELIEFS, REVIEW }

private data class PendingTrigger(val type: String, val startIso: String?)
private data class PendingMedicine(val name: String, val amount: String?, val startIso: String?, val notes: String?)
private data class PendingRelief(val type: String, val durationMinutes: Int?, val startIso: String?, val notes: String?)

/* ----------------------------------------------------------------------------- */

@Composable
fun EditMigraineScreen(
    navController: NavController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val auth by authVm.state.collectAsState()
    val token = auth.accessToken

    // Supabase access unchanged
    val db = remember { SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY) }
    val scope = rememberCoroutineScope()

    // Stepper (same order as draft flow)
    var step by remember { mutableStateOf(Step.CORE) }

    // Base row and loading
    var row by remember { mutableStateOf<SupabaseDbService.MigraineRow?>(null) }
    var loading by remember { mutableStateOf(true) }
    var error by remember { mutableStateOf<String?>(null) }
    var saving by remember { mutableStateOf(false) }

    // Pools and prefs
    var mgFrequent by remember { mutableStateOf(listOf<String>()) }
    var mgAll by remember { mutableStateOf(listOf<String>()) }

    var trigPool by remember { mutableStateOf(listOf<SupabaseDbService.UserTriggerRow>()) }
    var trigFreq by remember { mutableStateOf(listOf<String>()) }

    var medPool by remember { mutableStateOf(listOf<SupabaseDbService.UserMedicineRow>()) }
    var medFreq by remember { mutableStateOf(listOf<String>()) }

    var relPool by remember { mutableStateOf(listOf<SupabaseDbService.UserReliefRow>()) }
    var relFreq by remember { mutableStateOf(listOf<String>()) }

    // Linked rows
    var linkedTriggers by remember { mutableStateOf(listOf<SupabaseDbService.TriggerRow>()) }
    var linkedMeds by remember { mutableStateOf(listOf<SupabaseDbService.MedicineRow>()) }
    var linkedRels by remember { mutableStateOf(listOf<SupabaseDbService.ReliefRow>()) }

    // Draft (single save)
    var selectedLabel by remember { mutableStateOf<String?>(null) }
    var severity by remember { mutableStateOf(5f) }
    var beganAt by remember { mutableStateOf<String?>(null) }
    var endedAt by remember { mutableStateOf<String?>(null) }
    var notes by remember { mutableStateOf(TextFieldValue("")) }

    // Queues for adds and deletes
    var addTriggers by remember { mutableStateOf(listOf<PendingTrigger>()) }
    var addMeds by remember { mutableStateOf(listOf<PendingMedicine>()) }
    var addRels by remember { mutableStateOf(listOf<PendingRelief>()) }

    var deleteTriggerIds by remember { mutableStateOf(setOf<String>()) }
    var deleteMedicineIds by remember { mutableStateOf(setOf<String>()) }
    var deleteReliefIds by remember { mutableStateOf(setOf<String>()) }

    // UI flags
    var typeMenuOpen by remember { mutableStateOf(false) }
    var showAddTrig by remember { mutableStateOf<String?>(null) }
    var showAddMed by remember { mutableStateOf<String?>(null) }
    var showAddRel by remember { mutableStateOf<String?>(null) }

    // Validation
    val endBeforeStart by derivedStateOf { isEndBeforeStart(beganAt, endedAt) }

    // Load data
    LaunchedEffect(token, id) {
        if (token.isNullOrBlank()) return@LaunchedEffect
        try {
            loading = true
            error = null

            row = db.getMigraineById(token, id)

            val mgPrefs = db.getMigrainePrefs(token)
            mgFrequent = mgPrefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.migraine?.label }
            mgAll = db.getAllMigrainePool(token).map { it.label }

            val tprefs = db.getTriggerPrefs(token)
            trigFreq = tprefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.trigger?.label }
            trigPool = db.getAllTriggerPool(token)

            val mprefs = db.getMedicinePrefs(token)
            medFreq = mprefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.medicine?.label }
            medPool = db.getAllMedicinePool(token)

            val rprefs = db.getReliefPrefs(token)
            relFreq = rprefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.relief?.label }
            relPool = db.getAllReliefPool(token)

            linkedTriggers = db.getAllTriggers(token).filter { it.migraineId == id }.sortedByDescending { it.startAt }
            linkedMeds = db.getAllMedicines(token).filter { it.migraineId == id }.sortedByDescending { it.startAt }
            linkedRels = db.getAllReliefs(token).filter { it.migraineId == id }.sortedByDescending { it.startAt }
        } catch (e: Exception) {
            e.printStackTrace()
            error = e.message ?: "Failed to load"
        } finally {
            loading = false
        }
    }

    // Seed draft
    LaunchedEffect(row?.id) {
        row?.let {
            selectedLabel = it.type ?: "Migraine"
            severity = (it.severity ?: 5).coerceIn(1, 10).toFloat()
            beganAt = it.startAt
            endedAt = it.endAt
            notes = TextFieldValue(it.notes ?: "")
            addTriggers = emptyList(); addMeds = emptyList(); addRels = emptyList()
            deleteTriggerIds = emptySet(); deleteMedicineIds = emptySet(); deleteReliefIds = emptySet()
        }
    }

    // Bottom bar and stepper
    Scaffold(
        bottomBar = {
            Row(
                Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                OutlinedButton(
                    onClick = {
                        when (step) {
                            Step.CORE -> navController.popBackStack()
                            Step.TRIGGERS -> step = Step.CORE
                            Step.MEDICINES -> step = Step.TRIGGERS
                            Step.RELIEFS -> step = Step.MEDICINES
                            Step.REVIEW -> step = Step.RELIEFS
                        }
                    },
                    enabled = !saving
                ) { Text(if (step == Step.CORE) "Back" else "Previous") }

                when (step) {
                    Step.CORE, Step.TRIGGERS, Step.MEDICINES, Step.RELIEFS -> {
                        Button(
                            onClick = {
                                step = when (step) {
                                    Step.CORE -> Step.TRIGGERS
                                    Step.TRIGGERS -> Step.MEDICINES
                                    Step.MEDICINES -> Step.RELIEFS
                                    Step.RELIEFS -> Step.REVIEW
                                    Step.REVIEW -> Step.REVIEW
                                }
                            },
                            enabled = !saving && !(step == Step.CORE && endBeforeStart)
                        ) { Text("Next") }
                    }
                    Step.REVIEW -> {
                        Button(
                            onClick = {
                                if (token.isNullOrBlank() || row == null) return@Button
                                scope.launch {
                                    try {
                                        saving = true
                                        if (endBeforeStart) {
                                            error = "End time cannot be before start time"
                                            saving = false
                                            return@launch
                                        }
                                        // Update migraine
                                        row = db.updateMigraine(
                                            accessToken = token,
                                            id = id,
                                            type = selectedLabel,
                                            severity = severity.toInt(),
                                            startAt = beganAt,
                                            endAt = endedAt,
                                            notes = notes.text
                                        )
                                        // Deletes
                                        deleteTriggerIds.forEach { runCatching { db.deleteTrigger(token, it) } }
                                        deleteMedicineIds.forEach { runCatching { db.deleteMedicine(token, it) } }
                                        deleteReliefIds.forEach { runCatching { db.deleteRelief(token, it) } }
                                        // Adds
                                        addTriggers.forEach { t ->
                                            runCatching {
                                                db.insertTrigger(
                                                    accessToken = token,
                                                    migraineId = id,
                                                    type = t.type,
                                                    startAt = t.startIso ?: beganAt,
                                                    notes = null
                                                )
                                            }
                                        }
                                        addMeds.forEach { m ->
                                            runCatching {
                                                db.insertMedicine(
                                                    accessToken = token,
                                                    migraineId = id,
                                                    name = m.name,
                                                    amount = m.amount,
                                                    startAt = m.startIso ?: beganAt,
                                                    notes = m.notes
                                                )
                                            }
                                        }
                                        addRels.forEach { r ->
                                            runCatching {
                                                db.insertRelief(
                                                    accessToken = token,
                                                    migraineId = id,
                                                    type = r.type,
                                                    startAt = r.startIso ?: beganAt,
                                                    notes = r.notes
                                                )
                                            }
                                        }
                                        vm.loadJournal(token)
                                        navController.popBackStack()
                                    } catch (e: Exception) {
                                        e.printStackTrace()
                                        error = e.message ?: "Failed to save"
                                    } finally {
                                        saving = false
                                    }
                                }
                            },
                            enabled = !saving && !endBeforeStart
                        ) { Text(if (saving) "Saving..." else "Save") }
                    }
                }
            }
        }
    ) { inner ->
        if (loading) {
            Box(Modifier.fillMaxSize().padding(inner), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
            return@Scaffold
        }
        if (error != null || row == null) {
            Column(Modifier.fillMaxSize().padding(inner).padding(16.dp)) {
                Text(error ?: "Not found")
                Spacer(Modifier.height(12.dp))
                OutlinedButton(onClick = { navController.popBackStack() }) { Text("Back") }
            }
            return@Scaffold
        }

        when (step) {
            Step.CORE -> CorePage(
                selectedLabel = selectedLabel,
                onSelectLabel = { selectedLabel = it },
                mgFrequent = mgFrequent,
                mgAll = mgAll,
                typeMenuOpen = typeMenuOpen,
                setTypeMenuOpen = { typeMenuOpen = it },
                severity = severity,
                setSeverity = { severity = it.coerceIn(1f, 10f) },
                beganAt = beganAt,
                setBeganAt = { beganAt = it },
                endedAt = endedAt,
                setEndedAt = { endedAt = it },
                endBeforeStart = endBeforeStart,
                notes = notes,
                setNotes = { notes = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.TRIGGERS -> TriggersPage(
                trigFreq = trigFreq,
                trigPool = trigPool.filter { it.predictionValue?.uppercase() != "NONE" }.map { it.label },
                linked = linkedTriggers,
                addQueue = addTriggers,
                onQueueRemove = { addTriggers = addTriggers.filterNot { p -> p === it } },
                deleteIds = deleteTriggerIds,
                toggleDelete = { idToggle ->
                    deleteTriggerIds = if (deleteTriggerIds.contains(idToggle)) deleteTriggerIds - idToggle else deleteTriggerIds + idToggle
                },
                setShowAddTrig = { showAddTrig = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.MEDICINES -> MedicinesPage(
                medFreq = medFreq,
                medPool = medPool.map { it.label },
                linked = linkedMeds,
                addQueue = addMeds,
                onQueueRemove = { addMeds = addMeds.filterNot { p -> p === it } },
                deleteIds = deleteMedicineIds,
                toggleDelete = { idToggle ->
                    deleteMedicineIds = if (deleteMedicineIds.contains(idToggle)) deleteMedicineIds - idToggle else deleteMedicineIds + idToggle
                },
                setShowAddMed = { showAddMed = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.RELIEFS -> ReliefsPage(
                relFreq = relFreq,
                relPool = relPool.map { it.label },
                linked = linkedRels,
                addQueue = addRels,
                onQueueRemove = { addRels = addRels.filterNot { p -> p === it } },
                deleteIds = deleteReliefIds,
                toggleDelete = { idToggle ->
                    deleteReliefIds = if (deleteReliefIds.contains(idToggle)) deleteReliefIds - idToggle else deleteReliefIds + idToggle
                },
                setShowAddRel = { showAddRel = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.REVIEW -> ReviewPage(
                label = selectedLabel,
                severity = severity.toInt(),
                beganAt = beganAt,
                endedAt = endedAt,
                notes = notes.text,
                deletes = Triple(deleteTriggerIds.size, deleteMedicineIds.size, deleteReliefIds.size),
                adds = Triple(addTriggers.size, addMeds.size, addRels.size),
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(16.dp)
            )
        }
    }

    // Add dialogs (queue only)
    if (showAddTrig != null) {
        TimeAddDialog(
            title = "Add trigger",
            onDismiss = { showAddTrig = null },
            onConfirm = { iso ->
                val label = showAddTrig ?: return@TimeAddDialog
                addTriggers = listOf(PendingTrigger(type = label, startIso = iso)) + addTriggers
                showAddTrig = null
            }
        )
    }
    if (showAddMed != null) {
        MedicineAddDialog(
            title = "Add medicine",
            name = showAddMed!!,
            onDismiss = { showAddMed = null },
            onConfirm = { amount, iso, notesText ->
                val name = showAddMed ?: return@MedicineAddDialog
                addMeds = listOf(PendingMedicine(name, amount, iso, notesText)) + addMeds
                showAddMed = null
            }
        )
    }
    if (showAddRel != null) {
        ReliefAddDialog(
            title = "Add relief",
            typeLabel = showAddRel!!,
            onDismiss = { showAddRel = null },
            onConfirm = { durationMinutes, iso, notesText ->
                val type = showAddRel ?: return@ReliefAddDialog
                addRels = listOf(PendingRelief(type, durationMinutes, iso, notesText)) + addRels
                showAddRel = null
            }
        )
    }
}

/* -------------------- Pages -------------------- */

@Composable
private fun CorePage(
    selectedLabel: String?,
    onSelectLabel: (String) -> Unit,
    mgFrequent: List<String>,
    mgAll: List<String>,
    typeMenuOpen: Boolean,
    setTypeMenuOpen: (Boolean) -> Unit,
    severity: Float,
    setSeverity: (Float) -> Unit,
    beganAt: String?,
    setBeganAt: (String?) -> Unit,
    endedAt: String?,
    setEndedAt: (String?) -> Unit,
    endBeforeStart: Boolean,
    notes: TextFieldValue,
    setNotes: (TextFieldValue) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Column {
                OutlinedTextField(
                    value = selectedLabel ?: "Migraine",
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Migraine selection") },
                    trailingIcon = {
                        IconButton(onClick = { setTypeMenuOpen(true) }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(expanded = typeMenuOpen, onDismissRequest = { setTypeMenuOpen(false) }) {
                    if (mgFrequent.isNotEmpty()) {
                        DropdownMenuItem(text = { Text("Frequent") }, onClick = {}, enabled = false)
                        mgFrequent.forEach { label ->
                            DropdownMenuItem(text = { Text(label) }, onClick = {
                                setTypeMenuOpen(false); onSelectLabel(label)
                            })
                        }
                        HorizontalDivider()
                    }
                    if (mgAll.isNotEmpty()) {
                        DropdownMenuItem(text = { Text("All") }, onClick = {}, enabled = false)
                        mgAll.forEach { label ->
                            DropdownMenuItem(text = { Text(label) }, onClick = {
                                setTypeMenuOpen(false); onSelectLabel(label)
                            })
                        }
                    }
                }
            }
        }
        item {
            Column {
                Text("Severity: ${severity.toInt()}", style = MaterialTheme.typography.bodyMedium)
                Slider(
                    value = severity,
                    onValueChange = setSeverity,
                    valueRange = 1f..10f,
                    steps = 8,
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                AppDateTimePicker(label = "Start time") { iso -> setBeganAt(iso) }
                Text("Current: ${formatIsoDdMmYyHm(beganAt)}")
                AppDateTimePicker(label = "End time") { iso -> setEndedAt(iso) }
                Text("Current: ${formatIsoDdMmYyHm(endedAt)}")
                if (endBeforeStart) {
                    Text("End time cannot be before start time", color = MaterialTheme.colorScheme.error)
                }
            }
        }
        item {
            OutlinedTextField(
                value = notes,
                onValueChange = setNotes,
                label = { Text("Notes") },
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
private fun TriggersPage(
    trigFreq: List<String>,
    trigPool: List<String>,
    linked: List<SupabaseDbService.TriggerRow>,
    addQueue: List<PendingTrigger>,
    onQueueRemove: (PendingTrigger) -> Unit,
    deleteIds: Set<String>,
    toggleDelete: (String) -> Unit,
    setShowAddTrig: (String?) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item { Text("Triggers", style = MaterialTheme.typography.titleMedium) }
        items(linked, key = { it.id }) { t ->
            val mark = deleteIds.contains(t.id)
            val isPredicted = t.type == "menstruation_predicted"
            
            ElevatedCard(Modifier.fillMaxWidth()) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text("Type: ${t.type ?: "-"}")
                        Text("Time: ${formatIsoDdMmYyHm(t.startAt)}")
                        if (!t.notes.isNullOrBlank()) Text("Notes: ${t.notes}")
                        if (mark) Text("Marked for deletion", color = MaterialTheme.colorScheme.error)
                        if (isPredicted) {
                            Text(
                                "Predicted",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.outline
                            )
                        }
                    }
                    // Only show Edit/Delete for non-predicted triggers
                    if (!isPredicted) {
                        Row {
                            TextButton(onClick = { /* optional edit route */ }) { Text("Edit") }
                            IconButton(onClick = { toggleDelete(t.id) }) {
                                Icon(Icons.Filled.Delete, contentDescription = "Toggle delete trigger")
                            }
                        }
                    }
                }
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (trigFreq.isNotEmpty()) {
                    Text("Frequent", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { trigFreq.forEach { label -> AssistChip(onClick = { setShowAddTrig(label) }, label = { Text(label) }) } }
                }
                val remaining = trigPool.filter { it !in trigFreq }
                if (remaining.isNotEmpty()) {
                    Text("All", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { remaining.forEach { label -> AssistChip(onClick = { setShowAddTrig(label) }, label = { Text(label) }) } }
                }
            }
        }
        if (addQueue.isNotEmpty()) {
            item { Text("Pending triggers", style = MaterialTheme.typography.titleSmall) }
            items(addQueue) { pt ->
                ElevatedCard(Modifier.fillMaxWidth()) {
                    Row(
                        Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Column {
                            Text("Type: ${pt.type}")
                            Text("Time: ${formatIsoDdMmYyHm(pt.startIso)}")
                        }
                        TextButton(onClick = { onQueueRemove(pt) }) { Text("Remove") }
                    }
                }
            }
        }
    }
}

@Composable
private fun MedicinesPage(
    medFreq: List<String>,
    medPool: List<String>,
    linked: List<SupabaseDbService.MedicineRow>,
    addQueue: List<PendingMedicine>,
    onQueueRemove: (PendingMedicine) -> Unit,
    deleteIds: Set<String>,
    toggleDelete: (String) -> Unit,
    setShowAddMed: (String?) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item { Text("Medicines", style = MaterialTheme.typography.titleMedium) }
        items(linked, key = { it.id }) { m ->
            val mark = deleteIds.contains(m.id)
            ElevatedCard(Modifier.fillMaxWidth()) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text("Name: ${m.name ?: "-"}")
                        Text("Amount: ${m.amount ?: "-"}")
                        Text("Time: ${formatIsoDdMmYyHm(m.startAt)}")
                        if (!m.notes.isNullOrBlank()) Text("Notes: ${m.notes}")
                        if (mark) Text("Marked for deletion", color = MaterialTheme.colorScheme.error)
                    }
                    Row {
                        TextButton(onClick = { /* optional edit route */ }) { Text("Edit") }
                        IconButton(onClick = { toggleDelete(m.id) }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Toggle delete medicine")
                        }
                    }
                }
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (medFreq.isNotEmpty()) {
                    Text("Frequent", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { medFreq.forEach { label -> AssistChip(onClick = { setShowAddMed(label) }, label = { Text(label) }) } }
                }
                val remaining = medPool.filter { it !in medFreq }
                if (remaining.isNotEmpty()) {
                    Text("All", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { remaining.forEach { label -> AssistChip(onClick = { setShowAddMed(label) }, label = { Text(label) }) } }
                }
            }
        }
        if (addQueue.isNotEmpty()) {
            item { Text("Pending medicines", style = MaterialTheme.typography.titleSmall) }
            items(addQueue) { pm ->
                ElevatedCard(Modifier.fillMaxWidth()) {
                    Row(
                        Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Column {
                            Text("Name: ${pm.name}")
                            Text("Amount: ${pm.amount ?: "-"}")
                            Text("Time: ${formatIsoDdMmYyHm(pm.startIso)}")
                            if (!pm.notes.isNullOrBlank()) Text("Notes: ${pm.notes}")
                        }
                        TextButton(onClick = { onQueueRemove(pm) }) { Text("Remove") }
                    }
                }
            }
        }
    }
}

@Composable
private fun ReliefsPage(
    relFreq: List<String>,
    relPool: List<String>,
    linked: List<SupabaseDbService.ReliefRow>,
    addQueue: List<PendingRelief>,
    onQueueRemove: (PendingRelief) -> Unit,
    deleteIds: Set<String>,
    toggleDelete: (String) -> Unit,
    setShowAddRel: (String?) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item { Text("Reliefs", style = MaterialTheme.typography.titleMedium) }
        items(linked, key = { it.id }) { r ->
            val mark = deleteIds.contains(r.id)
            ElevatedCard(Modifier.fillMaxWidth()) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text("Type: ${r.type ?: "-"}")
                        Text("Duration: ${r.durationMinutes ?: 0} min")
                        Text("Time: ${formatIsoDdMmYyHm(r.startAt)}")
                        if (!r.notes.isNullOrBlank()) Text("Notes: ${r.notes}")
                        if (mark) Text("Marked for deletion", color = MaterialTheme.colorScheme.error)
                    }
                    Row {
                        TextButton(onClick = { /* optional edit route */ }) { Text("Edit") }
                        IconButton(onClick = { toggleDelete(r.id) }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Toggle delete relief")
                        }
                    }
                }
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (relFreq.isNotEmpty()) {
                    Text("Frequent", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { relFreq.forEach { label -> AssistChip(onClick = { setShowAddRel(label) }, label = { Text(label) }) } }
                }
                val remaining = relPool.filter { it !in relFreq }
                if (remaining.isNotEmpty()) {
                    Text("All", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { remaining.forEach { label -> AssistChip(onClick = { setShowAddRel(label) }, label = { Text(label) }) } }
                }
            }
        }
        if (addQueue.isNotEmpty()) {
            item { Text("Pending reliefs", style = MaterialTheme.typography.titleSmall) }
            items(addQueue) { pr ->
                ElevatedCard(Modifier.fillMaxWidth()) {
                    Row(
                        Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Column {
                            Text("Type: ${pr.type}")
                            Text("Duration: ${pr.durationMinutes ?: 0} min")
                            Text("Time: ${formatIsoDdMmYyHm(pr.startIso)}")
                            if (!pr.notes.isNullOrBlank()) Text("Notes: ${pr.notes}")
                        }
                        TextButton(onClick = { onQueueRemove(pr) }) { Text("Remove") }
                    }
                }
            }
        }
    }
}

@Composable
private fun ReviewPage(
    label: String?,
    severity: Int,
    beganAt: String?,
    endedAt: String?,
    notes: String?,
    deletes: Triple<Int, Int, Int>,
    adds: Triple<Int, Int, Int>,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier, verticalArrangement = Arrangement.spacedBy(12.dp)) {
        Text("Review", style = MaterialTheme.typography.titleLarge)
        Text("Migraine: ${label ?: "Migraine"}")
        Text("Severity: $severity")
        Text("Start: ${formatIsoDdMmYyHm(beganAt)}")
        Text("End: ${formatIsoDdMmYyHm(endedAt)}")
        if (!notes.isNullOrBlank()) Text("Notes: $notes")
        Spacer(Modifier.height(8.dp))
        Text("Queued changes:", style = MaterialTheme.typography.titleMedium)
        Text("Delete → Triggers: ${deletes.first}, Medicines: ${deletes.second}, Reliefs: ${deletes.third}")
        Text("Add → Triggers: ${adds.first}, Medicines: ${adds.second}, Reliefs: ${adds.third}")
    }
}

/* -------------------- Helpers -------------------- */

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun FlowRowWrap(content: @Composable () -> Unit) {
    FlowRow(
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
        modifier = Modifier.fillMaxWidth()
    ) { content() }
}

private fun formatIsoDdMmYyHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "-"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        "-"
    }
}

private fun isEndBeforeStart(startIso: String?, endIso: String?): Boolean {
    if (startIso.isNullOrBlank() || endIso.isNullOrBlank()) return false
    val start = parseInstantFlexible(startIso) ?: return false
    val end = parseInstantFlexible(endIso) ?: return false
    return end.isBefore(start)
}

private fun parseInstantFlexible(iso: String): Instant? {
    return runCatching { Instant.parse(iso) }.getOrElse {
        runCatching { OffsetDateTime.parse(iso).toInstant() }.getOrNull()
    }
}

/* ---------- local dialogs ---------- */

@Composable
private fun TimeAddDialog(
    title: String,
    onDismiss: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf<String?>(null) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text("Add") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Time: ${formatIsoDdMmYyHm(pickedIso)}")
                AppDateTimePicker(label = "Select time") { iso -> pickedIso = iso }
            }
        }
    )
}

@Composable
private fun MedicineAddDialog(
    title: String,
    name: String,
    onDismiss: () -> Unit,
    onConfirm: (amount: String?, startIso: String?, notes: String?) -> Unit
) {
    var amount by remember { mutableStateOf("") }
    var pickedIso by remember { mutableStateOf<String?>(null) }
    var notes by remember { mutableStateOf("") }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(onClick = { onConfirm(amount.ifBlank { null }, pickedIso, notes.ifBlank { null }) }) {
                Text("Add")
            }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Medicine: $name")
                OutlinedTextField(
                    value = amount,
                    onValueChange = { amount = it },
                    label = { Text("Amount") },
                    modifier = Modifier.fillMaxWidth()
                )
                AppDateTimePicker(label = "Select time") { iso -> pickedIso = iso }
                OutlinedTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = { Text("Notes") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    )
}

@Composable
private fun ReliefAddDialog(
    title: String,
    typeLabel: String,
    onDismiss: () -> Unit,
    onConfirm: (durationMinutes: Int?, startIso: String?, notes: String?) -> Unit
) {
    var durationText by remember { mutableStateOf("") }
    var pickedIso by remember { mutableStateOf<String?>(null) }
    var notes by remember { mutableStateOf("") }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = {
                    val dur = durationText.toIntOrNull()
                    onConfirm(dur, pickedIso, notes.ifBlank { null })
                }
            ) { Text("Add") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Relief: $typeLabel")
                OutlinedTextField(
                    value = durationText,
                    onValueChange = { v -> durationText = v.filter { it.isDigit() }.take(4) },
                    label = { Text("Duration minutes") },
                    modifier = Modifier.fillMaxWidth()
                )
                AppDateTimePicker(label = "Select time") { iso -> pickedIso = iso }
                OutlinedTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = { Text("Notes") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    )
}



title: EditReliefScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun EditReliefScreen(
    navController: NavHostController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken, id) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) {
            vm.loadReliefById(token, id)
            vm.loadReliefOptions(token)
            vm.loadMigraines(token)
        }
    }

    val row by vm.editRelief.collectAsState()
    val frequent by vm.reliefOptionsFrequent.collectAsState()
    val all by vm.reliefOptionsAll.collectAsState()
    val migraines by vm.migraines.collectAsState()

    var type by rememberSaveable(row?.id) { mutableStateOf(row?.type ?: "") }
    var durationText by rememberSaveable(row?.id) { mutableStateOf(row?.durationMinutes?.toString() ?: "") }
    var startAt by rememberSaveable(row?.id) { mutableStateOf(row?.startAt ?: "") }
    var notes by rememberSaveable(row?.id) { mutableStateOf(row?.notes ?: "") }
    var migraineId by rememberSaveable(row?.id) { mutableStateOf(row?.migraineId ?: "") }

    var typeMenuOpen by rememberSaveable { mutableStateOf(false) }
    var migraineMenuOpen by rememberSaveable { mutableStateOf(false) }

    fun labelForMigraine(startIso: String?): String {
        if (startIso.isNullOrBlank()) return "Unknown"
        return try {
            val odt = runCatching { OffsetDateTime.parse(startIso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(startIso)
            ldt.format(DateTimeFormatter.ofPattern("EEE, dd MMM yyyy • HH:mm"))
        } catch (_: Exception) { "Unknown" }
    }
    val selectedMigraineLabel = migraines
        .firstOrNull { it.id == migraineId }
        ?.let { labelForMigraine(it.startAt) }
        ?: "None"

    fun formatIsoDdMmHm(iso: String?): String {
        if (iso.isNullOrBlank()) return "Not set"
        return try {
            val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
            ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
        } catch (_: Exception) { "Not set" }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Edit Relief")

        // Type dropdown with Frequent / All
        if (frequent.isNotEmpty() || all.isNotEmpty()) {
            Box(modifier = Modifier.fillMaxWidth()) {
                OutlinedTextField(
                    value = type,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Type") },
                    trailingIcon = {
                        IconButton(onClick = { typeMenuOpen = true }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose type")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(
                    expanded = typeMenuOpen,
                    onDismissRequest = { typeMenuOpen = false }
                ) {
                    if (frequent.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        frequent.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                        if (all.isNotEmpty()) Divider()
                    }
                    if (all.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("All", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        all.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                    }
                }
            }
        } else {
            OutlinedTextField(
                value = type,
                onValueChange = { type = it },
                label = { Text("Type") },
                modifier = Modifier.fillMaxWidth()
            )
        }

        // Duration minutes numeric
        OutlinedTextField(
            value = durationText,
            onValueChange = { input -> durationText = input.filter { it.isDigit() }.take(4) },
            label = { Text("Duration minutes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Start time using shared picker
        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
            Text("Start time: ${formatIsoDdMmHm(startAt)}")
            AppDateTimePicker(
                label = "Select time",
                onDateTimeSelected = { iso -> startAt = iso ?: "" }
            )
        }

        OutlinedTextField(
            value = notes,
            onValueChange = { notes = it },
            label = { Text("Notes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Linked Migraine dropdown with time/day labels
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedMigraineLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Linked Migraine") },
                trailingIcon = {
                    IconButton(onClick = { migraineMenuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = migraineMenuOpen,
                onDismissRequest = { migraineMenuOpen = false }
            ) {
                DropdownMenuItem(
                    text = { Text("None") },
                    onClick = {
                        migraineId = ""
                        migraineMenuOpen = false
                    }
                )
                migraines
                    .sortedByDescending { it.startAt }
                    .forEach { m ->
                        val label = labelForMigraine(m.startAt)
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                migraineId = m.id
                                migraineMenuOpen = false
                            }
                        )
                    }
            }
        }

        Spacer(Modifier.height(8.dp))

        Button(
            onClick = {
                val token = authState.accessToken
                if (!token.isNullOrBlank()) {
                    val duration = durationText.toIntOrNull()
                    vm.updateRelief(
                        accessToken = token,
                        id = id,
                        type = type.ifBlank { null },
                        startAt = startAt.ifBlank { null },
                        notes = notes.ifBlank { null },
                        migraineId = migraineId.ifBlank { null }
                    )
                    navController.popBackStack()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save")
        }

        TextButton(
            onClick = { navController.popBackStack() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancel")
        }
    }
}

title: EditTriggerScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun EditTriggerScreen(
    navController: NavHostController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken, id) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) {
            vm.loadTriggerById(token, id)
            vm.loadTriggerOptions(token)
            vm.loadMigraines(token)
        }
    }

    val row by vm.editTrigger.collectAsState()
    val frequent by vm.triggerOptionsFrequent.collectAsState()
    val all by vm.triggerOptionsAll.collectAsState()
    val migraines by vm.migraines.collectAsState()

    var type by rememberSaveable(row?.id) { mutableStateOf(row?.type ?: "") }
    var startAt by rememberSaveable(row?.id) { mutableStateOf(row?.startAt ?: "") }
    var notes by rememberSaveable(row?.id) { mutableStateOf(row?.notes ?: "") }
    var migraineId by rememberSaveable(row?.id) { mutableStateOf(row?.migraineId ?: "") }

    var typeMenuOpen by rememberSaveable { mutableStateOf(false) }
    var migraineMenuOpen by rememberSaveable { mutableStateOf(false) }

    fun labelForMigraine(startIso: String?): String {
        if (startIso.isNullOrBlank()) return "Unknown"
        return try {
            val odt = runCatching { OffsetDateTime.parse(startIso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(startIso)
            ldt.format(DateTimeFormatter.ofPattern("EEE, dd MMM yyyy • HH:mm"))
        } catch (_: Exception) { "Unknown" }
    }
    val selectedMigraineLabel = migraines
        .firstOrNull { it.id == migraineId }
        ?.let { labelForMigraine(it.startAt) }
        ?: "None"

    fun formatIsoDdMmHm(iso: String?): String {
        if (iso.isNullOrBlank()) return "Not set"
        return try {
            val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
            ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
        } catch (_: Exception) { "Not set" }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Edit Trigger")

        // Type dropdown with Frequent / All
        if (frequent.isNotEmpty() || all.isNotEmpty()) {
            Box(modifier = Modifier.fillMaxWidth()) {
                OutlinedTextField(
                    value = type,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Type") },
                    trailingIcon = {
                        IconButton(onClick = { typeMenuOpen = true }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose type")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(
                    expanded = typeMenuOpen,
                    onDismissRequest = { typeMenuOpen = false }
                ) {
                    if (frequent.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        frequent.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                        if (all.isNotEmpty()) Divider()
                    }
                    if (all.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("All", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        all.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                    }
                }
            }
        } else {
            OutlinedTextField(
                value = type,
                onValueChange = { type = it },
                label = { Text("Type") },
                modifier = Modifier.fillMaxWidth()
            )
        }

        // Start time using your shared picker
        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
            Text("Start time: ${formatIsoDdMmHm(startAt)}")
            AppDateTimePicker(
                label = "Select time",
                onDateTimeSelected = { iso -> startAt = iso ?: "" }
            )
        }

        OutlinedTextField(
            value = notes,
            onValueChange = { notes = it },
            label = { Text("Notes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Linked Migraine dropdown (labels show time & day)
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedMigraineLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Linked Migraine") },
                trailingIcon = {
                    IconButton(onClick = { migraineMenuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = migraineMenuOpen,
                onDismissRequest = { migraineMenuOpen = false }
            ) {
                DropdownMenuItem(
                    text = { Text("None") },
                    onClick = {
                        migraineId = ""
                        migraineMenuOpen = false
                    }
                )
                migraines
                    .sortedByDescending { it.startAt }
                    .forEach { m ->
                        val label = labelForMigraine(m.startAt)
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                migraineId = m.id
                                migraineMenuOpen = false
                            }
                        )
                    }
            }
        }

        Spacer(Modifier.height(8.dp))

        Button(
            onClick = {
                val token = authState.accessToken
                if (!token.isNullOrBlank()) {
                    vm.updateTrigger(
                        accessToken = token,
                        id = id,
                        type = type.ifBlank { null },
                        startAt = startAt.ifBlank { null },
                        notes = notes.ifBlank { null },
                        migraineId = migraineId.ifBlank { null }
                    )
                    navController.popBackStack()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save")
        }

        TextButton(
            onClick = { navController.popBackStack() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancel")
        }
    }
}

title: EnvironmentDataHistoryScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.ChevronLeft
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.delete
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// ─── Data models ─────────────────────────────────────────────────────────────

data class WeatherDataEntry(
    val table: String,
    val label: String,
    val value: String,
    val unit: String,
    val source: String
)

@Serializable
private data class WeatherRowGeneric(
    val date: String? = null,
    val source: String? = null,
    @SerialName("temp_c_mean") val tempMean: Double? = null,
    @SerialName("pressure_hpa_mean") val pressureMean: Double? = null,
    @SerialName("humidity_pct_mean") val humidityMean: Double? = null,
    @SerialName("wind_speed_mps_mean") val windSpeedMean: Double? = null,
    @SerialName("uv_index_max") val uvIndexMax: Double? = null,
    @SerialName("is_thunderstorm_day") val isThunderstormDay: Boolean? = null,
    @SerialName("weather_code") val weatherCode: Int? = null
)

// ─── Supabase helpers ────────────────────────────────────────────────────────

private val client = HttpClient {
    install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
}

private val weatherFields = listOf(
    Triple("temp_c_mean", "Temperature", "°C"),
    Triple("pressure_hpa_mean", "Pressure", "hPa"),
    Triple("humidity_pct_mean", "Humidity", "%"),
    Triple("wind_speed_mps_mean", "Wind Speed", "m/s"),
    Triple("uv_index_max", "UV Index", "")
)

private suspend fun fetchWeatherEntriesForDate(
    date: String,
    accessToken: String,
    userId: String
): List<WeatherDataEntry> = withContext(Dispatchers.IO) {
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val entries = mutableListOf<WeatherDataEntry>()

    try {
        val rows: List<WeatherRowGeneric> = client.get("$base/rest/v1/user_weather_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            parameter("user_id", "eq.$userId")
            parameter("date", "eq.$date")
            parameter("select", "date,temp_c_mean,pressure_hpa_mean,humidity_pct_mean,wind_speed_mps_mean,uv_index_max,is_thunderstorm_day")
        }.body()

        for (row in rows) {
            val src = row.source ?: "api"
            row.tempMean?.let {
                entries.add(WeatherDataEntry("user_weather_daily", "Temperature", String.format("%.1f", it), "°C", src))
            }
            row.pressureMean?.let {
                entries.add(WeatherDataEntry("user_weather_daily", "Pressure", String.format("%.0f", it), "hPa", src))
            }
            row.humidityMean?.let {
                entries.add(WeatherDataEntry("user_weather_daily", "Humidity", String.format("%.0f", it), "%", src))
            }
            row.windSpeedMean?.let {
                entries.add(WeatherDataEntry("user_weather_daily", "Wind Speed", String.format("%.1f", it), "m/s", src))
            }
            row.uvIndexMax?.let {
                entries.add(WeatherDataEntry("user_weather_daily", "UV Index", String.format("%.0f", it), "", src))
            }
            row.isThunderstormDay?.let {
                entries.add(WeatherDataEntry("user_weather_daily", "Thunderstorm", if (it) "Yes" else "No", "", src))
            }
        }
    } catch (e: Exception) {
        Log.e("EnvDataHistory", "Failed to fetch weather: ${e.message}")
    }

    // Fetch altitude from user_location_daily
    try {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val locResp = client.get("$base/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            parameter("user_id", "eq.$userId")
            parameter("date", "eq.$date")
            parameter("select", "altitude_max_m,altitude_change_m")
            parameter("limit", "1")
        }
        if (locResp.status.isSuccess()) {
            val body = locResp.body<List<Map<String, Double?>>>()
            val row = body.firstOrNull()
            row?.get("altitude_max_m")?.let {
                entries.add(WeatherDataEntry("user_location_daily", "Altitude", String.format("%.0f", it), "m", "device"))
            }
            row?.get("altitude_change_m")?.let {
                entries.add(WeatherDataEntry("user_location_daily", "Altitude Change", String.format("%.0f", it), "m", "device"))
            }
        }
    } catch (e: Exception) {
        Log.e("EnvDataHistory", "Failed to fetch altitude: ${e.message}")
    }

    entries
}

private suspend fun deleteWeatherEntry(
    date: String,
    accessToken: String,
    userId: String
): Boolean = withContext(Dispatchers.IO) {
    try {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val resp = client.delete("$base/rest/v1/user_weather_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            parameter("user_id", "eq.$userId")
            parameter("date", "eq.$date")
            parameter("source", "eq.manual")
        }
        resp.status.isSuccess()
    } catch (e: Exception) {
        Log.e("EnvDataHistory", "Delete failed: ${e.message}")
        false
    }
}

private suspend fun upsertWeatherManualEntry(
    date: String,
    fields: Map<String, Any>,
    accessToken: String
): Boolean = withContext(Dispatchers.IO) {
    try {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val body = mutableMapOf<String, Any>("date" to date, "source" to "manual")
        body.putAll(fields)
        val resp = client.post("$base/rest/v1/user_weather_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            parameter("on_conflict", "user_id,source,date")
            contentType(ContentType.Application.Json)
            setBody(listOf(body))
        }
        resp.status.isSuccess()
    } catch (e: Exception) {
        Log.e("EnvDataHistory", "Upsert failed: ${e.message}")
        false
    }
}

// ─── Screen ──────────────────────────────────────────────────────────────────

@Composable
fun EnvironmentDataHistoryScreen(onBack: () -> Unit) {
    val context = LocalContext.current
    val scrollState = rememberSaveable(saver = ScrollState.Saver) { ScrollState(0) }
    val scope = rememberCoroutineScope()

    var selectedDateStr by rememberSaveable { mutableStateOf(LocalDate.now().toString()) }
    val selectedDate = LocalDate.parse(selectedDateStr)
    val today = LocalDate.now()

    var entries by remember { mutableStateOf<List<WeatherDataEntry>>(emptyList()) }
    val weatherConfig = remember { WeatherCardConfigStore.load(context) }
    var isLoading by remember { mutableStateOf(true) }

    var showEditDialog by remember { mutableStateOf(false) }
    var editTemp by remember { mutableStateOf("") }
    var editPressure by remember { mutableStateOf("") }
    var editHumidity by remember { mutableStateOf("") }
    var editWind by remember { mutableStateOf("") }
    var editUv by remember { mutableStateOf("") }

    val dateFormatter = DateTimeFormatter.ofPattern("EEEE, MMM d")

    val maxForecastDate = today.plusDays(7)

    fun loadEntries() {
        scope.launch {
            isLoading = true
            val token = SessionStore.readAccessToken(context) ?: return@launch
            val userId = SessionStore.readUserId(context) ?: return@launch
            entries = fetchWeatherEntriesForDate(selectedDateStr, token, userId)
            isLoading = false
        }
    }

    LaunchedEffect(selectedDateStr) { loadEntries() }

    // Edit dialog — weather is a single row so we edit all fields at once
    if (showEditDialog) {
        AlertDialog(
            onDismissRequest = { showEditDialog = false },
            title = { Text("Edit Environment Data", color = AppTheme.TitleColor) },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    WeatherEditField("Temperature (°C)", editTemp) { editTemp = it }
                    WeatherEditField("Pressure (hPa)", editPressure) { editPressure = it }
                    WeatherEditField("Humidity (%)", editHumidity) { editHumidity = it }
                    WeatherEditField("Wind Speed (m/s)", editWind) { editWind = it }
                    WeatherEditField("UV Index", editUv) { editUv = it }

                    Spacer(Modifier.height(8.dp))

                    // Delete manual entry
                    val hasManual = entries.any { it.source == "manual" }
                    if (hasManual) {
                        Text(
                            "Delete manual entry",
                            color = Color(0xFFE57373),
                            style = MaterialTheme.typography.bodyMedium,
                            modifier = Modifier
                                .clickable {
                                    scope.launch {
                                        val token = SessionStore.readAccessToken(context) ?: return@launch
                                        val userId = SessionStore.readUserId(context) ?: return@launch
                                        deleteWeatherEntry(selectedDateStr, token, userId)
                                        showEditDialog = false
                                        loadEntries()
                                    }
                                }
                                .padding(vertical = 8.dp)
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    scope.launch {
                        val token = SessionStore.readAccessToken(context) ?: return@launch
                        val fields = mutableMapOf<String, Any>()
                        editTemp.toDoubleOrNull()?.let { fields["temp_c_mean"] = it }
                        editPressure.toDoubleOrNull()?.let { fields["pressure_hpa_mean"] = it }
                        editHumidity.toDoubleOrNull()?.let { fields["humidity_pct_mean"] = it }
                        editWind.toDoubleOrNull()?.let { fields["wind_speed_mps_mean"] = it }
                        editUv.toDoubleOrNull()?.let { fields["uv_index_max"] = it }
                        if (fields.isNotEmpty()) {
                            upsertWeatherManualEntry(selectedDateStr, fields, token)
                        }
                        showEditDialog = false
                        loadEntries()
                    }
                }) { Text("Save", color = AppTheme.AccentPurple) }
            },
            dismissButton = {
                TextButton(onClick = { showEditDialog = false }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            containerColor = Color(0xFF1E0A2E)
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = onBack) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                }
            }

            HeroCard {
                Text(
                    "Environment Data",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    "View and edit environment entries",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            // Date navigation
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(onClick = { selectedDateStr = selectedDate.minusDays(1).toString() }) {
                        Icon(Icons.Default.ChevronLeft, contentDescription = "Previous day", tint = AppTheme.AccentPurple)
                    }
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            when {
                                selectedDate == today -> "Today"
                                selectedDate == today.minusDays(1) -> "Yesterday"
                                selectedDate == today.plusDays(1) -> "Tomorrow"
                                else -> selectedDate.format(dateFormatter)
                            },
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                    }
                    IconButton(
                        onClick = { selectedDateStr = selectedDate.plusDays(1).toString() },
                        enabled = selectedDate < maxForecastDate
                    ) {
                        Icon(
                            Icons.Default.ChevronRight,
                            contentDescription = "Next day",
                            tint = if (selectedDate < maxForecastDate) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f)
                        )
                    }
                }
            }

            // Entries
            BaseCard {
                if (isLoading) {
                    Row(
                        modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                    }
                } else {
                    // Map labels to metric keys
                    val labelToMetric = mapOf(
                        "Temperature" to WeatherCardConfig.METRIC_TEMPERATURE,
                        "Pressure" to WeatherCardConfig.METRIC_PRESSURE,
                        "Humidity" to WeatherCardConfig.METRIC_HUMIDITY,
                        "Wind Speed" to WeatherCardConfig.METRIC_WIND_SPEED,
                        "UV Index" to WeatherCardConfig.METRIC_UV_INDEX,
                        "Altitude" to WeatherCardConfig.METRIC_ALTITUDE,
                        "Altitude Change" to WeatherCardConfig.METRIC_ALTITUDE_CHANGE
                    )

                    // Best value per metric (prefer non-manual)
                    val bestByMetric = mutableMapOf<String, WeatherDataEntry>()
                    entries.forEach { entry ->
                        val metricKey = labelToMetric[entry.label] ?: return@forEach
                        val existing = bestByMetric[metricKey]
                        if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                            bestByMetric[metricKey] = entry
                        }
                    }

                    val selectedMetrics = weatherConfig.weatherDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                    // Top 3 selected metrics
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val entry = bestByMetric[metric]
                            val value = if (entry != null) "${entry.value}${if (entry.unit.isNotEmpty()) entry.unit else ""}" else "—"
                            val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(value, color = slotColors.getOrElse(index) { slotColors.last() }, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
                                Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    }

                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text("All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    // Show ALL metrics with "—" for missing
                    WeatherCardConfig.ALL_WEATHER_METRICS.forEach { metric ->
                        if (metric !in selectedMetrics) {
                            val entry = bestByMetric[metric]
                            val value = if (entry != null) "${entry.value}${if (entry.unit.isNotEmpty()) entry.unit else ""}" else "—"
                            val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                            Row(
                                modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                                Text(value, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
                            }
                        }
                    }

                    // All entries flat (no source grouping)
                    if (entries.isNotEmpty()) {
                        Spacer(Modifier.height(8.dp))
                        HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                        Spacer(Modifier.height(8.dp))

                        // Deduplicate: prefer non-manual source
                        val dedupedByLabel = mutableMapOf<String, WeatherDataEntry>()
                        entries.forEach { entry ->
                            val existing = dedupedByLabel[entry.label]
                            if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                                dedupedByLabel[entry.label] = entry
                            }
                        }

                        dedupedByLabel.values.forEach { entry ->
                            Row(
                                modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(entry.label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                                Text(
                                    "${entry.value}${if (entry.unit.isNotEmpty()) " ${entry.unit}" else ""}",
                                    color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }

                        // Show edit button if manual entries exist
                        if (entries.any { it.source == "manual" }) {
                            Spacer(Modifier.height(4.dp))
                            Text(
                                "✎ Edit manual entry",
                                color = AppTheme.AccentPurple,
                                style = MaterialTheme.typography.bodySmall,
                                modifier = Modifier.clickable {
                                    editTemp = entries.find { it.label == "Temperature" }?.value ?: ""
                                    editPressure = entries.find { it.label == "Pressure" }?.value ?: ""
                                    editHumidity = entries.find { it.label == "Humidity" }?.value ?: ""
                                    editWind = entries.find { it.label == "Wind Speed" }?.value ?: ""
                                    editUv = entries.find { it.label == "UV Index" }?.value ?: ""
                                    showEditDialog = true
                                }
                            )
                        }
                    }
                }
            }
        }
    }

@Composable
private fun WeatherEditField(label: String, value: String, onValueChange: (String) -> Unit) {
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        label = { Text(label, style = MaterialTheme.typography.labelSmall) },
        singleLine = true,
        colors = OutlinedTextFieldDefaults.colors(
            focusedBorderColor = AppTheme.AccentPurple,
            unfocusedBorderColor = AppTheme.SubtleTextColor.copy(alpha = 0.3f),
            focusedTextColor = AppTheme.TitleColor,
            unfocusedTextColor = AppTheme.TitleColor,
            focusedLabelColor = AppTheme.AccentPurple,
            unfocusedLabelColor = AppTheme.SubtleTextColor
        ),
        modifier = Modifier.fillMaxWidth()
    )
}

private fun envMetricColor(metric: String): Color = when (metric) {
    WeatherCardConfig.METRIC_TEMPERATURE -> Color(0xFFFF8A65)
    WeatherCardConfig.METRIC_PRESSURE -> Color(0xFF7986CB)
    WeatherCardConfig.METRIC_HUMIDITY -> Color(0xFF4FC3F7)
    WeatherCardConfig.METRIC_WIND_SPEED -> Color(0xFF81C784)
    WeatherCardConfig.METRIC_UV_INDEX -> Color(0xFFFFB74D)
    else -> Color(0xFF4FC3F7)
}

private fun weatherSourceLabel(source: String): String = when (source) {
    "manual" -> "Manual"
    "api" -> "Weather API"
    else -> source.replaceFirstChar { it.uppercase() }
}


title: EveningCheckInScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material.icons.outlined.Check
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Mic
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDate

private enum class CheckInPage { TRIGGERS, PRODROMES, MEDICINES, RELIEFS, NOTE, REVIEW }

private data class SelectableItem(
    val label: String,
    val iconKey: String? = null,
    val isFavourite: Boolean = false,
)

data class AiMatchItem(val label: String, val category: String)

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun EveningCheckInScreen(
    navController: NavController,
    authVm: AuthViewModel,
    triggerVm: TriggerViewModel = viewModel(),
    prodromeVm: ProdromeViewModel = viewModel(),
    medicineVm: MedicineViewModel = viewModel(),
    reliefVm: ReliefViewModel = viewModel(),
) {
    val scope = rememberCoroutineScope()
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { token ->
            triggerVm.loadAll(token)
            prodromeVm.loadAll(token)
            medicineVm.loadAll(token)
            reliefVm.loadAll(token)
        }
    }

    val triggerPool by triggerVm.pool.collectAsState()
    val triggerFreq by triggerVm.frequent.collectAsState()
    val prodromePool by prodromeVm.pool.collectAsState()
    val prodromeFreq by prodromeVm.frequent.collectAsState()
    val medicinePool by medicineVm.pool.collectAsState()
    val medicineFreq by medicineVm.frequent.collectAsState()
    val reliefPool by reliefVm.pool.collectAsState()
    val reliefFreq by reliefVm.frequent.collectAsState()

    val triggerFavIds = remember(triggerFreq) { triggerFreq.map { it.triggerId }.toSet() }
    val triggerItems = remember(triggerPool, triggerFavIds) {
        triggerPool.filter { it.predictionValue?.uppercase() != "NONE" }
            .map { SelectableItem(it.label, it.iconKey, it.id in triggerFavIds) }
    }
    val prodromeFavIds = remember(prodromeFreq) { prodromeFreq.map { it.prodromeId }.toSet() }
    val prodromeItems = remember(prodromePool, prodromeFavIds) {
        prodromePool.map { SelectableItem(it.label, it.iconKey, it.id in prodromeFavIds) }
    }
    val medicineFavIds = remember(medicineFreq) { medicineFreq.map { it.medicineId }.toSet() }
    val medicineItems = remember(medicinePool, medicineFavIds) {
        medicinePool.map { SelectableItem(it.label, it.category, it.id in medicineFavIds) }
    }
    val reliefFavIds = remember(reliefFreq) { reliefFreq.map { it.reliefId }.toSet() }
    val reliefItems = remember(reliefPool, reliefFavIds) {
        reliefPool.map { SelectableItem(it.label, it.iconKey, it.id in reliefFavIds) }
    }

    val selectedTriggers = remember { mutableStateListOf<String>() }
    val selectedProdromes = remember { mutableStateListOf<String>() }
    val selectedMedicines = remember { mutableStateListOf<String>() }
    val selectedReliefs = remember { mutableStateListOf<String>() }

    var noteText by remember { mutableStateOf("") }
    var aiMatches by remember { mutableStateOf<List<AiMatchItem>>(emptyList()) }
    var aiParsed by remember { mutableStateOf(false) }
    var aiLoading by remember { mutableStateOf(false) }

    var currentPage by remember { mutableStateOf(CheckInPage.TRIGGERS) }
    var saving by remember { mutableStateOf(false) }
    var saved by remember { mutableStateOf(false) }

    fun runAiParse() {
        if (noteText.isBlank()) { aiParsed = true; return }
        val token = authState.accessToken ?: return
        aiLoading = true
        scope.launch {
            try {
                val matches = withContext(Dispatchers.IO) {
                    callGptForMatches(
                        token,
                        noteText,
                        triggerPool.map { it.label },
                        prodromePool.map { it.label },
                        medicinePool.map { it.label },
                        reliefPool.map { it.label }
                    )
                }
                aiMatches = matches
                matches.forEach { m ->
                    when (m.category) {
                        "trigger" -> if (m.label !in selectedTriggers) selectedTriggers.add(m.label)
                        "prodrome" -> if (m.label !in selectedProdromes) selectedProdromes.add(m.label)
                        "medicine" -> if (m.label !in selectedMedicines) selectedMedicines.add(m.label)
                        "relief" -> if (m.label !in selectedReliefs) selectedReliefs.add(m.label)
                    }
                }
            } catch (e: Exception) {
                Log.e("EveningCheckIn", "AI parse failed, falling back to local", e)
                // Fallback to local matching
                val matches = matchNoteTextLocal(noteText, triggerPool.map { it.label }, prodromePool.map { it.label }, medicinePool.map { it.label }, reliefPool.map { it.label })
                aiMatches = matches
                matches.forEach { m ->
                    when (m.category) {
                        "trigger" -> if (m.label !in selectedTriggers) selectedTriggers.add(m.label)
                        "prodrome" -> if (m.label !in selectedProdromes) selectedProdromes.add(m.label)
                        "medicine" -> if (m.label !in selectedMedicines) selectedMedicines.add(m.label)
                        "relief" -> if (m.label !in selectedReliefs) selectedReliefs.add(m.label)
                    }
                }
            }
            aiParsed = true; aiLoading = false
        }
    }

    fun save() {
        val token = authState.accessToken ?: return
        saving = true
        scope.launch {
            try {
                withContext(Dispatchers.IO) {
                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                    val now = Instant.now().toString()
                    selectedTriggers.forEach { runCatching { db.insertTrigger(token, null, it, now, "evening check-in") } }
                    selectedProdromes.forEach { runCatching { db.insertProdrome(token, null, it, now, "evening check-in") } }
                    selectedMedicines.forEach { runCatching { db.insertMedicine(token, null, it, null, now, "evening check-in") } }
                    selectedReliefs.forEach { runCatching { db.insertRelief(token, null, it, now, "evening check-in") } }
                }
                saved = true
                kotlinx.coroutines.delay(1200)
                navController.popBackStack()
            } catch (e: Exception) { Log.e("EveningCheckIn", "Save failed", e) }
            finally { saving = false }
        }
    }

    val pages = CheckInPage.entries
    val pageIndex = pages.indexOf(currentPage)

    fun goNext() {
        if (currentPage == CheckInPage.NOTE && noteText.isNotBlank() && !aiParsed) runAiParse()
        pages.getOrNull(pageIndex + 1)?.let { currentPage = it }
    }
    fun goBack() { pages.getOrNull(pageIndex - 1)?.let { currentPage = it } }

    // ── UI ──

    val bgBrush = remember { androidx.compose.ui.graphics.Brush.verticalGradient(listOf(Color(0xFF1A0029), Color(0xFF2A003D), Color(0xFF1A0029))) }

    Column(Modifier.fillMaxSize().background(bgBrush).statusBarsPadding().navigationBarsPadding()) {
        LinearProgressIndicator(
            progress = { (pageIndex + 1).toFloat() / pages.size },
            modifier = Modifier.fillMaxWidth().padding(horizontal = 24.dp, vertical = 12.dp).height(4.dp).clip(RoundedCornerShape(2.dp)),
            color = AppTheme.AccentPink, trackColor = AppTheme.TrackColor
        )
        Text(
            "Evening Check-in — ${pageIndex + 1} of ${pages.size}",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelSmall,
            modifier = Modifier.padding(horizontal = 28.dp)
        )
        Spacer(Modifier.height(8.dp))

        Box(Modifier.weight(1f).fillMaxWidth()) {
            AnimatedContent(
                targetState = currentPage,
                transitionSpec = {
                    if (targetState.ordinal > initialState.ordinal)
                        slideInHorizontally { it } + fadeIn() togetherWith slideOutHorizontally { -it } + fadeOut()
                    else
                        slideInHorizontally { -it } + fadeIn() togetherWith slideOutHorizontally { it } + fadeOut()
                }, label = "checkinPage"
            ) { page -> when (page) {
                CheckInPage.TRIGGERS -> FavouritesPage("Any triggers today?", "Tap anything that happened", triggerItems, selectedTriggers, Color(0xFFFFB74D), { TriggerIcons.forKey(it) }) { l -> if (l in selectedTriggers) selectedTriggers.remove(l) else selectedTriggers.add(l) }
                CheckInPage.PRODROMES -> FavouritesPage("Any warning signs?", "Body signals you noticed", prodromeItems, selectedProdromes, Color(0xFF9575CD), { ProdromeIcons.forKey(it) }) { l -> if (l in selectedProdromes) selectedProdromes.remove(l) else selectedProdromes.add(l) }
                CheckInPage.MEDICINES -> FavouritesPage("Take any medicine?", "What did you take today", medicineItems, selectedMedicines, Color(0xFF4FC3F7), { MedicineIcons.forKey(it) }) { l -> if (l in selectedMedicines) selectedMedicines.remove(l) else selectedMedicines.add(l) }
                CheckInPage.RELIEFS -> FavouritesPage("Use any relief methods?", "What helped today", reliefItems, selectedReliefs, Color(0xFF81C784), { ReliefIcons.forKey(it) }) { l -> if (l in selectedReliefs) selectedReliefs.remove(l) else selectedReliefs.add(l) }
                CheckInPage.NOTE -> NotePage(noteText, { noteText = it; if (aiParsed) { aiParsed = false; aiMatches = emptyList() } }, aiLoading, aiParsed, aiMatches) { runAiParse() }
                CheckInPage.REVIEW -> ReviewPage(selectedTriggers, selectedProdromes, selectedMedicines, selectedReliefs, aiMatches.map { it.label }.toSet(), saving, saved, { selectedTriggers.remove(it) }, { selectedProdromes.remove(it) }, { selectedMedicines.remove(it) }, { selectedReliefs.remove(it) }) { save() }
            } }
        }

        if (!saved) {
            Row(Modifier.fillMaxWidth().padding(horizontal = 20.dp, vertical = 8.dp), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                if (currentPage == CheckInPage.TRIGGERS) {
                    TextButton(onClick = { navController.popBackStack() }, modifier = Modifier.height(36.dp)) { Text("Cancel", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall) }
                } else {
                    TextButton(onClick = { goBack() }, modifier = Modifier.height(36.dp)) { Icon(Icons.AutoMirrored.Filled.ArrowBack, null, Modifier.size(14.dp), tint = AppTheme.SubtleTextColor); Spacer(Modifier.width(2.dp)); Text("Back", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall) }
                }
                when (currentPage) {
                    CheckInPage.REVIEW -> Button(onClick = { save() }, enabled = !saving, modifier = Modifier.height(36.dp), colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink), shape = RoundedCornerShape(10.dp), contentPadding = PaddingValues(horizontal = 14.dp, vertical = 0.dp)) {
                        if (saving) { CircularProgressIndicator(Modifier.size(14.dp), Color.White, strokeWidth = 2.dp) } else { Icon(Icons.Outlined.Check, null, Modifier.size(14.dp)); Spacer(Modifier.width(4.dp)); Text("Save", style = MaterialTheme.typography.bodySmall) }
                    }
                    CheckInPage.NOTE -> Button(onClick = { if (noteText.isNotBlank() && !aiParsed) runAiParse(); goNext() }, enabled = !aiLoading, modifier = Modifier.height(36.dp), colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple), shape = RoundedCornerShape(10.dp), contentPadding = PaddingValues(horizontal = 14.dp, vertical = 0.dp)) {
                        Text(if (noteText.isNotBlank() && !aiParsed) "Match & review" else "Review", style = MaterialTheme.typography.bodySmall); Spacer(Modifier.width(2.dp)); Icon(Icons.AutoMirrored.Filled.ArrowForward, null, Modifier.size(14.dp))
                    }
                    else -> Button(onClick = { goNext() }, modifier = Modifier.height(36.dp), colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple), shape = RoundedCornerShape(10.dp), contentPadding = PaddingValues(horizontal = 14.dp, vertical = 0.dp)) {
                        Text("Next", style = MaterialTheme.typography.bodySmall); Spacer(Modifier.width(2.dp)); Icon(Icons.AutoMirrored.Filled.ArrowForward, null, Modifier.size(14.dp))
                    }
                }
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════
//  Favourites Page
// ═══════════════════════════════════════════════════════════════════

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun FavouritesPage(title: String, subtitle: String, items: List<SelectableItem>, selected: List<String>, accentColor: Color, iconResolver: (String?) -> ImageVector?, onToggle: (String) -> Unit) {
    val scrollState = rememberScrollState()
    var showAll by remember { mutableStateOf(false) }
    val favourites = remember(items) { items.filter { it.isFavourite } }
    val others = remember(items) { items.filter { !it.isFavourite } }

    Column(Modifier.fillMaxSize().verticalScroll(scrollState).padding(horizontal = 20.dp, vertical = 8.dp)) {
        Text(title, color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
        Spacer(Modifier.height(4.dp))
        Text(subtitle, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium)
        Spacer(Modifier.height(20.dp))

        if (favourites.isNotEmpty()) {
            Text("Favourites", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
            Spacer(Modifier.height(12.dp))
            FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(14.dp), modifier = Modifier.fillMaxWidth()) {
                favourites.forEach { item ->
                    CheckInCircle(item.label, iconResolver(item.iconKey) ?: iconResolver(item.label.lowercase()), item.label in selected, accentColor) { onToggle(item.label) }
                }
            }
            Spacer(Modifier.height(16.dp))
        }

        if (others.isNotEmpty()) {
            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
            Row(Modifier.fillMaxWidth().clickable { showAll = !showAll }.padding(vertical = 12.dp), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween) {
                Text(if (showAll) "Show less" else "Show all (${others.size} more)", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold))
                Icon(if (showAll) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
            }
            AnimatedVisibility(visible = showAll) {
                FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(14.dp), modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)) {
                    others.forEach { item ->
                        CheckInCircle(item.label, iconResolver(item.iconKey) ?: iconResolver(item.label.lowercase()), item.label in selected, accentColor) { onToggle(item.label) }
                    }
                }
            }
        }

        val count = selected.size
        if (count > 0) {
            Spacer(Modifier.height(8.dp))
            Text("$count selected", color = accentColor, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold), modifier = Modifier.fillMaxWidth(), textAlign = TextAlign.Center)
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════
//  Note Page
// ═══════════════════════════════════════════════════════════════════

@Composable
private fun NotePage(noteText: String, onNoteChange: (String) -> Unit, aiLoading: Boolean, aiParsed: Boolean, aiMatches: List<AiMatchItem>, onParse: () -> Unit) {
    val scrollState = rememberScrollState()
    val context = androidx.compose.ui.platform.LocalContext.current

    // Speech recogniser launcher
    val speechLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
        contract = androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == android.app.Activity.RESULT_OK) {
            val spoken = result.data
                ?.getStringArrayListExtra(android.speech.RecognizerIntent.EXTRA_RESULTS)
                ?.firstOrNull()
            if (!spoken.isNullOrBlank()) {
                val updated = if (noteText.isBlank()) spoken else "$noteText, $spoken"
                onNoteChange(updated)
            }
        }
    }

    fun launchVoice() {
        val intent = android.content.Intent(android.speech.RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(android.speech.RecognizerIntent.EXTRA_LANGUAGE_MODEL, android.speech.RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(android.speech.RecognizerIntent.EXTRA_PROMPT, "Describe your day…")
        }
        try { speechLauncher.launch(intent) } catch (_: Exception) {
            android.widget.Toast.makeText(context, "Voice input not available", android.widget.Toast.LENGTH_SHORT).show()
        }
    }

    Column(Modifier.fillMaxSize().verticalScroll(scrollState).padding(horizontal = 20.dp, vertical = 8.dp)) {
        Text("Tell our AI about your day", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
        Spacer(Modifier.height(4.dp))
        Text("Type or speak freely — we'll match it to your triggers, prodromes, medicines and reliefs as best we can", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium)
        Spacer(Modifier.height(20.dp))

        OutlinedTextField(
            value = noteText, onValueChange = onNoteChange,
            placeholder = { Text("e.g. \"had red wine, neck felt stiff, took ibuprofen\"", color = AppTheme.SubtleTextColor.copy(alpha = 0.5f)) },
            modifier = Modifier.fillMaxWidth(),
            colors = OutlinedTextFieldDefaults.colors(focusedTextColor = Color.White, unfocusedTextColor = AppTheme.BodyTextColor, cursorColor = AppTheme.AccentPurple, focusedBorderColor = AppTheme.AccentPurple, unfocusedBorderColor = Color.White.copy(alpha = 0.15f)),
            minLines = 3, maxLines = 6
        )
        Spacer(Modifier.height(10.dp))

        // Voice + Find matches row
        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            OutlinedButton(
                onClick = { launchVoice() },
                modifier = Modifier.height(40.dp),
                shape = RoundedCornerShape(10.dp),
                colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple),
                border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f))
            ) {
                Icon(Icons.Outlined.Mic, null, Modifier.size(18.dp))
                Spacer(Modifier.width(4.dp))
                Text("Voice", style = MaterialTheme.typography.bodySmall)
            }

            if (noteText.isNotBlank() && !aiParsed) {
                Button(
                    onClick = onParse, enabled = !aiLoading,
                    modifier = Modifier.weight(1f).height(40.dp),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple.copy(alpha = 0.8f)),
                    shape = RoundedCornerShape(10.dp)
                ) {
                    if (aiLoading) { CircularProgressIndicator(Modifier.size(16.dp), Color.White, strokeWidth = 2.dp); Spacer(Modifier.width(6.dp)); Text("Finding…", style = MaterialTheme.typography.bodySmall) }
                    else Text("Find matches", style = MaterialTheme.typography.bodySmall)
                }
            }
        }
        Spacer(Modifier.height(12.dp))

        if (aiParsed && aiMatches.isNotEmpty()) {
            Spacer(Modifier.height(16.dp))
            Text("Found ${aiMatches.size} match${if (aiMatches.size > 1) "es" else ""} — added to review:", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            Spacer(Modifier.height(8.dp))
            aiMatches.forEach { m ->
                Row(Modifier.fillMaxWidth().padding(vertical = 3.dp).background(catColor(m.category).copy(alpha = 0.12f), RoundedCornerShape(10.dp)).padding(horizontal = 12.dp, vertical = 10.dp), verticalAlignment = Alignment.CenterVertically) {
                    Text(m.label, color = Color.White, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium), modifier = Modifier.weight(1f))
                    Text(m.category.replaceFirstChar { it.uppercase() }, color = catColor(m.category), style = MaterialTheme.typography.labelSmall)
                }
            }
        }
        if (aiParsed && aiMatches.isEmpty() && noteText.isNotBlank()) {
            Spacer(Modifier.height(12.dp))
            Text("No extra matches found", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
        }
        if (noteText.isBlank()) {
            Spacer(Modifier.height(12.dp))
        }
        Spacer(Modifier.height(80.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════
//  Review Page
// ═══════════════════════════════════════════════════════════════════

@Composable
private fun ReviewPage(triggers: List<String>, prodromes: List<String>, medicines: List<String>, reliefs: List<String>, aiLabels: Set<String>, saving: Boolean, saved: Boolean, rmTrigger: (String) -> Unit, rmProdrome: (String) -> Unit, rmMedicine: (String) -> Unit, rmRelief: (String) -> Unit, onSave: () -> Unit) {
    val scrollState = rememberScrollState()
    val total = triggers.size + prodromes.size + medicines.size + reliefs.size

    Column(Modifier.fillMaxSize().verticalScroll(scrollState).padding(horizontal = 20.dp, vertical = 8.dp)) {
        Text("Review", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
        Spacer(Modifier.height(4.dp))
        Text(LocalDate.now().format(java.time.format.DateTimeFormatter.ofPattern("EEEE d MMMM")), color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium)
        Spacer(Modifier.height(20.dp))

        AnimatedVisibility(visible = saved) {
            Row(Modifier.fillMaxWidth().background(Color(0xFF2E7D32).copy(alpha = 0.85f), RoundedCornerShape(12.dp)).padding(horizontal = 16.dp, vertical = 12.dp), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.Center) {
                Icon(Icons.Outlined.Check, null, tint = Color.White, modifier = Modifier.size(20.dp)); Spacer(Modifier.width(8.dp)); Text("Check-in saved!", color = Color.White, fontWeight = FontWeight.SemiBold)
            }
        }

        if (total == 0 && !saved) {
            Spacer(Modifier.height(40.dp))
            Text("Nothing selected — go back to tap items, or save an empty check-in", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        }

        if (triggers.isNotEmpty()) ReviewSection("Triggers", Color(0xFFFFB74D), triggers, aiLabels, rmTrigger)
        if (prodromes.isNotEmpty()) ReviewSection("Prodromes", Color(0xFF9575CD), prodromes, aiLabels, rmProdrome)
        if (medicines.isNotEmpty()) ReviewSection("Medicines", Color(0xFF4FC3F7), medicines, aiLabels, rmMedicine)
        if (reliefs.isNotEmpty()) ReviewSection("Reliefs", Color(0xFF81C784), reliefs, aiLabels, rmRelief)

        if (total > 0 && !saved) {
            Spacer(Modifier.height(12.dp))
            Text("Logging $total item${if (total > 1) "s" else ""}", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        }
        Spacer(Modifier.height(80.dp))
    }
}

@Composable
private fun ReviewSection(title: String, color: Color, items: List<String>, aiLabels: Set<String>, onRemove: (String) -> Unit) {
    Spacer(Modifier.height(12.dp))
    Text("$title (${items.size})", color = color, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
    Spacer(Modifier.height(8.dp))
    items.forEach { label ->
        Row(Modifier.fillMaxWidth().padding(vertical = 2.dp).background(color.copy(alpha = 0.10f), RoundedCornerShape(10.dp)).padding(horizontal = 12.dp, vertical = 10.dp), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween) {
            Column(Modifier.weight(1f)) {
                Text(label, color = Color.White, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium))
                if (label in aiLabels) Text("matched from note", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
            }
            IconButton(onClick = { onRemove(label) }, modifier = Modifier.size(32.dp)) {
                Icon(Icons.Outlined.Close, "Remove", tint = color.copy(alpha = 0.7f), modifier = Modifier.size(18.dp))
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════════════
//  Circle Button
// ═══════════════════════════════════════════════════════════════════

@Composable
private fun CheckInCircle(label: String, icon: ImageVector?, isSelected: Boolean, color: Color, onClick: () -> Unit) {
    val bg = if (isSelected) color.copy(alpha = 0.35f) else Color.White.copy(alpha = 0.08f)
    val bdr = if (isSelected) color.copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    val tint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val txt = if (isSelected) Color.White else AppTheme.BodyTextColor

    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.width(72.dp).clickable(remember { MutableInteractionSource() }, null, onClick = onClick)) {
        Box(Modifier.size(52.dp).clip(CircleShape).background(bg).border(1.5.dp, bdr, CircleShape), contentAlignment = Alignment.Center) {
            if (icon != null) Icon(icon, label, tint = tint, modifier = Modifier.size(24.dp))
            else Text(label.take(2).uppercase(), color = tint, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold))
        }
        Spacer(Modifier.height(4.dp))
        Text(label, color = txt, style = MaterialTheme.typography.labelSmall, textAlign = TextAlign.Center, maxLines = 2, modifier = Modifier.fillMaxWidth())
    }
}

// ═══════════════════════════════════════════════════════════════════
//  GPT Matching via Edge Function
// ═══════════════════════════════════════════════════════════════════

private suspend fun callGptForMatches(
    accessToken: String,
    noteText: String,
    triggers: List<String>,
    prodromes: List<String>,
    medicines: List<String>,
    reliefs: List<String>
): List<AiMatchItem> {
    val systemPrompt = """
You are a migraine specialist AI. The user describes their day in natural language. Your job is to figure out which items from their personal pools are LIKELY relevant — even if not explicitly mentioned.

Think like a neurologist and infer what the situation implies:

EXAMPLES:
- "went to a festival" → Loud noise, Bright light, Alcohol, Dehydration, Poor sleep, Stress, Overexertion
- "busy day at work" → Stress, Excessive screen time, Poor posture, Skipped meal, Dehydration
- "flew to Spain" → Travel, Altitude change, Dehydration, Irregular sleep, Jet lag, Poor diet
- "had pizza and beer with mates" → Alcohol, Processed food, Cheese, Late meal
- "kids kept me up all night" → Poor sleep, Sleep deprivation, Stress, Fatigue
- "spent all day painting the house" → Overexertion, Strong smell, Neck tension, Dehydration, Skipped meal
- "had a migraine this morning, took tablets and lay down" → look for medicines (tablets, pills) and reliefs (rest, dark room) in their pools
- "feeling off, bit dizzy and nauseous" → look for prodromes like Dizziness, Nausea, Fatigue
- "period started today" → Menstruation, Hormonal change
- "skipped breakfast, only had coffee" → Skipped meal, Caffeine, Dehydration
- "hungover" → Alcohol, Dehydration, Poor sleep, Nausea
- "stared at screens all day on deadline" → Excessive screen time, Stress, Poor posture, Skipped meal, Eye strain
- "went for a long run" → Overexertion, Dehydration
- "argument with partner" → Emotional stress, Stress, Anxiety
- "weather changed suddenly, got really hot" → Weather change, Dehydration, Bright light

RULES:
- ONLY return items whose EXACT label exists in the provided pools. Never invent labels.
- Be thorough — flag anything that is likely or plausible, not just certain.
- Return a JSON array only. No markdown, no explanation.
- Each item: {"label": "exact pool label", "category": "trigger|prodrome|medicine|relief"}
- If genuinely nothing matches, return: []
""".trimIndent()

    val userMessage = """
User said: "$noteText"

TRIGGER pool: ${triggers.joinToString(", ")}
PRODROME pool: ${prodromes.joinToString(", ")}
MEDICINE pool: ${medicines.joinToString(", ")}
RELIEF pool: ${reliefs.joinToString(", ")}

Which items from these pools are likely relevant to what the user described? Think broadly about implications. JSON array only.
""".trimIndent()

    val requestBody = org.json.JSONObject().apply {
        put("system_prompt", systemPrompt)
        put("user_message", userMessage)
    }

    val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/ai-setup"

    val client = okhttp3.OkHttpClient()
    val request = okhttp3.Request.Builder()
        .url(url)
        .header("apikey", BuildConfig.SUPABASE_ANON_KEY)
        .header("Authorization", "Bearer $accessToken")
        .header("Content-Type", "application/json")
        .post(okhttp3.RequestBody.create(
            "application/json".toMediaTypeOrNull(),
            requestBody.toString()
        ))
        .build()

    val response = client.newCall(request).execute()
    val text = response.body?.string() ?: ""
    if (!response.isSuccessful) throw Exception("AI failed: ${response.code}")

    val clean = text.replace("```json", "").replace("```", "").trim()
        val arr = org.json.JSONArray(clean)
        val matches = mutableListOf<AiMatchItem>()
        for (i in 0 until arr.length()) {
            val obj = arr.getJSONObject(i)
            val label = obj.getString("label")
            val cat = obj.getString("category")
            // Only accept labels actually in the pools
            val valid = when (cat) {
                "trigger" -> label in triggers
                "prodrome" -> label in prodromes
                "medicine" -> label in medicines
                "relief" -> label in reliefs
                else -> false
            }
            if (valid) matches.add(AiMatchItem(label, cat))
        }
    return matches
}

// ═══════════════════════════════════════════════════════════════════
//  Local Fallback Matching (no API cost)
// ═══════════════════════════════════════════════════════════════════

private fun matchNoteTextLocal(text: String, triggers: List<String>, prodromes: List<String>, medicines: List<String>, reliefs: List<String>): List<AiMatchItem> {
    val lower = text.lowercase()
    val matches = mutableListOf<AiMatchItem>()
    triggers.forEach { if (hit(lower, it)) matches.add(AiMatchItem(it, "trigger")) }
    prodromes.forEach { if (hit(lower, it)) matches.add(AiMatchItem(it, "prodrome")) }
    medicines.forEach { if (hit(lower, it)) matches.add(AiMatchItem(it, "medicine")) }
    reliefs.forEach { if (hit(lower, it)) matches.add(AiMatchItem(it, "relief")) }
    return matches
}

private fun hit(text: String, label: String): Boolean {
    val l = label.lowercase()
    if (text.contains(l)) return true
    val words = l.split(" ", "_", "-").filter { it.length > 2 }
    if (words.size > 1 && words.all { text.contains(it) }) return true
    return SYNONYMS[l]?.any { text.contains(it) } == true
}

private fun catColor(cat: String): Color = when (cat) { "trigger" -> Color(0xFFFFB74D); "prodrome" -> Color(0xFF9575CD); "medicine" -> Color(0xFF4FC3F7); "relief" -> Color(0xFF81C784); else -> Color.White }

private val SYNONYMS: Map<String, List<String>> = mapOf(
    "alcohol" to listOf("wine", "beer", "drink", "drinking", "booze", "cocktail"),
    "poor sleep" to listOf("slept badly", "bad sleep", "insomnia", "couldn't sleep"),
    "skipped meal" to listOf("skipped lunch", "skipped dinner", "didn't eat", "forgot to eat"),
    "dehydration" to listOf("dehydrated", "not enough water", "thirsty"),
    "stress" to listOf("stressed", "stressful", "anxious", "overwhelmed"),
    "bright light" to listOf("bright lights", "glare", "fluorescent"),
    "loud noise" to listOf("loud", "noisy"),
    "weather change" to listOf("weather", "barometric", "storm"),
    "neck stiffness" to listOf("stiff neck", "neck pain", "tight neck"),
    "nausea" to listOf("nauseous", "queasy", "felt sick"),
    "fatigue" to listOf("exhausted", "tired", "worn out"),
    "brain fog" to listOf("foggy", "can't concentrate"),
    "light sensitivity" to listOf("sensitive to light", "photophobia"),
    "sound sensitivity" to listOf("sensitive to sound", "phonophobia"),
    "aura" to listOf("visual aura", "zigzag", "flashing"),
    "caffeine" to listOf("coffee", "espresso", "energy drink"),
    "menstruation" to listOf("period", "menstrual", "cycle"),
    "dizziness" to listOf("dizzy", "vertigo", "lightheaded"),
    "ibuprofen" to listOf("advil", "motrin", "nurofen"),
    "paracetamol" to listOf("acetaminophen", "tylenol", "panadol"),
    "sumatriptan" to listOf("imigran", "imitrex"),
    "meditation" to listOf("meditated", "mindfulness"),
    "ice" to listOf("ice pack", "cold pack", "cold compress"),
    "rest" to listOf("rested", "nap", "napped", "lay down"),
    "dark room" to listOf("darkness", "lay in dark"),
)

title: FacebookAuthService.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Intent
import android.net.Uri

/**
 * Starts Supabase OAuth for Facebook by opening the system browser.
 * Keeps auth fully in Supabase (no Facebook SDK, no auth-mode changes).
 *
 * Redirect comes back to: migraineme://auth/callback
 */
class FacebookAuthService(
    private val redirectUri: String = "migraineme://auth/callback"
) {
    fun startAuth(activity: Activity) {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val uri = Uri.parse("$base/auth/v1/authorize").buildUpon()
            .appendQueryParameter("provider", "facebook")
            .appendQueryParameter("redirect_to", redirectUri)
            .build()

        activity.startActivity(Intent(Intent.ACTION_VIEW, uri))
    }
}

title: FoodRiskClassifierService.kt
text:
package com.migraineme

import android.util.Log
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.util.concurrent.TimeUnit

/**
 * Result of food risk classification.
 * Each field is "none", "low", "medium", or "high".
 */
data class FoodRiskResult(
    val tyramine: String = "none",
    val alcohol: String = "none",
    val gluten: String = "none",
    val cached: Boolean = false
)

/**
 * Classifies food risks (tyramine, alcohol, gluten) via edge function.
 *
 * Calls classify-food-risks edge function, which:
 * 1. Checks a shared cache table first
 * 2. On miss, calls GPT-4o-mini for all three in one call
 * 3. Caches the result for all future lookups
 */
class FoodRiskClassifierService {

    companion object {
        private const val TAG = "FoodRiskClassifier"
        private const val BASE_URL = BuildConfig.SUPABASE_URL
        private const val ANON_KEY = BuildConfig.SUPABASE_ANON_KEY
    }

    private val httpClient = OkHttpClient.Builder()
        .connectTimeout(15, TimeUnit.SECONDS)
        .readTimeout(15, TimeUnit.SECONDS)
        .build()

    /**
     * Classify all food risks for a food item.
     *
     * @param accessToken User's Supabase access token
     * @param foodName The food name to classify
     * @return FoodRiskResult with tyramine, alcohol, gluten levels
     */
    fun classify(accessToken: String, foodName: String): FoodRiskResult {
        if (foodName.isBlank()) {
            Log.w(TAG, "Empty food name, returning defaults")
            return FoodRiskResult()
        }

        return try {
            val url = "${BASE_URL.trimEnd('/')}/functions/v1/classify-food-risks"

            val body = JSONObject().apply {
                put("food_name", foodName)
            }

            val request = Request.Builder()
                .url(url)
                .post(body.toString().toRequestBody("application/json".toMediaType()))
                .header("Authorization", "Bearer $accessToken")
                .header("apikey", ANON_KEY)
                .header("Content-Type", "application/json")
                .build()

            httpClient.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    Log.e(TAG, "Edge function failed: ${response.code}")
                    return FoodRiskResult()
                }

                val responseBody = response.body?.string() ?: return FoodRiskResult()
                val json = JSONObject(responseBody)

                val result = FoodRiskResult(
                    tyramine = json.optString("tyramine", "none"),
                    alcohol = json.optString("alcohol", "none"),
                    gluten = json.optString("gluten", "none"),
                    cached = json.optBoolean("cached", false)
                )

                Log.d(TAG, "✅ $foodName → T:${result.tyramine} A:${result.alcohol} G:${result.gluten} (cached=${result.cached})")
                result
            }
        } catch (e: Exception) {
            Log.e(TAG, "Classification failed for '$foodName': ${e.message}", e)
            FoodRiskResult()
        }
    }
}

title: FullScreenGraphScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.rememberDateRangePickerState
import androidx.compose.material3.DateRangePicker
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun FullScreenGraphScreen(
    graphType: String,
    onBack: () -> Unit
) {
    val scrollState = rememberScrollState()

    val rangeOptions = listOf(1 to "Day", 7 to "Week", 14 to "2 Weeks", 30 to "Month")
    var selectedDays by remember { mutableStateOf(14) }
    var periodOffset by remember { mutableStateOf(0) }
    var showCustomPicker by remember { mutableStateOf(false) }
    var isCustomRange by remember { mutableStateOf(false) }
    var customEndDate by remember { mutableStateOf(LocalDate.now()) }
    var customDays by remember { mutableStateOf(14) }

    val today = remember { LocalDate.now() }
    val endDate = if (isCustomRange) customEndDate else today.minusDays((periodOffset * selectedDays).toLong())
    val startDate = if (isCustomRange) customEndDate.minusDays(customDays.toLong() - 1) else endDate.minusDays(selectedDays.toLong() - 1)
    val activeDays = if (isCustomRange) customDays else selectedDays

    val isAtPresent = if (isCustomRange) false else periodOffset == 0

    // For weather at present, extend end date to include forecast
    val isWeatherForecast = graphType == "weather" && isAtPresent && !isCustomRange
    val displayEndDate = if (isWeatherForecast) endDate.plusDays(6) else endDate

    val dateFormat = DateTimeFormatter.ofPattern("MMM d")
    val dateRangeLabel = "${startDate.format(dateFormat)} – ${displayEndDate.format(dateFormat)}"

    val title = when (graphType) {
        "sleep" -> "Sleep History"
        "weather" -> if (isWeatherForecast) "Weather History + Forecast" else "Weather History"
        "nutrition" -> "Nutrition History"
        else -> "History"
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Time range toggles — 4 presets
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            for ((days, label) in rangeOptions) {
                val isSelected = !isCustomRange && selectedDays == days
                FilterChip(
                    selected = isSelected,
                    onClick = {
                        isCustomRange = false
                        selectedDays = days
                        periodOffset = 0
                    },
                    label = { Text(text = label, style = MaterialTheme.typography.labelSmall) },
                    colors = FilterChipDefaults.filterChipColors(
                        selectedContainerColor = AppTheme.AccentPurple.copy(alpha = 0.3f),
                        selectedLabelColor = AppTheme.AccentPurple,
                        containerColor = AppTheme.BaseCardContainer,
                        labelColor = AppTheme.SubtleTextColor
                    ),
                    border = FilterChipDefaults.filterChipBorder(
                        borderColor = if (isSelected) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        selectedBorderColor = AppTheme.AccentPurple,
                        enabled = true,
                        selected = isSelected
                    )
                )
            }
        }

        // Custom range chip — own row
        FilterChip(
            selected = isCustomRange,
            onClick = { showCustomPicker = true },
            label = {
                Text(
                    text = if (isCustomRange) "Custom: ${startDate.format(dateFormat)} – ${endDate.format(dateFormat)}" else "Custom range…",
                    style = MaterialTheme.typography.labelSmall,
                    maxLines = 1
                )
            },
            colors = FilterChipDefaults.filterChipColors(
                selectedContainerColor = AppTheme.AccentPink.copy(alpha = 0.3f),
                selectedLabelColor = AppTheme.AccentPink,
                containerColor = AppTheme.BaseCardContainer,
                labelColor = AppTheme.SubtleTextColor
            ),
            border = FilterChipDefaults.filterChipBorder(
                borderColor = if (isCustomRange) AppTheme.AccentPink else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                selectedBorderColor = AppTheme.AccentPink,
                enabled = true,
                selected = isCustomRange
            )
        )

        // Navigation: ← date range →
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(
                onClick = { if (!isCustomRange) periodOffset += 1 },
                enabled = !isCustomRange
            ) {
                Icon(
                    Icons.AutoMirrored.Filled.KeyboardArrowLeft,
                    contentDescription = "Earlier",
                    tint = if (isCustomRange) AppTheme.SubtleTextColor.copy(alpha = 0.3f) else AppTheme.AccentPurple,
                    modifier = Modifier.size(28.dp)
                )
            }

            Text(
                text = dateRangeLabel,
                color = if (isAtPresent && !isCustomRange) AppTheme.TitleColor else AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
            )

            IconButton(
                onClick = { if (!isAtPresent && !isCustomRange) periodOffset -= 1 },
                enabled = !isAtPresent && !isCustomRange
            ) {
                Icon(
                    Icons.AutoMirrored.Filled.KeyboardArrowRight,
                    contentDescription = "Later",
                    tint = if (isAtPresent || isCustomRange) AppTheme.SubtleTextColor.copy(alpha = 0.3f) else AppTheme.AccentPurple,
                    modifier = Modifier.size(28.dp)
                )
            }
        }

        // Graph
        when (graphType) {
            "sleep" -> SleepHistoryGraph(days = activeDays, endDate = endDate)
            "weather" -> {
                val isCurrent = isAtPresent && !isCustomRange
                val weatherEndDate = if (isCurrent) endDate.plusDays(6) else endDate
                val weatherDays = if (isCurrent) activeDays + 6 else activeDays
                val forecastStart = if (isCurrent) endDate.plusDays(1).toString() else null
                WeatherHistoryGraph(
                    days = weatherDays,
                    endDate = weatherEndDate,
                    forecastStartDate = forecastStart
                )
            }
            "nutrition" -> NutritionHistoryGraph(days = activeDays, endDate = endDate)
        }

        Spacer(Modifier.height(16.dp))
    }

    // Custom date range picker dialog
    if (showCustomPicker) {
        val dateRangePickerState = rememberDateRangePickerState()

        AlertDialog(
            onDismissRequest = { showCustomPicker = false },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            confirmButton = {
                TextButton(
                    onClick = {
                        val startMillis = dateRangePickerState.selectedStartDateMillis
                        val endMillis = dateRangePickerState.selectedEndDateMillis
                        if (startMillis != null && endMillis != null) {
                            val zone = ZoneId.systemDefault()
                            val pickedStart = Instant.ofEpochMilli(startMillis).atZone(zone).toLocalDate()
                            val pickedEnd = Instant.ofEpochMilli(endMillis).atZone(zone).toLocalDate()
                            val dayCount = (pickedEnd.toEpochDay() - pickedStart.toEpochDay() + 1).toInt().coerceAtLeast(1)
                            customEndDate = pickedEnd
                            customDays = dayCount
                            isCustomRange = true
                            periodOffset = 0
                        }
                        showCustomPicker = false
                    },
                    enabled = dateRangePickerState.selectedStartDateMillis != null && dateRangePickerState.selectedEndDateMillis != null
                ) {
                    Text(text = "Apply", color = if (dateRangePickerState.selectedStartDateMillis != null && dateRangePickerState.selectedEndDateMillis != null) AppTheme.AccentPurple else AppTheme.SubtleTextColor)
                }
            },
            dismissButton = {
                TextButton(onClick = { showCustomPicker = false }) {
                    Text(text = "Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            title = { Text(text = "Select date range") },
            text = {
                DateRangePicker(
                    state = dateRangePickerState,
                    modifier = Modifier.fillMaxWidth().height(450.dp),
                    title = null,
                    headline = null,
                    showModeToggle = false,
                    colors = appDatePickerColors()
                )
            }
        )
    }
}


title: HealthConnectChangesWorker.kt
text:
package com.migraineme

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.pm.ServiceInfo
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.changes.DeletionChange
import androidx.health.connect.client.changes.UpsertionChange
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.BloodGlucoseRecord
import androidx.health.connect.client.records.BloodPressureRecord
import androidx.health.connect.client.records.BodyFatRecord
import androidx.health.connect.client.records.BodyTemperatureRecord
import androidx.health.connect.client.records.ExerciseSessionRecord
import androidx.health.connect.client.records.HeartRateVariabilityRmssdRecord
import androidx.health.connect.client.records.HydrationRecord
import androidx.health.connect.client.records.OxygenSaturationRecord
import androidx.health.connect.client.records.Record
import androidx.health.connect.client.records.RespiratoryRateRecord
import androidx.health.connect.client.records.RestingHeartRateRecord
import androidx.health.connect.client.records.SleepSessionRecord
import androidx.health.connect.client.records.StepsRecord
import androidx.health.connect.client.records.WeightRecord
import androidx.health.connect.client.request.ChangesTokenRequest
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.time.Duration
import java.time.Instant
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import kotlin.reflect.KClass

/**
 * Worker that detects changes in Health Connect and queues them to the outbox.
 * Handles ALL supported Health Connect record types.
 * 
 * Pattern: Health Connect → Changes Worker → Room Outbox → Push Worker → Supabase
 * 
 * TRIGGERING: This worker is triggered by FCM push (sync_hourly) from the backend.
 * It is NOT scheduled locally - the backend controls when syncs happen.
 * 
 * FILTERING: This worker checks metric_settings from Supabase before collecting.
 * If a metric is disabled, data will NOT be collected for that record type.
 * This means user toggles in DataSettings actually control what gets synced.
 */
class HealthConnectChangesWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val TAG = "HCChangesWorker"
        private const val BACKFILL_DAYS = 14L
        
        // Notification constants for foreground service
        private const val NOTIFICATION_CHANNEL_ID = "health_connect_sync"
        private const val NOTIFICATION_ID = 1001

        // All supported record types with their permissions
        val SUPPORTED_RECORDS: Map<KClass<out Record>, String> = mapOf(
            SleepSessionRecord::class to HealthConnectRecordTypes.SLEEP,
            HeartRateVariabilityRmssdRecord::class to HealthConnectRecordTypes.HRV,
            RestingHeartRateRecord::class to HealthConnectRecordTypes.RESTING_HR,
            StepsRecord::class to HealthConnectRecordTypes.STEPS,
            ExerciseSessionRecord::class to HealthConnectRecordTypes.EXERCISE,
            WeightRecord::class to HealthConnectRecordTypes.WEIGHT,
            BodyFatRecord::class to HealthConnectRecordTypes.BODY_FAT,
            HydrationRecord::class to HealthConnectRecordTypes.HYDRATION,
            BloodPressureRecord::class to HealthConnectRecordTypes.BLOOD_PRESSURE,
            BloodGlucoseRecord::class to HealthConnectRecordTypes.BLOOD_GLUCOSE,
            OxygenSaturationRecord::class to HealthConnectRecordTypes.SPO2,
            RespiratoryRateRecord::class to HealthConnectRecordTypes.RESPIRATORY_RATE,
            BodyTemperatureRecord::class to HealthConnectRecordTypes.SKIN_TEMP
        )

        /**
         * Maps Health Connect record types to their corresponding metric names in metric_settings.
         * This is used to check if a metric is enabled before collecting data.
         */
        private val RECORD_TYPE_TO_METRIC: Map<String, String> = mapOf(
            HealthConnectRecordTypes.SLEEP to "sleep_duration_daily",
            HealthConnectRecordTypes.HRV to "hrv_daily",
            HealthConnectRecordTypes.RESTING_HR to "resting_hr_daily",
            HealthConnectRecordTypes.STEPS to "steps_daily",
            HealthConnectRecordTypes.EXERCISE to "time_in_high_hr_zones_daily",
            HealthConnectRecordTypes.WEIGHT to "weight_daily",
            HealthConnectRecordTypes.BODY_FAT to "body_fat_daily",
            HealthConnectRecordTypes.HYDRATION to "hydration_daily",
            HealthConnectRecordTypes.BLOOD_PRESSURE to "blood_pressure_daily",
            HealthConnectRecordTypes.BLOOD_GLUCOSE to "blood_glucose_daily",
            HealthConnectRecordTypes.SPO2 to "spo2_daily",
            HealthConnectRecordTypes.RESPIRATORY_RATE to "respiratory_rate_daily",
            HealthConnectRecordTypes.SKIN_TEMP to "skin_temp_daily"
        )

        fun getRequiredPermissions(): Set<String> = SUPPORTED_RECORDS.keys.map {
            HealthPermission.getReadPermission(it)
        }.toSet()
    }

    private val json = Json { ignoreUnknownKeys = true }

    /**
     * Creates notification channel for Android O+
     */
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Health Data Sync",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Syncing health data from Health Connect"
            }
            val notificationManager = applicationContext.getSystemService(NotificationManager::class.java)
            notificationManager?.createNotificationChannel(channel)
        }
    }

    /**
     * Provides ForegroundInfo for running as a foreground service.
     * This is required for Health Connect background access.
     */
    override suspend fun getForegroundInfo(): ForegroundInfo {
        createNotificationChannel()
        
        val notification = NotificationCompat.Builder(applicationContext, NOTIFICATION_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_health_connect)
            .setContentTitle("Syncing Health Data")
            .setContentText("Reading data from Health Connect...")
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOngoing(true)
            .build()

        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ForegroundInfo(
                NOTIFICATION_ID,
                notification,
                ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC
            )
        } else {
            ForegroundInfo(NOTIFICATION_ID, notification)
        }
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        // Run as foreground service to get Health Connect access
        setForeground(getForegroundInfo())
        
        Log.d(TAG, "Starting Health Connect changes sync")

        try {
            if (HealthConnectClient.getSdkStatus(applicationContext) != HealthConnectClient.SDK_AVAILABLE) {
                Log.w(TAG, "Health Connect not available")
                return@withContext Result.success()
            }

            val hc = HealthConnectClient.getOrCreate(applicationContext)
            val granted = hc.permissionController.getGrantedPermissions()
            
            val db = HealthConnectSyncDatabase.get(applicationContext)
            val dao = db.dao()
            
            var syncState = dao.getSyncState() ?: HealthConnectSyncStateEntity()

            // Fetch enabled metrics from Supabase metric_settings
            val enabledMetrics = fetchEnabledHealthConnectMetrics()
            Log.d(TAG, "Enabled HC metrics: $enabledMetrics")

            // Process each record type that has permission granted AND is enabled
            for ((recordClass, recordType) in SUPPORTED_RECORDS) {
                val permission = HealthPermission.getReadPermission(recordClass)
                if (permission !in granted) {
                    continue
                }

                // Check if this metric is enabled in metric_settings
                val metricName = RECORD_TYPE_TO_METRIC[recordType]
                if (metricName != null && metricName !in enabledMetrics) {
                    Log.d(TAG, "Skipping $recordType - metric '$metricName' is disabled")
                    continue
                }

                try {
                    syncState = processRecordType(hc, dao, syncState, recordClass, recordType)
                } catch (e: Exception) {
                    Log.e(TAG, "Error processing $recordType: ${e.message}", e)
                }
            }

            // Update sync state
            dao.upsertSyncState(syncState.copy(lastSyncAtEpochMs = System.currentTimeMillis()))

            Log.d(TAG, "Health Connect changes sync completed")
            Result.success()

        } catch (e: Exception) {
            Log.e(TAG, "Changes worker failed: ${e.message}", e)
            Result.retry()
        }
    }

    /**
     * Fetches the set of enabled metric names from Supabase metric_settings.
     * Only returns metrics where:
     * - enabled = true
     * - preferred_source = "health_connect" OR allowed_sources contains "health_connect"
     * 
     * @return Set of enabled metric names (e.g., "hrv_daily", "weight_daily")
     */
    private suspend fun fetchEnabledHealthConnectMetrics(): Set<String> {
        return try {
            val edge = EdgeFunctionsService()
            val settings = edge.getMetricSettings(applicationContext)
            
            settings
                .filter { setting ->
                    setting.enabled && isHealthConnectSource(setting)
                }
                .map { it.metric }
                .toSet()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to fetch metric_settings: ${e.message}")
            // On error, return ALL metrics as enabled to avoid blocking data collection
            // This is a fail-open approach to prevent data loss on network issues
            RECORD_TYPE_TO_METRIC.values.toSet()
        }
    }

    /**
     * Checks if a metric setting is configured to use Health Connect as source.
     */
    private fun isHealthConnectSource(setting: EdgeFunctionsService.MetricSettingResponse): Boolean {
        val preferredSource = setting.preferredSource?.lowercase() ?: ""
        val allowedSources = setting.allowedSources?.map { it.lowercase() } ?: emptyList()
        
        return preferredSource == "health_connect" || 
               allowedSources.contains("health_connect")
    }

    private suspend fun processRecordType(
        hc: HealthConnectClient,
        dao: HealthConnectSyncDao,
        state: HealthConnectSyncStateEntity,
        recordClass: KClass<out Record>,
        recordType: String
    ): HealthConnectSyncStateEntity {
        
        val existingToken = getTokenForType(state, recordType)
        
        if (existingToken == null) {
            // First run: backfill
            Log.d(TAG, "No token for $recordType - doing backfill")
            return doBackfill(hc, dao, state, recordClass, recordType)
        } else {
            // Incremental sync
            Log.d(TAG, "Processing changes for $recordType")
            return processChanges(hc, dao, state, recordClass, recordType, existingToken)
        }
    }

    private suspend fun doBackfill(
        hc: HealthConnectClient,
        dao: HealthConnectSyncDao,
        state: HealthConnectSyncStateEntity,
        recordClass: KClass<out Record>,
        recordType: String
    ): HealthConnectSyncStateEntity {
        
        val end = Instant.now()
        val start = end.minus(BACKFILL_DAYS, ChronoUnit.DAYS)

        val records = hc.readRecords(
            ReadRecordsRequest(
                recordType = recordClass,
                timeRangeFilter = TimeRangeFilter.between(start, end)
            )
        ).records

        Log.d(TAG, "Backfilling ${records.size} $recordType records")

        val outboxItems = records.mapNotNull { record ->
            recordToOutboxEntry(record, recordType, "UPSERT")
        }

        if (outboxItems.isNotEmpty()) {
            dao.insertOutboxBatch(outboxItems)
        }

        // Create token for future syncs
        val newToken = hc.getChangesToken(
            ChangesTokenRequest(recordTypes = setOf(recordClass))
        )

        return setTokenForType(state, recordType, newToken)
    }

    private suspend fun processChanges(
        hc: HealthConnectClient,
        dao: HealthConnectSyncDao,
        state: HealthConnectSyncStateEntity,
        recordClass: KClass<out Record>,
        recordType: String,
        token: String
    ): HealthConnectSyncStateEntity {
        
        var nextToken = token
        var hasMore = true
        var safety = 0

        while (hasMore && safety < 50) {
            safety++
            
            val resp = hc.getChanges(nextToken)
            nextToken = resp.nextChangesToken
            hasMore = resp.hasMore

            if (resp.changesTokenExpired) {
                Log.w(TAG, "$recordType token expired, creating new one")
                nextToken = hc.getChangesToken(
                    ChangesTokenRequest(recordTypes = setOf(recordClass))
                )
                break
            }

            val outboxItems = mutableListOf<HealthConnectOutboxEntity>()

            for (change in resp.changes) {
                when (change) {
                    is UpsertionChange -> {
                        val entry = recordToOutboxEntry(change.record, recordType, "UPSERT")
                        if (entry != null) outboxItems.add(entry)
                    }
                    is DeletionChange -> {
                        outboxItems.add(
                            HealthConnectOutboxEntity(
                                healthConnectId = change.recordId,
                                recordType = recordType,
                                operation = "DELETE",
                                date = "",
                                payload = "{}"
                            )
                        )
                    }
                }
            }

            if (outboxItems.isNotEmpty()) {
                dao.insertOutboxBatch(outboxItems)
            }
        }

        return setTokenForType(state, recordType, nextToken)
    }

    private fun recordToOutboxEntry(record: Record, recordType: String, operation: String): HealthConnectOutboxEntity? {
        return try {
            val (date, payload) = extractRecordData(record, recordType)
            HealthConnectOutboxEntity(
                healthConnectId = record.metadata.id,
                recordType = recordType,
                operation = operation,
                date = date,
                payload = payload
            )
        } catch (e: Exception) {
            Log.e(TAG, "Failed to convert record to outbox entry: ${e.message}")
            null
        }
    }

    private fun extractRecordData(record: Record, recordType: String): Pair<String, String> {
        return when (record) {
            is SleepSessionRecord -> {
                val date = record.endTime.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val duration = Duration.between(record.startTime, record.endTime).toMinutes()
                
                var remMin = 0L; var deepMin = 0L; var lightMin = 0L; var awakeMin = 0L
                for (stage in record.stages) {
                    val mins = Duration.between(stage.startTime, stage.endTime).toMinutes()
                    when (stage.stage) {
                        SleepSessionRecord.STAGE_TYPE_REM -> remMin += mins
                        SleepSessionRecord.STAGE_TYPE_DEEP -> deepMin += mins
                        SleepSessionRecord.STAGE_TYPE_LIGHT -> lightMin += mins
                        SleepSessionRecord.STAGE_TYPE_AWAKE -> awakeMin += mins
                    }
                }
                
                val payload = """{"duration_minutes":$duration,"start_time":"${record.startTime}","end_time":"${record.endTime}","rem_minutes":$remMin,"deep_minutes":$deepMin,"light_minutes":$lightMin,"awake_minutes":$awakeMin}"""
                date to payload
            }
            
            is HeartRateVariabilityRmssdRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_ms":${record.heartRateVariabilityMillis}}"""
                date to payload
            }
            
            is RestingHeartRateRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_bpm":${record.beatsPerMinute}}"""
                date to payload
            }
            
            is StepsRecord -> {
                val date = record.endTime.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_count":${record.count}}"""
                date to payload
            }
            
            is ExerciseSessionRecord -> {
                val date = record.endTime.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val duration = Duration.between(record.startTime, record.endTime).toMinutes()
                val payload = """{"duration_minutes":$duration,"exercise_type":${record.exerciseType},"start_time":"${record.startTime}","end_time":"${record.endTime}"}"""
                date to payload
            }
            
            is WeightRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_kg":${record.weight.inKilograms}}"""
                date to payload
            }
            
            is BodyFatRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_pct":${record.percentage.value}}"""
                date to payload
            }
            
            is HydrationRecord -> {
                val date = record.endTime.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_ml":${record.volume.inMilliliters}}"""
                date to payload
            }
            
            is BloodPressureRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"systolic_mmhg":${record.systolic.inMillimetersOfMercury},"diastolic_mmhg":${record.diastolic.inMillimetersOfMercury}}"""
                date to payload
            }
            
            is BloodGlucoseRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val mealType = record.relationToMeal?.toString() ?: "GENERAL"
                val payload = """{"value_mmol_l":${record.level.inMillimolesPerLiter},"meal_type":"$mealType"}"""
                date to payload
            }
            
            is OxygenSaturationRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_pct":${record.percentage.value}}"""
                date to payload
            }
            
            is RespiratoryRateRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_bpm":${record.rate}}"""
                date to payload
            }
            
            is BodyTemperatureRecord -> {
                val date = record.time.atZone(ZoneId.systemDefault()).toLocalDate().toString()
                val payload = """{"value_celsius":${record.temperature.inCelsius}}"""
                date to payload
            }
            
            else -> throw IllegalArgumentException("Unsupported record type: ${record::class.simpleName}")
        }
    }

    private fun getTokenForType(state: HealthConnectSyncStateEntity, recordType: String): String? {
        return when (recordType) {
            HealthConnectRecordTypes.SLEEP -> state.sleepToken
            HealthConnectRecordTypes.HRV -> state.hrvToken
            HealthConnectRecordTypes.RESTING_HR -> state.restingHrToken
            HealthConnectRecordTypes.STEPS -> state.stepsToken
            HealthConnectRecordTypes.EXERCISE -> state.exerciseToken
            HealthConnectRecordTypes.WEIGHT -> state.weightToken
            HealthConnectRecordTypes.BODY_FAT -> state.bodyFatToken
            HealthConnectRecordTypes.HYDRATION -> state.hydrationToken
            HealthConnectRecordTypes.BLOOD_PRESSURE -> state.bloodPressureToken
            HealthConnectRecordTypes.BLOOD_GLUCOSE -> state.bloodGlucoseToken
            HealthConnectRecordTypes.SPO2 -> state.spo2Token
            HealthConnectRecordTypes.RESPIRATORY_RATE -> state.respiratoryRateToken
            HealthConnectRecordTypes.SKIN_TEMP -> state.skinTempToken
            else -> null
        }
    }

    private fun setTokenForType(state: HealthConnectSyncStateEntity, recordType: String, token: String): HealthConnectSyncStateEntity {
        return when (recordType) {
            HealthConnectRecordTypes.SLEEP -> state.copy(sleepToken = token)
            HealthConnectRecordTypes.HRV -> state.copy(hrvToken = token)
            HealthConnectRecordTypes.RESTING_HR -> state.copy(restingHrToken = token)
            HealthConnectRecordTypes.STEPS -> state.copy(stepsToken = token)
            HealthConnectRecordTypes.EXERCISE -> state.copy(exerciseToken = token)
            HealthConnectRecordTypes.WEIGHT -> state.copy(weightToken = token)
            HealthConnectRecordTypes.BODY_FAT -> state.copy(bodyFatToken = token)
            HealthConnectRecordTypes.HYDRATION -> state.copy(hydrationToken = token)
            HealthConnectRecordTypes.BLOOD_PRESSURE -> state.copy(bloodPressureToken = token)
            HealthConnectRecordTypes.BLOOD_GLUCOSE -> state.copy(bloodGlucoseToken = token)
            HealthConnectRecordTypes.SPO2 -> state.copy(spo2Token = token)
            HealthConnectRecordTypes.RESPIRATORY_RATE -> state.copy(respiratoryRateToken = token)
            HealthConnectRecordTypes.SKIN_TEMP -> state.copy(skinTempToken = token)
            else -> state
        }
    }
}

title: HealthConnectDataAvailability.kt
text:
package com.migraineme

import android.content.Context
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.records.NutritionRecord
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * Helper to check if Health Connect actually has nutrition data available
 * Use this to show/hide nutrition features intelligently
 */
object HealthConnectDataAvailability {
    
    /**
     * Check if any nutrition data exists in Health Connect (last 30 days)
     * 
     * @return true if at least one nutrition record exists, false otherwise
     */
    suspend fun hasNutritionData(context: Context): Boolean {
        return try {
            val hc = HealthConnectClient.getOrCreate(context)
            
            // Check last 30 days for any nutrition records
            val end = Instant.now()
            val start = end.minus(30, ChronoUnit.DAYS)
            
            val request = ReadRecordsRequest(
                recordType = NutritionRecord::class,
                timeRangeFilter = TimeRangeFilter.between(start, end)
            )
            
            val response = hc.readRecords(request)
            
            // Return true if we found at least one record
            response.records.isNotEmpty()
            
        } catch (e: Exception) {
            android.util.Log.e("HealthConnectAvail", "Error checking nutrition data: ${e.message}")
            false
        }
    }
    
    /**
     * Get a user-friendly message about nutrition data availability
     */
    suspend fun getNutritionStatusMessage(context: Context, permissionGranted: Boolean): String {
        if (!permissionGranted) {
            return "Tap to connect Health Connect and track nutrition"
        }
        
        val hasData = hasNutritionData(context)
        
        return if (hasData) {
            "Connected • Syncing nutrition data"
        } else {
            "Connected • No nutrition data yet. Install Cronometer or MyFitnessPal to start tracking."
        }
    }
}

title: HealthConnectDataChecker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.health.connect.client.records.NutritionRecord
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * Checks if Health Connect has any data for specific metrics
 */
object HealthConnectDataChecker {
    
    data class DataStatus(
        val hasNutritionData: Boolean,
        val hasMenstruationData: Boolean
    )
    
    /**
     * Check if Health Connect has ANY records for nutrition and menstruation
     * Returns immediately if no data found (doesn't wait for sync)
     */
    suspend fun checkDataAvailability(context: Context): DataStatus {
        return withContext(Dispatchers.IO) {
            try {
                val client = HealthConnectClient.getOrCreate(context)
                
                // Check last 12 months (enough to determine if app is syncing)
                val now = Instant.now()
                val oneYearAgo = now.minus(365, ChronoUnit.DAYS)
                
                // Check nutrition
                val nutritionRequest = ReadRecordsRequest(
                    recordType = NutritionRecord::class,
                    timeRangeFilter = TimeRangeFilter.between(oneYearAgo, now)
                )
                val nutritionResponse = client.readRecords(nutritionRequest)
                val hasNutrition = nutritionResponse.records.isNotEmpty()
                
                Log.d("HC_DataChecker", "Nutrition records found: ${nutritionResponse.records.size}")
                
                // Check menstruation
                val menstruationRequest = ReadRecordsRequest(
                    recordType = MenstruationPeriodRecord::class,
                    timeRangeFilter = TimeRangeFilter.between(oneYearAgo, now)
                )
                val menstruationResponse = client.readRecords(menstruationRequest)
                val hasMenstruation = menstruationResponse.records.isNotEmpty()
                
                Log.d("HC_DataChecker", "Menstruation records found: ${menstruationResponse.records.size}")
                
                DataStatus(
                    hasNutritionData = hasNutrition,
                    hasMenstruationData = hasMenstruation
                )
                
            } catch (e: Exception) {
                Log.e("HC_DataChecker", "Failed to check data: ${e.message}", e)
                // Return false for both on error (assume no data)
                DataStatus(
                    hasNutritionData = false,
                    hasMenstruationData = false
                )
            }
        }
    }
}

title: HealthConnectMenstruationChangesWorker.kt
text:
package com.migraineme

import android.content.Context
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.changes.Change
import androidx.health.connect.client.changes.DeletionChange
import androidx.health.connect.client.changes.UpsertionChange
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.health.connect.client.request.ChangesTokenRequest
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * Worker that detects menstruation period changes in Health Connect
 * 
 * Runs every 15 minutes to detect:
 * - New periods logged in Flo/Clue
 * - Updated period dates
 * - Deleted periods
 * 
 * Similar pattern to HealthConnectNutritionChangesWorker
 */
class HealthConnectMenstruationChangesWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    companion object {
        private const val TAG = "HCMenstruationChanges"
        val REQUIRED_PERMISSIONS = setOf(
            HealthPermission.getReadPermission(MenstruationPeriodRecord::class)
        )
        private const val BACKFILL_DAYS = 730L // 2 years of history
    }
    
    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            android.util.Log.d(TAG, "Starting menstruation changes check")
            
            val hc = HealthConnectClient.getOrCreate(applicationContext)
            val granted = hc.permissionController.getGrantedPermissions()
            
            if (!REQUIRED_PERMISSIONS.all { it in granted }) {
                android.util.Log.e(TAG, "Missing permissions")
                return@withContext Result.failure()
            }
            
            val db = MenstruationSyncDatabase.get(applicationContext)
            val dao = db.dao()
            
            val existingState = dao.getSyncState()
            val hadTokenAlready = !existingState?.changesToken.isNullOrBlank()
            
            // If no token exists, do initial backfill
            if (!hadTokenAlready) {
                android.util.Log.d(TAG, "No token found - performing initial backfill")
                performInitialBackfill(hc, dao)
                return@withContext Result.success()
            }
            
            // Token exists - process incremental changes
            android.util.Log.d(TAG, "Processing incremental changes")
            processIncrementalChanges(hc, dao, existingState!!)
            
            Result.success()
        } catch (e: Exception) {
            android.util.Log.e(TAG, "Worker failed: ${e.message}", e)
            Result.retry()
        }
    }
    
    /**
     * Initial backfill - read last 2 years of periods
     */
    private suspend fun performInitialBackfill(
        hc: HealthConnectClient,
        dao: MenstruationSyncDao
    ) {
        val now = System.currentTimeMillis()
        val end = Instant.now()
        val start = end.minus(BACKFILL_DAYS, ChronoUnit.DAYS)
        
        android.util.Log.d(TAG, "Backfilling periods from $start to $end")
        
        val request = ReadRecordsRequest(
            recordType = MenstruationPeriodRecord::class,
            timeRangeFilter = TimeRangeFilter.between(start, end)
        )
        
        val response = hc.readRecords(request)
        
        android.util.Log.d(TAG, "Found ${response.records.size} historical periods")
        
        // Add all to outbox
        response.records.forEach { record ->
            val id = record.metadata.id
            dao.upsertOutbox(
                MenstruationOutboxEntity(
                    healthConnectId = id,
                    operation = "UPSERT",
                    createdAtEpochMs = now
                )
            )
        }
        
        // Create changes token for future incremental syncs
        val freshToken = hc.getChangesToken(
            ChangesTokenRequest(recordTypes = setOf(MenstruationPeriodRecord::class))
        )
        
        val nowMs = System.currentTimeMillis()
        dao.upsertSyncState(
            MenstruationSyncStateEntity(
                changesToken = freshToken,
                lastHourlyRunAtEpochMs = nowMs
            )
        )
        
        android.util.Log.d(TAG, "Initial backfill complete - ${response.records.size} periods queued")
    }
    
    /**
     * Process incremental changes using changes token
     */
    private suspend fun processIncrementalChanges(
        hc: HealthConnectClient,
        dao: MenstruationSyncDao,
        state: MenstruationSyncStateEntity
    ) {
        var nextToken: String = state.changesToken!!
        var hasMore = true
        var safety = 0
        var changesProcessed = 0
        
        while (hasMore && safety < 50) {
            safety++
            
            val resp = hc.getChanges(nextToken)
            nextToken = resp.nextChangesToken
            hasMore = resp.hasMore
            
            if (resp.changesTokenExpired) {
                android.util.Log.w(TAG, "Changes token expired - getting new token")
                nextToken = hc.getChangesToken(
                    ChangesTokenRequest(recordTypes = setOf(MenstruationPeriodRecord::class))
                )
                break
            }
            
            val now = System.currentTimeMillis()
            
            resp.changes.forEach { change ->
                when (change) {
                    is UpsertionChange -> {
                        val id = change.record.metadata.id
                        dao.upsertOutbox(
                            MenstruationOutboxEntity(
                                healthConnectId = id,
                                operation = "UPSERT",
                                createdAtEpochMs = now
                            )
                        )
                        changesProcessed++
                    }
                    is DeletionChange -> {
                        val id = change.recordId
                        dao.upsertOutbox(
                            MenstruationOutboxEntity(
                                healthConnectId = id,
                                operation = "DELETE",
                                createdAtEpochMs = now
                            )
                        )
                        changesProcessed++
                    }
                }
            }
        }
        
        // Update sync state
        val nowMs = System.currentTimeMillis()
        dao.upsertSyncState(
            state.copy(
                changesToken = nextToken,
                lastHourlyRunAtEpochMs = nowMs
            )
        )
        
        android.util.Log.d(TAG, "Incremental sync complete - $changesProcessed changes processed")
    }
}

title: HealthConnectMenstruationHistoryFetcher.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneOffset
import java.time.temporal.ChronoUnit

/**
 * Fetches historical menstruation data from Health Connect
 */
object HealthConnectMenstruationHistoryFetcher {

    data class HistoricalData(
        val periods: List<PeriodInfo>,
        val suggestedLastDate: LocalDate?,
        val suggestedAvgCycle: Int?
    )

    data class PeriodInfo(
        val startDate: LocalDate,
        val endDate: LocalDate?
    )

    /**
     * Fetch last 6 months of period data from Health Connect
     * and calculate suggested values
     */
    suspend fun fetchHistoricalData(context: Context): HistoricalData {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("MenstruationHistory", "Starting historical data fetch...")

                val client = HealthConnectClient.getOrCreate(context)

                // Fetch last 6 months of data
                val now = Instant.now()
                val sixMonthsAgo = now.minus(180, ChronoUnit.DAYS)

                val request = ReadRecordsRequest(
                    recordType = MenstruationPeriodRecord::class,
                    timeRangeFilter = TimeRangeFilter.between(sixMonthsAgo, now)
                )

                val response = client.readRecords(request)
                val records = response.records

                Log.d("MenstruationHistory", "Found ${records.size} period records")

                if (records.isEmpty()) {
                    return@withContext HistoricalData(
                        periods = emptyList(),
                        suggestedLastDate = null,
                        suggestedAvgCycle = null
                    )
                }

                // Convert to PeriodInfo
                val periods = records.map { record ->
                    PeriodInfo(
                        startDate = record.startTime.toLocalDate(),
                        endDate = record.endTime.toLocalDate()
                    )
                }.sortedByDescending { it.startDate }

                Log.d("MenstruationHistory", "Periods found:")
                periods.forEach { period ->
                    Log.d("MenstruationHistory", "  - ${period.startDate}")
                }

                // Most recent period
                val lastDate = periods.firstOrNull()?.startDate

                // Calculate average cycle length from last 6 periods
                val avgCycle = if (periods.size >= 2) {
                    calculateWeightedAverage(periods.take(6))
                } else {
                    null
                }

                Log.d("MenstruationHistory", "Suggested last date: $lastDate")
                Log.d("MenstruationHistory", "Suggested avg cycle: $avgCycle days")

                HistoricalData(
                    periods = periods,
                    suggestedLastDate = lastDate,
                    suggestedAvgCycle = avgCycle
                )

            } catch (e: Exception) {
                Log.e("MenstruationHistory", "Failed to fetch historical data: ${e.message}", e)
                HistoricalData(
                    periods = emptyList(),
                    suggestedLastDate = null,
                    suggestedAvgCycle = null
                )
            }
        }
    }

    /**
     * Calculate weighted average cycle length
     * Same logic as MenstruationCalculator
     */
    private fun calculateWeightedAverage(periods: List<PeriodInfo>): Int? {
        if (periods.size < 2) return null

        val cycleLengths = mutableListOf<Int>()

        for (i in 0 until periods.size - 1) {
            val current = periods[i].startDate
            val next = periods[i + 1].startDate
            val days = ChronoUnit.DAYS.between(next, current).toInt()

            if (days in 14..60) {  // Reasonable cycle length
                cycleLengths.add(days)
            }
        }

        if (cycleLengths.isEmpty()) return null

        // Weighted average: more recent cycles weigh more
        val weights = listOf(0.30, 0.25, 0.20, 0.15, 0.10)
        var weightedSum = 0.0
        var totalWeight = 0.0

        cycleLengths.take(5).forEachIndexed { index, length ->
            val weight = weights.getOrNull(index) ?: 0.0
            weightedSum += length * weight
            totalWeight += weight
        }

        return if (totalWeight > 0) {
            (weightedSum / totalWeight).toInt()
        } else {
            cycleLengths.average().toInt()
        }
    }
}

private fun Instant.toLocalDate(): LocalDate {
    return this.atZone(ZoneOffset.UTC).toLocalDate()
}

title: HealthConnectMissingDataBanner.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Warning
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

/**
 * Banner showing which Health Connect data sources are missing
 */
@Composable
fun HealthConnectMissingDataBanner(
    hasNutritionData: Boolean,
    hasMenstruationData: Boolean
) {
    // Only show if at least one is missing
    if (hasNutritionData && hasMenstruationData) {
        return
    }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(top = 8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = Icons.Outlined.Warning,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(20.dp)
                )
                Text(
                    "Missing Data from Health Connect",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.SemiBold
                )
            }
            
            // Nutrition missing
            if (!hasNutritionData) {
                Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
                    Text(
                        "• Nutrition - No data found",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        "  We suggest: Cronometer or MyFitnessPal (totals only)",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        "  Note: Data syncs every 15 minutes after logging",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
            
            // Menstruation missing
            if (!hasMenstruationData) {
                Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
                    Text(
                        "• Menstruation - No data found",
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        "  No compatible apps available yet",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        "  Set up manual tracking in Data Settings",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}

title: HealthConnectNutritionChangesWorker.kt
text:
package com.migraineme

import android.content.Context
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.changes.DeletionChange
import androidx.health.connect.client.changes.UpsertionChange
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.NutritionRecord
import androidx.health.connect.client.request.ChangesTokenRequest
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.temporal.ChronoUnit

class HealthConnectNutritionChangesWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        val REQUIRED_PERMISSIONS = setOf(
            HealthPermission.getReadPermission(NutritionRecord::class)
        )

        // One-time backfill window when token doesn't exist yet
        private const val BACKFILL_DAYS = 14L
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            val hc = HealthConnectClient.getOrCreate(applicationContext)
            val granted = hc.permissionController.getGrantedPermissions()
            if (!REQUIRED_PERMISSIONS.all { it in granted }) {
                return@withContext Result.failure()
            }

            val db = NutritionSyncDatabase.get(applicationContext)
            val dao = db.dao()

            val existingState = dao.getSyncState()
            val hadTokenAlready = !existingState?.nutritionChangesToken.isNullOrBlank()

            // If no token exists yet, do a one-time backfill FIRST, then create token.
            if (!hadTokenAlready) {
                val now = System.currentTimeMillis()
                val end = Instant.now()
                val start = end.minus(BACKFILL_DAYS, ChronoUnit.DAYS)

                val request = ReadRecordsRequest(
                    recordType = NutritionRecord::class,
                    timeRangeFilter = TimeRangeFilter.between(start, end)
                )

                val response = hc.readRecords(request)

                // Enqueue all records as UPSERT so the push worker uploads them to Supabase.
                response.records.forEach { record ->
                    val id = record.metadata.id
                    dao.upsertOutbox(
                        NutritionOutboxEntity(
                            healthConnectId = id,
                            operation = "UPSERT",
                            createdAtEpochMs = now
                        )
                    )
                }

                // Create a token AFTER backfill so changes start "from now".
                val freshToken = hc.getChangesToken(
                    ChangesTokenRequest(recordTypes = setOf(NutritionRecord::class))
                )

                val nowMs = System.currentTimeMillis()
                dao.upsertSyncState(
                    (existingState ?: SyncStateEntity()).copy(
                        nutritionChangesToken = freshToken,
                        lastHourlyRunAtEpochMs = nowMs
                    )
                )

                return@withContext Result.success()
            }

            // Token exists: normal incremental change processing.
            var nextToken: String = existingState!!.nutritionChangesToken!!

            var hasMore = true
            var safety = 0

            while (hasMore && safety < 50) {
                safety++

                val resp = hc.getChanges(nextToken)
                nextToken = resp.nextChangesToken
                hasMore = resp.hasMore

                if (resp.changesTokenExpired) {
                    // Token expired: reset token (next run will continue from new token).
                    nextToken = hc.getChangesToken(
                        ChangesTokenRequest(recordTypes = setOf(NutritionRecord::class))
                    )
                    break
                }

                val now = System.currentTimeMillis()

                resp.changes.forEach { change ->
                    when (change) {
                        is UpsertionChange -> {
                            val id = change.record.metadata.id
                            dao.upsertOutbox(
                                NutritionOutboxEntity(
                                    healthConnectId = id,
                                    operation = "UPSERT",
                                    createdAtEpochMs = now
                                )
                            )
                        }
                        is DeletionChange -> {
                            val id = change.recordId
                            dao.upsertOutbox(
                                NutritionOutboxEntity(
                                    healthConnectId = id,
                                    operation = "DELETE",
                                    createdAtEpochMs = now
                                )
                            )
                        }
                    }
                }
            }

            val nowMs = System.currentTimeMillis()
            dao.upsertSyncState(
                existingState.copy(
                    nutritionChangesToken = nextToken,
                    lastHourlyRunAtEpochMs = nowMs
                )
            )

            Result.success()
        } catch (e: Exception) {
            android.util.Log.e("HcNutritionChanges", "Worker failed: ${e.message}", e)
            Result.retry()
        }
    }
}


title: HealthConnectOutboxEntity.kt
text:
package com.migraineme

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Room entity for Health Connect sync outbox.
 * Stores pending changes to be pushed to Supabase.
 *
 * RETRY BEHAVIOR:
 * - Items start with status = "pending" and retryCount = 0
 * - On transient failures (network, 5xx), retryCount increments
 * - After MAX_RETRIES, status changes to "failed"
 * - On permanent failures (4xx client errors), status changes to "permanent_failure"
 * - "failed" items can be retried later (e.g., after app update)
 * - "permanent_failure" items need manual intervention or data fix
 */
@Entity(tableName = "health_connect_outbox")
data class HealthConnectOutboxEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,

    /** Health Connect record ID */
    val healthConnectId: String,

    /** Record type (e.g., "sleep", "hrv", "resting_hr", "steps", etc.) */
    val recordType: String,

    /** Operation: UPSERT or DELETE */
    val operation: String,

    /** Date for the record (YYYY-MM-DD) */
    val date: String,

    /** JSON payload with record-specific data */
    val payload: String,

    /** When this outbox entry was created */
    val createdAtEpochMs: Long = System.currentTimeMillis(),

    /** Number of failed retry attempts */
    val retryCount: Int = 0,

    /**
     * Status of this outbox item:
     * - "pending": Ready to be processed
     * - "failed": Exceeded max retries (transient errors) - can retry later
     * - "permanent_failure": Client error (4xx) - needs data fix
     */
    val status: String = "pending",

    /** Last error message for debugging */
    val lastError: String? = null
) {
    companion object {
        const val STATUS_PENDING = "pending"
        const val STATUS_FAILED = "failed"
        const val STATUS_PERMANENT_FAILURE = "permanent_failure"

        const val MAX_RETRIES = 5
    }
}

/**
 * Supported record types for Health Connect sync.
 */
object HealthConnectRecordTypes {
    const val SLEEP = "sleep"
    const val HRV = "hrv"
    const val RESTING_HR = "resting_hr"
    const val STEPS = "steps"
    const val EXERCISE = "exercise"
    const val WEIGHT = "weight"
    const val BODY_FAT = "body_fat"
    const val HYDRATION = "hydration"
    const val BLOOD_PRESSURE = "blood_pressure"
    const val BLOOD_GLUCOSE = "blood_glucose"
    const val SPO2 = "spo2"
    const val RESPIRATORY_RATE = "respiratory_rate"
    const val SKIN_TEMP = "skin_temp"
}

title: HealthConnectOutboxMigration.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

/**
 * Migration to add retry tracking columns to health_connect_outbox table.
 *
 * IMPORTANT: Update your database version in HealthConnectSyncDatabase and add this migration.
 *
 * Example in HealthConnectSyncDatabase:
 * ```
 * @Database(
 *     entities = [HealthConnectOutboxEntity::class, ...],
 *     version = 2,  // Increment from 1 to 2
 *     ...
 * )
 * abstract class HealthConnectSyncDatabase : RoomDatabase() {
 *     companion object {
 *         fun get(context: Context): HealthConnectSyncDatabase {
 *             return Room.databaseBuilder(...)
 *                 .addMigrations(HealthConnectOutboxMigration.MIGRATION_1_2)
 *                 .build()
 *         }
 *     }
 * }
 * ```
 */
object HealthConnectOutboxMigration {

    private const val TAG = "HCOutboxMigration"

    /**
     * Migration from version 1 to 2.
     * Adds retryCount, status, and lastError columns to health_connect_outbox.
     */
    val MIGRATION_1_2 = object : Migration(1, 2) {
        override fun migrate(database: SupportSQLiteDatabase) {
            Log.d(TAG, "Running migration 1 -> 2: Adding retry tracking columns")

            // Add retryCount column with default 0
            database.execSQL(
                "ALTER TABLE health_connect_outbox ADD COLUMN retryCount INTEGER NOT NULL DEFAULT 0"
            )

            // Add status column with default 'pending'
            database.execSQL(
                "ALTER TABLE health_connect_outbox ADD COLUMN status TEXT NOT NULL DEFAULT 'pending'"
            )

            // Add lastError column (nullable)
            database.execSQL(
                "ALTER TABLE health_connect_outbox ADD COLUMN lastError TEXT DEFAULT NULL"
            )

            Log.d(TAG, "Migration 1 -> 2 complete")
        }
    }
}

/**
 * One-time utility to reset failed items after deploying the fix.
 *
 * Call this once after the fix is deployed to give stuck items another chance.
 * Can be triggered from a debug menu, on app update, or via a feature flag.
 */
object HealthConnectOutboxRecovery {

    private const val TAG = "HCOutboxRecovery"

    /**
     * Reset all failed items to pending status.
     * Call this after deploying the encodeDefaults fix.
     */
    suspend fun retryAllFailedItems(context: Context) {
        val db = HealthConnectSyncDatabase.get(context)
        val dao = db.dao()

        // Reset items that failed due to transient errors
        dao.retryFailedItems()

        Log.i(TAG, "Reset failed items to pending status")
    }

    /**
     * Reset ALL non-pending items (both failed and permanent_failure).
     * Use after a major fix that should resolve permanent failures too.
     */
    suspend fun resetAllItems(context: Context) {
        val db = HealthConnectSyncDatabase.get(context)
        val dao = db.dao()

        dao.resetAllFailedItems()

        Log.i(TAG, "Reset ALL failed items to pending status")
    }

    /**
     * Clear the entire outbox and let Health Connect re-sync.
     * Use as last resort if data is corrupted.
     *
     * This is safe because Health Connect still has the original data.
     */
    suspend fun clearAndResync(context: Context) {
        val db = HealthConnectSyncDatabase.get(context)
        val dao = db.dao()

        // Clear outbox
        dao.clearOutbox()

        // Clear sync state to force full re-read from Health Connect
        dao.clearSyncState()

        Log.i(TAG, "Cleared outbox and sync state - will re-sync from Health Connect")
    }
}

title: HealthConnectPermissionHelper.kt
text:
package com.migraineme

import android.content.Context
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.health.connect.client.records.NutritionRecord
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

object HealthConnectPermissionHelper {

    /**
     * Backwards-compatible alias (original helper only checked Nutrition).
     */
    suspend fun hasPermission(context: Context): Boolean = hasNutritionPermission(context)

    suspend fun hasNutritionPermission(context: Context): Boolean = withContext(Dispatchers.IO) {
        try {
            if (HealthConnectClient.getSdkStatus(context) != HealthConnectClient.SDK_AVAILABLE) {
                return@withContext false
            }
            val client = HealthConnectClient.getOrCreate(context)
            val granted = client.permissionController.getGrantedPermissions()
            HealthPermission.getReadPermission(NutritionRecord::class) in granted
        } catch (e: Exception) {
            android.util.Log.e("HealthConnectHelper", "Error checking nutrition permission: ${e.message}")
            false
        }
    }

    suspend fun hasMenstruationPermission(context: Context): Boolean = withContext(Dispatchers.IO) {
        try {
            if (HealthConnectClient.getSdkStatus(context) != HealthConnectClient.SDK_AVAILABLE) {
                return@withContext false
            }
            val client = HealthConnectClient.getOrCreate(context)
            val granted = client.permissionController.getGrantedPermissions()
            HealthPermission.getReadPermission(MenstruationPeriodRecord::class) in granted
        } catch (e: Exception) {
            android.util.Log.e("HealthConnectHelper", "Error checking menstruation permission: ${e.message}")
            false
        }
    }
}

title: HealthConnectPushWorker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.double
import kotlinx.serialization.json.int
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.long

/**
 * Worker that pushes Health Connect outbox entries to Supabase.
 * Processes entries from the local Room database outbox.
 *
 * TRIGGERING: This worker is triggered by FCM push (sync_hourly) from the backend.
 * It is NOT scheduled locally - the backend controls when syncs happen.
 *
 * FLOW:
 * 1. FCM arrives with type=sync_hourly
 * 2. MigraineMeFirebaseService triggers this worker via OneTimeWorkRequest
 * 3. Worker reads PENDING outbox items from Room DB
 * 4. Worker pushes each item to Supabase
 * 5. Successful items are deleted from outbox
 * 6. Failed items have their retry count incremented
 * 7. Items exceeding MAX_RETRIES are marked as "failed" (can retry later)
 * 8. Permanent failures (4xx) are marked as "permanent_failure"
 *
 * ERROR HANDLING:
 * - Transient errors (network, 5xx): Increment retry, will try again next run
 * - Permanent errors (4xx): Mark as permanent_failure, won't retry automatically
 * - After MAX_RETRIES: Mark as failed, can be manually retried after fix deployed
 */
class HealthConnectPushWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val TAG = "HCPushWorker"
        private const val BATCH_SIZE = 50
        private const val MAX_RETRIES = 5
        private const val MAX_WORKER_ATTEMPTS = 3  // Don't let WorkManager retry forever either
    }

    private val json = Json { ignoreUnknownKeys = true }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        Log.d(TAG, "Starting Health Connect push (attempt: $runAttemptCount)")

        try {
            val accessToken = SessionStore.getValidAccessToken(applicationContext)
            if (accessToken == null) {
                Log.w(TAG, "No valid access token")
                return@withContext Result.retry()
            }

            val db = HealthConnectSyncDatabase.get(applicationContext)
            val dao = db.dao()
            val service = SupabaseHealthConnectService(applicationContext)

            var totalProcessed = 0
            var totalFailed = 0
            var hasMore = true

            while (hasMore) {
                // Only fetch PENDING items (not failed or permanent_failure)
                val batch = dao.getPendingOutboxBatch(BATCH_SIZE)
                if (batch.isEmpty()) {
                    hasMore = false
                    continue
                }

                val successIds = mutableListOf<Long>()
                val retryableFailureIds = mutableListOf<Long>()
                val permanentFailureIds = mutableListOf<Long>()
                val errorMessages = mutableMapOf<Long, String>()

                for (item in batch) {
                    try {
                        val result = processOutboxItem(item, accessToken, service)

                        when (result) {
                            is ProcessResult.Success -> {
                                successIds.add(item.id)
                            }
                            is ProcessResult.RetryableFailure -> {
                                retryableFailureIds.add(item.id)
                                errorMessages[item.id] = result.message
                                Log.w(TAG, "Retryable failure for item ${item.id}: ${result.message}")
                            }
                            is ProcessResult.PermanentFailure -> {
                                permanentFailureIds.add(item.id)
                                errorMessages[item.id] = result.message
                                Log.e(TAG, "Permanent failure for item ${item.id}: ${result.message}")
                            }
                        }
                    } catch (e: Exception) {
                        // Unexpected exceptions are treated as retryable
                        retryableFailureIds.add(item.id)
                        errorMessages[item.id] = e.message ?: "Unknown error"
                        Log.e(TAG, "Exception processing outbox item ${item.id}: ${e.message}")
                    }
                }

                // Delete successful items
                if (successIds.isNotEmpty()) {
                    dao.deleteOutboxByIds(successIds)
                    totalProcessed += successIds.size
                }

                // Increment retry count for transient failures
                if (retryableFailureIds.isNotEmpty()) {
                    dao.incrementRetryCount(retryableFailureIds)
                    totalFailed += retryableFailureIds.size

                    // Update error messages for debugging
                    for (id in retryableFailureIds) {
                        errorMessages[id]?.let { dao.updateLastError(id, it) }
                    }
                }

                // Mark permanent failures
                if (permanentFailureIds.isNotEmpty()) {
                    val errorMsg = permanentFailureIds.mapNotNull { errorMessages[it] }.firstOrNull() ?: "Client error"
                    dao.markAsPermanentFailure(permanentFailureIds, errorMsg)
                    totalFailed += permanentFailureIds.size
                }

                // Safety: don't loop forever
                if (batch.size < BATCH_SIZE) {
                    hasMore = false
                }
            }

            // Mark items that have exceeded max retries as "failed" (removes them from pending queue)
            dao.markExceededRetriesAsFailed(MAX_RETRIES)

            Log.d(TAG, "Health Connect push completed: $totalProcessed succeeded, $totalFailed failed")

            // Check if there are still pending items to process
            val remainingCount = dao.getOutboxCount()  // Use existing method
            val pendingBatch = dao.getPendingOutboxBatch(1)
            val hasPendingWork = pendingBatch.isNotEmpty()
            
            when {
                !hasPendingWork -> {
                    // All done!
                    Log.d(TAG, "All items processed successfully")
                    Result.success()
                }
                totalProcessed > 0 -> {
                    // We made progress - retry to continue processing
                    Log.d(TAG, "$remainingCount items remain, made progress, scheduling retry")
                    Result.retry()
                }
                runAttemptCount >= MAX_WORKER_ATTEMPTS -> {
                    // We've tried multiple times with no progress - stop and wait for next trigger
                    // This prevents infinite retry loops when all items are failing
                    Log.w(TAG, "No progress after $runAttemptCount attempts, waiting for next scheduled run")
                    Result.success()
                }
                else -> {
                    // No progress but haven't hit limit - retry with backoff
                    Log.d(TAG, "No progress this run, will retry (attempt $runAttemptCount of $MAX_WORKER_ATTEMPTS)")
                    Result.retry()
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Push worker failed: ${e.message}", e)
            
            // If we've tried too many times, give up until next trigger
            if (runAttemptCount >= MAX_WORKER_ATTEMPTS) {
                Log.w(TAG, "Worker failed after $runAttemptCount attempts, waiting for next scheduled run")
                Result.success()
            } else {
                Result.retry()
            }
        }
    }

    /**
     * Result of processing a single outbox item.
     */
    sealed class ProcessResult {
        object Success : ProcessResult()
        data class RetryableFailure(val message: String) : ProcessResult()
        data class PermanentFailure(val message: String) : ProcessResult()
    }

    private suspend fun processOutboxItem(
        item: HealthConnectOutboxEntity,
        accessToken: String,
        service: SupabaseHealthConnectService
    ): ProcessResult {
        if (item.operation == "DELETE") {
            val success = service.deleteBySourceMeasureId(
                accessToken = accessToken,
                recordType = item.recordType,
                sourceMeasureId = item.healthConnectId
            )
            return if (success) ProcessResult.Success else ProcessResult.RetryableFailure("Delete failed")
        }

        // UPSERT operation
        val payload = try {
            json.decodeFromString<JsonObject>(item.payload)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse payload: ${item.payload}")
            // Invalid payload is a permanent failure - retrying won't help
            return ProcessResult.PermanentFailure("Invalid payload: ${e.message}")
        }

        val success = when (item.recordType) {
            HealthConnectRecordTypes.SLEEP -> {
                val durationMinutes = payload["duration_minutes"]?.jsonPrimitive?.long ?: 0
                val startTime = payload["start_time"]?.jsonPrimitive?.content ?: ""
                val endTime = payload["end_time"]?.jsonPrimitive?.content ?: ""
                val remMin = payload["rem_minutes"]?.jsonPrimitive?.long?.toInt() ?: 0
                val deepMin = payload["deep_minutes"]?.jsonPrimitive?.long?.toInt() ?: 0
                val lightMin = payload["light_minutes"]?.jsonPrimitive?.long?.toInt() ?: 0
                val awakeMin = payload["awake_minutes"]?.jsonPrimitive?.long?.toInt() ?: 0

                service.upsertSleep(
                    accessToken = accessToken,
                    date = item.date,
                    durationHours = durationMinutes / 60.0,
                    startTime = startTime,
                    endTime = endTime,
                    remMinutes = remMin,
                    deepMinutes = deepMin,
                    lightMinutes = lightMin,
                    awakeMinutes = awakeMin,
                    sourceId = item.healthConnectId
                )
            }

            HealthConnectRecordTypes.HRV -> {
                val valueMs = payload["value_ms"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_ms")
                service.upsertHrv(accessToken, item.date, valueMs, item.healthConnectId)
            }

            HealthConnectRecordTypes.RESTING_HR -> {
                val valueBpm = payload["value_bpm"]?.jsonPrimitive?.long
                    ?: return ProcessResult.PermanentFailure("Missing value_bpm")
                service.upsertRestingHr(accessToken, item.date, valueBpm.toDouble(), item.healthConnectId)
            }

            HealthConnectRecordTypes.STEPS -> {
                val count = payload["value_count"]?.jsonPrimitive?.long
                    ?: return ProcessResult.PermanentFailure("Missing value_count")
                service.upsertSteps(accessToken, item.date, count, item.healthConnectId)
            }

            HealthConnectRecordTypes.EXERCISE -> {
                val durationMinutes = payload["duration_minutes"]?.jsonPrimitive?.long ?: 0
                val exerciseType = payload["exercise_type"]?.jsonPrimitive?.int ?: 0
                // Pass start/end times for session-based upsert
                val startTime = payload["start_time"]?.jsonPrimitive?.content
                val endTime = payload["end_time"]?.jsonPrimitive?.content
                service.upsertExercise(
                    accessToken = accessToken,
                    date = item.date,
                    durationMinutes = durationMinutes.toInt(),
                    exerciseType = exerciseType,
                    sourceId = item.healthConnectId,
                    startTime = startTime,
                    endTime = endTime
                )
            }

            HealthConnectRecordTypes.WEIGHT -> {
                val valueKg = payload["value_kg"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_kg")
                service.upsertWeight(accessToken, item.date, valueKg, item.healthConnectId)
            }

            HealthConnectRecordTypes.BODY_FAT -> {
                val valuePct = payload["value_pct"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_pct")
                service.upsertBodyFat(accessToken, item.date, valuePct, item.healthConnectId)
            }

            HealthConnectRecordTypes.HYDRATION -> {
                val valueMl = payload["value_ml"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_ml")
                service.upsertHydration(accessToken, item.date, valueMl, item.healthConnectId)
            }

            HealthConnectRecordTypes.BLOOD_PRESSURE -> {
                val systolic = payload["systolic_mmhg"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing systolic_mmhg")
                val diastolic = payload["diastolic_mmhg"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing diastolic_mmhg")
                service.upsertBloodPressure(accessToken, item.date, systolic, diastolic, item.healthConnectId)
            }

            HealthConnectRecordTypes.BLOOD_GLUCOSE -> {
                val valueMmol = payload["value_mmol_l"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_mmol_l")
                val mealType = payload["meal_type"]?.jsonPrimitive?.content ?: "GENERAL"
                service.upsertBloodGlucose(accessToken, item.date, valueMmol, mealType, item.healthConnectId)
            }

            HealthConnectRecordTypes.SPO2 -> {
                val valuePct = payload["value_pct"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_pct")
                service.upsertSpo2(accessToken, item.date, valuePct, item.healthConnectId)
            }

            HealthConnectRecordTypes.RESPIRATORY_RATE -> {
                val valueBpm = payload["value_bpm"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_bpm")
                service.upsertRespiratoryRate(accessToken, item.date, valueBpm, item.healthConnectId)
            }

            HealthConnectRecordTypes.SKIN_TEMP -> {
                val valueCelsius = payload["value_celsius"]?.jsonPrimitive?.double
                    ?: return ProcessResult.PermanentFailure("Missing value_celsius")
                service.upsertSkinTemp(accessToken, item.date, valueCelsius, item.healthConnectId)
            }

            else -> {
                Log.w(TAG, "Unknown record type: ${item.recordType}")
                return ProcessResult.PermanentFailure("Unknown record type: ${item.recordType}")
            }
        }

        return if (success) ProcessResult.Success else ProcessResult.RetryableFailure("Upsert returned false")
    }
}

title: HealthConnectRationaleActivity.kt
text:
package com.migraineme

import android.content.Intent
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

/**
 * Rationale activity shown when user taps the (i) info button on ANY permission dialog.
 * This explains ALL permissions the app may request.
 */
class HealthConnectRationaleActivity : ComponentActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        android.util.Log.d("PermissionRationale", "===== RATIONALE ACTIVITY STARTED =====")
        android.util.Log.d("PermissionRationale", "Intent: ${intent.action}")
        android.util.Log.d("PermissionRationale", "Extras: ${intent.extras}")

        setContent {
            MaterialTheme {
                RationaleScreen(
                    onContinue = {
                        setResult(RESULT_OK)
                        finish()
                    },
                    onCancel = {
                        setResult(RESULT_CANCELED)
                        finish()
                    }
                )
            }
        }
    }
}

@Composable
private fun RationaleScreen(
    onContinue: () -> Unit,
    onCancel: () -> Unit
) {
    Scaffold { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(24.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Spacer(Modifier.weight(0.3f))

            Text(
                "App Permissions",
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold
            )

            Text(
                "MigraineMe collects various data to help identify your migraine triggers. Here's what we use and why:",
                style = MaterialTheme.typography.bodyLarge
            )

            Spacer(Modifier.height(8.dp))

            // Location Section
            Text(
                "📍 Location",
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                "Used to get local weather data (temperature, pressure, humidity) which can trigger migraines. Requires \"Allow all the time\" for background updates.",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(Modifier.height(8.dp))

            // Microphone Section
            Text(
                "🎤 Microphone",
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                "Used to sample ambient noise levels. We only measure volume (decibels), not actual audio content.",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(Modifier.height(8.dp))

            // Health Connect Section
            Text(
                "❤️ Health Connect",
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                "Used to read nutrition, sleep, heart rate, HRV, steps, menstruation, and other health data from apps like Cronometer, WHOOP, Samsung Health, etc.",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(Modifier.height(8.dp))

            // Screen Time Section
            Text(
                "📱 Usage Access",
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.SemiBold
            )
            Text(
                "Used to track screen time which may correlate with migraines.",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(Modifier.height(16.dp))

            Divider()

            Spacer(Modifier.height(8.dp))

            Text(
                "Your data is stored securely and used only to analyze your migraine patterns. We never share your data with third parties.",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(Modifier.weight(1f))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = onCancel,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Cancel")
                }

                Button(
                    onClick = {
                        android.util.Log.d("PermissionRationale", "User clicked CONTINUE")
                        onContinue()
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Continue")
                }
            }

            Spacer(Modifier.height(16.dp))
        }
    }
}

title: HealthConnectSyncDao.kt
text:
package com.migraineme

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query

@Dao
interface HealthConnectSyncDao {

    // ============================================================
    // Sync State
    // ============================================================

    @Query("SELECT * FROM health_connect_sync_state WHERE id = 1")
    suspend fun getSyncState(): HealthConnectSyncStateEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertSyncState(state: HealthConnectSyncStateEntity)

    // ============================================================
    // Outbox - Basic Operations
    // ============================================================

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOutbox(item: HealthConnectOutboxEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOutboxBatch(items: List<HealthConnectOutboxEntity>)

    @Query("SELECT * FROM health_connect_outbox ORDER BY createdAtEpochMs ASC LIMIT :limit")
    suspend fun getOutboxBatch(limit: Int): List<HealthConnectOutboxEntity>

    @Query("SELECT * FROM health_connect_outbox WHERE recordType = :recordType ORDER BY createdAtEpochMs ASC LIMIT :limit")
    suspend fun getOutboxByType(recordType: String, limit: Int): List<HealthConnectOutboxEntity>

    @Query("DELETE FROM health_connect_outbox WHERE id IN (:ids)")
    suspend fun deleteOutboxByIds(ids: List<Long>)

    @Query("DELETE FROM health_connect_outbox WHERE healthConnectId = :healthConnectId")
    suspend fun deleteOutboxByHealthConnectId(healthConnectId: String)

    @Query("SELECT COUNT(*) FROM health_connect_outbox")
    suspend fun getOutboxCount(): Int

    @Query("SELECT COUNT(*) FROM health_connect_outbox WHERE recordType = :recordType")
    suspend fun getOutboxCountByType(recordType: String): Int

    // ============================================================
    // Outbox - Retry Management (NEW)
    // ============================================================

    /**
     * Get pending items only (excludes failed and permanent_failure).
     * This is the main query used by the push worker.
     */
    @Query("SELECT * FROM health_connect_outbox WHERE status = 'pending' ORDER BY createdAtEpochMs ASC LIMIT :limit")
    suspend fun getPendingOutboxBatch(limit: Int): List<HealthConnectOutboxEntity>

    /**
     * Increment retry count for items that failed with transient errors.
     */
    @Query("UPDATE health_connect_outbox SET retryCount = retryCount + 1 WHERE id IN (:ids)")
    suspend fun incrementRetryCount(ids: List<Long>)

    /**
     * Update last error message for debugging.
     */
    @Query("UPDATE health_connect_outbox SET lastError = :error WHERE id = :id")
    suspend fun updateLastError(id: Long, error: String)

    /**
     * Mark items as "failed" after exceeding max retries.
     * These can be retried later (e.g., after an app update fixes the issue).
     */
    @Query("UPDATE health_connect_outbox SET status = 'failed' WHERE retryCount >= :maxRetries AND status = 'pending'")
    suspend fun markExceededRetriesAsFailed(maxRetries: Int)

    /**
     * Mark items as "permanent_failure" (client errors that won't be fixed by retrying).
     */
    @Query("UPDATE health_connect_outbox SET status = 'permanent_failure', lastError = :error WHERE id IN (:ids)")
    suspend fun markAsPermanentFailure(ids: List<Long>, error: String)

    /**
     * Reset failed items to pending status.
     * Call this after deploying a fix to give items another chance.
     */
    @Query("UPDATE health_connect_outbox SET status = 'pending', retryCount = 0 WHERE status = 'failed'")
    suspend fun retryFailedItems()

    /**
     * Reset ALL non-pending items (both failed and permanent_failure).
     * Use with caution - typically after a major fix or schema change.
     */
    @Query("UPDATE health_connect_outbox SET status = 'pending', retryCount = 0 WHERE status != 'pending'")
    suspend fun resetAllFailedItems()

    /**
     * Delete old permanent failures (cleanup after 30 days).
     */
    @Query("DELETE FROM health_connect_outbox WHERE status = 'permanent_failure' AND createdAtEpochMs < :beforeEpochMs")
    suspend fun deleteOldPermanentFailures(beforeEpochMs: Long)

    // ============================================================
    // Cleanup
    // ============================================================

    @Query("DELETE FROM health_connect_outbox WHERE createdAtEpochMs < :beforeEpochMs")
    suspend fun deleteOldOutboxEntries(beforeEpochMs: Long)

    @Query("DELETE FROM health_connect_outbox")
    suspend fun clearOutbox()

    @Query("DELETE FROM health_connect_sync_state")
    suspend fun clearSyncState()
}

title: HealthConnectSyncDatabase.kt
text:
package com.migraineme

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase

@Database(
    entities = [
        HealthConnectSyncStateEntity::class,
        HealthConnectOutboxEntity::class
    ],
    version = 2,  // Incremented from 1 to 2
    exportSchema = false
)
abstract class HealthConnectSyncDatabase : RoomDatabase() {

    abstract fun dao(): HealthConnectSyncDao

    companion object {
        @Volatile
        private var INSTANCE: HealthConnectSyncDatabase? = null

        fun get(context: Context): HealthConnectSyncDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    HealthConnectSyncDatabase::class.java,
                    "health_connect_sync_db"
                )
                    .addMigrations(HealthConnectOutboxMigration.MIGRATION_1_2)  // Add migration
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

title: HealthConnectSyncManager.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.health.connect.client.HealthConnectClient
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager

/**
 * Manager for triggering Health Connect syncs.
 * 
 * Handles:
 * - Sync on app resume (primary method - always works when app is open)
 * - Debouncing to avoid excessive syncs
 * - Checking if Health Connect is available/connected
 * 
 * This ensures data syncs reliably when the user opens the app,
 * complementing the FCM-triggered background syncs which only work
 * when the app is in foreground.
 */
object HealthConnectSyncManager {
    
    private const val TAG = "HCSyncManager"
    private const val PREFS_NAME = "health_connect_sync"
    private const val KEY_LAST_SYNC = "last_sync_time"
    
    private const val WORK_NAME_CHANGES = "health_connect_changes_sync"
    private const val WORK_NAME_PUSH = "health_connect_push_sync"
    
    // Minimum time between syncs (5 minutes)
    // This prevents excessive syncs if user rapidly opens/closes app
    private const val MIN_SYNC_INTERVAL_MS = 5 * 60 * 1000L
    
    /**
     * Triggers Health Connect sync if:
     * 1. Health Connect is available
     * 2. Enough time has passed since last sync
     * 3. User has connected Health Connect (has granted permissions)
     */
    fun triggerSyncIfEnabled(context: Context) {
        try {
            // Check if Health Connect is available
            if (HealthConnectClient.getSdkStatus(context) != HealthConnectClient.SDK_AVAILABLE) {
                Log.d(TAG, "Health Connect not available, skipping sync")
                return
            }
            
            // Check debounce - don't sync too frequently
            if (!shouldSync(context)) {
                Log.d(TAG, "Skipping sync - too soon since last sync")
                return
            }
            
            // Check if user has connected Health Connect (any permissions granted)
            val prefs = context.getSharedPreferences("health_connect", Context.MODE_PRIVATE)
            val isConnected = prefs.getBoolean("is_connected", false)
            if (!isConnected) {
                Log.d(TAG, "Health Connect not connected by user, skipping sync")
                return
            }
            
            // Trigger sync
            Log.d(TAG, "Triggering Health Connect sync on app resume")
            triggerSync(context)
            
            // Update last sync time
            updateLastSyncTime(context)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error checking sync conditions: ${e.message}")
        }
    }
    
    /**
     * Force trigger sync regardless of debounce.
     * Used when user manually requests sync or when first connecting.
     */
    fun triggerSyncNow(context: Context) {
        Log.d(TAG, "Force triggering Health Connect sync")
        triggerSync(context)
        updateLastSyncTime(context)
    }
    
    private fun triggerSync(context: Context) {
        val workManager = WorkManager.getInstance(context)
        
        // Use REPLACE policy - if work is already running/enqueued, replace it
        // This prevents duplicate workers from piling up
        
        // Trigger changes worker (reads from Health Connect → Room outbox)
        workManager.enqueueUniqueWork(
            WORK_NAME_CHANGES,
            ExistingWorkPolicy.REPLACE,
            OneTimeWorkRequestBuilder<HealthConnectChangesWorker>().build()
        )
        
        // Trigger push worker (pushes from Room outbox → Supabase)
        workManager.enqueueUniqueWork(
            WORK_NAME_PUSH,
            ExistingWorkPolicy.REPLACE,
            OneTimeWorkRequestBuilder<HealthConnectPushWorker>().build()
        )
    }
    
    private fun shouldSync(context: Context): Boolean {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val lastSync = prefs.getLong(KEY_LAST_SYNC, 0)
        val now = System.currentTimeMillis()
        return (now - lastSync) >= MIN_SYNC_INTERVAL_MS
    }
    
    private fun updateLastSyncTime(context: Context) {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit().putLong(KEY_LAST_SYNC, System.currentTimeMillis()).apply()
    }
    
    /**
     * Call this when user connects Health Connect in settings.
     * Marks HC as connected so sync-on-resume will work.
     * Also triggers an immediate sync.
     */
    fun markAsConnected(context: Context) {
        val prefs = context.getSharedPreferences("health_connect", Context.MODE_PRIVATE)
        prefs.edit().putBoolean("is_connected", true).apply()
        Log.d(TAG, "Health Connect marked as connected")
        
        // Trigger immediate sync since user just connected
        triggerSync(context)
        updateLastSyncTime(context)
    }
    
    /**
     * Call this when user disconnects Health Connect in settings.
     */
    fun markAsDisconnected(context: Context) {
        val prefs = context.getSharedPreferences("health_connect", Context.MODE_PRIVATE)
        prefs.edit().putBoolean("is_connected", false).apply()
        Log.d(TAG, "Health Connect marked as disconnected")
    }
}

title: HealthConnectSyncStateEntity.kt
text:
package com.migraineme

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * Room entity for storing Health Connect sync state.
 * Stores change tokens for each record type.
 */
@Entity(tableName = "health_connect_sync_state")
data class HealthConnectSyncStateEntity(
    @PrimaryKey val id: Int = 1, // Single row
    
    // Change tokens for each record type
    val sleepToken: String? = null,
    val hrvToken: String? = null,
    val restingHrToken: String? = null,
    val stepsToken: String? = null,
    val exerciseToken: String? = null,
    val weightToken: String? = null,
    val bodyFatToken: String? = null,
    val hydrationToken: String? = null,
    val bloodPressureToken: String? = null,
    val bloodGlucoseToken: String? = null,
    val spo2Token: String? = null,
    val respiratoryRateToken: String? = null,
    val skinTempToken: String? = null,
    
    // Last sync timestamps
    val lastSyncAtEpochMs: Long = 0
)

title: HomeScreen.kt
text:
package com.migraineme

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.lerp
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import io.ktor.client.HttpClient
import io.ktor.client.engine.android.Android
import io.ktor.client.request.header
import io.ktor.client.request.post
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import kotlin.math.cos
import kotlin.math.sin

@Composable
fun HomeScreenRoot(
    onLogout: () -> Unit,
    onNavigateToMigraine: () -> Unit = {},
    onNavigateToRiskDetail: () -> Unit = {},
    authVm: AuthViewModel,
    logVm: LogViewModel,
    vm: HomeViewModel = viewModel(),
    // Quick log VMs — created at call site or defaulted
    triggerVm: TriggerViewModel = viewModel(),
    medicineVm: MedicineViewModel = viewModel(),
    reliefVm: ReliefViewModel = viewModel(),
    prodromeVm: ProdromeViewModel = viewModel(),
    symptomVm: SymptomViewModel = viewModel(),
) {
    val state by vm.state.collectAsState()
    val auth by authVm.state.collectAsState()

    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext

    /**
     * On WHOOP OAuth return, MainActivity persists the callback URI.
     * Previously, the token exchange + backfill trigger only happened in ThirdPartyConnectionsScreen.
     * Since the callback returns to Home, we complete auth here too (best-effort, once per pending callback).
     */
    LaunchedEffect(Unit) {
        val prefs = appCtx.getSharedPreferences("whoop_oauth", android.content.Context.MODE_PRIVATE)
        val lastUri = prefs.getString("last_uri", null)

        if (!lastUri.isNullOrBlank()) {
            withContext(Dispatchers.IO) {
                val persistedToken = SessionStore.getValidAccessToken(appCtx)
                if (!persistedToken.isNullOrBlank()) {
                    var persistedUserId = SessionStore.readUserId(appCtx)
                    if (persistedUserId.isNullOrBlank()) {
                        persistedUserId = JwtUtils.extractUserIdFromAccessToken(persistedToken)
                        if (!persistedUserId.isNullOrBlank()) {
                            SessionStore.saveUserId(appCtx, persistedUserId)
                        }
                    }
                }

                val ok = WhoopAuthService().completeAuth(appCtx)

                if (ok) {
                    val accessToken = SessionStore.getValidAccessToken(appCtx)
                    if (!accessToken.isNullOrBlank()) {
                        val client = HttpClient(Android)
                        try {
                            client.post("${BuildConfig.SUPABASE_URL}/functions/v1/enqueue-login-backfill") {
                                header("Authorization", "Bearer $accessToken")
                                header("Content-Type", "application/json")
                            }
                        } catch (_: Throwable) {
                        } finally {
                            client.close()
                        }
                    }
                }
            }
        }
    }

    // ── Load real risk score from triggers + prodromes ──
    LaunchedEffect(auth.accessToken) {
        if (!auth.accessToken.isNullOrBlank()) {
            vm.loadRisk(appCtx)
        }
    }

    if (state.loading) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
    } else {
        val scrollState = rememberScrollState()

        // Selected day index: 0 = today (default), 1 = tomorrow, etc.
        var selectedDay by remember { mutableStateOf(0) }

        // Derive the displayed data from selected day
        val dayData = state.dayRisks.getOrNull(selectedDay)
        val displayScore = dayData?.score ?: state.riskScore
        val displayZone = dayData?.zone ?: state.riskZone
        val displayPercent = dayData?.percent ?: state.riskPercent
        val displayTriggers = dayData?.topTriggers ?: state.triggersAtRisk

        // Recommendation adjusts for selected day
        val displayRecommendation = if (selectedDay == 0) {
            state.aiRecommendation
        } else {
            val dayLabel = dayData?.date?.format(java.time.format.DateTimeFormatter.ofPattern("EEEE")) ?: "that day"
            when (displayZone) {
                RiskZone.HIGH -> "High risk predicted for $dayLabel. Plan ahead: avoid known triggers, prepare medication, and keep your schedule light."
                RiskZone.MILD -> "Moderate risk predicted for $dayLabel. Stay mindful of your triggers and keep regular meals and breaks."
                RiskZone.LOW -> "Low risk predicted for $dayLabel. Maintain your healthy routine."
                RiskZone.NONE -> "No significant risk predicted for $dayLabel. Looking good!"
            }
        }

        ScrollFadeContainer(scrollState = scrollState) { scroll ->
            ScrollableScreenContent(scrollState = scroll) {

                RiskHeroCard(
                    riskPercent = displayPercent,
                    riskScore = displayScore,
                    riskZone = displayZone,
                    forecast = state.forecast,
                    selectedDay = selectedDay,
                    dayRisks = state.dayRisks,
                    onDaySelected = { selectedDay = it },
                    onTap = onNavigateToRiskDetail
                )

                // ── Quick Log Strip — below the gauge ──
                QuickLogStrip(
                    authVm = authVm,
                    triggerVm = triggerVm,
                    medicineVm = medicineVm,
                    reliefVm = reliefVm,
                    prodromeVm = prodromeVm,
                    symptomVm = symptomVm,
                    onLogComplete = { vm.loadRisk(appCtx) }
                )

                ActiveTriggersCard(
                    triggers = displayTriggers.take(3),
                    gaugeMax = state.gaugeMaxScore,
                    onTap = onNavigateToRiskDetail
                )
                RecommendationCard(recommendation = displayRecommendation)
            }
        }
    }
}

@Composable
private fun RiskHeroCard(
    riskPercent: Int,
    riskScore: Double = 0.0,
    riskZone: RiskZone = RiskZone.NONE,
    forecast: List<Int> = listOf(0, 0, 0, 0, 0, 0, 0),
    selectedDay: Int = 0,
    dayRisks: List<DayRisk> = emptyList(),
    onDaySelected: (Int) -> Unit = {},
    onTap: () -> Unit = {},
    modifier: Modifier = Modifier
) {
    val clamped = riskPercent.coerceIn(0, 100)

    val zoneColor = when (riskZone) {
        RiskZone.HIGH -> Color(0xFFE57373)
        RiskZone.MILD -> Color(0xFFFFB74D)
        RiskZone.LOW -> Color(0xFF81C784)
        RiskZone.NONE -> AppTheme.SubtleTextColor
    }

    // Day label for selected day
    val dayLabel = if (selectedDay == 0) "Risk today" else {
        val date = dayRisks.getOrNull(selectedDay)?.date
        if (date != null) "Risk · ${date.format(java.time.format.DateTimeFormatter.ofPattern("EEE d MMM"))}"
        else "Risk"
    }

    HeroCard(modifier = modifier.clickable { onTap() }) {
        Text(
            dayLabel,
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        RiskGauge(
            percent = clamped,
            diameter = 220.dp,
            stroke = 16.dp,
            trackColor = AppTheme.TrackColor,
            progressColor = AppTheme.AccentPurple
        )

        // Score display
        Text(
            "%.1f".format(riskScore),
            color = Color.White,
            style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold)
        )

        // Zone label
        Text(
            riskZone.label,
            color = zoneColor,
            style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        SevenDayOutlook(
            values = forecast,
            selectedDay = selectedDay,
            dayRisks = dayRisks,
            onDaySelected = onDaySelected
        )
    }
}

@Composable
private fun SevenDayOutlook(
    values: List<Int>,
    selectedDay: Int = 0,
    dayRisks: List<DayRisk> = emptyList(),
    onDaySelected: (Int) -> Unit = {},
    modifier: Modifier = Modifier
) {
    val zone = ZoneId.systemDefault()
    val today = LocalDate.now(zone)
    val dayFmt = DateTimeFormatter.ofPattern("EEE")

    Column(
        modifier = modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(6.dp),
        horizontalAlignment = Alignment.Start
    ) {
        Text(
            "7-day forecast",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            for (i in 0 until 7) {
                val percent = values.getOrNull(i)?.coerceIn(0, 100) ?: 0
                val date = today.plusDays(i.toLong())
                val dayLabel = if (i == 0) "Today" else date.format(dayFmt)
                val isSelected = i == selectedDay

                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(2.dp),
                    modifier = Modifier.clickable { onDaySelected(i) }
                ) {
                    Box(contentAlignment = Alignment.Center) {
                        if (isSelected) {
                            Box(
                                modifier = Modifier
                                    .size(42.dp)
                                    .background(
                                        color = AppTheme.AccentPurple.copy(alpha = 0.25f),
                                        shape = CircleShape
                                    )
                            )
                        }
                        MiniGauge(
                            percent = percent,
                            size = 36.dp,
                            strokeWidth = 3.5.dp
                        )
                    }
                    Text(
                        dayLabel,
                        color = if (isSelected) AppTheme.AccentPurple else if (i == 0) Color.White else AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall.copy(
                            fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal
                        )
                    )
                }
            }
        }
    }
}

@Composable
private fun MiniGauge(
    percent: Int,
    size: Dp,
    strokeWidth: Dp
) {
    val clamped = percent.coerceIn(0, 100)
    val p = clamped / 100f

    val progressColor = lerp(AppTheme.AccentPurple, AppTheme.AccentPink, p)

    Box(
        modifier = Modifier.width(size).height(size * 0.62f),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val sw = strokeWidth.toPx()
            val radius = (minOf(this.size.width, this.size.height * 2f) / 2f) - sw
            val cx = this.size.width / 2f; val cy = this.size.height
            drawArc(AppTheme.TrackColor, 180f, 180f, false,
                Offset(cx - radius, cy - radius), Size(radius * 2f, radius * 2f),
                style = Stroke(sw * 0.7f, cap = StrokeCap.Round))
            if (p > 0f) {
                drawArc(progressColor, 180f, 180f * p, false,
                    Offset(cx - radius, cy - radius), Size(radius * 2f, radius * 2f),
                    style = Stroke(sw, cap = StrokeCap.Round))
            }
        }
    }
}

@Composable
private fun ActiveTriggersCard(
    triggers: List<TriggerScore>,
    gaugeMax: Double = 10.0,
    onTap: () -> Unit = {}
) {
    if (triggers.isEmpty()) return

    BaseCard(modifier = Modifier.clickable { onTap() }) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                "Top contributors",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.weight(1f))
            Text(
                "→",
                color = AppTheme.AccentPurple,
                style = MaterialTheme.typography.bodyMedium
            )
        }

        Spacer(Modifier.height(8.dp))

        triggers.forEach { t ->
            val sevColor = when (t.severity.uppercase()) {
                "HIGH" -> Color(0xFFE57373)
                "MILD" -> Color(0xFFFFB74D)
                else -> Color(0xFF81C784)
            }
            val sevBg = sevColor.copy(alpha = 0.12f)
            val totalPts = triggers.sumOf { it.score }.coerceAtLeast(1)
            val pctOfTotal = (t.score * 100) / totalPts
            val barFraction = (t.score.toFloat() / gaugeMax.toFloat()).coerceIn(0f, 1f)

            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 4.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier
                        .size(6.dp)
                        .background(sevColor, CircleShape)
                )

                Column(
                    modifier = Modifier
                        .weight(1f)
                        .padding(horizontal = 12.dp, vertical = 8.dp),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    // Top row: name + severity chip
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            t.name,
                            color = Color.White,
                            style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium),
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis,
                            modifier = Modifier.weight(1f)
                        )

                        Spacer(Modifier.width(8.dp))

                        Box(
                            modifier = Modifier
                                .background(
                                    color = sevBg,
                                    shape = RoundedCornerShape(12.dp)
                                )
                                .padding(horizontal = 8.dp, vertical = 2.dp)
                        ) {
                            Text(
                                t.severity,
                                color = sevColor,
                                style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold)
                            )
                        }
                    }

                    // Progress bar
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(4.dp)
                            .background(
                                color = AppTheme.TrackColor,
                                shape = RoundedCornerShape(2.dp)
                            )
                    ) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth(barFraction)
                                .height(4.dp)
                                .background(
                                    color = sevColor,
                                    shape = RoundedCornerShape(2.dp)
                                )
                        )
                    }

                    // Bottom row: points + days active
                    Text(
                        "${pctOfTotal}% of risk · ${t.score} pts · ${if (t.daysActive == 1) "today only" else "${t.daysActive} days active"}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            }
        }
    }
}

@Composable
private fun RecommendationCard(recommendation: String) {
    BaseCard {
        Text(
            "Recommendation",
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )
        Text(
            recommendation.ifBlank { "—" },
            color = AppTheme.BodyTextColor
        )
    }
}

@Composable
private fun RiskGauge(
    percent: Int,
    diameter: Dp,
    stroke: Dp,
    trackColor: Color,
    progressColor: Color
) {
    val clamped = percent.coerceIn(0, 100)

    val anim = remember { Animatable(0f) }
    LaunchedEffect(clamped) {
        anim.animateTo(
            targetValue = clamped.toFloat(),
            animationSpec = tween(durationMillis = 900, easing = FastOutSlowInEasing)
        )
    }
    val p = (anim.value / 100f).coerceIn(0f, 1f)

    val progressStroke = stroke
    val trackStroke = (stroke.value * 0.72f).dp

    val width = diameter
    val height = diameter * 0.62f

    Box(
        modifier = Modifier.width(width).height(height),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val radius = (minOf(size.width, size.height * 2f) / 2f) - progressStroke.toPx()
            val cx = size.width / 2f
            val cy = size.height

            val startAngle = 180f
            val fullSweep = 180f
            val sweep = fullSweep * p

            drawArc(
                color = trackColor,
                startAngle = startAngle,
                sweepAngle = fullSweep,
                useCenter = false,
                topLeft = Offset(cx - radius, cy - radius),
                size = Size(radius * 2f, radius * 2f),
                style = Stroke(width = trackStroke.toPx(), cap = StrokeCap.Round)
            )

            val tickCount = 11
            val tickOuter = radius + trackStroke.toPx() * 0.10f
            val tickInner = radius - trackStroke.toPx() * 0.55f
            for (i in 0 until tickCount) {
                val a = startAngle + (fullSweep / (tickCount - 1)) * i
                val rad = Math.toRadians(a.toDouble())
                val ox = cx + cos(rad).toFloat() * tickOuter
                val oy = cy + sin(rad).toFloat() * tickOuter
                val ix = cx + cos(rad).toFloat() * tickInner
                val iy = cy + sin(rad).toFloat() * tickInner
                drawLine(
                    color = Color.White.copy(alpha = 0.14f),
                    start = Offset(ix, iy),
                    end = Offset(ox, oy),
                    strokeWidth = 2.dp.toPx(),
                    cap = StrokeCap.Round
                )
            }

            drawArc(
                color = progressColor.copy(alpha = 0.22f),
                startAngle = startAngle,
                sweepAngle = sweep,
                useCenter = false,
                topLeft = Offset(cx - radius, cy - radius),
                size = Size(radius * 2f, radius * 2f),
                style = Stroke(width = (progressStroke.toPx() * 1.75f), cap = StrokeCap.Round)
            )

            val segs = 42
            val segSweep = sweep / segs
            for (j in 0 until segs) {
                val t = if (segs == 1) 1f else j / (segs - 1f)
                val c = lerp(AppTheme.AccentPurple, AppTheme.AccentPink, t)
                val sa = startAngle + segSweep * j
                drawArc(
                    color = c,
                    startAngle = sa,
                    sweepAngle = segSweep.coerceAtLeast(0f),
                    useCenter = false,
                    topLeft = Offset(cx - radius, cy - radius),
                    size = Size(radius * 2f, radius * 2f),
                    style = Stroke(width = progressStroke.toPx(), cap = StrokeCap.Round)
                )
            }

            val endAngle = startAngle + sweep
            val endRad = Math.toRadians(endAngle.toDouble())
            val ex = cx + cos(endRad).toFloat() * radius
            val ey = cy + sin(endRad).toFloat() * radius
            drawCircle(
                color = Color.White.copy(alpha = 0.90f),
                radius = (progressStroke.toPx() * 0.42f),
                center = Offset(ex, ey)
            )
            drawCircle(
                color = AppTheme.AccentPink.copy(alpha = 0.95f),
                radius = (progressStroke.toPx() * 0.30f),
                center = Offset(ex, ey)
            )
        }
    }
}


title: HomeViewModel.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.UUID

data class MigraineLog(
    val id: String = UUID.randomUUID().toString(),
    val time: Instant = Instant.now(),
    val severity: Int, // 0..10
    val note: String? = null,
    val type: String = "Headache"
)

data class TriggerScore(
    val name: String,
    val score: Int,          // total contribution points
    val severity: String = "LOW",   // highest severity (HIGH/MILD/LOW)
    val daysActive: Int = 1         // how many of the last 7 days this trigger appeared
)

/** Risk zone derived from gauge thresholds */
enum class RiskZone(val label: String) {
    NONE("None"),
    LOW("Low"),
    MILD("Mild"),
    HIGH("High")
}

/** Per-day risk breakdown for the 7-day forecast */
data class DayRisk(
    val date: LocalDate,
    val score: Double,
    val zone: RiskZone,
    val percent: Int,
    val topTriggers: List<TriggerScore>
)

data class HomeUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val riskScore: Double = 0.0,            // raw summed score
    val riskZone: RiskZone = RiskZone.NONE,
    val riskPercent: Int = 0,               // 0..100 for gauge animation (mapped from score)
    val triggersAtRisk: List<TriggerScore> = emptyList(),
    val aiRecommendation: String = "",
    val recentLogs: List<MigraineLog> = emptyList(),
    // Gauge thresholds for display
    val gaugeMaxScore: Double = 10.0,       // the HIGH threshold — used as gauge max
    val forecast: List<Int> = listOf(0, 0, 0, 0, 0, 0, 0),  // 7-day risk % (today + next 6 days)
    val dayRisks: List<DayRisk> = emptyList()  // full per-day breakdown
)

class HomeViewModel : ViewModel() {

    private val _state = MutableStateFlow(HomeUiState(loading = true))
    val state: StateFlow<HomeUiState> = _state

    private val timeFmt = DateTimeFormatter.ofPattern("EEE d MMM • HH:mm")

    /**
     * Read pre-computed score from risk_score_live.
     * If missing or stale >2h, trigger edge function then re-read.
     */
    fun loadRisk(context: Context) {
        viewModelScope.launch {
            _state.value = HomeUiState(loading = true)

            try {
                val result = withContext(Dispatchers.IO) { loadFromLiveScore(context) }
                _state.value = result
            } catch (e: Exception) {
                Log.e(TAG, "loadRisk error: ${e.message}", e)
                _state.value = HomeUiState(
                    loading = false,
                    riskScore = 0.0,
                    riskZone = RiskZone.NONE,
                    riskPercent = 0,
                    triggersAtRisk = emptyList(),
                    aiRecommendation = "Unable to load risk data right now. Pull down to refresh.",
                    forecast = listOf(0, 0, 0, 0, 0, 0, 0),
                    dayRisks = emptyList()
                )
            }
        }
    }

    // ═════════════════════════════════════════════════════════════════
    // Read from risk_score_live (DB only)
    // ═════════════════════════════════════════════════════════════════

    private suspend fun loadFromLiveScore(context: Context): HomeUiState {
        val appCtx = context.applicationContext
        val accessToken = SessionStore.getValidAccessToken(appCtx)
            ?: return HomeUiState(
                loading = false,
                riskScore = 0.0,
                riskZone = RiskZone.NONE,
                riskPercent = 0,
                triggersAtRisk = emptyList(),
                aiRecommendation = "Sign in to see your risk score.",
                forecast = listOf(0, 0, 0, 0, 0, 0, 0),
                dayRisks = emptyList()
            )

        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
        val edge = EdgeFunctionsService()
        val userId = SessionStore.readUserId(appCtx)
        Log.d(TAG, "Logged in userId=$userId")

        // Try reading pre-computed score
        var live = db.getRiskScoreLive(accessToken)
        Log.d(TAG, "Live score read: ${if (live != null) "rowUserId=${live.userId} score=${live.score} zone=${live.zone}" else "NULL"}")

        // If no data or stale (>2 hours), trigger on-demand calculation
        if (live == null || isStale(live.updatedAt, hours = 2)) {
            Log.d(TAG, "Live score ${if (live == null) "missing" else "stale (updatedAt=${live.updatedAt})"}, triggering on-demand calculation")
            if (userId != null) {
                try {
                    edge.triggerRiskCalculation(appCtx, userId)
                    // Re-read after calculation
                    live = db.getRiskScoreLive(accessToken)
                    Log.d(TAG, "After on-demand: ${if (live != null) "score=${live.score}" else "still NULL"}")
                } catch (e: Exception) {
                    Log.w(TAG, "On-demand calc failed: ${e.message}")
                }
            }
        }

        if (live != null) {
            return mapLiveToUiState(live, edge, appCtx)
        }

        // No data at all — still show cards with zero values so the UI is never empty
        Log.w(TAG, "No live score available at all")
        return HomeUiState(
            loading = false,
            riskScore = 0.0,
            riskZone = RiskZone.NONE,
            riskPercent = 0,
            triggersAtRisk = emptyList(),
            aiRecommendation = "No risk data yet. Your score will appear once triggers are detected.",
            forecast = listOf(0, 0, 0, 0, 0, 0, 0),
            dayRisks = emptyList()
        )
    }

    private fun isStale(updatedAt: String?, hours: Int): Boolean {
        if (updatedAt == null) return true
        return try {
            // PostgREST may return various timestamptz formats
            val normalized = updatedAt
                .replace(" ", "T")           // "2026-02-15 14:10:21" → "2026-02-15T14:10:21"
                .let { if (it.endsWith("+00")) "${it}:00" else it } // "+00" → "+00:00"
            val updated = Instant.parse(normalized)
            val age = java.time.Duration.between(updated, Instant.now())
            age.toHours() >= hours
        } catch (_: Exception) {
            Log.w(TAG, "isStale: could not parse updatedAt='$updatedAt', treating as stale")
            true
        }
    }

    private suspend fun mapLiveToUiState(
        live: SupabaseDbService.RiskScoreLiveRow,
        edge: EdgeFunctionsService,
        appCtx: Context
    ): HomeUiState {
        val zone = when (live.zone.uppercase()) {
            "HIGH" -> RiskZone.HIGH; "MILD" -> RiskZone.MILD; "LOW" -> RiskZone.LOW
            else -> RiskZone.NONE
        }

        val topTriggers = parseTopTriggers(live.topTriggers)
        val forecast = parseForecast(live.forecast)
        val dayRisks = parseDayRisks(live.dayRisks)

        // Fetch gauge thresholds for gaugeMax display
        val thresholdRows = edge.getRiskGaugeThresholds(appCtx)
        val thresholdHigh = thresholdRows.find { it.zone.uppercase() == "HIGH" }?.minValue ?: 10.0
        val gaugeMax = thresholdHigh * 1.2

        val aiTip = when (zone) {
            RiskZone.HIGH ->
                "High risk: consider taking early abortive medication, reduce screen time, stay hydrated, and avoid known triggers today."
            RiskZone.MILD ->
                "Moderate risk: keep regular meals, take breaks every 45–60 min, and monitor for early symptoms."
            RiskZone.LOW ->
                "Low risk: maintain your routine. Stay hydrated and keep stress levels in check."
            RiskZone.NONE ->
                "Looking good! No significant active triggers. Keep up your healthy habits."
        }

        return HomeUiState(
            loading = false,
            riskScore = live.score,
            riskZone = zone,
            riskPercent = live.percent,
            triggersAtRisk = topTriggers,
            aiRecommendation = aiTip,
            gaugeMaxScore = gaugeMax,
            forecast = forecast,
            dayRisks = dayRisks,
        )
    }

    // ═════════════════════════════════════════════════════════════════
    // JSON Parsing helpers for risk_score_live columns
    // ═════════════════════════════════════════════════════════════════

    private fun parseTopTriggers(json: String?): List<TriggerScore> {
        if (json.isNullOrBlank() || json == "[]" || json == "null") return emptyList()
        return try {
            val arr = org.json.JSONArray(json)
            (0 until arr.length()).map { i ->
                val obj = arr.getJSONObject(i)
                TriggerScore(
                    name = obj.getString("name"),
                    score = obj.optInt("score", 0),
                    severity = obj.optString("severity", "LOW"),
                )
            }
        } catch (e: Exception) {
            Log.w(TAG, "parseTopTriggers error: ${e.message}")
            emptyList()
        }
    }

    private fun parseForecast(json: String?): List<Int> {
        if (json.isNullOrBlank() || json == "[]" || json == "null") return listOf(0, 0, 0, 0, 0, 0, 0)
        return try {
            val arr = org.json.JSONArray(json)
            (0 until arr.length()).map { arr.getInt(it) }
        } catch (e: Exception) {
            Log.w(TAG, "parseForecast error: ${e.message}")
            listOf(0, 0, 0, 0, 0, 0, 0)
        }
    }

    private fun parseDayRisks(json: String?): List<DayRisk> {
        if (json.isNullOrBlank() || json == "[]" || json == "null") return emptyList()
        return try {
            val arr = org.json.JSONArray(json)
            (0 until arr.length()).map { i ->
                val obj = arr.getJSONObject(i)
                val dateStr = obj.getString("date")
                val date = LocalDate.parse(dateStr.substring(0, 10))
                val zoneStr = obj.optString("zone", "NONE").uppercase()
                DayRisk(
                    date = date,
                    score = obj.getDouble("score"),
                    zone = when (zoneStr) {
                        "HIGH" -> RiskZone.HIGH; "MILD" -> RiskZone.MILD; "LOW" -> RiskZone.LOW
                        else -> RiskZone.NONE
                    },
                    percent = obj.optInt("percent", 0),
                    topTriggers = try {
                        val ta = obj.getJSONArray("top_triggers")
                        (0 until ta.length()).map { j ->
                            val to = ta.getJSONObject(j)
                            TriggerScore(to.getString("name"), to.optInt("score", 0), to.optString("severity", "LOW"))
                        }
                    } catch (_: Exception) { emptyList() }
                )
            }
        } catch (e: Exception) {
            Log.w(TAG, "parseDayRisks error: ${e.message}")
            emptyList()
        }
    }

    fun formatTime(instant: Instant): String {
        val dt = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
        return dt.format(timeFmt)
    }

    companion object {
        private const val TAG = "HomeViewModel"
    }
}

title: HubIcons.kt
text:
package com.migraineme

import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Fill
import androidx.compose.ui.graphics.drawscope.Stroke

/**
 * Shared custom hand-drawn icons used across MigraineHub, wizard screens, and quick-log screens.
 */
object HubIcons {

    fun DrawScope.drawMigraineStarburst(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.035f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        drawCircle(color.copy(alpha = 0.6f), radius = w * 0.08f, center = Offset(w * 0.5f, h * 0.5f), style = Fill)
        drawCircle(color, radius = w * 0.15f, center = Offset(w * 0.5f, h * 0.5f), style = Stroke(w * 0.03f, cap = StrokeCap.Round))
        drawLine(color, Offset(w * 0.50f, h * 0.30f), Offset(w * 0.50f, h * 0.08f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.50f, h * 0.70f), Offset(w * 0.50f, h * 0.92f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.30f, h * 0.50f), Offset(w * 0.08f, h * 0.50f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.70f, h * 0.50f), Offset(w * 0.92f, h * 0.50f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.36f, h * 0.36f), Offset(w * 0.20f, h * 0.20f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.64f, h * 0.36f), Offset(w * 0.80f, h * 0.20f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.36f, h * 0.64f), Offset(w * 0.20f, h * 0.80f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.64f, h * 0.64f), Offset(w * 0.80f, h * 0.80f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
        drawCircle(color, radius = w * 0.24f, center = Offset(w * 0.5f, h * 0.5f), style = stroke)
    }

    fun DrawScope.drawTriggerBolt(color: Color) {
        val w = size.width; val h = size.height
        val bolt = Path().apply {
            moveTo(w * 0.55f, h * 0.05f)
            lineTo(w * 0.30f, h * 0.45f)
            lineTo(w * 0.50f, h * 0.45f)
            lineTo(w * 0.28f, h * 0.95f)
            lineTo(w * 0.70f, h * 0.40f)
            lineTo(w * 0.50f, h * 0.40f)
            lineTo(w * 0.70f, h * 0.05f)
            close()
        }
        drawPath(bolt, color, style = Fill)
    }

    fun DrawScope.drawMedicinePill(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.07f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        val r = w * 0.18f
        drawRoundRect(color, topLeft = Offset(w * 0.18f, h * 0.15f),
            size = androidx.compose.ui.geometry.Size(w * 0.64f, h * 0.70f),
            cornerRadius = androidx.compose.ui.geometry.CornerRadius(r, r), style = stroke)
        drawLine(color, Offset(w * 0.18f, h * 0.50f), Offset(w * 0.82f, h * 0.50f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.50f, h * 0.25f), Offset(w * 0.50f, h * 0.40f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.42f, h * 0.325f), Offset(w * 0.58f, h * 0.325f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
    }

    fun DrawScope.drawReliefLeaf(color: Color) {
        val w = size.width; val h = size.height
        val leaf = Path().apply {
            moveTo(w * 0.50f, h * 0.08f)
            cubicTo(w * 0.85f, h * 0.15f, w * 0.90f, h * 0.55f, w * 0.50f, h * 0.75f)
            cubicTo(w * 0.10f, h * 0.55f, w * 0.15f, h * 0.15f, w * 0.50f, h * 0.08f)
            close()
        }
        drawPath(leaf, color, style = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round))
        drawLine(color, Offset(w * 0.50f, h * 0.18f), Offset(w * 0.50f, h * 0.68f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.50f, h * 0.35f), Offset(w * 0.34f, h * 0.26f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.50f, h * 0.35f), Offset(w * 0.66f, h * 0.26f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.50f, h * 0.50f), Offset(w * 0.30f, h * 0.42f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.50f, h * 0.50f), Offset(w * 0.70f, h * 0.42f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
        val drop = Path().apply {
            moveTo(w * 0.50f, h * 0.78f)
            cubicTo(w * 0.44f, h * 0.85f, w * 0.38f, h * 0.92f, w * 0.50f, h * 0.98f)
            cubicTo(w * 0.62f, h * 0.92f, w * 0.56f, h * 0.85f, w * 0.50f, h * 0.78f)
            close()
        }
        drawPath(drop, color, style = Fill)
    }

    fun DrawScope.drawProdromeEye(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        val top = Path().apply {
            moveTo(w * 0.05f, h * 0.50f)
            cubicTo(w * 0.25f, h * 0.15f, w * 0.75f, h * 0.15f, w * 0.95f, h * 0.50f)
        }
        val bottom = Path().apply {
            moveTo(w * 0.05f, h * 0.50f)
            cubicTo(w * 0.25f, h * 0.85f, w * 0.75f, h * 0.85f, w * 0.95f, h * 0.50f)
        }
        drawPath(top, color, style = stroke)
        drawPath(bottom, color, style = stroke)
        drawCircle(color, radius = w * 0.14f, center = Offset(w * 0.50f, h * 0.50f), style = stroke)
        drawCircle(color, radius = w * 0.06f, center = Offset(w * 0.50f, h * 0.50f), style = Fill)
        drawLine(color, Offset(w * 0.80f, h * 0.15f), Offset(w * 0.88f, h * 0.08f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.90f, h * 0.22f), Offset(w * 0.97f, h * 0.18f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.85f, h * 0.08f), Offset(w * 0.92f, h * 0.12f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
    }

    fun DrawScope.drawNotesIcon(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        // Notepad outline
        drawRoundRect(color, topLeft = Offset(w * 0.15f, h * 0.08f),
            size = androidx.compose.ui.geometry.Size(w * 0.70f, h * 0.84f),
            cornerRadius = androidx.compose.ui.geometry.CornerRadius(w * 0.08f, w * 0.08f), style = stroke)
        // Lines
        drawLine(color, Offset(w * 0.28f, h * 0.30f), Offset(w * 0.72f, h * 0.30f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.28f, h * 0.45f), Offset(w * 0.72f, h * 0.45f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.28f, h * 0.60f), Offset(w * 0.55f, h * 0.60f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
        // Pencil
        drawLine(color, Offset(w * 0.68f, h * 0.62f), Offset(w * 0.82f, h * 0.78f), strokeWidth = w * 0.05f, cap = StrokeCap.Round)
        drawLine(color, Offset(w * 0.82f, h * 0.78f), Offset(w * 0.78f, h * 0.85f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
    }

    fun DrawScope.drawReviewCheck(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        // Circle
        drawCircle(color, radius = w * 0.40f, center = Offset(w * 0.50f, h * 0.50f), style = stroke)
        // Checkmark
        val check = Path().apply {
            moveTo(w * 0.30f, h * 0.50f)
            lineTo(w * 0.45f, h * 0.65f)
            lineTo(w * 0.72f, h * 0.35f)
        }
        drawPath(check, color, style = Stroke(w * 0.07f, cap = StrokeCap.Round, join = StrokeJoin.Round))
    }

    /** Location pin icon – teardrop with inner circle */
    fun DrawScope.drawLocationPin(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        // Teardrop shape
        val pin = Path().apply {
            moveTo(w * 0.50f, h * 0.92f)
            cubicTo(w * 0.35f, h * 0.70f, w * 0.12f, h * 0.48f, w * 0.12f, h * 0.35f)
            cubicTo(w * 0.12f, h * 0.10f, w * 0.30f, h * 0.05f, w * 0.50f, h * 0.05f)
            cubicTo(w * 0.70f, h * 0.05f, w * 0.88f, h * 0.10f, w * 0.88f, h * 0.35f)
            cubicTo(w * 0.88f, h * 0.48f, w * 0.65f, h * 0.70f, w * 0.50f, h * 0.92f)
            close()
        }
        drawPath(pin, color, style = stroke)
        // Inner dot
        drawCircle(color, radius = w * 0.12f, center = Offset(w * 0.50f, h * 0.34f), style = Fill)
    }

    /** Activity pulse / heartbeat icon */
    fun DrawScope.drawActivityPulse(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        // Running figure simplified as a pulse line
        val pulse = Path().apply {
            moveTo(w * 0.04f, h * 0.55f)
            lineTo(w * 0.25f, h * 0.55f)
            lineTo(w * 0.32f, h * 0.30f)
            lineTo(w * 0.42f, h * 0.75f)
            lineTo(w * 0.52f, h * 0.15f)
            lineTo(w * 0.62f, h * 0.65f)
            lineTo(w * 0.70f, h * 0.45f)
            lineTo(w * 0.78f, h * 0.55f)
            lineTo(w * 0.96f, h * 0.55f)
        }
        drawPath(pulse, color, style = stroke)
        // Small circle at peak
        drawCircle(color, radius = w * 0.05f, center = Offset(w * 0.52f, h * 0.15f), style = Fill)
    }

    /** Missed activity icon – cancelled/crossed-out circle */
    fun DrawScope.drawMissedActivity(color: Color) {
        val w = size.width; val h = size.height
        val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
        // Circle
        drawCircle(color, radius = w * 0.38f, center = Offset(w * 0.50f, h * 0.50f), style = stroke)
        // Diagonal cross
        drawLine(color, Offset(w * 0.28f, h * 0.28f), Offset(w * 0.72f, h * 0.72f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
        // Small dash marks for "missed" feel
        drawLine(color, Offset(w * 0.38f, h * 0.50f), Offset(w * 0.62f, h * 0.50f), strokeWidth = w * 0.05f, cap = StrokeCap.Round)
    }
}

title: InsightsBreakdownScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController

/**
 * Drill-down screen: shows one SpiderData's categories,
 * each expanded into a subcategory spider chart.
 */
@Composable
fun InsightsBreakdownScreen(
    logType: String,
    navController: NavController,
    vm: InsightsViewModel = viewModel()
) {
    val spiderData = when (logType) {
        "Triggers" -> vm.triggerSpider.collectAsState().value
        "Prodromes" -> vm.prodromeSpider.collectAsState().value
        "Symptoms" -> vm.symptomSpider.collectAsState().value
        "Medicines" -> vm.medicineSpider.collectAsState().value
        "Reliefs" -> vm.reliefSpider.collectAsState().value
        "Activities" -> vm.activitySpider.collectAsState().value
        "Missed Activities" -> vm.missedActivitySpider.collectAsState().value
        "Locations" -> vm.locationSpider.collectAsState().value
        else -> null
    }

    val scrollState = rememberScrollState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Header
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.Outlined.ArrowBack, "Back", tint = AppTheme.BodyTextColor)
                }
                Spacer(Modifier.width(4.dp))
                Column {
                    Text(
                        logType,
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold)
                    )
                    if (spiderData != null) {
                        Text(
                            "${spiderData.totalLogged} logged across ${spiderData.breakdown.size} categories",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }

            Spacer(Modifier.height(8.dp))

            if (spiderData == null || spiderData.breakdown.isEmpty()) {
                BaseCard {
                    Text(
                        "No data yet — log items linked to a migraine to see breakdowns here.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
                return@ScrollableScreenContent
            }

            // Special layout for Symptoms
            if (logType == "Symptoms") {
                SymptomsBreakdownContent(vm = vm)
                return@ScrollableScreenContent
            }

            // Overall spider chart (categories)
            HeroCard {
                Text(
                    "Categories Overview",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(8.dp))

                if (spiderData.axes.size >= 3) {
                    Box(
                        modifier = Modifier.fillMaxWidth(),
                        contentAlignment = Alignment.Center
                    ) {
                        SpiderChart(
                            axes = spiderData.axes,
                            accentColor = colorForLogType(logType),
                            size = 260.dp
                        )
                    }
                } else {
                    // 1–2 categories — stacked proportional bar
                    StackedProportionalBar(
                        axes = spiderData.axes,
                        accentColor = colorForLogType(logType)
                    )
                }
            }

            // Effectiveness by category (Medicines & Reliefs only) — dual spider
            if (logType == "Medicines" || logType == "Reliefs") {
                val effectiveness = if (logType == "Medicines")
                    vm.medicineEffectiveness.collectAsState().value
                else
                    vm.reliefEffectiveness.collectAsState().value

                if (effectiveness.isNotEmpty() && effectiveness.size >= 3) {
                    val accentCol = colorForLogType(logType)
                    val reliefCol = accentCol.copy(alpha = 0.5f)
                    BaseCard {
                        Text(
                            "Usage vs Effectiveness",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                        )
                        Spacer(Modifier.height(4.dp))

                        // Legend
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Box(Modifier.size(10.dp).clip(RoundedCornerShape(2.dp)).background(accentCol))
                            Spacer(Modifier.width(6.dp))
                            Text("Count", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                            Spacer(Modifier.width(16.dp))
                            Box(Modifier.size(10.dp).clip(RoundedCornerShape(2.dp)).background(Color.White.copy(alpha = 0.6f)))
                            Spacer(Modifier.width(6.dp))
                            Text("Avg Relief", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        }

                        Spacer(Modifier.height(8.dp))

                        val countAxes = effectiveness.map {
                            SpiderAxis(label = it.category, value = it.count.toFloat())
                        }
                        val reliefAxes = effectiveness.map {
                            SpiderAxis(label = it.category, value = it.avgRelief, maxValue = 3f)
                        }

                        Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                            SpiderChart(
                                axes = countAxes,
                                accentColor = accentCol,
                                size = 260.dp,
                                fillAlpha = 0.15f,
                                secondAxes = reliefAxes,
                                secondColor = Color.White.copy(alpha = 0.6f)
                            )
                        }
                    }
                }
            }

            // Per-category subcategory spider charts
            for (cat in spiderData.breakdown) {
                BaseCard {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                cat.categoryName,
                                color = AppTheme.TitleColor,
                                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                            )
                            Text(
                                "${cat.totalCount} logged • ${cat.items.size} types",
                                color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.bodySmall
                            )
                        }

                        // Show category-level relief badge for meds/reliefs
                        if (logType == "Medicines" || logType == "Reliefs") {
                            val effectiveness = if (logType == "Medicines")
                                vm.medicineEffectiveness.collectAsState().value
                            else
                                vm.reliefEffectiveness.collectAsState().value
                            val catEff = effectiveness.find { it.category == cat.categoryName }
                            if (catEff != null) {
                                val reliefLabel = when {
                                    catEff.avgRelief >= 2.5f -> "High"
                                    catEff.avgRelief >= 1.5f -> "Mild"
                                    catEff.avgRelief >= 0.5f -> "Low"
                                    else -> "None"
                                }
                                val reliefColor = when {
                                    catEff.avgRelief >= 2.5f -> Color(0xFF81C784)
                                    catEff.avgRelief >= 1.5f -> Color(0xFFFFB74D)
                                    catEff.avgRelief >= 0.5f -> Color(0xFFE57373)
                                    else -> Color(0xFF666666)
                                }
                                Box(
                                    modifier = Modifier
                                        .clip(RoundedCornerShape(4.dp))
                                        .background(reliefColor.copy(alpha = 0.2f))
                                        .padding(horizontal = 6.dp, vertical = 2.dp)
                                ) {
                                    Text(reliefLabel, color = reliefColor,
                                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold))
                                }
                            }
                        }
                    }

                    Spacer(Modifier.height(8.dp))

                    // Build item-level relief axes for meds/reliefs
                    val itemEffMap = if (logType == "Medicines")
                        vm.medicineItemEffectiveness.collectAsState().value
                    else if (logType == "Reliefs")
                        vm.reliefItemEffectiveness.collectAsState().value
                    else emptyMap()

                    val subAxes = cat.items.map {
                        SpiderAxis(label = it.first, value = it.second.toFloat())
                    }
                    val subReliefAxes = if (itemEffMap.isNotEmpty() && (logType == "Medicines" || logType == "Reliefs")) {
                        cat.items.map {
                            SpiderAxis(label = it.first, value = itemEffMap[it.first.lowercase()] ?: 0f, maxValue = 3f)
                        }
                    } else null

                    if (cat.items.size >= 3) {
                        Box(
                            modifier = Modifier.fillMaxWidth(),
                            contentAlignment = Alignment.Center
                        ) {
                            SpiderChart(
                                axes = subAxes,
                                accentColor = colorForLogType(logType),
                                size = 240.dp,
                                fillAlpha = 0.2f,
                                secondAxes = subReliefAxes,
                                secondColor = Color.White.copy(alpha = 0.6f)
                            )
                        }
                    } else {
                        StackedProportionalBar(
                            axes = subAxes,
                            accentColor = colorForLogType(logType)
                        )
                        // Show relief per item for 1-2 items
                        if (subReliefAxes != null) {
                            Spacer(Modifier.height(8.dp))
                            for (i in cat.items.indices) {
                                val relief = itemEffMap[cat.items[i].first.lowercase()] ?: 0f
                                val rl = when {
                                    relief >= 2.5f -> "High"
                                    relief >= 1.5f -> "Mild"
                                    relief >= 0.5f -> "Low"
                                    else -> "None"
                                }
                                val rc = when {
                                    relief >= 2.5f -> Color(0xFF81C784)
                                    relief >= 1.5f -> Color(0xFFFFB74D)
                                    relief >= 0.5f -> Color(0xFFE57373)
                                    else -> Color(0xFF666666)
                                }
                                Row(
                                    modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
                                    horizontalArrangement = Arrangement.SpaceBetween,
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Text(cat.items[i].first, color = AppTheme.BodyTextColor,
                                        style = MaterialTheme.typography.bodySmall)
                                    Box(
                                        modifier = Modifier
                                            .clip(RoundedCornerShape(4.dp))
                                            .background(rc.copy(alpha = 0.2f))
                                            .padding(horizontal = 6.dp, vertical = 2.dp)
                                    ) {
                                        Text(rl, color = rc,
                                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun CategoryBarRow(label: String, count: Int, maxCount: Int, color: Color) {
    Column(modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp)) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                label,
                color = AppTheme.BodyTextColor,
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.weight(1f)
            )
            Text(
                "$count",
                color = color,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
            )
        }
        Spacer(Modifier.height(4.dp))
        LinearProgressIndicator(
            progress = { (count.toFloat() / maxCount.toFloat()).coerceIn(0f, 1f) },
            modifier = Modifier.fillMaxWidth().height(4.dp),
            color = color,
            trackColor = color.copy(alpha = 0.1f)
        )
    }
}

internal fun colorForLogType(logType: String): Color = when (logType) {
    "Triggers" -> Color(0xFFFF8A65)
    "Prodromes" -> Color(0xFFFFD54F)
    "Symptoms" -> Color(0xFFE57373)
    "Medicines" -> Color(0xFF4FC3F7)
    "Reliefs" -> Color(0xFF81C784)
    "Activities" -> Color(0xFFBA68C8)
    "Missed Activities" -> Color(0xFFFF7043)
    "Locations" -> Color(0xFF4DD0E1)
    else -> AppTheme.AccentPurple
}

@Composable
private fun SymptomsBreakdownContent(vm: InsightsViewModel) {
    val painCharSpider by vm.painCharSpider.collectAsState()
    val accompSpider by vm.accompSpider.collectAsState()
    val painLocSpider by vm.painLocationSpider.collectAsState()
    val severityCounts by vm.severityCounts.collectAsState()
    val durationStats by vm.durationStats.collectAsState()

    val painCharColor = Color(0xFFEF5350)
    val accompColor = Color(0xFFBA68C8)
    val painLocColor = Color(0xFFFF8A65)
    val severityColor = Color(0xFF4FC3F7)
    val durationColor = Color(0xFF81C784)

    // Pain Character
    if (painCharSpider != null && painCharSpider!!.axes.isNotEmpty()) {
        SpiderSection(title = "Pain Character", spider = painCharSpider!!, color = painCharColor)
    }

    // Accompanying Experience
    if (accompSpider != null && accompSpider!!.axes.isNotEmpty()) {
        SpiderSection(title = "Accompanying Experience", spider = accompSpider!!, color = accompColor)
    }

    // Pain Locations
    if (painLocSpider != null && painLocSpider!!.axes.isNotEmpty()) {
        SpiderSection(title = "Pain Locations", spider = painLocSpider!!, color = painLocColor)
    }

    // Severity Distribution
    if (severityCounts.isNotEmpty()) {
        val sevAxes = severityCounts.map { (sev, count) ->
            SpiderAxis(label = "Level $sev", value = count.toFloat())
        }
        val sevTotal = severityCounts.sumOf { it.second }
        val allSevValues = severityCounts.flatMap { (sev, count) -> List(count) { sev } }
        val sevMin = allSevValues.min()
        val sevMax = allSevValues.max()
        val sevAvg = allSevValues.average().toFloat()

        BaseCard {
            Text(
                "Severity Distribution",
                color = severityColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.height(4.dp))
            Text(
                "$sevTotal migraines rated",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
            Spacer(Modifier.height(12.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                SeverityStat(label = "Lowest", value = sevMin, color = Color(0xFF81C784))
                SeverityStat(label = "Average", value = sevAvg, color = severityColor)
                SeverityStat(label = "Highest", value = sevMax, color = Color(0xFFEF5350))
            }

            Spacer(Modifier.height(16.dp))

            if (sevAxes.size >= 3) {
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    SpiderChart(axes = sevAxes, accentColor = severityColor, size = 220.dp, fillAlpha = 0.2f)
                }
            } else {
                StackedProportionalBar(axes = sevAxes, accentColor = severityColor)
            }
        }
    }

    // Duration Stats
    if (durationStats != null) {
        val stats = durationStats!!
        BaseCard {
            Text(
                "Duration",
                color = durationColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.height(4.dp))
            Text(
                "${stats.durations.size} migraines with end time",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
            Spacer(Modifier.height(12.dp))

            // Stat cards row
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                DurationStat(label = "Shortest", hours = stats.minHours, color = Color(0xFF81C784))
                DurationStat(label = "Average", hours = stats.avgHours, color = durationColor)
                DurationStat(label = "Longest", hours = stats.maxHours, color = Color(0xFFEF5350))
            }

            // Bucket distribution as spider/bar/card
            if (stats.durations.size > 1) {
                Spacer(Modifier.height(16.dp))

                val buckets = mutableMapOf<String, Int>()
                for (h in stats.durations) {
                    val bucket = when {
                        h < 1f -> "< 1h"
                        h < 4f -> "1-4h"
                        h < 12f -> "4-12h"
                        h < 24f -> "12-24h"
                        h < 48f -> "1 day"
                        h < 72f -> "2 days"
                        h < 96f -> "3 days"
                        h < 120f -> "4 days"
                        h < 144f -> "5 days"
                        h < 168f -> "6 days"
                        else -> "7+ days"
                    }
                    buckets[bucket] = (buckets[bucket] ?: 0) + 1
                }
                val orderedBuckets = listOf("< 1h", "1-4h", "4-12h", "12-24h", "1 day", "2 days", "3 days", "4 days", "5 days", "6 days", "7+ days")
                val durationAxes = orderedBuckets
                    .filter { (buckets[it] ?: 0) > 0 }
                    .map { SpiderAxis(label = it, value = (buckets[it] ?: 0).toFloat()) }

                if (durationAxes.size >= 3) {
                    Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                        SpiderChart(axes = durationAxes, accentColor = durationColor, size = 220.dp, fillAlpha = 0.2f)
                    }
                } else {
                    StackedProportionalBar(axes = durationAxes, accentColor = durationColor)
                }
            }
        }
    }
}

@Composable
private fun SpiderSection(title: String, spider: SpiderData, color: Color) {
    BaseCard {
        Text(
            title,
            color = color,
            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
        )
        Spacer(Modifier.height(4.dp))
        Text(
            "${spider.totalLogged} logged • ${spider.axes.size} types",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.bodySmall
        )
        Spacer(Modifier.height(8.dp))

        if (spider.axes.size >= 3) {
            Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                SpiderChart(axes = spider.axes, accentColor = color, size = 240.dp, fillAlpha = 0.2f)
            }
        } else if (spider.axes.size == 1) {
            StackedProportionalBar(axes = spider.axes, accentColor = color)
        } else {
            StackedProportionalBar(axes = spider.axes, accentColor = color)
        }
    }
}

@Composable
private fun DurationStat(label: String, hours: Float, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            formatDuration(hours),
            color = color,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold)
        )
        Text(
            label,
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelSmall
        )
    }
}

private fun formatDuration(hours: Float): String = when {
    hours < 1f -> "${(hours * 60).toInt()}m"
    hours < 24f -> "%.1fh".format(hours)
    else -> "%.1fd".format(hours / 24f)
}

@Composable
private fun SeverityStat(label: String, value: Number, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            if (value is Float) "%.1f".format(value) else "${value}",
            color = color,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold)
        )
        Text(
            label,
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelSmall
        )
    }
}

title: InsightsDetailScreen.kt
text:
// FILE: InsightsDetailScreen.kt
package com.migraineme

import android.content.Context
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModelStoreOwner
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import java.time.Duration
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter

// ═══════ Filter category colors (matching the card / spider colors) ═══════

private val FilterCatColors = mapOf(
    "Severity" to Color(0xFFFF7043),
    "Symptom" to Color(0xFFCE93D8),
    "Pain Location" to Color(0xFFFF8A80),
    "Trigger" to Color(0xFFFF8A65),
    "Prodrome" to Color(0xFFFFD54F),
    "Medicine" to Color(0xFF4FC3F7),
    "Relief" to Color(0xFF81C784),
    "Activity" to Color(0xFFBA68C8),
    "Location" to Color(0xFF4DD0E1),
    "Missed Activity" to Color(0xFFEF9A9A)
)

// ═══════ Ordered categories to match the migraine log flow ═══════

private val FilterCatOrder = listOf(
    "Severity", "Symptom", "Pain Location", "Trigger", "Prodrome",
    "Medicine", "Relief", "Activity", "Location", "Missed Activity"
)

@Composable
fun InsightsDetailScreen(
    navController: NavController,
    vm: InsightsViewModel = viewModel()
) {
    val owner = LocalContext.current as ViewModelStoreOwner
    val ctx: Context = LocalContext.current.applicationContext
    val authVm: AuthViewModel = viewModel(owner)
    val auth by authVm.state.collectAsState()
    LaunchedEffect(auth.accessToken) {
        auth.accessToken?.takeIf { it.isNotBlank() }?.let { vm.load(ctx, it) }
    }

    val migraines by vm.migraines.collectAsState()
    val allDailyMetrics by vm.allDailyMetrics.collectAsState()
    val linkedItems by vm.selectedLinkedItems.collectAsState()
    val linkedLoading by vm.linkedItemsLoading.collectAsState()
    val scrollState = rememberScrollState()
    val zone = ZoneId.systemDefault()

    // ── Filter state ──
    val tagIndex by vm.migraineTagIndex.collectAsState()
    val availableTags by vm.availableFilterTags.collectAsState()
    val activeFilters by vm.activeFilters.collectAsState()
    val timeFrame by vm.timeFrame.collectAsState()
    val customRange by vm.customRange.collectAsState()

    // ── Filtered migraines ──
    val sorted = remember(migraines) { migraines.sortedByDescending { it.start } }
    val filteredSorted = remember(sorted, activeFilters, tagIndex, timeFrame, customRange) {
        val cutoff = when {
            timeFrame == InsightsViewModel.TimeFrame.CUSTOM && customRange != null -> {
                customRange!!.from.atStartOfDay(zone).toInstant()
            }
            timeFrame.days != null -> Instant.now().minus(Duration.ofDays(timeFrame.days!!.toLong()))
            else -> null
        }
        val upperBound = if (timeFrame == InsightsViewModel.TimeFrame.CUSTOM && customRange != null) {
            customRange!!.to.plusDays(1).atStartOfDay(zone).toInstant()
        } else null

        sorted.filter { m ->
            if (cutoff != null && m.start.isBefore(cutoff)) return@filter false
            if (upperBound != null && m.start.isAfter(upperBound)) return@filter false
            if (activeFilters.isEmpty()) true
            else {
                val tags = tagIndex[m.id] ?: emptySet()
                activeFilters.all { it in tags }
            }
        }
    }

    val selIdx by vm.selectedMigraineIndex.collectAsState()
    // Clamp to filtered list
    val clampedIdx = selIdx.coerceIn(0, (filteredSorted.size - 1).coerceAtLeast(0))
    LaunchedEffect(filteredSorted.size, selIdx) {
        if (filteredSorted.isNotEmpty() && selIdx >= filteredSorted.size) vm.selectMigraine(0)
    }
    val sel = filteredSorted.getOrNull(clampedIdx)
    LaunchedEffect(sel?.id) { sel?.id?.let { vm.loadLinkedItems(it) } }

    // ±7 day window
    // Window days (shared with report screen)
    val wBefore by vm.windowDaysBefore.collectAsState()
    val wAfter by vm.windowDaysAfter.collectAsState()
    val wStart = sel?.start?.minus(Duration.ofDays(wBefore))
    val wEnd = (sel?.end ?: sel?.start)?.plus(Duration.ofDays(wAfter))
    val windowDates = remember(wStart, wEnd) {
        if (wStart == null || wEnd == null) emptySet()
        else {
            val f = LocalDate.ofInstant(wStart, zone)
            val t = LocalDate.ofInstant(wEnd, zone)
            generateSequence(f) { it.plusDays(1) }
                .takeWhile { !it.isAfter(t) }
                .map { it.toString() }.toSet()
        }
    }

    val allMissed by vm.allMissedActivities.collectAsState()
    val allActs by vm.allActivities.collectAsState()

    val windowEvents = remember(linkedItems, allMissed, allActs, sel?.id) {
        val actsForMigraine = allActs.filter { it.migraineId == sel?.id }
        val missedForMigraine = allMissed.filter { it.migraineId == sel?.id }
        buildEventMarkers(linkedItems, actsForMigraine, missedForMigraine)
    }

    val templateMap by vm.labelToMetricMap.collectAsState()
    val autoSelectedKeys = remember(windowEvents, templateMap) {
        windowEvents.filter { it.isAutomated }
            .mapNotNull { ev: EventMarker -> vm.labelToMetricKey(ev.name) }
            .toSet()
    }

    val available = remember(allDailyMetrics, windowDates) {
        AllMetricDefs.filter { d ->
            allDailyMetrics[d.key]?.any { it.date in windowDates } == true
        }
    }

    val userToggledKeys by vm.userToggledMetrics.collectAsState()
    val enabledKeys = autoSelectedKeys + userToggledKeys

    val enabledSeries = remember(available, enabledKeys, allDailyMetrics, windowDates) {
        available.filter { it.key in enabledKeys }.map { d ->
            MetricSeries(d.key, d.label, d.unit, d.color,
                allDailyMetrics[d.key]!!
                    .filter { it.date in windowDates }
                    .map { DailyMetricPoint(it.date, it.value) })
        }
    }

    val windowMigs = remember(migraines, wStart, wEnd) {
        if (wStart == null || wEnd == null) listOfNotNull(sel)
        else migraines.filter { m ->
            val e = m.end ?: m.start
            !m.start.isAfter(wEnd) && !e.isBefore(wStart)
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {

            // ── Back arrow ──
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back", tint = Color.White)
                }
            }

            // ══════════ 1. FILTER CARD (collapsible) ══════════
            FilterCard(
                availableTags = availableTags,
                activeFilters = activeFilters,
                timeFrame = timeFrame,
                customRange = customRange,
                totalCount = sorted.size,
                filteredCount = filteredSorted.size,
                onToggle = { vm.toggleFilter(it) },
                onTimeFrame = { vm.setTimeFrame(it) },
                onCustomRange = { from, to -> vm.setCustomRange(from, to) },
                onClear = { vm.clearFilters() }
            )

            // ══════════ 2. GRAPH CARD ══════════
            HeroCard {
                Text("Migraine Timeline", color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))

                if (filteredSorted.isEmpty()) {
                    Text(
                        if (sorted.isEmpty()) "No migraines logged yet"
                        else "No migraines match filters",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
                    return@HeroCard
                }

                // Migraine selector (navigates filtered list)
                DetailMigraineSelector(filteredSorted, clampedIdx, sel,
                    onPrev = { if (clampedIdx < filteredSorted.size - 1) vm.selectMigraine(clampedIdx + 1) },
                    onNext = { if (clampedIdx > 0) vm.selectMigraine(clampedIdx - 1) })

                if (linkedLoading) {
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(Modifier.size(16.dp),
                            strokeWidth = 2.dp, color = AppTheme.AccentPurple)
                    }
                } else {
                    val catCounts = remember(windowEvents) {
                        windowEvents.groupBy { it.category }.mapValues { it.value.size }
                    }
                    if (catCounts.isNotEmpty()) {
                        Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                            horizontalArrangement = Arrangement.spacedBy(10.dp),
                            verticalAlignment = Alignment.CenterVertically) {
                            catCounts.forEach { (c, n) ->
                                DetailChip(n, c, EventCategoryColors[c] ?: AppTheme.AccentPurple)
                            }
                        }
                    }
                }

                // Graph
                InsightsTimelineGraph(
                    windowMigs, windowEvents, enabledSeries,
                    wStart, wEnd, sel?.start,
                    Modifier.fillMaxWidth().height(360.dp))

                Text("Window around migraine", color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall,
                    textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())

                // Window adjustment
                WindowDaysControl(wBefore, wAfter, onChanged = { b, a -> vm.setWindowDays(b, a) })
            }

            // ══════════ 3. METRIC PICKER (below graph) ══════════
            if (available.isNotEmpty()) {
                BaseCard {
                    Text("Overlay Metrics", color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(2.dp))
                    Text("Tap to toggle metric lines on the graph. ⚡ = auto-detected from triggers.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall)
                    Spacer(Modifier.height(8.dp))

                    val groups = available.groupBy { it.group }
                    groups.forEach { (group, defs) ->
                        Text(group, color = AppTheme.SubtleTextColor.copy(alpha = 0.6f),
                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold),
                            modifier = Modifier.padding(top = 4.dp, bottom = 2.dp))
                        Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                            horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                            defs.forEach { d ->
                                val isAuto = d.key in autoSelectedKeys
                                val isEnabled = d.key in enabledKeys
                                DetailToggle(
                                    label = d.label,
                                    color = d.color,
                                    active = isEnabled,
                                    isAutoSelected = isAuto,
                                    onClick = { vm.toggleMetric(d.key) }
                                )
                            }
                        }
                    }
                }
            }

        }
    }
}

// ═══════ Filter card ═══════

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun FilterCard(
    availableTags: Map<String, List<String>>,
    activeFilters: Set<InsightsViewModel.FilterTag>,
    timeFrame: InsightsViewModel.TimeFrame,
    customRange: InsightsViewModel.CustomRange?,
    totalCount: Int,
    filteredCount: Int,
    onToggle: (InsightsViewModel.FilterTag) -> Unit,
    onTimeFrame: (InsightsViewModel.TimeFrame) -> Unit,
    onCustomRange: (java.time.LocalDate, java.time.LocalDate) -> Unit,
    onClear: () -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val hasFilters = activeFilters.isNotEmpty() || timeFrame != InsightsViewModel.TimeFrame.ALL
    val activeCount = activeFilters.size + if (timeFrame != InsightsViewModel.TimeFrame.ALL) 1 else 0

    // Custom date picker state
    var showFromPicker by remember { mutableStateOf(false) }
    var showToPicker by remember { mutableStateOf(false) }
    var customFrom by remember(customRange) {
        mutableStateOf(customRange?.from ?: java.time.LocalDate.now().minusDays(30))
    }
    var customTo by remember(customRange) {
        mutableStateOf(customRange?.to ?: java.time.LocalDate.now())
    }

    BaseCard {
        // Header row — always visible, tappable
        Row(
            Modifier
                .fillMaxWidth()
                .clickable { expanded = !expanded },
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(Icons.Filled.FilterList,
                contentDescription = "Filter",
                tint = if (hasFilters) AppTheme.AccentPurple else AppTheme.SubtleTextColor,
                modifier = Modifier.size(20.dp))
            Spacer(Modifier.width(8.dp))
            Column(Modifier.weight(1f)) {
                Text(
                    if (hasFilters) "Filters ($activeCount)"
                    else "Filter Migraines",
                    color = if (hasFilters) Color.White else AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                if (hasFilters) {
                    Text("$filteredCount of $totalCount migraines",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.labelSmall)
                }
            }
            if (hasFilters) {
                Text("Clear",
                    color = AppTheme.AccentPurple.copy(alpha = 0.7f),
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold),
                    modifier = Modifier
                        .clip(RoundedCornerShape(8.dp))
                        .clickable { onClear() }
                        .padding(horizontal = 8.dp, vertical = 4.dp))
                Spacer(Modifier.width(4.dp))
            }
            Icon(
                if (expanded) Icons.Filled.KeyboardArrowUp
                else Icons.Filled.KeyboardArrowDown,
                contentDescription = "Expand",
                tint = AppTheme.SubtleTextColor,
                modifier = Modifier.size(20.dp))
        }

        // Active filter chips (shown when collapsed + has filters)
        if (!expanded && hasFilters) {
            Spacer(Modifier.height(6.dp))
            Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                if (timeFrame != InsightsViewModel.TimeFrame.ALL) {
                    val timeLabel = if (timeFrame == InsightsViewModel.TimeFrame.CUSTOM && customRange != null) {
                        val df = java.time.format.DateTimeFormatter.ofPattern("MMM d")
                        "${df.format(customRange.from)} – ${df.format(customRange.to)}"
                    } else timeFrame.label
                    Row(
                        Modifier
                            .clip(RoundedCornerShape(16.dp))
                            .background(AppTheme.AccentPurple.copy(alpha = 0.2f))
                            .clickable { onTimeFrame(InsightsViewModel.TimeFrame.ALL) }
                            .padding(horizontal = 10.dp, vertical = 4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(timeLabel, color = AppTheme.AccentPurple,
                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium))
                        Spacer(Modifier.width(4.dp))
                        Text("✕", color = AppTheme.AccentPurple.copy(alpha = 0.6f),
                            style = MaterialTheme.typography.labelSmall)
                    }
                }
                activeFilters.sortedBy { it.key }.forEach { tag ->
                    val color = FilterCatColors[tag.category] ?: AppTheme.AccentPurple
                    ActiveFilterChip(tag, color, onToggle)
                }
            }
        }

        // Expanded: timeframe + all categories
        AnimatedVisibility(
            visible = expanded,
            enter = expandVertically(),
            exit = shrinkVertically()
        ) {
            Column(Modifier.padding(top = 8.dp)) {
                // Timeframe selector
                Text("Time Range", color = AppTheme.AccentPurple.copy(alpha = 0.8f),
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                    modifier = Modifier.padding(bottom = 2.dp))
                Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                    horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                    InsightsViewModel.TimeFrame.entries.forEach { tf ->
                        val isActive = tf == timeFrame
                        FilterOptionChip(
                            label = tf.label,
                            color = AppTheme.AccentPurple,
                            active = isActive,
                            onClick = {
                                if (tf == InsightsViewModel.TimeFrame.CUSTOM) {
                                    showFromPicker = true
                                } else {
                                    onTimeFrame(tf)
                                }
                            }
                        )
                    }
                }

                // Custom date range row (shown when custom is active or being set)
                AnimatedVisibility(visible = timeFrame == InsightsViewModel.TimeFrame.CUSTOM) {
                    val df = java.time.format.DateTimeFormatter.ofPattern("MMM d, yyyy")
                    Row(
                        Modifier.fillMaxWidth().padding(top = 4.dp),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // From button
                        Column(Modifier.weight(1f)) {
                            Text("From", color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.labelSmall)
                            Row(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(10.dp))
                                    .background(Color.White.copy(alpha = 0.06f))
                                    .clickable { showFromPicker = true }
                                    .padding(horizontal = 12.dp, vertical = 8.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(df.format(customFrom), color = Color.White,
                                    style = MaterialTheme.typography.bodySmall)
                            }
                        }
                        Text("–", color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(top = 12.dp))
                        // To button
                        Column(Modifier.weight(1f)) {
                            Text("To", color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.labelSmall)
                            Row(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(10.dp))
                                    .background(Color.White.copy(alpha = 0.06f))
                                    .clickable { showToPicker = true }
                                    .padding(horizontal = 12.dp, vertical = 8.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(df.format(customTo), color = Color.White,
                                    style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    }
                }

                // Tag categories
                val orderedCats = FilterCatOrder.filter { it in availableTags }
                orderedCats.forEach { cat ->
                    val labels = availableTags[cat] ?: return@forEach
                    val color = FilterCatColors[cat] ?: AppTheme.AccentPurple
                    Text(cat, color = color.copy(alpha = 0.8f),
                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                        modifier = Modifier.padding(top = 6.dp, bottom = 2.dp))
                    Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                        horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                        labels.forEach { label ->
                            val tag = InsightsViewModel.FilterTag(cat, label)
                            val isActive = tag in activeFilters
                            FilterOptionChip(label, color, isActive) { onToggle(tag) }
                        }
                    }
                }
            }
        }
    }

    // ── Date picker dialogs ──
    if (showFromPicker) {
        val state = rememberDatePickerState(
            initialSelectedDateMillis = customFrom.atStartOfDay(java.time.ZoneOffset.UTC)
                .toInstant().toEpochMilli()
        )
        DatePickerDialog(
            onDismissRequest = { showFromPicker = false },
            confirmButton = {
                TextButton(onClick = {
                    state.selectedDateMillis?.let { ms ->
                        customFrom = java.time.Instant.ofEpochMilli(ms)
                            .atZone(java.time.ZoneOffset.UTC).toLocalDate()
                        if (customFrom.isAfter(customTo)) customTo = customFrom
                        onCustomRange(customFrom, customTo)
                    }
                    showFromPicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showFromPicker = false }) { Text("Cancel") }
            }
        ) {
            DatePicker(state = state)
        }
    }

    if (showToPicker) {
        val state = rememberDatePickerState(
            initialSelectedDateMillis = customTo.atStartOfDay(java.time.ZoneOffset.UTC)
                .toInstant().toEpochMilli()
        )
        DatePickerDialog(
            onDismissRequest = { showToPicker = false },
            confirmButton = {
                TextButton(onClick = {
                    state.selectedDateMillis?.let { ms ->
                        customTo = java.time.Instant.ofEpochMilli(ms)
                            .atZone(java.time.ZoneOffset.UTC).toLocalDate()
                        if (customTo.isBefore(customFrom)) customFrom = customTo
                        onCustomRange(customFrom, customTo)
                    }
                    showToPicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showToPicker = false }) { Text("Cancel") }
            }
        ) {
            DatePicker(state = state)
        }
    }
}

@Composable
private fun ActiveFilterChip(
    tag: InsightsViewModel.FilterTag, color: Color,
    onRemove: (InsightsViewModel.FilterTag) -> Unit
) {
    Row(
        Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(color.copy(alpha = 0.2f))
            .clickable { onRemove(tag) }
            .padding(horizontal = 10.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(Modifier.size(6.dp).clip(CircleShape).background(color))
        Spacer(Modifier.width(4.dp))
        Text(tag.label, color = color,
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium),
            maxLines = 1, overflow = TextOverflow.Ellipsis)
        Spacer(Modifier.width(4.dp))
        Text("✕", color = color.copy(alpha = 0.6f),
            style = MaterialTheme.typography.labelSmall)
    }
}

@Composable
private fun FilterOptionChip(
    label: String, color: Color, active: Boolean, onClick: () -> Unit
) {
    val bg = if (active) color.copy(alpha = 0.2f) else Color.White.copy(alpha = 0.04f)
    val tc = if (active) color else AppTheme.SubtleTextColor.copy(alpha = 0.5f)
    Row(
        Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(bg)
            .clickable(onClick = onClick)
            .padding(horizontal = 10.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(Modifier.size(6.dp).clip(CircleShape)
            .background(if (active) color else color.copy(alpha = 0.3f)))
        Spacer(Modifier.width(4.dp))
        Text(label, color = tc,
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium),
            maxLines = 1, overflow = TextOverflow.Ellipsis)
    }
}

// ═══════ Shared helper to build event markers from linked items ═══════

internal fun buildEventMarkers(
    linkedItems: SupabaseDbService.MigraineLinkedItems,
    extraActivities: List<SupabaseDbService.ActivityLogRow> = emptyList(),
    missedActivities: List<SupabaseDbService.MissedActivityLogRow> = emptyList()
): List<EventMarker> {
    val ev = mutableListOf<EventMarker>()
    linkedItems.triggers.forEach { row ->
        parseInstant(row.startAt)?.let { t ->
            ev += EventMarker(t, null, row.type ?: "Trigger", "Trigger", row.notes,
                EventCategoryColors["Trigger"]!!, row.source == "system")
        }
    }
    linkedItems.prodromes.forEach { row ->
        parseInstant(row.startAt)?.let { t ->
            ev += EventMarker(t, null, row.type ?: "Prodrome", "Prodrome", row.notes,
                EventCategoryColors["Prodrome"]!!, row.source == "system")
        }
    }
    linkedItems.medicines.forEach { row ->
        parseInstant(row.startAt)?.let { t ->
            val d = listOfNotNull(
                row.amount,
                row.reliefScale?.takeIf { it != "NONE" }?.let { "Relief: $it" }
            ).joinToString(" • ")
            ev += EventMarker(t, null, row.name ?: "Medicine", "Medicine",
                d.ifEmpty { null }, EventCategoryColors["Medicine"]!!, row.source == "system")
        }
    }
    linkedItems.reliefs.forEach { row ->
        parseInstant(row.startAt)?.let { s ->
            val e = row.endAt?.let { parseInstant(it) }
                ?: row.durationMinutes?.let { s.plusSeconds(it.toLong() * 60) }
            val d = row.reliefScale?.takeIf { it != "NONE" }?.let { "Relief: $it" }
            ev += EventMarker(s, e, row.type ?: "Relief", "Relief", d,
                EventCategoryColors["Relief"]!!, row.source == "system")
        }
    }
    // Merge linked activities + extra activities (from allActivities), deduplicate by ID
    val linkedIds = linkedItems.activities.map { it.id }.toSet()
    val allActs = linkedItems.activities + extraActivities.filter { it.id !in linkedIds }
    allActs.forEach { row ->
        parseInstant(row.startAt)?.let { t ->
            ev += EventMarker(t, null, row.type ?: "Activity", "Activity", null,
                EventCategoryColors["Activity"]!!, row.source == "system")
        }
    }
    linkedItems.locations.forEach { row ->
        parseInstant(row.startAt)?.let { t ->
            ev += EventMarker(t, null, row.type ?: "Location", "Location", null,
                EventCategoryColors["Location"]!!, row.source == "system")
        }
    }
    missedActivities.forEach { row ->
        parseInstant(row.startAt)?.let { t ->
            ev += EventMarker(t, null, row.type ?: "Missed Activity", "Missed Activity", null,
                EventCategoryColors["Missed Activity"]!!, row.source == "system")
        }
    }
    return ev.sortedBy { it.at }
}

internal fun parseInstant(iso: String?): Instant? =
    iso?.let { runCatching { Instant.parse(it) }.getOrNull() }

// ═══════ Private composables ═══════

@Composable
private fun DetailMigraineSelector(
    sorted: List<MigraineSpan>, idx: Int, sel: MigraineSpan?,
    onPrev: () -> Unit, onNext: () -> Unit
) {
    val z = ZoneId.systemDefault()
    val df = DateTimeFormatter.ofPattern("MMM d, yyyy").withZone(z)
    val tf = DateTimeFormatter.ofPattern("h:mm a").withZone(z)
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically) {
        IconButton(onClick = onPrev, enabled = idx < sorted.size - 1) {
            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Older",
                tint = if (idx < sorted.size - 1) AppTheme.AccentPurple
                else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                modifier = Modifier.size(22.dp))
        }
        Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.weight(1f)) {
            Text(sel?.label ?: "Migraine", color = Color.White,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold),
                maxLines = 1, overflow = TextOverflow.Ellipsis)
            if (sel != null) {
                Text(df.format(sel.start) + " • " + tf.format(sel.start),
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                val e = sel.end
                if (e != null) {
                    val d = Duration.between(sel.start, e)
                    val hStr = if (d.toHours() > 0) "${d.toHours()}h " else ""
                    Text("$hStr${d.minusHours(d.toHours()).toMinutes()}m • Severity: ${sel.severity ?: "–"}/10",
                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                } else {
                    Text("Severity: ${sel.severity ?: "–"}/10",
                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
            Text("${idx + 1} of ${sorted.size}", color = AppTheme.AccentPurple,
                style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
        }
        IconButton(onClick = onNext, enabled = idx > 0) {
            Icon(Icons.AutoMirrored.Filled.ArrowForward, "Newer",
                tint = if (idx > 0) AppTheme.AccentPurple
                else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                modifier = Modifier.size(22.dp))
        }
    }
}

@Composable
private fun DetailChip(n: Int, label: String, color: Color) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Box(Modifier.size(8.dp).clip(CircleShape).background(color))
        Spacer(Modifier.width(4.dp))
        Text("$n", color = Color.White,
            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold))
        Spacer(Modifier.width(2.dp))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
    }
}

@Composable
private fun DetailToggle(
    label: String, color: Color, active: Boolean,
    isAutoSelected: Boolean, onClick: () -> Unit
) {
    val bg = if (active) color.copy(alpha = 0.2f) else Color.White.copy(alpha = 0.04f)
    val tc = if (active) color else AppTheme.SubtleTextColor.copy(alpha = 0.5f)
    Row(
        Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(bg)
            .clickable(onClick = onClick)
            .padding(horizontal = 10.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (isAutoSelected) {
            Box(Modifier.size(6.dp).clip(CircleShape).background(Color(0xFFFFD54F)))
        } else {
            Box(Modifier.size(6.dp).clip(CircleShape)
                .background(if (active) color else color.copy(alpha = 0.3f)))
        }
        Spacer(Modifier.width(4.dp))
        Text(label, color = tc,
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium))
    }
}


title: InsightsReportScreen.kt
text:
// FILE: InsightsReportScreen.kt
package com.migraineme

import android.content.Context
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.ui.geometry.CornerRadius
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.PathEffect
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import kotlinx.coroutines.launch
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModelStoreOwner
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import java.time.Duration
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter

// ═══════ Filter category colors (matching the card / spider colors) ═══════

private val FilterCatColors = mapOf(
    "Severity" to Color(0xFFFF7043),
    "Symptom" to Color(0xFFCE93D8),
    "Pain Location" to Color(0xFFFF8A80),
    "Trigger" to Color(0xFFFF8A65),
    "Prodrome" to Color(0xFFFFD54F),
    "Medicine" to Color(0xFF4FC3F7),
    "Relief" to Color(0xFF81C784),
    "Activity" to Color(0xFFBA68C8),
    "Location" to Color(0xFF4DD0E1),
    "Missed Activity" to Color(0xFFEF9A9A)
)

// ═══════ Ordered categories to match the migraine log flow ═══════

private val FilterCatOrder = listOf(
    "Severity", "Symptom", "Pain Location", "Trigger", "Prodrome",
    "Medicine", "Relief", "Activity", "Location", "Missed Activity"
)

@Composable
fun InsightsReportScreen(
    navController: NavController,
    vm: InsightsViewModel = viewModel()
) {
    val owner = LocalContext.current as ViewModelStoreOwner
    val ctx: Context = LocalContext.current.applicationContext
    val activityCtx = LocalContext.current as? android.app.Activity
    val authVm: AuthViewModel = viewModel(owner)
    val auth by authVm.state.collectAsState()
    LaunchedEffect(auth.accessToken) {
        auth.accessToken?.takeIf { it.isNotBlank() }?.let { vm.load(ctx, it) }
    }

    val migraines by vm.migraines.collectAsState()
    val allDailyMetrics by vm.allDailyMetrics.collectAsState()
    val linkedItems by vm.selectedLinkedItems.collectAsState()
    val linkedLoading by vm.linkedItemsLoading.collectAsState()
    val scrollState = rememberScrollState()
    val zone = ZoneId.systemDefault()

    // ── Filter state ──
    // Reset to NONE on first open so no metrics are pre-selected
    LaunchedEffect(Unit) { vm.setTimeFrame(InsightsViewModel.TimeFrame.NONE) }
    val tagIndex by vm.migraineTagIndex.collectAsState()
    val activeFilters by vm.activeFilters.collectAsState()
    val timeFrame by vm.timeFrame.collectAsState()
    val customRange by vm.customRange.collectAsState()

    // ── Filtered migraines ──
    val sorted = remember(migraines) { migraines.sortedByDescending { it.start } }
    val filteredSorted = remember(sorted, activeFilters, tagIndex, timeFrame, customRange) {
        if (timeFrame == InsightsViewModel.TimeFrame.NONE) return@remember emptyList()
        val cutoff = when {
            timeFrame == InsightsViewModel.TimeFrame.CUSTOM && customRange != null -> {
                customRange!!.from.atStartOfDay(zone).toInstant()
            }
            timeFrame.days != null -> Instant.now().minus(Duration.ofDays(timeFrame.days!!.toLong()))
            else -> null
        }
        val upperBound = if (timeFrame == InsightsViewModel.TimeFrame.CUSTOM && customRange != null) {
            customRange!!.to.plusDays(1).atStartOfDay(zone).toInstant()
        } else null

        sorted.filter { m ->
            if (cutoff != null && m.start.isBefore(cutoff)) return@filter false
            if (upperBound != null && m.start.isAfter(upperBound)) return@filter false
            if (activeFilters.isEmpty()) true
            else {
                val tags = tagIndex[m.id] ?: emptySet()
                activeFilters.all { it in tags }
            }
        }
    }

    val selIdx by vm.selectedMigraineIndex.collectAsState()
    // Clamp to filtered list
    val clampedIdx = selIdx.coerceIn(0, (filteredSorted.size - 1).coerceAtLeast(0))
    LaunchedEffect(filteredSorted.size, selIdx) {
        if (filteredSorted.isNotEmpty() && selIdx >= filteredSorted.size) vm.selectMigraine(0)
    }
    val sel = filteredSorted.getOrNull(clampedIdx)
    LaunchedEffect(sel?.id) { sel?.id?.let { vm.loadLinkedItems(it) } }

    // Window days (shared with detail screen)
    val wBefore by vm.windowDaysBefore.collectAsState()
    val wAfter by vm.windowDaysAfter.collectAsState()
    val wStart = sel?.start?.minus(Duration.ofDays(wBefore))
    val wEnd = (sel?.end ?: sel?.start)?.plus(Duration.ofDays(wAfter))
    val windowDates = remember(wStart, wEnd) {
        if (wStart == null || wEnd == null) emptySet()
        else {
            val f = LocalDate.ofInstant(wStart, zone)
            val t = LocalDate.ofInstant(wEnd, zone)
            generateSequence(f) { it.plusDays(1) }
                .takeWhile { !it.isAfter(t) }
                .map { it.toString() }.toSet()
        }
    }

    val allMissed by vm.allMissedActivities.collectAsState()
    val allActs by vm.allActivities.collectAsState()

    val windowEvents = remember(linkedItems, allMissed, allActs, sel?.id) {
        val actsForMigraine = allActs.filter { it.migraineId == sel?.id }
        val missedForMigraine = allMissed.filter { it.migraineId == sel?.id }
        buildEventMarkers(linkedItems, actsForMigraine, missedForMigraine)
    }

    val autoSelectedKeys = remember(windowEvents) {
        windowEvents.filter { it.isAutomated }
            .mapNotNull { ev: EventMarker -> vm.labelToMetricKey(ev.name) }
            .toSet()
    }

    // Auto-selected keys across ALL filtered migraines (for the full report)
    val filteredIds = remember(filteredSorted) { filteredSorted.mapNotNull { it.id }.toSet() }

    // Available tags scoped to filtered migraines only
    val filteredAvailableTags = remember(filteredIds, tagIndex) {
        val tags = mutableSetOf<InsightsViewModel.FilterTag>()
        filteredIds.forEach { id -> tagIndex[id]?.let { tags.addAll(it) } }
        tags.groupBy({ it.category }, { it.label })
            .mapValues { it.value.distinct().sorted() }
    }

    val templateMap by vm.labelToMetricMap.collectAsState()

    val allAutoSelectedKeys = remember(filteredIds, allDailyMetrics, templateMap) {
        vm.autoMetricKeysForMigraines(filteredIds)
    }

    val available = remember(allDailyMetrics, timeFrame) {
        if (timeFrame == InsightsViewModel.TimeFrame.NONE) emptyList()
        else AllMetricDefs.filter { d -> allDailyMetrics.containsKey(d.key) }
    }

    val userToggledKeys by vm.userToggledMetrics.collectAsState()
    val enabledKeys = allAutoSelectedKeys + userToggledKeys

    // ── Report generation gate ──
    var reportGenerated by remember { mutableStateOf(false) }

    val enabledSeries = remember(available, enabledKeys, allDailyMetrics, windowDates) {
        available.filter { it.key in enabledKeys }.map { d ->
            MetricSeries(d.key, d.label, d.unit, d.color,
                allDailyMetrics[d.key]!!
                    .filter { it.date in windowDates }
                    .map { DailyMetricPoint(it.date, it.value) })
        }
    }

    val windowMigs = remember(migraines, wStart, wEnd) {
        if (wStart == null || wEnd == null) listOfNotNull(sel)
        else migraines.filter { m ->
            val e = m.end ?: m.start
            !m.start.isAfter(wEnd) && !e.isBefore(wStart)
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {

            // ── Back arrow ──
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back", tint = Color.White)
                }
            }

            // ══════════ 1. FILTER CARD (collapsible) ══════════
            FilterCard(
                availableTags = filteredAvailableTags,
                activeFilters = activeFilters,
                timeFrame = timeFrame,
                customRange = customRange,
                totalCount = sorted.size,
                filteredCount = filteredSorted.size,
                onToggle = { vm.toggleFilter(it) },
                onTimeFrame = { vm.setTimeFrame(it) },
                onCustomRange = { from, to -> vm.setCustomRange(from, to) },
                onClear = { vm.clearFilters() },
                availableMetrics = available,
                enabledKeys = enabledKeys,
                autoSelectedKeys = allAutoSelectedKeys,
                onToggleMetric = { key ->
                    if (key !in allAutoSelectedKeys) {
                        vm.toggleMetric(key)
                    }
                }
            )

            // ══════════ Spiders (computed regardless, needed for PDF) ══════════
            val spiderLoading by vm.spiderLoading.collectAsState()
            val spiders = remember(filteredIds, spiderLoading) {
                if (spiderLoading) InsightsViewModel.FilteredSpiders()
                else vm.buildFilteredSpiders(filteredIds)
            }

            // ══════════ GENERATE / DOWNLOAD REPORT BUTTON ══════════
            if (!reportGenerated) {
                Spacer(Modifier.height(8.dp))
                Button(
                    onClick = { reportGenerated = true },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(48.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = AppTheme.AccentPurple
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text(
                        "Generate Report",
                        color = Color.White,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                }
            }

            // ══════════ 2. REPORT CONTENT (shown after Generate) ══════════
            if (reportGenerated) {

            // ══════════ DOWNLOAD REPORT BUTTON ══════════
            Spacer(Modifier.height(12.dp))
            var isGeneratingPdf by remember { mutableStateOf(false) }
            val scope = rememberCoroutineScope()

            Button(
                onClick = {
                    isGeneratingPdf = true
                    val timeLabel = when (timeFrame) {
                        InsightsViewModel.TimeFrame.NONE -> "All"
                        InsightsViewModel.TimeFrame.WEEK_1 -> "Last 7 Days"
                        InsightsViewModel.TimeFrame.WEEK_2 -> "Last 14 Days"
                        InsightsViewModel.TimeFrame.MONTH_1 -> "Last 30 Days"
                        InsightsViewModel.TimeFrame.MONTH_3 -> "Last 3 Months"
                        InsightsViewModel.TimeFrame.MONTH_6 -> "Last 6 Months"
                        InsightsViewModel.TimeFrame.YEAR_1 -> "Last Year"
                        InsightsViewModel.TimeFrame.ALL -> "All Time"
                        InsightsViewModel.TimeFrame.CUSTOM -> {
                            val cr = customRange
                            if (cr != null) "${cr.from} – ${cr.to}" else "Custom"
                        }
                    }
                    scope.launch {
                        try {
                            data class MgGraphData(
                                val mg: MigraineSpan, val events: List<EventMarker>,
                                val windowMigs: List<MigraineSpan>, val windowDates: Set<String>,
                                val wStart: java.time.Instant, val wEnd: java.time.Instant,
                                val autoKeys: Set<String>
                            )
                            val allGd = mutableListOf<MgGraphData>()
                            val globalAutoKeys = mutableSetOf<String>()

                            for (mg in filteredSorted) {
                                val mgId = mg.id ?: continue
                                val linked = vm.getLinkedItemsFor(mgId)
                                val actsFor = allActs.filter { it.migraineId == mgId }
                                val missedFor = allMissed.filter { it.migraineId == mgId }
                                val events = buildEventMarkers(linked, actsFor, missedFor)
                                val mWStart = mg.start.minus(Duration.ofDays(wBefore))
                                val mWEnd = (mg.end ?: mg.start).plus(Duration.ofDays(wAfter))
                                val mWindowDates = run {
                                    val f = LocalDate.ofInstant(mWStart, zone)
                                    val t = LocalDate.ofInstant(mWEnd, zone)
                                    generateSequence(f) { it.plusDays(1) }
                                        .takeWhile { !it.isAfter(t) }
                                        .map { it.toString() }.toSet()
                                }
                                val mWindowMigs = migraines.filter { m ->
                                    val e = m.end ?: m.start
                                    !m.start.isAfter(mWEnd) && !e.isBefore(mWStart)
                                }
                                val mAutoKeys = events.filter { it.isAutomated }
                                    .mapNotNull { ev -> vm.labelToMetricKey(ev.name) }.toSet()
                                globalAutoKeys.addAll(mAutoKeys)
                                allGd.add(MgGraphData(mg, events, mWindowMigs, mWindowDates, mWStart, mWEnd, mAutoKeys))
                            }

                            val overlayKeys = globalAutoKeys + userToggledKeys
                            val captures = mutableListOf<ReportPdfGenerator.TimelineCapture>()
                            for (gd in allGd) {
                                val mAvail = AllMetricDefs.filter { d ->
                                    allDailyMetrics[d.key]?.any { it.date in gd.windowDates } == true
                                }
                                fun series(keys: Set<String>) = mAvail.filter { it.key in keys }.map { d ->
                                    MetricSeries(d.key, d.label, d.unit, d.color,
                                        allDailyMetrics[d.key]!!.filter { it.date in gd.windowDates }
                                            .map { DailyMetricPoint(it.date, it.value) })
                                }
                                val autoSeries = series(gd.autoKeys)
                                val fullSeries = series(overlayKeys)

                                if (activityCtx != null) {
                                    val autoBmp = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.Main) {
                                        captureTimelineGraph(activityCtx, gd.windowMigs, gd.events, autoSeries, gd.wStart, gd.wEnd, gd.mg.start)
                                    }
                                    val fullBmp = if (fullSeries.size > autoSeries.size) {
                                        kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.Main) {
                                            captureTimelineGraph(activityCtx, gd.windowMigs, gd.events, fullSeries, gd.wStart, gd.wEnd, gd.mg.start)
                                        }
                                    } else autoBmp

                                    val sortedEvents = gd.events.sortedBy { it.at }
                                    val legendEvents = sortedEvents.mapIndexed { i, ev ->
                                        ReportPdfGenerator.LegendEvent(i + 1, ev.name, ev.category,
                                            ev.color.let { android.graphics.Color.argb((it.alpha * 255).toInt(), (it.red * 255).toInt(), (it.green * 255).toInt(), (it.blue * 255).toInt()) },
                                            ev.isAutomated)
                                    }
                                    fun metricLegend(s: List<MetricSeries>) = s.map { ms ->
                                        ReportPdfGenerator.LegendMetric(ms.label, ms.unit,
                                            ms.color.let { android.graphics.Color.argb((it.alpha * 255).toInt(), (it.red * 255).toInt(), (it.green * 255).toInt(), (it.blue * 255).toInt()) })
                                    }
                                    if (autoBmp != null && fullBmp != null) {
                                        captures.add(ReportPdfGenerator.TimelineCapture(
                                            gd.mg, autoBmp, fullBmp, legendEvents, metricLegend(autoSeries), metricLegend(fullSeries)))
                                    }
                                }
                            }

                            val reportData = ReportPdfGenerator.ReportData(
                                filteredMigraines = filteredSorted, timeFrameLabel = timeLabel,
                                spiders = spiders, enabledMetrics = enabledSeries,
                                autoMetricKeys = allAutoSelectedKeys, allDailyMetrics = allDailyMetrics,
                                timelineCaptures = captures)
                            val generator = ReportPdfGenerator(ctx)
                            val file = generator.generate(reportData)
                            isGeneratingPdf = false
                            if (file != null) { generator.share(file) }
                            else { android.widget.Toast.makeText(ctx, "Failed to generate PDF", android.widget.Toast.LENGTH_SHORT).show() }
                        } catch (e: Exception) {
                            isGeneratingPdf = false
                            android.util.Log.e("ReportPDF", "PDF error", e)
                            android.widget.Toast.makeText(ctx, "PDF error: ${e.message}", android.widget.Toast.LENGTH_LONG).show()
                        }
                    }
                },
                enabled = !isGeneratingPdf && !spiderLoading,
                modifier = Modifier.fillMaxWidth().height(48.dp),
                colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                shape = RoundedCornerShape(12.dp)
            ) {
                if (isGeneratingPdf) {
                    CircularProgressIndicator(Modifier.size(20.dp), strokeWidth = 2.dp, color = Color.White)
                    Spacer(Modifier.width(8.dp))
                    Text("Generating PDF…", color = Color.White, style = MaterialTheme.typography.titleSmall)
                } else if (spiderLoading) {
                    CircularProgressIndicator(Modifier.size(20.dp), strokeWidth = 2.dp, color = Color.White.copy(alpha = 0.5f))
                    Spacer(Modifier.width(8.dp))
                    Text("Loading…", color = Color.White.copy(alpha = 0.5f), style = MaterialTheme.typography.titleSmall)
                } else {
                    Text("Download Report", color = Color.White,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                }
            }

            Spacer(Modifier.height(12.dp))

            HeroCard {
                Text("Migraine Timeline", color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))

                if (filteredSorted.isEmpty()) {
                    Text(
                        if (sorted.isEmpty()) "No migraines logged yet"
                        else "No migraines match filters",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
                    return@HeroCard
                }

                // Migraine selector (navigates filtered list)
                DetailMigraineSelector(filteredSorted, clampedIdx, sel,
                    onPrev = { if (clampedIdx < filteredSorted.size - 1) vm.selectMigraine(clampedIdx + 1) },
                    onNext = { if (clampedIdx > 0) vm.selectMigraine(clampedIdx - 1) })

                if (linkedLoading) {
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(Modifier.size(16.dp),
                            strokeWidth = 2.dp, color = AppTheme.AccentPurple)
                    }
                } else {
                    val catCounts = remember(windowEvents) {
                        windowEvents.groupBy { it.category }.mapValues { it.value.size }
                    }
                    if (catCounts.isNotEmpty()) {
                        Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                            horizontalArrangement = Arrangement.spacedBy(10.dp),
                            verticalAlignment = Alignment.CenterVertically) {
                            catCounts.forEach { (c, n) ->
                                DetailChip(n, c, EventCategoryColors[c] ?: AppTheme.AccentPurple)
                            }
                        }
                    }
                }

                // Graph
                InsightsTimelineGraph(
                    windowMigs, windowEvents, enabledSeries,
                    wStart, wEnd, sel?.start,
                    Modifier.fillMaxWidth().height(360.dp))

                Text("Window around migraine", color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall,
                    textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())

                // Window adjustment
                WindowDaysControl(wBefore, wAfter, onChanged = { b, a -> vm.setWindowDays(b, a) })
            }

            // ══════════ 3. FILTERED INSIGHT CARDS (same as main page, filtered aggregation) ══════════

            if (filteredSorted.isNotEmpty()) {
                // Symptoms card (same as SymptomsInsightCard on main page)
                spiders.symptoms?.takeIf { it.totalLogged > 0 }?.let {
                    FilteredSymptomsCard(
                        migCount = filteredSorted.size,
                        painChar = spiders.painChar,
                        accompanying = spiders.accompanying,
                        onClick = { navController.navigate("${Routes.INSIGHTS_BREAKDOWN}/Symptoms") }
                    )
                }

                // All other spiders (same as SpiderInsightCard on main page)
                listOf(
                    spiders.prodromes, spiders.triggers,
                    spiders.medicines, spiders.reliefs,
                    spiders.locations, spiders.activities,
                    spiders.missedActivities
                ).forEach { sp ->
                    if (sp != null && sp.totalLogged > 0) {
                        val effAxes = when (sp.logType) {
                            "Medicines" -> if (spiders.medicineEffectiveness.isNotEmpty() && sp.axes.size >= 3) {
                                val m = spiders.medicineEffectiveness.associate { it.category to it.avgRelief }
                                sp.axes.map { SpiderAxis(it.label, m[it.label] ?: 0f, 3f) }
                            } else null
                            "Reliefs" -> if (spiders.reliefEffectiveness.isNotEmpty() && sp.axes.size >= 3) {
                                val m = spiders.reliefEffectiveness.associate { it.category to it.avgRelief }
                                sp.axes.map { SpiderAxis(it.label, m[it.label] ?: 0f, 3f) }
                            } else null
                            else -> null
                        }
                        FilteredSpiderCard(sp, effAxes) {
                            navController.navigate("${Routes.INSIGHTS_BREAKDOWN}/${sp.logType}")
                        }
                    }
                }
            }

            // ══════════ HEALTH METRICS SPARKLINES ══════════
            if (enabledSeries.isNotEmpty()) {
                Spacer(Modifier.height(12.dp))
                Text("Health Metrics", color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold),
                    modifier = Modifier.padding(horizontal = 4.dp))
                Spacer(Modifier.height(8.dp))

                // Date range from filtered migraines ±7 days
                val metricMigDates = remember(filteredSorted) {
                    filteredSorted.map { it.start.atZone(zone).toLocalDate() }
                }
                val metricRangeStart = remember(metricMigDates) {
                    metricMigDates.minOrNull()?.minusDays(7)
                }
                val metricRangeEnd = remember(metricMigDates, filteredSorted) {
                    metricMigDates.maxOrNull()?.let { last ->
                        filteredSorted.find { it.start.atZone(zone).toLocalDate() == last }?.end
                            ?.let { it.atZone(zone).toLocalDate().plusDays(7) }
                            ?: last.plusDays(7)
                    }
                }

                enabledSeries.forEach { series ->
                    val filteredPoints = remember(series, metricRangeStart, metricRangeEnd) {
                        if (metricRangeStart != null && metricRangeEnd != null) {
                            series.points.filter {
                                val d = LocalDate.parse(it.date)
                                !d.isBefore(metricRangeStart) && !d.isAfter(metricRangeEnd)
                            }
                        } else series.points
                    }
                    if (filteredPoints.size >= 2) {
                        val isAuto = series.key in allAutoSelectedKeys
                        BaseCard(modifier = Modifier.padding(vertical = 4.dp)) {
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                Text("${series.label} (${series.unit})",
                                    color = series.color,
                                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                                if (isAuto) {
                                    Spacer(Modifier.width(8.dp))
                                    Text("AUTO",
                                        color = AppTheme.AccentPink,
                                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                                        modifier = Modifier
                                            .background(AppTheme.AccentPink.copy(alpha = 0.15f), RoundedCornerShape(4.dp))
                                            .padding(horizontal = 6.dp, vertical = 2.dp))
                                }
                            }
                            Spacer(Modifier.height(8.dp))

                            // Sparkline with migraine markers
                            val sorted = filteredPoints.sortedBy { it.date }
                            val minV = sorted.minOf { it.value }
                            val maxV = sorted.maxOf { it.value }
                            val avgV = sorted.map { it.value }.average()

                            Canvas(Modifier.fillMaxWidth().height(100.dp)) {
                                val w = size.width; val h = size.height
                                val padL = 40f; val padR = 8f; val padT = 12f; val padB = 20f
                                val cw = w - padL - padR; val ch = h - padT - padB
                                val rng = if (maxV - minV < 0.001) 1.0 else maxV - minV
                                val firstDate = LocalDate.parse(sorted.first().date)
                                val lastDate = LocalDate.parse(sorted.last().date)
                                val daySpan = java.time.temporal.ChronoUnit.DAYS.between(firstDate, lastDate).toFloat().coerceAtLeast(1f)

                                fun dateX(ds: String): Float {
                                    val days = java.time.temporal.ChronoUnit.DAYS.between(firstDate, LocalDate.parse(ds)).toFloat()
                                    return padL + (days / daySpan) * cw
                                }
                                fun valY(v: Double): Float = padT + ch - ((v - minV) / rng).toFloat() * ch

                                // Grid lines (3 horizontal)
                                val gridColor = Color.White.copy(alpha = 0.08f)
                                listOf(maxV, (minV + maxV) / 2.0, minV).forEach { v ->
                                    val gy = valY(v)
                                    drawLine(gridColor, Offset(padL, gy), Offset(w - padR, gy), 1f)
                                }

                                // Y-axis labels
                                val yPaint = android.graphics.Paint().apply {
                                    color = Color.White.copy(alpha = 0.4f).toArgb()
                                    textSize = 20f; isAntiAlias = true; textAlign = android.graphics.Paint.Align.RIGHT
                                }
                                drawContext.canvas.nativeCanvas.drawText("%.1f".format(maxV), padL - 4f, valY(maxV) + 5f, yPaint)
                                drawContext.canvas.nativeCanvas.drawText("%.1f".format(minV), padL - 4f, valY(minV) + 5f, yPaint)

                                // Avg dashed line
                                val avgY = valY(avgV)
                                drawLine(series.color.copy(alpha = 0.2f), Offset(padL, avgY), Offset(w - padR, avgY), 1f,
                                    pathEffect = PathEffect.dashPathEffect(floatArrayOf(6f, 4f)))

                                // Migraine markers
                                filteredSorted.forEach { mg ->
                                    val mDate = mg.start.atZone(zone).toLocalDate().toString()
                                    val days = java.time.temporal.ChronoUnit.DAYS.between(firstDate, LocalDate.parse(mDate)).toFloat()
                                    if (days < 0 || days > daySpan) return@forEach
                                    val mx = padL + (days / daySpan) * cw
                                    drawLine(AppTheme.AccentPink.copy(alpha = 0.4f),
                                        Offset(mx, padT), Offset(mx, h - padB), 1.5f,
                                        pathEffect = PathEffect.dashPathEffect(floatArrayOf(6f, 4f)))
                                    val sev = mg.severity ?: 0
                                    if (sev > 0) {
                                        drawRoundRect(AppTheme.AccentPink.copy(alpha = 0.3f),
                                            Offset(mx - 10f, padT - 2f), androidx.compose.ui.geometry.Size(20f, 14f),
                                            cornerRadius = CornerRadius(4f))
                                        drawContext.canvas.nativeCanvas.drawText("$sev", mx,
                                            padT + 9f, android.graphics.Paint().apply {
                                                color = AppTheme.AccentPink.toArgb(); textSize = 18f
                                                isAntiAlias = true; textAlign = android.graphics.Paint.Align.CENTER
                                                typeface = android.graphics.Typeface.DEFAULT_BOLD
                                            })
                                    }
                                }

                                // Sparkline
                                val path = Path()
                                sorted.forEachIndexed { i, pt ->
                                    val x = dateX(pt.date); val py = valY(pt.value)
                                    if (i == 0) path.moveTo(x, py) else path.lineTo(x, py)
                                }
                                drawPath(path, series.color.copy(alpha = 0.15f), style = Stroke(width = 5f, cap = StrokeCap.Round))
                                drawPath(path, series.color.copy(alpha = 0.8f), style = Stroke(width = 2f, cap = StrokeCap.Round))
                                sorted.forEach { pt ->
                                    drawCircle(series.color.copy(alpha = 0.3f), 4f, Offset(dateX(pt.date), valY(pt.value)))
                                    drawCircle(series.color, 2f, Offset(dateX(pt.date), valY(pt.value)))
                                }

                                // X-axis dates
                                val xPaint = android.graphics.Paint().apply {
                                    color = Color.White.copy(alpha = 0.4f).toArgb()
                                    textSize = 18f; isAntiAlias = true; textAlign = android.graphics.Paint.Align.CENTER
                                }
                                val xFmt = java.time.format.DateTimeFormatter.ofPattern("dd MMM")
                                val labelCount = 5.coerceAtMost(daySpan.toInt() + 1)
                                for (i in 0 until labelCount) {
                                    val frac = if (labelCount <= 1) 0f else i.toFloat() / (labelCount - 1)
                                    val ld = firstDate.plusDays((frac * daySpan).toLong())
                                    val dx = padL + frac * cw
                                    drawContext.canvas.nativeCanvas.drawText(ld.format(xFmt), dx, h - 2f, xPaint)
                                }
                            }

                            // Stats row
                            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                                Text("Min: ${"%.1f".format(minV)}", color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.labelSmall)
                                Text("Avg: ${"%.1f".format(avgV)}", color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.labelSmall)
                                Text("Max: ${"%.1f".format(maxV)}", color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.labelSmall)
                            }
                        }
                    }
                }
            }

            } // end if (reportGenerated)
        }
    }
}

// ═══════ Filter card ═══════

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun FilterCard(
    availableTags: Map<String, List<String>>,
    activeFilters: Set<InsightsViewModel.FilterTag>,
    timeFrame: InsightsViewModel.TimeFrame,
    customRange: InsightsViewModel.CustomRange?,
    totalCount: Int,
    filteredCount: Int,
    onToggle: (InsightsViewModel.FilterTag) -> Unit,
    onTimeFrame: (InsightsViewModel.TimeFrame) -> Unit,
    onCustomRange: (java.time.LocalDate, java.time.LocalDate) -> Unit,
    onClear: () -> Unit,
    availableMetrics: List<MetricDef> = emptyList(),
    enabledKeys: Set<String> = emptySet(),
    autoSelectedKeys: Set<String> = emptySet(),
    onToggleMetric: (String) -> Unit = {}
) {
    var expanded by remember { mutableStateOf(true) }
    val hasFilters = activeFilters.isNotEmpty() || (timeFrame != InsightsViewModel.TimeFrame.ALL && timeFrame != InsightsViewModel.TimeFrame.NONE)
    val activeCount = activeFilters.size + if (timeFrame != InsightsViewModel.TimeFrame.ALL && timeFrame != InsightsViewModel.TimeFrame.NONE) 1 else 0
    val enabledMetricCount = enabledKeys.size

    // Custom date picker state
    var showFromPicker by remember { mutableStateOf(false) }
    var showToPicker by remember { mutableStateOf(false) }
    var customFrom by remember(customRange) {
        mutableStateOf(customRange?.from ?: java.time.LocalDate.now().minusDays(30))
    }
    var customTo by remember(customRange) {
        mutableStateOf(customRange?.to ?: java.time.LocalDate.now())
    }

    BaseCard {
        // Header row — always visible, tappable
        Row(
            Modifier
                .fillMaxWidth()
                .clickable { expanded = !expanded },
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(Icons.Filled.FilterList,
                contentDescription = "Filter",
                tint = if (hasFilters) AppTheme.AccentPurple else AppTheme.SubtleTextColor,
                modifier = Modifier.size(20.dp))
            Spacer(Modifier.width(8.dp))
            Column(Modifier.weight(1f)) {
                val totalActive = activeCount + enabledMetricCount
                Text(
                    if (hasFilters || enabledMetricCount > 0) "Select Metrics ($totalActive)"
                    else "Select Metrics",
                    color = if (hasFilters || enabledMetricCount > 0) Color.White else AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                if (hasFilters) {
                    Text("$filteredCount of $totalCount migraines",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.labelSmall)
                }
            }
            if (hasFilters) {
                Text("Clear",
                    color = AppTheme.AccentPurple.copy(alpha = 0.7f),
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold),
                    modifier = Modifier
                        .clip(RoundedCornerShape(8.dp))
                        .clickable { onClear() }
                        .padding(horizontal = 8.dp, vertical = 4.dp))
                Spacer(Modifier.width(4.dp))
            }
            Icon(
                if (expanded) Icons.Filled.KeyboardArrowUp
                else Icons.Filled.KeyboardArrowDown,
                contentDescription = "Expand",
                tint = AppTheme.SubtleTextColor,
                modifier = Modifier.size(20.dp))
        }

        // Active filter chips (shown when collapsed + has filters)
        if (!expanded && hasFilters) {
            Spacer(Modifier.height(6.dp))
            Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                if (timeFrame != InsightsViewModel.TimeFrame.ALL && timeFrame != InsightsViewModel.TimeFrame.NONE) {
                    val timeLabel = if (timeFrame == InsightsViewModel.TimeFrame.CUSTOM && customRange != null) {
                        val df = java.time.format.DateTimeFormatter.ofPattern("MMM d")
                        "${df.format(customRange.from)} – ${df.format(customRange.to)}"
                    } else timeFrame.label
                    Row(
                        Modifier
                            .clip(RoundedCornerShape(16.dp))
                            .background(AppTheme.AccentPurple.copy(alpha = 0.2f))
                            .clickable { onTimeFrame(InsightsViewModel.TimeFrame.ALL) }
                            .padding(horizontal = 10.dp, vertical = 4.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(timeLabel, color = AppTheme.AccentPurple,
                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium))
                        Spacer(Modifier.width(4.dp))
                        Text("✕", color = AppTheme.AccentPurple.copy(alpha = 0.6f),
                            style = MaterialTheme.typography.labelSmall)
                    }
                }
                activeFilters.sortedBy { it.key }.forEach { tag ->
                    val color = FilterCatColors[tag.category] ?: AppTheme.AccentPurple
                    ActiveFilterChip(tag, color, onToggle)
                }
            }
        }

        // Expanded: timeframe + all categories
        AnimatedVisibility(
            visible = expanded,
            enter = expandVertically(),
            exit = shrinkVertically()
        ) {
            Column(Modifier.padding(top = 8.dp)) {
                // Timeframe selector
                Text("Time Range", color = AppTheme.AccentPurple.copy(alpha = 0.8f),
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                    modifier = Modifier.padding(bottom = 2.dp))
                Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                    horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                    InsightsViewModel.TimeFrame.entries
                        .filter { it != InsightsViewModel.TimeFrame.NONE }
                        .forEach { tf ->
                        val isActive = tf == timeFrame
                        FilterOptionChip(
                            label = tf.label,
                            color = AppTheme.AccentPurple,
                            active = isActive,
                            onClick = {
                                if (tf == InsightsViewModel.TimeFrame.CUSTOM) {
                                    showFromPicker = true
                                } else {
                                    onTimeFrame(tf)
                                }
                            }
                        )
                    }
                }

                // Custom date range row (shown when custom is active or being set)
                AnimatedVisibility(visible = timeFrame == InsightsViewModel.TimeFrame.CUSTOM) {
                    val df = java.time.format.DateTimeFormatter.ofPattern("MMM d, yyyy")
                    Row(
                        Modifier.fillMaxWidth().padding(top = 4.dp),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // From button
                        Column(Modifier.weight(1f)) {
                            Text("From", color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.labelSmall)
                            Row(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(10.dp))
                                    .background(Color.White.copy(alpha = 0.06f))
                                    .clickable { showFromPicker = true }
                                    .padding(horizontal = 12.dp, vertical = 8.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(df.format(customFrom), color = Color.White,
                                    style = MaterialTheme.typography.bodySmall)
                            }
                        }
                        Text("–", color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(top = 12.dp))
                        // To button
                        Column(Modifier.weight(1f)) {
                            Text("To", color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.labelSmall)
                            Row(
                                Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(10.dp))
                                    .background(Color.White.copy(alpha = 0.06f))
                                    .clickable { showToPicker = true }
                                    .padding(horizontal = 12.dp, vertical = 8.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(df.format(customTo), color = Color.White,
                                    style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    }
                }

                // Tag categories + Overlay Metrics — only shown after a time range is selected
                if (timeFrame != InsightsViewModel.TimeFrame.NONE) {

                // Tag categories
                val orderedCats = FilterCatOrder.filter { it in availableTags }
                orderedCats.forEach { cat ->
                    val labels = availableTags[cat] ?: return@forEach
                    val color = FilterCatColors[cat] ?: AppTheme.AccentPurple
                    Text(cat, color = color.copy(alpha = 0.8f),
                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                        modifier = Modifier.padding(top = 6.dp, bottom = 2.dp))
                    Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                        horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                        labels.forEach { label ->
                            val tag = InsightsViewModel.FilterTag(cat, label)
                            val isActive = tag in activeFilters
                            FilterOptionChip(label, color, isActive) { onToggle(tag) }
                        }
                    }
                }

                // ── Overlay Metrics ──
                if (availableMetrics.isNotEmpty()) {
                    Spacer(Modifier.height(12.dp))
                    Text("Overlay Metrics", color = AppTheme.AccentPurple.copy(alpha = 0.8f),
                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold),
                        modifier = Modifier.padding(bottom = 2.dp))
                    Text("Toggle metric lines on the graph. ⚡ = auto-detected.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall)
                    Spacer(Modifier.height(4.dp))
                    val metricGroups = availableMetrics.groupBy { it.group }
                    metricGroups.forEach { (group, defs) ->
                        Text(group, color = AppTheme.SubtleTextColor.copy(alpha = 0.6f),
                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold),
                            modifier = Modifier.padding(top = 4.dp, bottom = 2.dp))
                        Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                            horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                            defs.forEach { d ->
                                val isAuto = d.key in autoSelectedKeys
                                val isEnabled = d.key in enabledKeys
                                DetailToggle(
                                    label = d.label,
                                    color = d.color,
                                    active = isEnabled,
                                    isAutoSelected = isAuto,
                                    onClick = { onToggleMetric(d.key) }
                                )
                            }
                        }
                    }
                }

                } // end if timeFrame != NONE
            }
        }
    }

    // ── Date picker dialogs ──
    if (showFromPicker) {
        val state = rememberDatePickerState(
            initialSelectedDateMillis = customFrom.atStartOfDay(java.time.ZoneOffset.UTC)
                .toInstant().toEpochMilli()
        )
        DatePickerDialog(
            onDismissRequest = { showFromPicker = false },
            confirmButton = {
                TextButton(onClick = {
                    state.selectedDateMillis?.let { ms ->
                        customFrom = java.time.Instant.ofEpochMilli(ms)
                            .atZone(java.time.ZoneOffset.UTC).toLocalDate()
                        if (customFrom.isAfter(customTo)) customTo = customFrom
                        onCustomRange(customFrom, customTo)
                    }
                    showFromPicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showFromPicker = false }) { Text("Cancel") }
            }
        ) {
            DatePicker(state = state)
        }
    }

    if (showToPicker) {
        val state = rememberDatePickerState(
            initialSelectedDateMillis = customTo.atStartOfDay(java.time.ZoneOffset.UTC)
                .toInstant().toEpochMilli()
        )
        DatePickerDialog(
            onDismissRequest = { showToPicker = false },
            confirmButton = {
                TextButton(onClick = {
                    state.selectedDateMillis?.let { ms ->
                        customTo = java.time.Instant.ofEpochMilli(ms)
                            .atZone(java.time.ZoneOffset.UTC).toLocalDate()
                        if (customTo.isBefore(customFrom)) customFrom = customTo
                        onCustomRange(customFrom, customTo)
                    }
                    showToPicker = false
                }) { Text("OK") }
            },
            dismissButton = {
                TextButton(onClick = { showToPicker = false }) { Text("Cancel") }
            }
        ) {
            DatePicker(state = state)
        }
    }
}

@Composable
private fun ActiveFilterChip(
    tag: InsightsViewModel.FilterTag, color: Color,
    onRemove: (InsightsViewModel.FilterTag) -> Unit
) {
    Row(
        Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(color.copy(alpha = 0.2f))
            .clickable { onRemove(tag) }
            .padding(horizontal = 10.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(Modifier.size(6.dp).clip(CircleShape).background(color))
        Spacer(Modifier.width(4.dp))
        Text(tag.label, color = color,
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium),
            maxLines = 1, overflow = TextOverflow.Ellipsis)
        Spacer(Modifier.width(4.dp))
        Text("✕", color = color.copy(alpha = 0.6f),
            style = MaterialTheme.typography.labelSmall)
    }
}

@Composable
private fun FilterOptionChip(
    label: String, color: Color, active: Boolean, onClick: () -> Unit
) {
    val bg = if (active) color.copy(alpha = 0.2f) else Color.White.copy(alpha = 0.04f)
    val tc = if (active) color else AppTheme.SubtleTextColor.copy(alpha = 0.5f)
    Row(
        Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(bg)
            .clickable(onClick = onClick)
            .padding(horizontal = 10.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(Modifier.size(6.dp).clip(CircleShape)
            .background(if (active) color else color.copy(alpha = 0.3f)))
        Spacer(Modifier.width(4.dp))
        Text(label, color = tc,
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium),
            maxLines = 1, overflow = TextOverflow.Ellipsis)
    }
}

// ═══════ Filtered spider cards (same layout as main page) ═══════

@Composable
private fun FilteredSpiderCard(data: SpiderData, secondAxes: List<SpiderAxis>? = null, onClick: () -> Unit = {}) {
    val color = colorForLogType(data.logType)
    BaseCard(modifier = Modifier.clickable(onClick = onClick)) {
        Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            Canvas(Modifier.size(24.dp)) {
                HubIcons.run {
                    when (data.logType) {
                        "Triggers" -> drawTriggerBolt(color)
                        "Prodromes" -> drawProdromeEye(color)
                        "Symptoms" -> drawMigraineStarburst(color)
                        "Medicines" -> drawMedicinePill(color)
                        "Reliefs" -> drawReliefLeaf(color)
                        "Activities" -> drawActivityPulse(color)
                        "Missed Activities" -> drawMissedActivity(color)
                        "Locations" -> drawLocationPin(color)
                    }
                }
            }
            Spacer(Modifier.width(10.dp))
            Column(Modifier.weight(1f)) {
                Text(data.logType, color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Text("${data.totalLogged} logged • ${data.breakdown.size} categories",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }
            Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodyMedium)
        }
        Spacer(Modifier.height(8.dp))
        if (data.axes.size >= 3) {
            Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                SpiderChart(axes = data.axes, accentColor = color, size = 220.dp,
                    secondAxes = secondAxes, secondColor = Color.White.copy(alpha = 0.6f))
            }
        } else {
            StackedProportionalBar(axes = data.axes, accentColor = color)
        }
    }
}

@Composable
private fun FilteredSymptomsCard(
    migCount: Int,
    painChar: SpiderData?,
    accompanying: SpiderData?,
    onClick: () -> Unit = {}
) {
    BaseCard(modifier = Modifier.clickable(onClick = onClick)) {
        Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            Canvas(Modifier.size(24.dp)) { HubIcons.run { drawMigraineStarburst(AppTheme.AccentPink) } }
            Spacer(Modifier.width(10.dp))
            Column(Modifier.weight(1f)) {
                Text("Symptoms", color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Text("$migCount migraines",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }
            Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodyMedium)
        }
        painChar?.takeIf { it.axes.isNotEmpty() }?.let { data ->
            Spacer(Modifier.height(12.dp))
            Text("Pain Character", color = Color(0xFFEF5350),
                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
            Spacer(Modifier.height(4.dp))
            if (data.axes.size >= 3) {
                Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    SpiderChart(axes = data.axes, accentColor = Color(0xFFEF5350), size = 200.dp)
                }
            } else StackedProportionalBar(axes = data.axes, accentColor = Color(0xFFEF5350))
        }
        accompanying?.takeIf { it.axes.isNotEmpty() }?.let { data ->
            Spacer(Modifier.height(16.dp))
            Text("Accompanying Experience", color = Color(0xFFBA68C8),
                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
            Spacer(Modifier.height(4.dp))
            if (data.axes.size >= 3) {
                Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    SpiderChart(axes = data.axes, accentColor = Color(0xFFBA68C8), size = 200.dp)
                }
            } else StackedProportionalBar(axes = data.axes, accentColor = Color(0xFFBA68C8))
        }
    }
}

// ═══════ Private composables ═══════

@Composable
private fun DetailMigraineSelector(
    sorted: List<MigraineSpan>, idx: Int, sel: MigraineSpan?,
    onPrev: () -> Unit, onNext: () -> Unit
) {
    val z = ZoneId.systemDefault()
    val df = DateTimeFormatter.ofPattern("MMM d, yyyy").withZone(z)
    val tf = DateTimeFormatter.ofPattern("h:mm a").withZone(z)
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically) {
        IconButton(onClick = onPrev, enabled = idx < sorted.size - 1) {
            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Older",
                tint = if (idx < sorted.size - 1) AppTheme.AccentPurple
                else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                modifier = Modifier.size(22.dp))
        }
        Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.weight(1f)) {
            Text(sel?.label ?: "Migraine", color = Color.White,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold),
                maxLines = 1, overflow = TextOverflow.Ellipsis)
            if (sel != null) {
                Text(df.format(sel.start) + " • " + tf.format(sel.start),
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                val e = sel.end
                if (e != null) {
                    val d = Duration.between(sel.start, e)
                    val hStr = if (d.toHours() > 0) "${d.toHours()}h " else ""
                    Text("$hStr${d.minusHours(d.toHours()).toMinutes()}m • Severity: ${sel.severity ?: "–"}/10",
                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                } else {
                    Text("Severity: ${sel.severity ?: "–"}/10",
                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
            Text("${idx + 1} of ${sorted.size}", color = AppTheme.AccentPurple,
                style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
        }
        IconButton(onClick = onNext, enabled = idx > 0) {
            Icon(Icons.AutoMirrored.Filled.ArrowForward, "Newer",
                tint = if (idx > 0) AppTheme.AccentPurple
                else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                modifier = Modifier.size(22.dp))
        }
    }
}

@Composable
private fun DetailChip(n: Int, label: String, color: Color) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Box(Modifier.size(8.dp).clip(CircleShape).background(color))
        Spacer(Modifier.width(4.dp))
        Text("$n", color = Color.White,
            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold))
        Spacer(Modifier.width(2.dp))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
    }
}

@Composable
private fun DetailToggle(
    label: String, color: Color, active: Boolean,
    isAutoSelected: Boolean, onClick: () -> Unit
) {
    val bg = if (active) color.copy(alpha = 0.2f) else Color.White.copy(alpha = 0.04f)
    val tc = if (active) color else AppTheme.SubtleTextColor.copy(alpha = 0.5f)
    Row(
        Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(bg)
            .then(
                if (isAutoSelected) Modifier // not clickable
                else Modifier.clickable(onClick = onClick)
            )
            .padding(horizontal = 10.dp, vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        if (isAutoSelected) {
            Box(Modifier.size(6.dp).clip(CircleShape).background(Color(0xFFFFD54F)))
        } else {
            Box(Modifier.size(6.dp).clip(CircleShape)
                .background(if (active) color else color.copy(alpha = 0.3f)))
        }
        Spacer(Modifier.width(4.dp))
        Text(label, color = tc,
            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Medium))
    }
}

// ═══════ Shared: Window days control ═══════

@Composable
internal fun WindowDaysControl(
    before: Long,
    after: Long,
    onChanged: (before: Long, after: Long) -> Unit
) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Before control
        Text("Before", color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelSmall)
        Spacer(Modifier.width(4.dp))
        SmallStepButton("−") { if (before > 1) onChanged(before - 1, after) }
        Text("${before}d", color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold),
            modifier = Modifier.padding(horizontal = 6.dp))
        SmallStepButton("+") { if (before < 30) onChanged(before + 1, after) }

        Spacer(Modifier.width(16.dp))

        // After control
        Text("After", color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelSmall)
        Spacer(Modifier.width(4.dp))
        SmallStepButton("−") { if (after > 1) onChanged(before, after - 1) }
        Text("${after}d", color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold),
            modifier = Modifier.padding(horizontal = 6.dp))
        SmallStepButton("+") { if (after < 30) onChanged(before, after + 1) }
    }
}

@Composable
private fun SmallStepButton(label: String, onClick: () -> Unit) {
    Box(
        modifier = Modifier
            .size(24.dp)
            .clip(RoundedCornerShape(6.dp))
            .background(AppTheme.AccentPurple.copy(alpha = 0.2f))
            .clickable(onClick = onClick),
        contentAlignment = Alignment.Center
    ) {
        Text(label, color = AppTheme.AccentPurple,
            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold))
    }
}

/** Render InsightsTimelineGraph composable offscreen and capture as Bitmap */
private suspend fun captureTimelineGraph(
    activity: android.app.Activity,
    migraines: List<MigraineSpan>,
    events: List<EventMarker>,
    metricSeries: List<MetricSeries>,
    windowStart: java.time.Instant,
    windowEnd: java.time.Instant,
    highlightStart: java.time.Instant
): android.graphics.Bitmap? {
    return kotlinx.coroutines.suspendCancellableCoroutine { cont ->
        val widthPx = (activity.resources.displayMetrics.density * 520).toInt()
        val heightPx = (activity.resources.displayMetrics.density * 220).toInt()

        val composeView = androidx.compose.ui.platform.ComposeView(activity).apply {
            setContent {
                InsightsTimelineGraph(
                    migraines = migraines,
                    events = events,
                    metricSeries = metricSeries,
                    windowStart = windowStart,
                    windowEnd = windowEnd,
                    highlightMigraineStart = highlightStart,
                    modifier = androidx.compose.ui.Modifier
                        .fillMaxWidth()
                        .height(220.dp)
                )
            }
        }

        val root = activity.findViewById<android.view.ViewGroup>(android.R.id.content)
        composeView.layoutParams = android.view.ViewGroup.LayoutParams(widthPx, heightPx)
        root.addView(composeView)

        composeView.viewTreeObserver.addOnGlobalLayoutListener(
            object : android.view.ViewTreeObserver.OnGlobalLayoutListener {
                override fun onGlobalLayout() {
                    composeView.viewTreeObserver.removeOnGlobalLayoutListener(this)
                    composeView.postDelayed({
                        try {
                            val bitmap = android.graphics.Bitmap.createBitmap(
                                composeView.width.coerceAtLeast(1),
                                composeView.height.coerceAtLeast(1),
                                android.graphics.Bitmap.Config.ARGB_8888
                            )
                            val canvas = android.graphics.Canvas(bitmap)
                            composeView.draw(canvas)
                            root.removeView(composeView)
                            cont.resume(bitmap) {}
                        } catch (e: Exception) {
                            root.removeView(composeView)
                            cont.resume(null) {}
                        }
                    }, 150)
                }
            }
        )
    }
}

title: InsightsScreen.kt
text:
package com.migraineme

import android.content.Context
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModelStoreOwner
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavHostController
import java.time.Duration
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter

data class MigraineSpan(val start: Instant, val end: Instant?, val severity: Int? = null, val label: String? = null, val id: String? = null)
data class ReliefSpan(val start: Instant, val end: Instant?, val intensity: Int? = null, val name: String)
data class TriggerPoint(val at: Instant, val name: String)
data class MedicinePoint(val at: Instant, val name: String, val amount: String?)
enum class TimeSpan(val days: Long, val label: String) { DAY(1, "Day"), WEEK(7, "Week"), MONTH(30, "Month"), YEAR(365, "Year"); val millis: Long get() = days * 24L * 60L * 60L * 1000L }
data class DailyMetricPoint(val date: String, val value: Double)
data class MetricSeries(val key: String, val label: String, val unit: String, val color: Color, val points: List<DailyMetricPoint>)
data class EventMarker(val at: Instant, val endAt: Instant? = null, val name: String, val category: String, val detail: String? = null, val color: Color, val isAutomated: Boolean = false)

val EventCategoryColors = mapOf(
    "Trigger" to Color(0xFFFF8A65), "Prodrome" to Color(0xFFFFD54F), "Medicine" to Color(0xFF4FC3F7),
    "Relief" to Color(0xFF81C784), "Activity" to Color(0xFFBA68C8), "Location" to Color(0xFF4DD0E1),
    "Missed Activity" to Color(0xFFEF9A9A)
)

/**
 * Resolves a trigger/prodrome type string to a metric key for auto-selection.
 * Built from trigger_templates and prodrome_templates source of truth.
 * Handles both template-label format ("Skin temp low") and legacy colon format ("Pressure: Low").
 */
/** All available metric definitions grouped by category. Key must match ViewModel allDailyMetrics keys. */
data class MetricDef(val key: String, val label: String, val unit: String, val color: Color, val group: String)
val AllMetricDefs = listOf(
    // Environment
    MetricDef("pressure", "Pressure", "hPa", Color(0xFF7986CB), "Environment"),
    MetricDef("temp", "Temp", "°C", Color(0xFFFF8A65), "Environment"),
    MetricDef("humidity", "Humidity", "%", Color(0xFF4FC3F7), "Environment"),
    MetricDef("wind", "Wind", "m/s", Color(0xFF81C784), "Environment"),
    MetricDef("uv", "UV Index", "", Color(0xFFFFB74D), "Environment"),
    MetricDef("altitude", "Altitude", "m", Color(0xFFCE93D8), "Environment"),
    MetricDef("alt_change", "Alt. Change", "m", Color(0xFFBA68C8), "Environment"),
    // Physical
    MetricDef("recovery", "Recovery", "%", Color(0xFFFFCC80), "Physical"),
    MetricDef("hrv", "HRV", "ms", Color(0xFFA5D6A7), "Physical"),
    MetricDef("rhr", "Resting HR", "bpm", Color(0xFFEF9A9A), "Physical"),
    MetricDef("spo2", "SpO₂", "%", Color(0xFF80DEEA), "Physical"),
    MetricDef("skin_temp", "Skin Temp", "°C", Color(0xFFFFAB91), "Physical"),
    MetricDef("resp_rate", "Resp. Rate", "bpm", Color(0xFFB39DDB), "Physical"),
    MetricDef("stress", "Stress", "", Color(0xFFE57373), "Physical"),
    MetricDef("strain", "Strain", "", Color(0xFFFF8A80), "Physical"),
    MetricDef("high_hr", "High HR Zones", "min", Color(0xFFF48FB1), "Physical"),
    MetricDef("steps", "Steps", "", Color(0xFFDCE775), "Physical"),
    MetricDef("weight", "Weight", "kg", Color(0xFFBCAAA4), "Physical"),
    MetricDef("body_fat", "Body Fat", "%", Color(0xFFFFCC80), "Physical"),
    MetricDef("bp_sys", "BP Systolic", "mmHg", Color(0xFFEF9A9A), "Physical"),
    MetricDef("glucose", "Glucose", "mg/dL", Color(0xFFFFE082), "Physical"),
    // Sleep
    MetricDef("sleep_dur", "Sleep", "hrs", Color(0xFF90CAF9), "Sleep"),
    MetricDef("sleep_score", "Sleep Score", "%", Color(0xFF64B5F6), "Sleep"),
    MetricDef("sleep_eff", "Sleep Eff.", "%", Color(0xFF42A5F5), "Sleep"),
    MetricDef("sleep_dist", "Disturbances", "", Color(0xFF7986CB), "Sleep"),
    MetricDef("sleep_deep", "Deep Sleep", "hrs", Color(0xFF5C6BC0), "Sleep"),
    MetricDef("sleep_rem", "REM Sleep", "hrs", Color(0xFF7E57C2), "Sleep"),
    MetricDef("sleep_light", "Light Sleep", "hrs", Color(0xFF9575CD), "Sleep"),
    MetricDef("bedtime", "Bedtime", "hrs", Color(0xFF3949AB), "Sleep"),
    MetricDef("wake_time", "Wake Time", "hrs", Color(0xFF26A69A), "Sleep"),
    // Mental
    MetricDef("screen_time", "Screen Time", "min", Color(0xFFFF8A65), "Mental"),
    MetricDef("late_screen", "Late Screen", "hrs", Color(0xFFFF7043), "Mental"),
    MetricDef("noise", "Noise", "dB", Color(0xFFFFB74D), "Mental"),
    MetricDef("brightness", "Brightness", "%", Color(0xFFFFF176), "Mental"),
    MetricDef("volume", "Volume", "%", Color(0xFFAED581), "Mental"),
    MetricDef("unlocks", "Unlocks", "", Color(0xFF4DD0E1), "Mental"),
    MetricDef("dark_mode", "Dark Mode", "hrs", Color(0xFF546E7A), "Mental"),
    MetricDef("mindfulness", "Mindfulness", "min", Color(0xFF80CBC4), "Mental"),
    // Diet — macros
    MetricDef("calories", "Calories", "kcal", Color(0xFFFFAB91), "Diet"),
    MetricDef("protein", "Protein", "g", Color(0xFFEF9A9A), "Diet"),
    MetricDef("carbs", "Carbs", "g", Color(0xFFFFCC80), "Diet"),
    MetricDef("fat", "Fat", "g", Color(0xFFFFE082), "Diet"),
    MetricDef("fiber", "Fiber", "g", Color(0xFFA5D6A7), "Diet"),
    MetricDef("sugar", "Sugar", "g", Color(0xFFF48FB1), "Diet"),
    MetricDef("sodium", "Sodium", "mg", Color(0xFFB39DDB), "Diet"),
    MetricDef("caffeine", "Caffeine", "mg", Color(0xFFAED581), "Diet"),
    MetricDef("cholesterol", "Cholesterol", "mg", Color(0xFFFFAB91), "Diet"),
    MetricDef("sat_fat", "Sat. Fat", "g", Color(0xFFEF9A9A), "Diet"),
    MetricDef("unsat_fat", "Unsat. Fat", "g", Color(0xFFFFCC80), "Diet"),
    MetricDef("trans_fat", "Trans Fat", "g", Color(0xFFE57373), "Diet"),
    MetricDef("hydration", "Hydration", "ml", Color(0xFF29B6F6), "Diet"),
    // Diet — minerals
    MetricDef("potassium", "Potassium", "mg", Color(0xFF80CBC4), "Diet"),
    MetricDef("calcium", "Calcium", "mg", Color(0xFFB0BEC5), "Diet"),
    MetricDef("iron", "Iron", "mg", Color(0xFFBCAAA4), "Diet"),
    MetricDef("magnesium", "Magnesium", "mg", Color(0xFF80DEEA), "Diet"),
    MetricDef("zinc", "Zinc", "mg", Color(0xFFCE93D8), "Diet"),
    MetricDef("selenium", "Selenium", "mcg", Color(0xFFFFD54F), "Diet"),
    MetricDef("phosphorus", "Phosphorus", "mg", Color(0xFFA5D6A7), "Diet"),
    MetricDef("copper", "Copper", "mg", Color(0xFFFFAB91), "Diet"),
    MetricDef("manganese", "Manganese", "mg", Color(0xFFB39DDB), "Diet"),
    // Diet — vitamins
    MetricDef("vitamin_a", "Vitamin A", "mcg", Color(0xFFFFCC80), "Diet"),
    MetricDef("vitamin_c", "Vitamin C", "mg", Color(0xFFFFE082), "Diet"),
    MetricDef("vitamin_d", "Vitamin D", "mcg", Color(0xFFFFF176), "Diet"),
    MetricDef("vitamin_e", "Vitamin E", "mg", Color(0xFFA5D6A7), "Diet"),
    MetricDef("vitamin_k", "Vitamin K", "mcg", Color(0xFF81C784), "Diet"),
    MetricDef("vitamin_b6", "Vitamin B6", "mg", Color(0xFF80CBC4), "Diet"),
    MetricDef("vitamin_b12", "Vitamin B12", "mcg", Color(0xFF4FC3F7), "Diet"),
    MetricDef("thiamin", "Thiamin", "mg", Color(0xFF90CAF9), "Diet"),
    MetricDef("riboflavin", "Riboflavin", "mg", Color(0xFF7986CB), "Diet"),
    MetricDef("niacin", "Niacin", "mg", Color(0xFF5C6BC0), "Diet"),
    MetricDef("folate", "Folate", "mcg", Color(0xFF7E57C2), "Diet"),
    MetricDef("biotin", "Biotin", "mcg", Color(0xFF9575CD), "Diet"),
    MetricDef("panto_acid", "Panto. Acid", "mg", Color(0xFFBA68C8), "Diet"),
    // Diet — food risks (0=none, 1=low, 2=medium, 3=high)
    MetricDef("tyramine", "Tyramine", "risk", Color(0xFFFFAB40), "Diet"),
    MetricDef("alcohol", "Alcohol", "risk", Color(0xFFEF5350), "Diet"),
    MetricDef("gluten", "Gluten", "risk", Color(0xFFFFD54F), "Diet"),
)

@Composable
fun InsightsScreen(navController: NavHostController, vm: InsightsViewModel = viewModel()) {
    val owner = LocalContext.current as ViewModelStoreOwner
    val ctx: Context = LocalContext.current.applicationContext
    val authVm: AuthViewModel = viewModel(owner)
    val auth by authVm.state.collectAsState()
    LaunchedEffect(auth.accessToken) { auth.accessToken?.takeIf { it.isNotBlank() }?.let { vm.load(ctx, it) } }

    val migraines by vm.migraines.collectAsState()
    val spiderLoading by vm.spiderLoading.collectAsState()
    val allDailyMetrics by vm.allDailyMetrics.collectAsState()
    val linkedItems by vm.selectedLinkedItems.collectAsState()
    val linkedLoading by vm.linkedItemsLoading.collectAsState()
    val scrollState = rememberScrollState()
    val zone = ZoneId.systemDefault()
    val sorted = remember(migraines) { migraines.sortedByDescending { it.start } }
    val selIdx by vm.selectedMigraineIndex.collectAsState()
    LaunchedEffect(sorted.size) { if (selIdx >= sorted.size && sorted.isNotEmpty()) vm.selectMigraine(0) }
    val sel = sorted.getOrNull(selIdx)
    LaunchedEffect(sel?.id) { sel?.id?.let { vm.loadLinkedItems(it) } }

    // Window days (shared across all insight screens)
    val wBefore by vm.windowDaysBefore.collectAsState()
    val wAfter by vm.windowDaysAfter.collectAsState()
    val wStart = sel?.start?.minus(Duration.ofDays(wBefore))
    val wEnd = (sel?.end ?: sel?.start)?.plus(Duration.ofDays(wAfter))
    val windowDates = remember(wStart, wEnd) {
        if (wStart == null || wEnd == null) emptySet()
        else {
            val f = LocalDate.ofInstant(wStart, zone)
            val t = LocalDate.ofInstant(wEnd, zone)
            generateSequence(f) { it.plusDays(1) }.takeWhile { !it.isAfter(t) }.map { it.toString() }.toSet()
        }
    }

    val allMissed by vm.allMissedActivities.collectAsState()
    val allActs by vm.allActivities.collectAsState()

    // Events from linked items + activities/missed filtered by migraine
    val windowEvents = remember(linkedItems, allMissed, allActs, sel?.id) {
        val actsForMigraine = allActs.filter { it.migraineId == sel?.id }
        val missedForMigraine = allMissed.filter { it.migraineId == sel?.id }
        buildEventMarkers(linkedItems, actsForMigraine, missedForMigraine)
    }

    // Auto-select metrics based on ALL automated items linked to this migraine
    val templateMap by vm.labelToMetricMap.collectAsState()
    val autoSelectedKeys = remember(windowEvents, templateMap) {
        windowEvents
            .filter { it.isAutomated }
            .mapNotNull { ev -> vm.labelToMetricKey(ev.name) }
            .toSet()
    }

    // Available metrics (only those with data in window)
    val available = remember(allDailyMetrics, windowDates) {
        AllMetricDefs.filter { d ->
            allDailyMetrics[d.key]?.any { it.date in windowDates } == true
        }
    }

    // Enabled metrics: auto-selected from triggers + user toggles (stored in VM)
    val userToggledKeys by vm.userToggledMetrics.collectAsState()

    val enabledKeys = autoSelectedKeys + userToggledKeys

    val enabledSeries = remember(available, enabledKeys, allDailyMetrics, windowDates) {
        available.filter { it.key in enabledKeys }.map { d ->
            MetricSeries(d.key, d.label, d.unit, d.color,
                allDailyMetrics[d.key]!!
                    .filter { it.date in windowDates }
                    .map { DailyMetricPoint(it.date, it.value) })
        }
    }

    val windowMigs = remember(migraines, wStart, wEnd) {
        if (wStart == null || wEnd == null) listOfNotNull(sel)
        else migraines.filter { m ->
            val e = m.end ?: m.start
            !m.start.isAfter(wEnd) && !e.isBefore(wStart)
        }
    }

    // Spiders
    val triggerSpider by vm.triggerSpider.collectAsState()
    val prodromeSpider by vm.prodromeSpider.collectAsState()
    val symptomSpider by vm.symptomSpider.collectAsState()
    val medicineSpider by vm.medicineSpider.collectAsState()
    val reliefSpider by vm.reliefSpider.collectAsState()
    val activitySpider by vm.activitySpider.collectAsState()
    val missedActivitySpider by vm.missedActivitySpider.collectAsState()
    val locationSpider by vm.locationSpider.collectAsState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {

            // ── Full Report card ──
            HeroCard(modifier = Modifier.clickable { navController.navigate(Routes.INSIGHTS_REPORT) }) {
                Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Column(Modifier.weight(1f)) {
                        Text("Full Report", color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                        Text("Filter, compare & explore all your migraine data",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall)
                    }
                    Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
                }
            }

            // ── Timeline card ──
            HeroCard(modifier = Modifier.clickable { navController.navigate(Routes.INSIGHTS_DETAIL) }) {
                Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Text("Migraine Timeline", color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.weight(1f))
                    Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
                }

                if (sorted.isEmpty()) {
                    Text("No migraines logged yet", color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
                    return@HeroCard
                }

                MigraineSelector(sorted, selIdx, sel,
                    { if (selIdx < sorted.size - 1) vm.selectMigraine(selIdx + 1) },
                    { if (selIdx > 0) vm.selectMigraine(selIdx - 1) })

                if (linkedLoading) {
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(Modifier.size(16.dp), strokeWidth = 2.dp, color = AppTheme.AccentPurple)
                    }
                } else {
                    // Event count chips (categories only — no "Auto" chip)
                    val catCounts = remember(windowEvents) {
                        windowEvents.groupBy { it.category }.mapValues { it.value.size }
                    }
                    if (catCounts.isNotEmpty()) {
                        Row(Modifier.fillMaxWidth().horizontalScroll(rememberScrollState()),
                            horizontalArrangement = Arrangement.spacedBy(10.dp),
                            verticalAlignment = Alignment.CenterVertically) {
                            catCounts.forEach { (c, n) ->
                                Chip(n, c, EventCategoryColors[c] ?: AppTheme.AccentPurple)
                            }
                        }
                    }
                }

                // Metric picker chips (grouped by category)
                // ── REMOVED: metric picker is on the detail screen ──

                // Graph (compact)
                InsightsTimelineGraph(
                    windowMigs, windowEvents, enabledSeries,
                    wStart, wEnd, sel?.start,
                    Modifier.fillMaxWidth().height(220.dp))

                Text("Window around migraine", color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall,
                    textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())

                WindowDaysControl(wBefore, wAfter, onChanged = { b, a -> vm.setWindowDays(b, a) })
            }

            Spacer(Modifier.height(4.dp))

            // Spider cards
            if (spiderLoading) {
                BaseCard {
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center,
                        verticalAlignment = Alignment.CenterVertically) {
                        CircularProgressIndicator(Modifier.size(20.dp), strokeWidth = 2.dp, color = AppTheme.AccentPurple)
                        Spacer(Modifier.width(12.dp))
                        Text("Loading insights...", color = AppTheme.SubtleTextColor)
                    }
                }
            } else {
                val ml by vm.migraines.collectAsState()
                if (symptomSpider != null && symptomSpider!!.totalLogged > 0) {
                    SymptomsInsightCard(ml) {
                        navController.navigate("${Routes.INSIGHTS_BREAKDOWN}/${symptomSpider!!.logType}")
                    }
                }
                val medEff by vm.medicineEffectiveness.collectAsState()
                val relEff by vm.reliefEffectiveness.collectAsState()
                listOf(prodromeSpider, triggerSpider, medicineSpider, reliefSpider,
                    locationSpider, activitySpider, missedActivitySpider).forEach { sp ->
                    if (sp != null && sp.totalLogged > 0) {
                        val eff = when (sp.logType) {
                            "Medicines" -> if (medEff.isNotEmpty() && sp.axes.size >= 3) {
                                val m = medEff.associate { it.category to it.avgRelief }
                                sp.axes.map { SpiderAxis(it.label, m[it.label] ?: 0f, 3f) }
                            } else null
                            "Reliefs" -> if (relEff.isNotEmpty() && sp.axes.size >= 3) {
                                val m = relEff.associate { it.category to it.avgRelief }
                                sp.axes.map { SpiderAxis(it.label, m[it.label] ?: 0f, 3f) }
                            } else null
                            else -> null
                        }
                        SpiderInsightCard(sp, {
                            navController.navigate("${Routes.INSIGHTS_BREAKDOWN}/${sp.logType}")
                        }, eff)
                    }
                }
            }
        }
    }
}

// ═══════ Composable helpers ═══════

@Composable
private fun MigraineSelector(
    sorted: List<MigraineSpan>, idx: Int, sel: MigraineSpan?,
    onPrev: () -> Unit, onNext: () -> Unit
) {
    val z = ZoneId.systemDefault()
    val df = DateTimeFormatter.ofPattern("MMM d, yyyy").withZone(z)
    val tf = DateTimeFormatter.ofPattern("h:mm a").withZone(z)
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically) {
        IconButton(onClick = onPrev, enabled = idx < sorted.size - 1) {
            Icon(Icons.AutoMirrored.Filled.ArrowBack, "Older",
                tint = if (idx < sorted.size - 1) AppTheme.AccentPurple
                else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                modifier = Modifier.size(22.dp))
        }
        Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.weight(1f)) {
            Text(sel?.label ?: "Migraine", color = Color.White,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold),
                maxLines = 1, overflow = TextOverflow.Ellipsis)
            if (sel != null) {
                Text(df.format(sel.start) + " • " + tf.format(sel.start),
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                val e = sel.end
                if (e != null) {
                    val d = Duration.between(sel.start, e)
                    val hStr = if (d.toHours() > 0) "${d.toHours()}h " else ""
                    Text("$hStr${d.minusHours(d.toHours()).toMinutes()}m • Severity: ${sel.severity ?: "–"}/10",
                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                } else {
                    Text("Severity: ${sel.severity ?: "–"}/10",
                        color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
            Text("${idx + 1} of ${sorted.size}", color = AppTheme.AccentPurple,
                style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
        }
        IconButton(onClick = onNext, enabled = idx > 0) {
            Icon(Icons.AutoMirrored.Filled.ArrowForward, "Newer",
                tint = if (idx > 0) AppTheme.AccentPurple
                else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                modifier = Modifier.size(22.dp))
        }
    }
}

@Composable
private fun Chip(n: Int, label: String, color: Color) {
    Row(verticalAlignment = Alignment.CenterVertically) {
        Box(Modifier.size(8.dp).clip(CircleShape).background(color))
        Spacer(Modifier.width(4.dp))
        Text("$n", color = Color.White,
            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold))
        Spacer(Modifier.width(2.dp))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
    }
}

// ═══════ Spider/Symptom cards ═══════

@Composable
private fun SpiderInsightCard(data: SpiderData, onClick: () -> Unit, secondAxes: List<SpiderAxis>? = null) {
    val color = colorForLogType(data.logType)
    BaseCard(modifier = Modifier.clickable(onClick = onClick)) {
        Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            Canvas(Modifier.size(24.dp)) {
                HubIcons.run {
                    when (data.logType) {
                        "Triggers" -> drawTriggerBolt(color)
                        "Prodromes" -> drawProdromeEye(color)
                        "Symptoms" -> drawMigraineStarburst(color)
                        "Medicines" -> drawMedicinePill(color)
                        "Reliefs" -> drawReliefLeaf(color)
                        "Activities" -> drawActivityPulse(color)
                        "Missed Activities" -> drawMissedActivity(color)
                        "Locations" -> drawLocationPin(color)
                    }
                }
            }
            Spacer(Modifier.width(10.dp))
            Column(Modifier.weight(1f)) {
                Text(data.logType, color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Text("${data.totalLogged} logged • ${data.breakdown.size} categories",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }
            Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodyMedium)
        }
        Spacer(Modifier.height(8.dp))
        if (data.axes.size >= 3) {
            Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                SpiderChart(axes = data.axes, accentColor = color, size = 220.dp,
                    secondAxes = secondAxes, secondColor = Color.White.copy(alpha = 0.6f))
            }
        } else {
            StackedProportionalBar(axes = data.axes, accentColor = color)
        }
    }
}

@Composable
private fun SymptomsInsightCard(ms: List<MigraineSpan>, onClick: () -> Unit) {
    val vm: InsightsViewModel = viewModel(LocalContext.current as ViewModelStoreOwner)
    val pcs by vm.painCharSpider.collectAsState()
    val acs by vm.accompSpider.collectAsState()
    BaseCard(modifier = Modifier.clickable(onClick = onClick)) {
        Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            Canvas(Modifier.size(24.dp)) { HubIcons.run { drawMigraineStarburst(AppTheme.AccentPink) } }
            Spacer(Modifier.width(10.dp))
            Column(Modifier.weight(1f)) {
                Text("Symptoms", color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Text("${ms.size} migraines logged",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }
            Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodyMedium)
        }
        pcs?.takeIf { it.axes.isNotEmpty() }?.let { data ->
            Spacer(Modifier.height(12.dp))
            Text("Pain Character", color = Color(0xFFEF5350),
                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
            Spacer(Modifier.height(4.dp))
            if (data.axes.size >= 3) {
                Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    SpiderChart(axes = data.axes, accentColor = Color(0xFFEF5350), size = 200.dp)
                }
            } else StackedProportionalBar(axes = data.axes, accentColor = Color(0xFFEF5350))
        }
        acs?.takeIf { it.axes.isNotEmpty() }?.let { data ->
            Spacer(Modifier.height(16.dp))
            Text("Accompanying Experience", color = Color(0xFFBA68C8),
                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
            Spacer(Modifier.height(4.dp))
            if (data.axes.size >= 3) {
                Box(Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    SpiderChart(axes = data.axes, accentColor = Color(0xFFBA68C8), size = 200.dp)
                }
            } else StackedProportionalBar(axes = data.axes, accentColor = Color(0xFFBA68C8))
        }
    }
}


title: InsightsTimelineGraph.kt
text:
package com.migraineme

import android.graphics.Paint
import android.graphics.Typeface
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.PathEffect
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import java.time.Duration
import java.time.Instant
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min
import kotlin.math.roundToInt

private data class HitTarget(val x: Float, val y: Float, val label: String)
private val GridColor = Color.White.copy(alpha = 0.06f)
private val AxisColor = Color.White.copy(alpha = 0.12f)
private val MigBarColor = Color(0xFFB97BFF)
private val HighlightCol = Color(0xFFFF7BB0)
private val PopupBg = Color(0xFF2A0C3C)
private val AutoDotColor = Color(0xFFFFD54F)

@Composable
fun InsightsTimelineGraph(
    migraines: List<MigraineSpan>, events: List<EventMarker>, metricSeries: List<MetricSeries>,
    windowStart: Instant?, windowEnd: Instant?, highlightMigraineStart: Instant? = null, modifier: Modifier = Modifier
) {
    Surface(modifier = modifier.fillMaxWidth(), color = Color(0xFF1A0628).copy(alpha = 0.85f), shape = RoundedCornerShape(14.dp)) {
        if (windowStart != null && windowEnd != null) CoreCanvas(migraines, events, metricSeries, windowStart, windowEnd, highlightMigraineStart, Modifier.fillMaxSize().padding(8.dp))
    }
}

@Composable
fun InsightsTimelineGraphInteractive(
    migraines: List<MigraineSpan>, reliefs: List<ReliefSpan>, triggers: List<TriggerPoint>, meds: List<MedicinePoint>,
    hOffsetPx: androidx.compose.runtime.MutableState<Float>, timeSpan: TimeSpan, modifier: Modifier
) {
    val events = remember(triggers, meds, reliefs) {
        val ev = mutableListOf<EventMarker>()
        triggers.forEach { ev += EventMarker(it.at, null, it.name, "Trigger", null, EventCategoryColors["Trigger"]!!) }
        meds.forEach { ev += EventMarker(it.at, null, it.name, "Medicine", it.amount?.let { a -> "Amount: $a" }, EventCategoryColors["Medicine"]!!) }
        reliefs.forEach { ev += EventMarker(it.start, it.end, it.name, "Relief", null, EventCategoryColors["Relief"]!!) }
        ev.sortedBy { it.at }
    }
    val now = Instant.now()
    Surface(modifier = modifier.fillMaxWidth(), color = Color(0xFF1A0628).copy(alpha = 0.85f), shape = RoundedCornerShape(14.dp)) {
        CoreCanvas(migraines, events, emptyList(), now.minusMillis(timeSpan.millis), now, null, Modifier.fillMaxSize().padding(12.dp))
    }
}

@Composable
private fun CoreCanvas(
    migraines: List<MigraineSpan>, events: List<EventMarker>, metricSeries: List<MetricSeries>,
    windowStart: Instant, windowEnd: Instant, highlightMigraineStart: Instant?, modifier: Modifier
) {
    val density = LocalDensity.current
    var cW by remember { mutableStateOf(0) }; var cH by remember { mutableStateOf(0) }
    var popup by remember { mutableStateOf<HitTarget?>(null) }
    val zone = ZoneId.systemDefault(); val visMs = Duration.between(windowStart, windowEnd).toMillis().coerceAtLeast(1)
    val eventCats = remember(events) { events.map { it.category }.distinct() }
    val sortedEvents = remember(events) { events.sortedBy { it.at } }
    val datePaint = remember { Paint().apply { color = Color.White.copy(alpha = 0.5f).toArgb(); textSize = 24f; isAntiAlias = true } }
    val catPaint = remember { Paint().apply { color = Color.White.copy(alpha = 0.35f).toArgb(); textSize = 20f; isAntiAlias = true; typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD) } }
    val numPaint = remember { Paint().apply { color = Color.White.copy(alpha = 0.85f).toArgb(); textSize = 14f; isAntiAlias = true; typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD); textAlign = Paint.Align.CENTER } }

    Box(modifier = modifier.onSizeChanged { cW = it.width; cH = it.height }) {
        Canvas(Modifier.matchParentSize().pointerInput(windowStart, windowEnd) {
            detectTapGestures { pos ->
                val w = cW.toFloat(); val h = cH.toFloat(); val x0 = 8f; val x1 = w - 8f
                fun xOf(t: Instant): Float { val cl = t.clamp(windowStart, windowEnd); return x0 + (cl.toEpochMilli() - windowStart.toEpochMilli()).toFloat() / visMs * (x1 - x0) }
                val migBot = h * 0.16f; val evTop = migBot + 4f; val evBot = if (eventCats.isNotEmpty()) h * 0.48f else evTop; val now = Instant.now()
                val hits = mutableListOf<HitTarget>()
                migraines.forEach { m -> val xs = xOf(m.start); val xe = xOf(m.end ?: now); hits += HitTarget((xs + xe) / 2f, migBot / 2f, "${m.label ?: "Migraine"}\nSeverity: ${m.severity ?: "–"}/10\n${hDur(m.start, m.end ?: now)}") }
                val cc = eventCats.size.coerceAtLeast(1); val rh = (evBot - evTop) / cc; val hitMin = 14f
                val hitOffsets = mutableListOf<Pair<Float, Float>>() // (cx, cy) of placed dots
                sortedEvents.forEachIndexed { idx, ev -> val ci = eventCats.indexOf(ev.category).coerceAtLeast(0); val auto = if (ev.isAutomated) " ⚡auto" else ""
                    val rcy = evTop + ci * rh + rh / 2f; val ex = xOf(ev.at)
                    val nearby = hitOffsets.filter { kotlin.math.abs(it.first - ex) < hitMin && kotlin.math.abs(it.second - rcy) < 1f }
                    val ox = if (nearby.isEmpty()) 0f else { val n = nearby.size; val s = if (n % 2 == 0) -1f else 1f; s * ((n + 1) / 2) * hitMin }
                    hitOffsets.add(Pair(ex + ox, rcy))
                    hits += HitTarget(ex + ox, rcy, "#${idx + 1} ${ev.name}$auto${ev.detail?.let { "\n$it" } ?: ""}") }
                val near = hits.minByOrNull { hypot(it.x - pos.x, it.y - pos.y) }
                popup = if (near != null && hypot(near.x - pos.x, near.y - pos.y) <= 56f) near else null
            }
        }) {
            val now = Instant.now(); val w = size.width; val h = size.height; val x0 = 8f; val x1 = w - 8f; val bPad = 32f
            fun xOf(t: Instant): Float { val cl = t.clamp(windowStart, windowEnd); return x0 + (cl.toEpochMilli() - windowStart.toEpochMilli()).toFloat() / visMs * (x1 - x0) }
            val migBot = h * 0.16f; val evTop = migBot + 4f; val catCnt = eventCats.size; val evBot = if (catCnt > 0) h * 0.48f else evTop; val metTop = evBot + 8f; val metBot = h - bPad

            // X-axis date labels — skip days to prevent overlap
            val totalDays = ChronoUnit.DAYS.between(
                ZonedDateTime.ofInstant(windowStart, zone).truncatedTo(ChronoUnit.DAYS),
                ZonedDateTime.ofInstant(windowEnd, zone).truncatedTo(ChronoUnit.DAYS)
            ).toInt() + 1
            // Show at most ~6 labels so they never overlap
            val labelEveryN = when {
                totalDays <= 7 -> 1
                totalDays <= 14 -> 2
                totalDays <= 21 -> 3
                totalDays <= 42 -> 5
                else -> 7
            }
            val dateFmt = if (totalDays <= 14)
                DateTimeFormatter.ofPattern("d").withZone(zone)
            else
                DateTimeFormatter.ofPattern("d").withZone(zone)
            val monthFmt = DateTimeFormatter.ofPattern("MMM").withZone(zone)

            var day = ZonedDateTime.ofInstant(windowStart, zone).truncatedTo(ChronoUnit.DAYS)
            val endDay = ZonedDateTime.ofInstant(windowEnd, zone).truncatedTo(ChronoUnit.DAYS).plusDays(1)
            var dayIdx = 0
            while (!day.isAfter(endDay)) {
                val xi = xOf(day.toInstant())
                // Grid line for every day
                drawLine(GridColor, Offset(xi, 0f), Offset(xi, h - bPad), 1f)
                // Label only every Nth day
                if (dayIdx % labelEveryN == 0) {
                    val dayStr = dateFmt.format(day)
                    val monthStr = monthFmt.format(day)
                    // Show month on first label or when month changes
                    val showMonth = dayIdx == 0 || day.dayOfMonth <= labelEveryN
                    val label = if (showMonth) "$monthStr $dayStr" else dayStr
                    val tw = datePaint.measureText(label)
                    drawContext.canvas.nativeCanvas.drawText(
                        label, xi - tw / 2f, h - 6f, datePaint
                    )
                }
                day = day.plusDays(1)
                dayIdx++
            }
            drawLine(AxisColor, Offset(x0, migBot), Offset(x1, migBot), 1f); if (catCnt > 0) drawLine(AxisColor, Offset(x0, evBot), Offset(x1, evBot), 1f)

            if (highlightMigraineStart != null) migraines.find { it.start == highlightMigraineStart }?.let { sel ->
                val xs = xOf(sel.start); val xe = xOf(sel.end ?: now); val bL = min(xs, xe); val bR = max(xs, xe)
                drawRect(brush = Brush.verticalGradient(listOf(HighlightCol.copy(alpha = 0.10f), HighlightCol.copy(alpha = 0.02f))), topLeft = Offset(bL, 0f), size = Size((bR - bL).coerceAtLeast(4f), h - bPad))
                val dash = PathEffect.dashPathEffect(floatArrayOf(8f, 6f)); drawLine(HighlightCol.copy(alpha = 0.4f), Offset(xs, 0f), Offset(xs, h - bPad), 1.5f, pathEffect = dash)
                if (sel.end != null) drawLine(HighlightCol.copy(alpha = 0.3f), Offset(xe, 0f), Offset(xe, h - bPad), 1.5f, pathEffect = dash)
            }

            val barY = migBot / 2f; val minStk = with(density) { 7.dp.toPx() }; val maxStk = with(density) { 14.dp.toPx() }
            migraines.sortedBy { it.start }.forEach { m -> val xs = xOf(m.start); val xe = xOf(m.end ?: now); val sev = (m.severity ?: 0).coerceIn(0, 10); val thick = minStk + (maxStk - minStk) * (sev / 10f)
                val isHl = highlightMigraineStart != null && m.start == highlightMigraineStart; val col = if (isHl) HighlightCol else MigBarColor
                drawLine(col.copy(alpha = 0.15f), Offset(xs, barY), Offset(xe, barY), thick + 8f, StrokeCap.Round); drawLine(col.copy(alpha = 0.8f), Offset(xs, barY), Offset(xe, barY), thick, StrokeCap.Round)
                if (sev > 0) drawContext.canvas.nativeCanvas.drawText("$sev", (xs + xe) / 2f - 6f, barY + 4f, Paint().apply { color = Color.White.toArgb(); textSize = 20f; isAntiAlias = true; typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD) }) }

            if (catCnt > 0) { val rowH = (evBot - evTop) / catCnt
                eventCats.forEachIndexed { ci, catName -> val rcy = evTop + ci * rowH + rowH / 2f; drawContext.canvas.nativeCanvas.drawText(catName, x0 + 2f, rcy + 5f, catPaint); if (ci > 0) drawLine(GridColor, Offset(x0, evTop + ci * rowH), Offset(x1, evTop + ci * rowH), 0.5f) }

                // Pre-compute positions with overlap offset
                data class DotPos(val idx: Int, val ev: EventMarker, val cx: Float, val cy: Float, val ox: Float, val oy: Float)
                val dotPositions = mutableListOf<DotPos>()
                val minSpacing = 14f // min px between dot centers before we spread

                sortedEvents.forEachIndexed { idx, ev ->
                    val ci = eventCats.indexOf(ev.category).coerceAtLeast(0)
                    val rcy = evTop + ci * rowH + rowH / 2f
                    val ex = xOf(ev.at)

                    // Find how many prior dots in same row are too close
                    val nearby = dotPositions.filter { kotlin.math.abs(it.cx - ex) < minSpacing && kotlin.math.abs(it.cy - rcy) < 1f }
                    val offsetX = if (nearby.isEmpty()) 0f else {
                        val n = nearby.size
                        // Alternate left/right: 0, +14, -14, +28, -28...
                        val sign = if (n % 2 == 0) -1f else 1f
                        sign * ((n + 1) / 2) * minSpacing
                    }
                    dotPositions.add(DotPos(idx, ev, ex, rcy, ex + offsetX, rcy))
                }

                // Draw dots at offset positions
                dotPositions.forEach { dp ->
                    val ev = dp.ev; val dx = dp.ox; val dy = dp.oy
                    if (ev.endAt != null) { val ex2 = xOf(ev.endAt); drawLine(ev.color.copy(alpha = 0.6f), Offset(dp.cx, dy), Offset(ex2, dy), 6f, StrokeCap.Round) }
                    if (ev.isAutomated) { drawCircle(AutoDotColor.copy(alpha = 0.2f), 12f, Offset(dx, dy)); drawCircle(AutoDotColor, 6f, Offset(dx, dy)) }
                    else { drawCircle(ev.color.copy(alpha = 0.15f), 10f, Offset(dx, dy)); drawCircle(ev.color, 5f, Offset(dx, dy)) }
                    // Number label above dot
                    drawContext.canvas.nativeCanvas.drawText("${dp.idx + 1}", dx, dy - 10f, numPaint)
                }
            }

            if (metricSeries.isNotEmpty() && metTop < metBot) { val chartH = metBot - metTop
                metricSeries.forEach { series -> if (series.points.size < 2) return@forEach; val sorted = series.points.sortedBy { it.date }; val minV = sorted.minOf { it.value }; val maxV = sorted.maxOf { it.value }; val range = (maxV - minV).coerceAtLeast(0.01)
                    fun dateX(ds: String): Float { val ld = java.time.LocalDate.parse(ds); return xOf(ld.atStartOfDay(zone).toInstant().plusSeconds(43200)) }
                    fun valY(v: Double): Float { return metBot - ((v - minV) / range).toFloat().coerceIn(0f, 1f) * chartH * 0.85f }
                    val path = Path(); sorted.forEachIndexed { i, pt -> if (i == 0) path.moveTo(dateX(pt.date), valY(pt.value)) else path.lineTo(dateX(pt.date), valY(pt.value)) }
                    drawPath(path, series.color.copy(alpha = 0.1f), style = Stroke(width = 6f, cap = StrokeCap.Round)); drawPath(path, series.color.copy(alpha = 0.7f), style = Stroke(width = 2.5f, cap = StrokeCap.Round))
                    sorted.forEach { pt -> drawCircle(series.color.copy(alpha = 0.3f), 5f, Offset(dateX(pt.date), valY(pt.value))); drawCircle(series.color, 2.5f, Offset(dateX(pt.date), valY(pt.value))) }
                    val first = sorted.first(); drawContext.canvas.nativeCanvas.drawText("${series.label}: ${"%.1f".format(first.value)}${series.unit}", dateX(first.date) + 4f, valY(first.value) - 6f, Paint().apply { color = series.color.copy(alpha = 0.5f).toArgb(); textSize = 17f; isAntiAlias = true })
                    if (sorted.size > 2) { val last = sorted.last(); drawContext.canvas.nativeCanvas.drawText("${"%.1f".format(last.value)}", dateX(last.date) - 12f, valY(last.value) - 6f, Paint().apply { color = series.color.copy(alpha = 0.5f).toArgb(); textSize = 17f; isAntiAlias = true }) }
                }
            }
        }
        popup?.let { hit -> val offX = (hit.x - 120f).roundToInt().coerceAtLeast(0); val offY = (hit.y - 70f).roundToInt().coerceAtLeast(0)
            Card(Modifier.offset { IntOffset(offX, offY) }, colors = CardDefaults.cardColors(containerColor = PopupBg), shape = RoundedCornerShape(10.dp), elevation = CardDefaults.cardElevation(8.dp)) {
                Text(hit.label, Modifier.padding(horizontal = 12.dp, vertical = 8.dp), style = MaterialTheme.typography.bodySmall, color = Color.White.copy(alpha = 0.9f)) } }
    }
}

private fun Instant.clamp(a: Instant, b: Instant): Instant = when { this.isBefore(a) -> a; this.isAfter(b) -> b; else -> this }
private fun hDur(s: Instant, e: Instant): String { val d = Duration.between(s, e).abs(); val h = d.toHours(); val m = d.minusHours(h).toMinutes(); return buildString { if (h > 0) append("${h}h "); append("${m}m") } }


title: InsightsViewModel.kt
text:
// FILE: InsightsViewModel.kt
package com.migraineme

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONArray
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit

data class CategoryBreakdown(
    val categoryName: String,
    val totalCount: Int,
    val items: List<Pair<String, Int>>
)

data class SpiderData(
    val logType: String,
    val axes: List<SpiderAxis>,
    val totalLogged: Int,
    val breakdown: List<CategoryBreakdown>
)

class InsightsViewModel : ViewModel() {

    // ═══════ Core flows ═══════

    private val _migraines = MutableStateFlow<List<MigraineSpan>>(emptyList())
    val migraines: StateFlow<List<MigraineSpan>> = _migraines

    private val _reliefs = MutableStateFlow<List<ReliefSpan>>(emptyList())
    val reliefs: StateFlow<List<ReliefSpan>> = _reliefs

    private val _triggers = MutableStateFlow<List<TriggerPoint>>(emptyList())
    val triggers: StateFlow<List<TriggerPoint>> = _triggers

    private val _medicines = MutableStateFlow<List<MedicinePoint>>(emptyList())
    val medicines: StateFlow<List<MedicinePoint>> = _medicines

    // Sleep
    data class SleepDurationRow(val date: String, val hours: Double)
    data class SleepDisturbancesRow(val date: String, val count: Int)
    data class SleepStagesRow(val date: String, val swsHm: Double, val remHm: Double, val lightHm: Double)

    private val _sleepDuration = MutableStateFlow<List<SleepDurationRow>>(emptyList())
    val sleepDuration: StateFlow<List<SleepDurationRow>> = _sleepDuration

    private val _sleepDisturbances = MutableStateFlow<List<SleepDisturbancesRow>>(emptyList())
    val sleepDisturbances: StateFlow<List<SleepDisturbancesRow>> = _sleepDisturbances

    private val _sleepStages = MutableStateFlow<List<SleepStagesRow>>(emptyList())
    val sleepStages: StateFlow<List<SleepStagesRow>> = _sleepStages

    // Location
    data class UserLocationRow(val date: String, val latitude: Double, val longitude: Double)
    private val _userLocations = MutableStateFlow<List<UserLocationRow>>(emptyList())
    val userLocations: StateFlow<List<UserLocationRow>> = _userLocations

    private val _latestSleepDate = MutableStateFlow<String?>(null)
    val latestSleepDate: StateFlow<String?> = _latestSleepDate

    // ═══════ Spider chart flows ═══════

    private val _triggerSpider = MutableStateFlow<SpiderData?>(null)
    val triggerSpider: StateFlow<SpiderData?> = _triggerSpider

    private val _prodromeSpider = MutableStateFlow<SpiderData?>(null)
    val prodromeSpider: StateFlow<SpiderData?> = _prodromeSpider

    private val _symptomSpider = MutableStateFlow<SpiderData?>(null)
    val symptomSpider: StateFlow<SpiderData?> = _symptomSpider

    private val _painCharSpider = MutableStateFlow<SpiderData?>(null)
    val painCharSpider: StateFlow<SpiderData?> = _painCharSpider

    private val _accompSpider = MutableStateFlow<SpiderData?>(null)
    val accompSpider: StateFlow<SpiderData?> = _accompSpider

    private val _painLocationSpider = MutableStateFlow<SpiderData?>(null)
    val painLocationSpider: StateFlow<SpiderData?> = _painLocationSpider

    private val _severityCounts = MutableStateFlow<List<Pair<Int, Int>>>(emptyList())
    val severityCounts: StateFlow<List<Pair<Int, Int>>> = _severityCounts

    data class DurationStats(
        val avgHours: Float, val minHours: Float, val maxHours: Float, val durations: List<Float>
    )
    private val _durationStats = MutableStateFlow<DurationStats?>(null)
    val durationStats: StateFlow<DurationStats?> = _durationStats

    private val _painLocationCounts = MutableStateFlow<List<Pair<String, Int>>>(emptyList())
    val painLocationCounts: StateFlow<List<Pair<String, Int>>> = _painLocationCounts

    private val _medicineSpider = MutableStateFlow<SpiderData?>(null)
    val medicineSpider: StateFlow<SpiderData?> = _medicineSpider

    private val _reliefSpider = MutableStateFlow<SpiderData?>(null)
    val reliefSpider: StateFlow<SpiderData?> = _reliefSpider

    data class ReliefEffectiveness(val category: String, val count: Int, val avgRelief: Float)

    private val _medicineEffectiveness = MutableStateFlow<List<ReliefEffectiveness>>(emptyList())
    val medicineEffectiveness: StateFlow<List<ReliefEffectiveness>> = _medicineEffectiveness

    private val _reliefEffectiveness = MutableStateFlow<List<ReliefEffectiveness>>(emptyList())
    val reliefEffectiveness: StateFlow<List<ReliefEffectiveness>> = _reliefEffectiveness

    private val _medicineItemEffectiveness = MutableStateFlow<Map<String, Float>>(emptyMap())
    val medicineItemEffectiveness: StateFlow<Map<String, Float>> = _medicineItemEffectiveness

    private val _reliefItemEffectiveness = MutableStateFlow<Map<String, Float>>(emptyMap())
    val reliefItemEffectiveness: StateFlow<Map<String, Float>> = _reliefItemEffectiveness

    private val _activitySpider = MutableStateFlow<SpiderData?>(null)
    val activitySpider: StateFlow<SpiderData?> = _activitySpider

    private val _missedActivitySpider = MutableStateFlow<SpiderData?>(null)
    val missedActivitySpider: StateFlow<SpiderData?> = _missedActivitySpider

    private val _locationSpider = MutableStateFlow<SpiderData?>(null)
    val locationSpider: StateFlow<SpiderData?> = _locationSpider

    private val _spiderLoading = MutableStateFlow(true)
    val spiderLoading: StateFlow<Boolean> = _spiderLoading

    // ═══════ Per-migraine linked items ═══════

    private val _selectedLinkedItems = MutableStateFlow(SupabaseDbService.MigraineLinkedItems())
    val selectedLinkedItems: StateFlow<SupabaseDbService.MigraineLinkedItems> = _selectedLinkedItems

    private val _linkedItemsLoading = MutableStateFlow(false)
    val linkedItemsLoading: StateFlow<Boolean> = _linkedItemsLoading

    private val _allMissedActivities = MutableStateFlow<List<SupabaseDbService.MissedActivityLogRow>>(emptyList())
    val allMissedActivities: StateFlow<List<SupabaseDbService.MissedActivityLogRow>> = _allMissedActivities

    private val _allActivities = MutableStateFlow<List<SupabaseDbService.ActivityLogRow>>(emptyList())
    val allActivities: StateFlow<List<SupabaseDbService.ActivityLogRow>> = _allActivities

    private val _rawMigraineRows = MutableStateFlow<List<SupabaseDbService.MigraineRow>>(emptyList())

    // Raw linked items stored for filtered spider computation
    private val _allTriggers = MutableStateFlow<List<SupabaseDbService.TriggerRow>>(emptyList())
    private val _allMedicines = MutableStateFlow<List<SupabaseDbService.MedicineRow>>(emptyList())
    private val _allReliefs = MutableStateFlow<List<SupabaseDbService.ReliefRow>>(emptyList())
    private val _allProdromes = MutableStateFlow<List<SupabaseDbService.ProdromeLogRow>>(emptyList())
    private val _allLocations = MutableStateFlow<List<SupabaseDbService.LocationLogRow>>(emptyList())

    // Category maps (label.lowercase -> category)
    private val _catMaps = MutableStateFlow<CatMaps>(CatMaps())
    data class CatMaps(
        val trigger: Map<String, String> = emptyMap(),
        val prodrome: Map<String, String> = emptyMap(),
        val symptom: Map<String, String> = emptyMap(),
        val medicine: Map<String, String> = emptyMap(),
        val relief: Map<String, String> = emptyMap(),
        val activity: Map<String, String> = emptyMap(),
        val missedActivity: Map<String, String> = emptyMap(),
        val location: Map<String, String> = emptyMap()
    )

    /** Build spiders for a filtered set of migraine IDs */
    data class FilteredSpiders(
        val triggers: SpiderData? = null,
        val prodromes: SpiderData? = null,
        val symptoms: SpiderData? = null,
        val painChar: SpiderData? = null,
        val accompanying: SpiderData? = null,
        val painLocations: SpiderData? = null,
        val medicines: SpiderData? = null,
        val reliefs: SpiderData? = null,
        val activities: SpiderData? = null,
        val locations: SpiderData? = null,
        val missedActivities: SpiderData? = null,
        val severityCounts: List<Pair<Int, Int>> = emptyList(),
        val durationStats: DurationStats? = null,
        val painLocationCounts: List<Pair<String, Int>> = emptyList(),
        val medicineEffectiveness: List<ReliefEffectiveness> = emptyList(),
        val reliefEffectiveness: List<ReliefEffectiveness> = emptyList(),
        val medicineItemEffectiveness: Map<String, Float> = emptyMap(),
        val reliefItemEffectiveness: Map<String, Float> = emptyMap()
    )

    fun buildFilteredSpiders(migraineIds: Set<String>): FilteredSpiders {
        val cm = _catMaps.value
        val rows = _rawMigraineRows.value.filter { it.id in migraineIds }

        val fT = _allTriggers.value.filter { it.migraineId in migraineIds }
        val fM = _allMedicines.value.filter { it.migraineId in migraineIds }
        val fR = _allReliefs.value.filter { it.migraineId in migraineIds }
        val fP = _allProdromes.value.filter { it.migraineId in migraineIds }
        val fA = _allActivities.value.filter { it.migraineId in migraineIds }
        val fL = _allLocations.value.filter { it.migraineId in migraineIds }
        val fMs = _allMissedActivities.value.filter { it.migraineId in migraineIds }

        val allSym = rows.flatMap { row ->
            row.type?.split(",")?.map { it.trim() }?.filter { it.isNotBlank() && it != "Migraine" } ?: emptyList()
        }
        val painCharLabels = allSym.filter { cm.symptom[it.lowercase()] == "pain_character" }
        val accompLabels = allSym.filter { cm.symptom[it.lowercase()] == "accompanying" }
        val allPainLocs = rows.flatMap { it.painLocations ?: emptyList() }

        // Duration stats
        val durations = rows.mapNotNull { row ->
            val endAt = row.endAt ?: return@mapNotNull null
            try {
                java.time.Duration.between(
                    Instant.parse(row.startAt), Instant.parse(endAt)
                ).toMinutes() / 60f
            } catch (_: Exception) { null }
        }
        val durStats = if (durations.isNotEmpty()) DurationStats(
            avgHours = durations.average().toFloat(),
            minHours = durations.min(),
            maxHours = durations.max(),
            durations = durations.sorted()
        ) else null

        return FilteredSpiders(
            triggers = if (fT.isNotEmpty()) buildSpider("Triggers", fT.mapNotNull { it.type }, cm.trigger) else null,
            prodromes = if (fP.isNotEmpty()) buildSpider("Prodromes", fP.mapNotNull { it.type }, cm.prodrome) else null,
            symptoms = if (allSym.isNotEmpty()) buildSpider("Symptoms", allSym, cm.symptom) else null,
            painChar = if (painCharLabels.isNotEmpty()) buildFlatSpider("Pain Character", painCharLabels) else null,
            accompanying = if (accompLabels.isNotEmpty()) buildFlatSpider("Accompanying", accompLabels) else null,
            painLocations = if (allPainLocs.isNotEmpty()) buildFlatSpider("Pain Locations", allPainLocs) else null,
            medicines = if (fM.isNotEmpty()) buildSpider("Medicines", fM.mapNotNull { it.name }, cm.medicine) else null,
            reliefs = if (fR.isNotEmpty()) buildSpider("Reliefs", fR.mapNotNull { it.type }, cm.relief) else null,
            activities = if (fA.isNotEmpty()) buildSpider("Activities", fA.mapNotNull { it.type }, cm.activity) else null,
            locations = if (fL.isNotEmpty()) buildSpider("Locations", fL.mapNotNull { it.type }, cm.location) else null,
            missedActivities = if (fMs.isNotEmpty()) buildSpider("Missed Activities", fMs.mapNotNull { it.type }, cm.missedActivity) else null,
            severityCounts = rows.mapNotNull { it.severity }
                .groupingBy { it }.eachCount().toList().sortedBy { it.first },
            durationStats = durStats,
            painLocationCounts = allPainLocs.groupingBy { it }.eachCount().toList().sortedByDescending { it.second },
            medicineEffectiveness = fM
                .groupBy { cm.medicine[it.name?.lowercase()] ?: "Other" }
                .map { entry ->
                    ReliefEffectiveness(entry.key, entry.value.size,
                        entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat())
                }.sortedByDescending { it.count },
            reliefEffectiveness = fR
                .groupBy { cm.relief[it.type?.lowercase()] ?: "Other" }
                .map { entry ->
                    ReliefEffectiveness(entry.key, entry.value.size,
                        entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat())
                }.sortedByDescending { it.count },
            medicineItemEffectiveness = fM
                .groupBy { it.name?.lowercase() ?: "unknown" }
                .mapValues { entry -> entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat() },
            reliefItemEffectiveness = fR
                .groupBy { it.type?.lowercase() ?: "unknown" }
                .mapValues { entry -> entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat() }
        )
    }

    // ═══════ ALL daily metrics ═══════

    data class DailyValue(val date: String, val value: Double)

    private val _allDailyMetrics = MutableStateFlow<Map<String, List<DailyValue>>>(emptyMap())
    val allDailyMetrics: StateFlow<Map<String, List<DailyValue>>> = _allDailyMetrics

    // ═══════ Shared UI state (used by both InsightsScreen and InsightsDetailScreen) ═══════

    private val _selectedMigraineIndex = MutableStateFlow(0)
    val selectedMigraineIndex: StateFlow<Int> = _selectedMigraineIndex

    private val _userToggledMetrics = MutableStateFlow<Set<String>>(emptySet())
    val userToggledMetrics: StateFlow<Set<String>> = _userToggledMetrics

    private val _windowDaysBefore = MutableStateFlow(7L)
    val windowDaysBefore: StateFlow<Long> = _windowDaysBefore

    private val _windowDaysAfter = MutableStateFlow(2L)
    val windowDaysAfter: StateFlow<Long> = _windowDaysAfter

    fun selectMigraine(index: Int) {
        _selectedMigraineIndex.value = index
        _userToggledMetrics.value = emptySet() // reset user toggles on migraine change
    }

    fun setWindowDays(before: Long, after: Long) {
        _windowDaysBefore.value = before
        _windowDaysAfter.value = after
    }

    fun toggleMetric(key: String) {
        val current = _userToggledMetrics.value
        _userToggledMetrics.value = if (key in current) current - key else current + key
    }

    // ═══════ Dynamic template → metric mapping ═══════

    /**
     * Maps Supabase metric_table names → VM metric keys.
     * This is the ONLY hardcoded mapping. Everything else is driven by DB templates.
     * When a new metric table is added to the DB AND to loadAllDailyMetrics, add its entry here.
     */
    companion object {
        val TABLE_TO_KEY: Map<String, String> = mapOf(
            // Sleep
            "sleep_duration_daily" to "sleep_dur",
            "sleep_score_daily" to "sleep_score",
            "sleep_efficiency_daily" to "sleep_eff",
            "sleep_disturbances_daily" to "sleep_dist",
            "sleep_stages_daily" to "sleep_deep",
            "fell_asleep_time_daily" to "bedtime",
            "woke_up_time_daily" to "wake_time",
            // Body / Physical
            "recovery_score_daily" to "recovery",
            "stress_index_daily" to "stress",
            "time_in_high_hr_zones_daily" to "high_hr",
            "steps_daily" to "steps",
            "weight_daily" to "weight",
            "body_fat_daily" to "body_fat",
            "blood_pressure_daily" to "bp_sys",
            "blood_glucose_daily" to "glucose",
            "strain_daily" to "strain",
            // Physical prodromes
            "hrv_daily" to "hrv",
            "resting_hr_daily" to "rhr",
            "spo2_daily" to "spo2",
            "skin_temp_daily" to "skin_temp",
            "respiratory_rate_daily" to "resp_rate",
            // Environment
            "user_weather_daily" to "pressure",
            "user_location_daily" to "altitude",
            // Mental / Cognitive
            "screen_time_daily" to "screen_time",
            "screen_time_late_night" to "late_screen",
            "ambient_noise_index_daily" to "noise",
            "phone_brightness_daily" to "brightness",
            "phone_volume_daily" to "volume",
            "phone_unlock_daily" to "unlocks",
            "phone_dark_mode_daily" to "dark_mode",
            // Wellness
            "hydration_daily" to "hydration",
            "mindfulness_daily" to "mindfulness",
            // Diet
            "nutrition_daily" to "calories",
        )

        /**
         * For tables with multiple metric columns, use "table:column" to pick the right VM key.
         */
        val TABLE_COL_TO_KEY: Map<String, String> = mapOf(
            // Weather
            "user_weather_daily:temp_c_mean" to "temp",
            "user_weather_daily:pressure_hpa_mean" to "pressure",
            "user_weather_daily:humidity_pct_mean" to "humidity",
            "user_weather_daily:wind_speed_mps_mean" to "wind",
            "user_weather_daily:uv_index_max" to "uv",
            // Location
            "user_location_daily:altitude_max_m" to "altitude",
            "user_location_daily:altitude_change_m" to "alt_change",
            // Sleep stages
            "sleep_stages_daily:value_sws_hm" to "sleep_deep",
            "sleep_stages_daily:value_rem_hm" to "sleep_rem",
            "sleep_stages_daily:value_light_hm" to "sleep_light",
            // Nutrition
            "nutrition_daily:total_calories" to "calories",
            "nutrition_daily:total_protein_g" to "protein",
            "nutrition_daily:total_carbs_g" to "carbs",
            "nutrition_daily:total_fat_g" to "fat",
            "nutrition_daily:total_fiber_g" to "fiber",
            "nutrition_daily:total_sugar_g" to "sugar",
            "nutrition_daily:total_sodium_mg" to "sodium",
            "nutrition_daily:total_caffeine_mg" to "caffeine",
            "nutrition_daily:total_saturated_fat_g" to "sat_fat",
            "nutrition_daily:total_unsaturated_fat_g" to "unsat_fat",
            "nutrition_daily:total_trans_fat_g" to "trans_fat",
            "nutrition_daily:total_cholesterol_mg" to "cholesterol",
            "nutrition_daily:total_potassium_mg" to "potassium",
            "nutrition_daily:total_calcium_mg" to "calcium",
            "nutrition_daily:total_iron_mg" to "iron",
            "nutrition_daily:total_magnesium_mg" to "magnesium",
            "nutrition_daily:total_zinc_mg" to "zinc",
            "nutrition_daily:total_selenium_mcg" to "selenium",
        )
    }

    /**
     * Dynamic map: normalised trigger/prodrome label → VM metric key.
     * Built at startup from trigger_templates + prodrome_templates fetched from Supabase.
     */
    private val _labelToMetricKey = MutableStateFlow<Map<String, String>>(emptyMap())
    val labelToMetricMap: StateFlow<Map<String, String>> = _labelToMetricKey

    /** Group name → all associated VM metric keys (e.g. "poor sleep" → {sleep_dur, sleep_score, ...}) */
    private val _groupToMetricKeys = MutableStateFlow<Map<String, Set<String>>>(emptyMap())

    /** Fetch trigger_templates + prodrome_templates and build label → metric key map */
    private fun loadTemplateMap(client: OkHttpClient, base: String, key: String, token: String) {
        val map = mutableMapOf<String, String>()
        val groupMap = mutableMapOf<String, MutableSet<String>>()
        for (table in listOf("trigger_templates", "prodrome_templates")) {
            try {
                val url = "$base/rest/v1/$table?select=label,metric_table,metric_column,display_group&metric_table=not.is.null"
                val req = Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $token")
                    .build()
                val resp = client.newCall(req).execute()
                val body = resp.body?.string()
                if (!resp.isSuccessful || body.isNullOrBlank()) continue
                val arr = JSONArray(body)
                for (i in 0 until arr.length()) {
                    val o = arr.getJSONObject(i)
                    val label = o.optString("label", "").takeIf { it.isNotBlank() } ?: continue
                    val metricTable = o.optString("metric_table", "").takeIf { it.isNotBlank() } ?: continue
                    val metricCol = o.optString("metric_column", "")
                    val displayGroup = o.optString("display_group", "").takeIf { it.isNotBlank() }
                    val vmKey = if (metricCol.isNotBlank()) {
                        TABLE_COL_TO_KEY["$metricTable:$metricCol"] ?: TABLE_TO_KEY[metricTable]
                    } else {
                        TABLE_TO_KEY[metricTable]
                    }
                    if (vmKey != null) {
                        map[normaliseLabel(label)] = vmKey
                        // If this belongs to a display_group, also map group → keys
                        if (displayGroup != null) {
                            val normGroup = normaliseLabel(displayGroup)
                            map[normGroup] = vmKey
                            groupMap.getOrPut(normGroup) { mutableSetOf() }.add(vmKey)
                        }
                    }
                }
            } catch (_: Exception) { /* templates optional */ }
        }
        _labelToMetricKey.value = map
        _groupToMetricKeys.value = groupMap
    }

    /** Normalise a trigger/prodrome label for lookup: lowercase, strip colons, strip direction suffixes */
    private fun normaliseLabel(raw: String): String {
        return raw.lowercase()
            .replace(":", "")
            .trim()
            .replace(Regex("\\s+(low|high|short|long|late|early|many|few)\\b.*"), "")
            .trim()
    }

    /** Resolve a trigger/prodrome type string to a VM metric key using the dynamic template map */
    fun labelToMetricKey(label: String): String? {
        return _labelToMetricKey.value[normaliseLabel(label)]
    }

    /** Resolve a trigger/prodrome type to ALL associated VM metric keys.
     *  For grouped triggers (e.g. "Poor sleep"), returns all member keys.
     *  For individual triggers, returns the single key in a set. */
    fun metricKeysForLabel(label: String): Set<String> {
        val norm = normaliseLabel(label)
        val groupKeys = _groupToMetricKeys.value[norm]
        if (!groupKeys.isNullOrEmpty()) return groupKeys
        val single = _labelToMetricKey.value[norm]
        return if (single != null) setOf(single) else emptySet()
    }

    /** Return auto-detected metric keys from ALL triggers/prodromes linked to the given migraine IDs. */
    fun autoMetricKeysForMigraines(migraineIds: Set<String>): Set<String> {
        val keys = mutableSetOf<String>()
        _allTriggers.value
            .filter { it.migraineId in migraineIds }
            .forEach { keys.addAll(metricKeysForLabel(it.type ?: "")) }
        _allProdromes.value
            .filter { it.migraineId in migraineIds }
            .forEach { keys.addAll(metricKeysForLabel(it.type ?: "")) }
        _allMedicines.value
            .filter { it.migraineId in migraineIds }
            .forEach { keys.addAll(metricKeysForLabel(it.name ?: "")) }
        _allReliefs.value
            .filter { it.migraineId in migraineIds }
            .forEach { keys.addAll(metricKeysForLabel(it.type ?: "")) }
        return keys
    }

    // ═══════ Filtering ═══════

    /** Tag = "category:label", e.g. "Trigger:Pressure Drop", "Symptom:Nausea" */
    data class FilterTag(val category: String, val label: String) {
        val key get() = "$category:$label"
    }

    /** Map of migraineId -> set of tags for that migraine */
    private val _migraineTagIndex = MutableStateFlow<Map<String, Set<FilterTag>>>(emptyMap())
    val migraineTagIndex: StateFlow<Map<String, Set<FilterTag>>> = _migraineTagIndex

    /** All available tags across all migraines, grouped by category */
    private val _availableFilterTags = MutableStateFlow<Map<String, List<String>>>(emptyMap())
    val availableFilterTags: StateFlow<Map<String, List<String>>> = _availableFilterTags

    /** Currently active filters */
    private val _activeFilters = MutableStateFlow<Set<FilterTag>>(emptySet())
    val activeFilters: StateFlow<Set<FilterTag>> = _activeFilters

    /** Time range filter */
    enum class TimeFrame(val label: String, val days: Int?) {
        NONE("None", null),
        ALL("All Time", null),
        WEEK_1("7 Days", 7),
        WEEK_2("14 Days", 14),
        MONTH_1("30 Days", 30),
        MONTH_3("3 Months", 90),
        MONTH_6("6 Months", 180),
        YEAR_1("1 Year", 365),
        CUSTOM("Custom", null)
    }

    private val _timeFrame = MutableStateFlow(TimeFrame.ALL)
    val timeFrame: StateFlow<TimeFrame> = _timeFrame

    /** Custom date range (only used when timeFrame == CUSTOM) */
    data class CustomRange(val from: java.time.LocalDate, val to: java.time.LocalDate)

    private val _customRange = MutableStateFlow<CustomRange?>(null)
    val customRange: StateFlow<CustomRange?> = _customRange

    fun setTimeFrame(tf: TimeFrame) {
        _timeFrame.value = tf
        if (tf != TimeFrame.CUSTOM) _customRange.value = null
        _selectedMigraineIndex.value = 0
    }

    fun setCustomRange(from: java.time.LocalDate, to: java.time.LocalDate) {
        _customRange.value = CustomRange(from, to)
        _timeFrame.value = TimeFrame.CUSTOM
        _selectedMigraineIndex.value = 0
    }

    fun toggleFilter(tag: FilterTag) {
        val c = _activeFilters.value
        _activeFilters.value = if (tag in c) c - tag else c + tag
        _selectedMigraineIndex.value = 0
    }

    fun clearFilters() {
        _activeFilters.value = emptySet()
        _timeFrame.value = TimeFrame.ALL
        _customRange.value = null
        _selectedMigraineIndex.value = 0
    }

    private fun buildMigraineTagIndex(
        rawRows: List<SupabaseDbService.MigraineRow>,
        allTriggers: List<SupabaseDbService.TriggerRow>,
        allMedicines: List<SupabaseDbService.MedicineRow>,
        allReliefs: List<SupabaseDbService.ReliefRow>,
        allProdromes: List<SupabaseDbService.ProdromeLogRow>,
        allActivities: List<SupabaseDbService.ActivityLogRow>,
        allLocations: List<SupabaseDbService.LocationLogRow>,
        allMissed: List<SupabaseDbService.MissedActivityLogRow>
    ) {
        val index = mutableMapOf<String, MutableSet<FilterTag>>()
        val allTags = mutableSetOf<FilterTag>()

        for (m in rawRows) {
            val tags = index.getOrPut(m.id) { mutableSetOf() }
            // Symptoms from type field (comma-separated)
            m.type?.split(",")?.map { it.trim() }?.filter { it.isNotBlank() && it != "Migraine" }?.forEach {
                val t = FilterTag("Symptom", it); tags += t; allTags += t
            }
            // Pain locations
            m.painLocations?.forEach {
                val t = FilterTag("Pain Location", it); tags += t; allTags += t
            }
            // Severity bucket
            m.severity?.let { sev ->
                val bucket = when {
                    sev <= 3 -> "Mild (1-3)"
                    sev <= 6 -> "Moderate (4-6)"
                    else -> "Severe (7-10)"
                }
                val t = FilterTag("Severity", bucket); tags += t; allTags += t
            }
        }

        fun <T> indexItems(items: List<T>, cat: String, getId: (T) -> String?, getType: (T) -> String?) {
            for (item in items) {
                val mid = getId(item) ?: continue
                val type = getType(item)?.takeIf { it.isNotBlank() } ?: continue
                val t = FilterTag(cat, type)
                index.getOrPut(mid) { mutableSetOf() } += t; allTags += t
            }
        }

        indexItems(allTriggers, "Trigger", { it.migraineId }, { it.type })
        indexItems(allMedicines, "Medicine", { it.migraineId }, { it.name })
        indexItems(allReliefs, "Relief", { it.migraineId }, { it.type })
        indexItems(allProdromes, "Prodrome", { it.migraineId }, { it.type })
        indexItems(allActivities, "Activity", { it.migraineId }, { it.type })
        indexItems(allLocations, "Location", { it.migraineId }, { it.type })
        indexItems(allMissed, "Missed Activity", { it.migraineId }, { it.type })

        _migraineTagIndex.value = index
        _availableFilterTags.value = allTags.groupBy({ it.category }, { it.label })
            .mapValues { it.value.distinct().sorted() }
    }

    // ═══════ Internal ═══════

    private val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
    private var cachedToken: String? = null

    // ═══════ Public API ═══════

    fun load(context: Context, accessToken: String) {
        cachedToken = accessToken
        viewModelScope.launch {
            try {
                val now = Instant.now()

                // Load template → metric mapping FIRST (fast, needed for auto-selection)
                withContext(Dispatchers.IO) {
                    val client = OkHttpClient()
                    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
                    val apiKey = BuildConfig.SUPABASE_ANON_KEY
                    loadTemplateMap(client, base, apiKey, accessToken)
                }

                val migs = db.getMigraines(accessToken)
                _rawMigraineRows.value = migs
                _migraines.value = migs.map { row ->
                    MigraineSpan(
                        start = Instant.parse(row.startAt),
                        end = row.endAt?.let { Instant.parse(it) },
                        severity = row.severity,
                        label = row.type,
                        id = row.id
                    )
                }

                val rels = db.getAllReliefs(accessToken)
                _reliefs.value = rels.map { row ->
                    val s = Instant.parse(row.startAt)
                    val e = row.durationMinutes?.let { s.plus(it.toLong(), ChronoUnit.MINUTES) } ?: now
                    ReliefSpan(s, e, null, row.type ?: "Relief")
                }

                val meds = db.getAllMedicines(accessToken)
                _medicines.value = meds.map { row ->
                    MedicinePoint(Instant.parse(row.startAt), row.name ?: "Medicine", row.amount)
                }

                val trigs = db.getAllTriggers(accessToken)
                _triggers.value = trigs.map { row ->
                    TriggerPoint(Instant.parse(row.startAt), row.type ?: "Trigger")
                }

                // Populate raw linked items immediately so auto-metric detection works
                _allTriggers.value = trigs
                _allMedicines.value = meds
                _allReliefs.value = rels
                val prods = db.getAllProdromeLog(accessToken)
                _allProdromes.value = prods

                // Sleep
                val metrics = SupabaseMetricsService(context)
                val dur = metrics.fetchSleepDurationDaily(accessToken, 180)
                _sleepDuration.value = dur.map { SleepDurationRow(it.date, it.value_hours) }
                _latestSleepDate.value = dur.firstOrNull()?.date

                val dst = metrics.fetchSleepDisturbancesDaily(accessToken, 180)
                _sleepDisturbances.value = dst.map { SleepDisturbancesRow(it.date, it.value_count) }

                val stg = metrics.fetchSleepStagesDaily(accessToken, 180)
                _sleepStages.value = stg.map { SleepStagesRow(it.date, it.value_sws_hm, it.value_rem_hm, it.value_light_hm) }

                // Location
                val personal = SupabasePersonalService(context)
                val locs = personal.fetchUserLocationDaily(accessToken, 180)
                _userLocations.value = locs.map { UserLocationRow(it.date, it.latitude, it.longitude) }

                // ALL daily metrics from Supabase
                withContext(Dispatchers.IO) { loadAllDailyMetrics(context, accessToken) }

                // Spider data
                loadSpiderData(accessToken, trigs, meds, rels, prods)
            } catch (_: Exception) {
                _migraines.value = emptyList()
                _reliefs.value = emptyList()
                _triggers.value = emptyList()
                _medicines.value = emptyList()
                _sleepDuration.value = emptyList()
                _sleepDisturbances.value = emptyList()
                _sleepStages.value = emptyList()
                _userLocations.value = emptyList()
                _latestSleepDate.value = null
                _spiderLoading.value = false
            }
        }
    }

    fun loadLinkedItems(migraineId: String) {
        val token = cachedToken ?: return
        viewModelScope.launch {
            _linkedItemsLoading.value = true
            _selectedLinkedItems.value = try {
                db.getLinkedItems(token, migraineId)
            } catch (_: Exception) {
                SupabaseDbService.MigraineLinkedItems()
            }
            _linkedItemsLoading.value = false
        }
    }

    /** Load linked items for a specific migraine (for PDF batch rendering) */
    suspend fun getLinkedItemsFor(migraineId: String): SupabaseDbService.MigraineLinkedItems {
        val token = cachedToken ?: return SupabaseDbService.MigraineLinkedItems()
        return try {
            db.getLinkedItems(token, migraineId)
        } catch (_: Exception) {
            SupabaseDbService.MigraineLinkedItems()
        }
    }

    // ═══════ Load EVERY daily metric table via direct Supabase REST ═══════

    private fun loadAllDailyMetrics(context: Context, token: String) {
        val userId = SessionStore.readUserId(context) ?: return
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val key = BuildConfig.SUPABASE_ANON_KEY
        val client = OkHttpClient()
        val cutoff = LocalDate.now().minusDays(180).toString()
        val map = mutableMapOf<String, List<DailyValue>>()

        // ── Weather (user_weather_daily) ──
        val weatherArr = fetchArr(client, base, key, token, userId, "user_weather_daily",
            "date,temp_c_mean,pressure_hpa_mean,humidity_pct_mean,wind_speed_mps_mean,uv_index_max", cutoff)
        if (weatherArr != null) {
            map["pressure"] = parseDoubleCol(weatherArr, "pressure_hpa_mean")
            map["temp"] = parseDoubleCol(weatherArr, "temp_c_mean")
            map["humidity"] = parseDoubleCol(weatherArr, "humidity_pct_mean")
            map["wind"] = parseDoubleCol(weatherArr, "wind_speed_mps_mean")
            map["uv"] = parseDoubleCol(weatherArr, "uv_index_max")
        }

        // ── Location/Altitude (user_location_daily) ──
        val locArr = fetchArr(client, base, key, token, userId, "user_location_daily",
            "date,altitude_max_m,altitude_change_m", cutoff)
        if (locArr != null) {
            map["altitude"] = parseDoubleCol(locArr, "altitude_max_m")
            map["alt_change"] = parseDoubleCol(locArr, "altitude_change_m")
        }

        // ── Physical health metrics (each in its own table) ──
        map["recovery"] = fetchAndParse(client, base, key, token, userId, "recovery_score_daily", "value_pct", cutoff)
        map["hrv"] = fetchAndParse(client, base, key, token, userId, "hrv_daily", "value_rmssd_ms", cutoff)
        map["rhr"] = fetchAndParse(client, base, key, token, userId, "resting_hr_daily", "value_bpm", cutoff)
        map["spo2"] = fetchAndParse(client, base, key, token, userId, "spo2_daily", "value_pct", cutoff)
        map["skin_temp"] = fetchAndParse(client, base, key, token, userId, "skin_temp_daily", "value_celsius", cutoff)
        map["resp_rate"] = fetchAndParse(client, base, key, token, userId, "respiratory_rate_daily", "value_bpm", cutoff)
        map["stress"] = fetchAndParse(client, base, key, token, userId, "stress_index_daily", "value", cutoff)
        map["high_hr"] = fetchAndParse(client, base, key, token, userId, "time_in_high_hr_zones_daily", "value_minutes", cutoff)
        map["steps"] = fetchAndParseInt(client, base, key, token, userId, "steps_daily", "value_count", cutoff)
        map["weight"] = fetchAndParse(client, base, key, token, userId, "weight_daily", "value_kg", cutoff)
        map["body_fat"] = fetchAndParse(client, base, key, token, userId, "body_fat_daily", "value_pct", cutoff)
        map["bp_sys"] = fetchAndParse(client, base, key, token, userId, "blood_pressure_daily", "value_systolic", cutoff)
        map["glucose"] = fetchAndParse(client, base, key, token, userId, "blood_glucose_daily", "value_mgdl", cutoff)

        // ── Sleep metrics ──
        map["sleep_dur"] = fetchAndParse(client, base, key, token, userId, "sleep_duration_daily", "value_hours", cutoff)
        map["sleep_score"] = fetchAndParse(client, base, key, token, userId, "sleep_score_daily", "value_pct", cutoff)
        map["sleep_eff"] = fetchAndParse(client, base, key, token, userId, "sleep_efficiency_daily", "value_pct", cutoff)
        map["sleep_dist"] = fetchAndParseInt(client, base, key, token, userId, "sleep_disturbances_daily", "value_count", cutoff)

        val stagesArr = fetchArr(client, base, key, token, userId, "sleep_stages_daily",
            "date,value_sws_hm,value_rem_hm,value_light_hm", cutoff)
        if (stagesArr != null) {
            map["sleep_deep"] = parseDoubleCol(stagesArr, "value_sws_hm")
            map["sleep_rem"] = parseDoubleCol(stagesArr, "value_rem_hm")
            map["sleep_light"] = parseDoubleCol(stagesArr, "value_light_hm")
        }

        // ── Screen time (only total from screen_time_daily; other phone metrics from their own tables below) ──
        val screenArr = fetchArr(client, base, key, token, userId, "screen_time_daily",
            "date,value_minutes", cutoff)
        if (screenArr != null) {
            map["screen_time"] = parseDoubleCol(screenArr, "value_minutes")
        }

        // ── Nutrition / Diet ──
        // nutrition_daily has basic 8 fields; nutrition_records has ALL nutrients per-record.
        // We query nutrition_records and aggregate by date for the full picture.
        loadNutritionMetrics(client, base, key, token, userId, cutoff, map)

        // Also load nutrition_daily as fallback for dates that may not have records
        val nutritionArr = fetchArr(client, base, key, token, userId, "nutrition_daily",
            "date,total_calories,total_protein_g,total_carbs_g,total_fat_g,total_fiber_g,total_sugar_g,total_sodium_mg,total_caffeine_mg", cutoff)
        if (nutritionArr != null) {
            // Only fill in keys that weren't already populated from nutrition_records
            fun fillIfEmpty(key: String, col: String) {
                if (map[key].isNullOrEmpty()) map[key] = parseDoubleCol(nutritionArr, col)
            }
            fillIfEmpty("calories", "total_calories")
            fillIfEmpty("protein", "total_protein_g")
            fillIfEmpty("carbs", "total_carbs_g")
            fillIfEmpty("fat", "total_fat_g")
            fillIfEmpty("fiber", "total_fiber_g")
            fillIfEmpty("sugar", "total_sugar_g")
            fillIfEmpty("sodium", "total_sodium_mg")
            fillIfEmpty("caffeine", "total_caffeine_mg")
        }

        // ── Bedtime / Wake time (timestamp → 24h decimal, bedtime shifted +24 if < 12 for smooth plotting) ──
        fun parseTimestampToHours(arr: JSONArray, col: String, shiftPastNoon: Boolean): List<DailyValue> {
            val list = mutableListOf<DailyValue>()
            for (i in 0 until arr.length()) {
                val o = arr.getJSONObject(i)
                val date = o.optString("date", "").takeIf { it.length >= 10 } ?: continue
                val ts = o.optString(col, "").takeIf { it.isNotBlank() } ?: continue
                try {
                    val inst = Instant.parse(ts)
                    val zoned = inst.atZone(java.time.ZoneId.systemDefault())
                    var hours = zoned.hour + zoned.minute / 60.0
                    if (shiftPastNoon && hours < 12.0) hours += 24.0  // e.g. 00:30 → 24.5
                    list += DailyValue(date, hours)
                } catch (_: Exception) { /* skip unparseable */ }
            }
            return list
        }

        val bedtimeArr = fetchArr(client, base, key, token, userId, "fell_asleep_time_daily", "date,value_at", cutoff)
        if (bedtimeArr != null) {
            map["bedtime"] = parseTimestampToHours(bedtimeArr, "value_at", shiftPastNoon = true)
        }
        val wakeArr = fetchArr(client, base, key, token, userId, "woke_up_time_daily", "date,value_at", cutoff)
        if (wakeArr != null) {
            map["wake_time"] = parseTimestampToHours(wakeArr, "value_at", shiftPastNoon = false)
        }

        // ── Additional physical ──
        map["strain"] = fetchAndParse(client, base, key, token, userId, "strain_daily", "value_strain", cutoff)

        // ── Additional mental / phone ──
        map["late_screen"] = fetchAndParse(client, base, key, token, userId, "screen_time_late_night", "value_hours", cutoff)
        map["noise"] = fetchAndParse(client, base, key, token, userId, "ambient_noise_index_daily", "day_mean_lmean", cutoff)
        map["brightness"] = fetchAndParse(client, base, key, token, userId, "phone_brightness_daily", "value_mean", cutoff)
        map["volume"] = fetchAndParse(client, base, key, token, userId, "phone_volume_daily", "value_mean_pct", cutoff)
        map["unlocks"] = fetchAndParseInt(client, base, key, token, userId, "phone_unlock_daily", "value_count", cutoff)
        map["dark_mode"] = fetchAndParse(client, base, key, token, userId, "phone_dark_mode_daily", "value_hours", cutoff)

        // ── Wellness ──
        map["hydration"] = fetchAndParse(client, base, key, token, userId, "hydration_daily", "value_ml", cutoff)
        map["mindfulness"] = fetchAndParse(client, base, key, token, userId, "mindfulness_daily", "duration_minutes", cutoff)

        _allDailyMetrics.value = map.filterValues { it.isNotEmpty() }
    }

    /** Aggregate ALL nutrient columns from nutrition_records by date. */
    private fun loadNutritionMetrics(
        client: OkHttpClient, base: String, key: String, token: String,
        userId: String, cutoff: String, map: MutableMap<String, List<DailyValue>>
    ) {
        try {
            val cols = "timestamp,calories,protein,total_carbohydrate,total_fat,dietary_fiber,sugar," +
                "sodium,caffeine,cholesterol,saturated_fat,unsaturated_fat,trans_fat," +
                "potassium,calcium,iron,magnesium,zinc,selenium,phosphorus,copper,manganese," +
                "vitamin_a,vitamin_c,vitamin_d,vitamin_e,vitamin_k,vitamin_b6,vitamin_b12," +
                "thiamin,riboflavin,niacin,folate,biotin,pantothenic_acid," +
                "tyramine_exposure,alcohol_exposure,gluten_exposure"
            val url = "$base/rest/v1/nutrition_records?user_id=eq.$userId&timestamp=gte.${cutoff}T00:00:00Z&select=$cols&order=timestamp.desc&limit=5000"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token")
                .build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (!resp.isSuccessful || body.isNullOrBlank()) return
            val arr = JSONArray(body)
            if (arr.length() == 0) return

            // Group by date and sum each nutrient column
            val colKeys = listOf(
                "calories" to "calories", "protein" to "protein", "carbs" to "total_carbohydrate",
                "fat" to "total_fat", "fiber" to "dietary_fiber", "sugar" to "sugar",
                "sodium" to "sodium", "caffeine" to "caffeine", "cholesterol" to "cholesterol",
                "sat_fat" to "saturated_fat", "unsat_fat" to "unsaturated_fat", "trans_fat" to "trans_fat",
                "potassium" to "potassium", "calcium" to "calcium", "iron" to "iron",
                "magnesium" to "magnesium", "zinc" to "zinc", "selenium" to "selenium",
                "phosphorus" to "phosphorus", "copper" to "copper", "manganese" to "manganese",
                "vitamin_a" to "vitamin_a", "vitamin_c" to "vitamin_c", "vitamin_d" to "vitamin_d",
                "vitamin_e" to "vitamin_e", "vitamin_k" to "vitamin_k", "vitamin_b6" to "vitamin_b6",
                "vitamin_b12" to "vitamin_b12", "thiamin" to "thiamin", "riboflavin" to "riboflavin",
                "niacin" to "niacin", "folate" to "folate", "biotin" to "biotin",
                "panto_acid" to "pantothenic_acid"
            )

            // date -> (metricKey -> sum)
            val daySums = mutableMapOf<String, MutableMap<String, Double>>()
            for (i in 0 until arr.length()) {
                val o = arr.getJSONObject(i)
                val ts = o.optString("timestamp", "") // ISO timestamp
                val date = ts.take(10) // "YYYY-MM-DD"
                if (date.length < 10) continue
                val sums = daySums.getOrPut(date) { mutableMapOf() }
                for ((metKey, dbCol) in colKeys) {
                    val v = o.optDouble(dbCol)
                    if (!v.isNaN() && v > 0.0) {
                        sums[metKey] = (sums[metKey] ?: 0.0) + v
                    }
                }
            }

            // Convert to DailyValue lists
            for ((metKey, _) in colKeys) {
                val list = mutableListOf<DailyValue>()
                for ((date, sums) in daySums) {
                    val v = sums[metKey]
                    if (v != null && v > 0.0) list += DailyValue(date, v)
                }
                if (list.isNotEmpty()) {
                    map[metKey] = list.sortedByDescending { it.date }
                }
            }

            // Risk metrics (tyramine, alcohol, gluten) — string "none"/"low"/"medium"/"high" → 0/1/2/3
            val riskKeys = listOf(
                "tyramine" to "tyramine_exposure",
                "alcohol" to "alcohol_exposure",
                "gluten" to "gluten_exposure"
            )
            fun riskToNum(s: String?): Double? = when (s?.lowercase()) {
                "high" -> 3.0; "medium" -> 2.0; "low" -> 1.0; "none" -> 0.0; else -> null
            }
            val riskDaySums = mutableMapOf<String, MutableMap<String, Double>>()
            for (i in 0 until arr.length()) {
                val o = arr.getJSONObject(i)
                val ts = o.optString("timestamp", "")
                val date = ts.take(10)
                if (date.length < 10) continue
                val sums = riskDaySums.getOrPut(date) { mutableMapOf() }
                for ((metKey, dbCol) in riskKeys) {
                    val raw = if (o.has(dbCol) && !o.isNull(dbCol)) o.optString(dbCol) else null
                    val v = riskToNum(raw)
                    if (v != null && v > (sums[metKey] ?: -1.0)) {
                        sums[metKey] = v // take max risk level per day
                    }
                }
            }
            for ((metKey, _) in riskKeys) {
                val list = mutableListOf<DailyValue>()
                for ((date, sums) in riskDaySums) {
                    val v = sums[metKey]
                    if (v != null && v > 0.0) list += DailyValue(date, v)
                }
                if (list.isNotEmpty()) {
                    map[metKey] = list.sortedByDescending { it.date }
                }
            }
        } catch (_: Exception) { /* nutrition data optional */ }
    }

    // ── REST helpers ──

    private fun fetchArr(
        client: OkHttpClient, base: String, key: String, token: String,
        userId: String, table: String, select: String, cutoff: String
    ): JSONArray? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=gte.$cutoff&select=$select&order=date.desc&limit=365"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token")
                .build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) JSONArray(body) else null
        } catch (_: Exception) { null }
    }

    private fun parseDoubleCol(arr: JSONArray, col: String): List<DailyValue> {
        val list = mutableListOf<DailyValue>()
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            val v = o.optDouble(col)
            if (!v.isNaN()) list += DailyValue(o.getString("date"), v)
        }
        return list
    }

    private fun parseIntCol(arr: JSONArray, col: String): List<DailyValue> {
        val list = mutableListOf<DailyValue>()
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            val v = o.optInt(col, Int.MIN_VALUE)
            if (v != Int.MIN_VALUE) list += DailyValue(o.getString("date"), v.toDouble())
        }
        return list
    }

    private fun fetchAndParse(
        client: OkHttpClient, base: String, key: String, token: String,
        userId: String, table: String, col: String, cutoff: String
    ): List<DailyValue> {
        val arr = fetchArr(client, base, key, token, userId, table, "date,$col", cutoff) ?: return emptyList()
        return parseDoubleCol(arr, col)
    }

    private fun fetchAndParseInt(
        client: OkHttpClient, base: String, key: String, token: String,
        userId: String, table: String, col: String, cutoff: String
    ): List<DailyValue> {
        val arr = fetchArr(client, base, key, token, userId, table, "date,$col", cutoff) ?: return emptyList()
        return parseIntCol(arr, col)
    }

    // ═══════ Spider data ═══════

    private suspend fun loadSpiderData(
        accessToken: String,
        allTriggers: List<SupabaseDbService.TriggerRow>,
        allMedicines: List<SupabaseDbService.MedicineRow>,
        allReliefs: List<SupabaseDbService.ReliefRow>,
        allProdromes: List<SupabaseDbService.ProdromeLogRow>
    ) {
        try {
            _spiderLoading.value = true

            val triggerPool = db.getAllTriggerPool(accessToken)
            val prodromePool = db.getAllProdromePool(accessToken)
            val symptomPool = db.getAllSymptomPool(accessToken)
            val medicinePool = db.getAllMedicinePool(accessToken)
            val reliefPool = db.getAllReliefPool(accessToken)
            val activityPool = db.getAllActivityPool(accessToken)
            val missedActivityPool = db.getAllMissedActivityPool(accessToken)
            val locationPool = db.getAllLocationPool(accessToken)

            val linkedT = allTriggers.filter { it.migraineId != null }
            val linkedM = allMedicines.filter { it.migraineId != null }
            val linkedR = allReliefs.filter { it.migraineId != null }

            val allP = allProdromes
            val linkedP = allP.filter { it.migraineId != null }

            val allA = db.getAllActivityLog(accessToken)
            val linkedA = allA.filter { it.migraineId != null }
            _allActivities.value = allA

            val allL = db.getAllLocationLog(accessToken)
            val linkedL = allL.filter { it.migraineId != null }

            val allMs = db.getAllMissedActivityLog(accessToken)
            val linkedMs = allMs.filter { it.migraineId != null }
            _allMissedActivities.value = allMs

            _allActivities.value = allA
            _allLocations.value = allL

            val tcBase = triggerPool.associate { it.label.lowercase() to (it.category ?: "Other") }
            // Also map display_group names to their category (use first member's category)
            val tcGroups = mutableMapOf<String, String>()
            for (row in triggerPool) {
                val group = row.displayGroup
                if (group != null && group !in tcGroups) {
                    tcGroups[group.lowercase()] = row.category ?: "Other"
                }
            }
            val tc: Map<String, String> = tcBase + tcGroups
            val pc = prodromePool.associate { it.label.lowercase() to (it.category ?: "Other") }
            val sc = symptomPool.associate { it.label.lowercase() to (it.category ?: "Other") }
            val mc = medicinePool.associate { it.label.lowercase() to (it.category ?: "Other") }
            val rc = reliefPool.associate { it.label.lowercase() to (it.category ?: "Other") }
            val ac = activityPool.associate { it.label.lowercase() to (it.category ?: "Other") }
            val msc = missedActivityPool.associate { it.label.lowercase() to (it.category ?: "Other") }
            val lc = locationPool.associate { it.label.lowercase() to (it.category ?: "Other") }

            _catMaps.value = CatMaps(tc, pc, sc, mc, rc, ac, msc, lc)

            _triggerSpider.value = buildSpider("Triggers", linkedT.mapNotNull { it.type }, tc)
            _prodromeSpider.value = buildSpider("Prodromes", linkedP.mapNotNull { it.type }, pc)
            _medicineSpider.value = buildSpider("Medicines", linkedM.mapNotNull { it.name }, mc)
            _reliefSpider.value = buildSpider("Reliefs", linkedR.mapNotNull { it.type }, rc)

            _medicineEffectiveness.value = linkedM
                .groupBy { mc[it.name?.lowercase()] ?: "Other" }
                .map { entry ->
                    ReliefEffectiveness(
                        entry.key, entry.value.size,
                        entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat()
                    )
                }
                .sortedByDescending { it.count }

            _medicineItemEffectiveness.value = linkedM
                .groupBy { it.name?.lowercase() ?: "unknown" }
                .mapValues { entry -> entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat() }

            _reliefEffectiveness.value = linkedR
                .groupBy { rc[it.type?.lowercase()] ?: "Other" }
                .map { entry ->
                    ReliefEffectiveness(
                        entry.key, entry.value.size,
                        entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat()
                    )
                }
                .sortedByDescending { it.count }

            _reliefItemEffectiveness.value = linkedR
                .groupBy { it.type?.lowercase() ?: "unknown" }
                .mapValues { entry -> entry.value.map { reliefToNum(it.reliefScale) }.average().toFloat() }

            _activitySpider.value = buildSpider("Activities", linkedA.mapNotNull { it.type }, ac)
            _locationSpider.value = buildSpider("Locations", linkedL.mapNotNull { it.type }, lc)
            _missedActivitySpider.value = buildSpider("Missed Activities", linkedMs.mapNotNull { it.type }, msc)

            // Symptoms from migraine type field
            val migs = db.getMigraines(accessToken)
            val allSym = migs.flatMap { row ->
                row.type?.split(",")?.map { it.trim() }?.filter { it.isNotBlank() && it != "Migraine" } ?: emptyList()
            }
            _symptomSpider.value = buildSpider("Symptoms", allSym, sc)

            val painCharLabels = allSym.filter { sc[it.lowercase()] == "pain_character" }
            val accompLabels = allSym.filter { sc[it.lowercase()] == "accompanying" }

            _painCharSpider.value = buildFlatSpider("Pain Character", painCharLabels)
            _accompSpider.value = buildFlatSpider("Accompanying", accompLabels)

            val allPainLocs = migs.flatMap { it.painLocations ?: emptyList() }
            _painLocationSpider.value = buildFlatSpider("Pain Locations", allPainLocs)

            _severityCounts.value = migs.mapNotNull { it.severity }
                .groupingBy { it }.eachCount().toList().sortedBy { it.first }

            val durations = migs.mapNotNull { row ->
                val endAt = row.endAt ?: return@mapNotNull null
                try {
                    val hours = java.time.Duration.between(
                        Instant.parse(row.startAt), Instant.parse(endAt)
                    ).toMinutes() / 60f
                    if (hours > 0f) hours else null
                } catch (_: Exception) { null }
            }
            if (durations.isNotEmpty()) {
                _durationStats.value = DurationStats(
                    avgHours = durations.average().toFloat(),
                    minHours = durations.min(),
                    maxHours = durations.max(),
                    durations = durations.sorted()
                )
            }

            // Build filter tag index
            buildMigraineTagIndex(
                _rawMigraineRows.value,
                allTriggers, allMedicines, allReliefs,
                allP, allA, allL, allMs
            )
        } catch (e: Exception) {
            e.printStackTrace()
        } finally {
            _spiderLoading.value = false
        }
    }

    // ── Spider helpers ──

    internal fun buildSpider(
        logType: String,
        labels: List<String>,
        catMap: Map<String, String>
    ): SpiderData {
        val labelCounts = labels.groupingBy { it.lowercase() }.eachCount()
        val catGroups = mutableMapOf<String, MutableList<Pair<String, Int>>>()
        for ((label, count) in labelCounts) {
            val cat = catMap[label] ?: "Other"
            catGroups.getOrPut(cat) { mutableListOf() }
                .add(label.replaceFirstChar { it.uppercase() } to count)
        }
        val breakdowns = catGroups.map { (cat, items) ->
            CategoryBreakdown(cat, items.sumOf { it.second }, items.sortedByDescending { it.second })
        }.sortedByDescending { it.totalCount }

        return SpiderData(
            logType = logType,
            axes = breakdowns.map { SpiderAxis(it.categoryName, it.totalCount.toFloat()) },
            totalLogged = labels.size,
            breakdown = breakdowns
        )
    }

    /** Build SpiderData for flat lists (no category grouping). */
    internal fun buildFlatSpider(logType: String, labels: List<String>): SpiderData {
        val counts = labels.groupingBy { it }.eachCount()
        val breakdowns = counts.map { (label, count) ->
            CategoryBreakdown(label, count, listOf(label to count))
        }.sortedByDescending { it.totalCount }

        return SpiderData(
            logType = logType,
            axes = breakdowns.map { SpiderAxis(it.categoryName, it.totalCount.toFloat()) },
            totalLogged = labels.size,
            breakdown = breakdowns
        )
    }

    private fun reliefToNum(scale: String?): Float = when (scale?.uppercase()) {
        "HIGH" -> 3f
        "MILD" -> 2f
        "LOW" -> 1f
        else -> 0f
    }
}



title: InsightsWeatherPanel.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.location.LocationManager
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel

@Composable
fun InsightsWeatherPanel(
    vm: CityWeatherViewModel = viewModel()
) {
    val ctx = LocalContext.current
    val state by vm.state.collectAsState()

    val permLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) {
        vm.loadNearestAndDaily(getLastKnownLocationPreferGps(ctx))
    }

    LaunchedEffect(Unit) {
        val fine = ContextCompat.checkSelfPermission(ctx, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED
        val coarse = ContextCompat.checkSelfPermission(ctx, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED
        if (fine || coarse) {
            vm.loadNearestAndDaily(getLastKnownLocationPreferGps(ctx))
        } else {
            permLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }

    Column(
        Modifier
            .fillMaxWidth()
            .padding(12.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text("Local weather", style = MaterialTheme.typography.titleMedium)

        when {
            state.loading -> {
                Text("Loading…", style = MaterialTheme.typography.bodyMedium)
            }
            state.error != null -> {
                Text(
                    state.error ?: "Error",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.error
                )
            }
            else -> {
                val city = state.nearestCity
                if (city != null) {
                    Text(
                        "Nearest: ${city.label}" + (city.timezone?.let { "  •  $it" } ?: ""),
                        style = MaterialTheme.typography.bodyMedium
                    )
                } else {
                    Text("Nearest city unknown", style = MaterialTheme.typography.bodyMedium)
                }

                Divider()

                HeaderRow()

                Divider()

                state.days.forEach { d ->
                    DataRow(
                        day = d.day,
                        temp = d.tempMeanC,
                        pressure = d.pressureMeanHpa,
                        humidity = d.humidityMeanPct
                    )
                    Divider()
                }

                if (state.days.isEmpty()) {
                    Text("No daily data", style = MaterialTheme.typography.bodySmall)
                }
            }
        }
    }
}

/**
 * Prefer GPS if available. Otherwise return the most recent of Network/Passive.
 * This avoids Mountain View or Brighton from stale network fixes.
 */
private fun getLastKnownLocationPreferGps(ctx: Context): Location? {
    val lm = ctx.getSystemService(Context.LOCATION_SERVICE) as? LocationManager ?: return null
    val gps = try { lm.getLastKnownLocation(LocationManager.GPS_PROVIDER) } catch (_: SecurityException) { null }
    if (gps != null) return gps

    var best: Location? = null
    for (p in listOf(LocationManager.NETWORK_PROVIDER, LocationManager.PASSIVE_PROVIDER)) {
        val loc = try { lm.getLastKnownLocation(p) } catch (_: SecurityException) { null }
        if (loc != null && (best == null || loc.time > best!!.time)) {
            best = loc
        }
    }
    return best
}

@Composable
private fun HeaderRow() {
    Row(Modifier.fillMaxWidth().padding(top = 6.dp, bottom = 4.dp)) {
        Text("Day", Modifier.weight(1.2f), style = MaterialTheme.typography.labelMedium)
        Text("Temp °C", Modifier.weight(0.8f), style = MaterialTheme.typography.labelMedium)
        Text("Pressure hPa", Modifier.weight(1.0f), style = MaterialTheme.typography.labelMedium)
        Text("Humidity %", Modifier.weight(0.8f), style = MaterialTheme.typography.labelMedium)
    }
}

@Composable
private fun DataRow(day: String, temp: Double?, pressure: Double?, humidity: Double?) {
    Row(Modifier.fillMaxWidth().padding(vertical = 4.dp)) {
        Text(day, Modifier.weight(1.2f), style = MaterialTheme.typography.bodySmall)
        Text(temp?.let { String.format("%.1f", it) } ?: "—", Modifier.weight(0.8f), style = MaterialTheme.typography.bodySmall)
        Text(pressure?.let { String.format("%.0f", it) } ?: "—", Modifier.weight(1.0f), style = MaterialTheme.typography.bodySmall)
        Text(humidity?.let { String.format("%.0f", it) } ?: "—", Modifier.weight(0.8f), style = MaterialTheme.typography.bodySmall)
    }
}

title: JournalScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Error
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

@Composable
fun JournalScreen(navController: NavHostController, authVm: AuthViewModel, vm: LogViewModel) {
    val authState by authVm.state.collectAsState()
    val journal by vm.journal.collectAsState()
    val triggerLabelMap by vm.triggerLabelMap.collectAsState()

    LaunchedEffect(authState.accessToken) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) vm.loadJournal(token)
    }

    // Filter state
    val filters = listOf("All", "Migraines", "Triggers", "Prodromes", "Medicines", "Reliefs", "Activities", "Locations", "Needs attention")
    var filterOpen by rememberSaveable { mutableStateOf(false) }
    var selectedFilter by rememberSaveable { mutableStateOf("All") }

    // Apply filter
    val filtered = when (selectedFilter) {
        "Migraines" -> journal.filterIsInstance<JournalEvent.Migraine>()
        "Triggers" -> journal.filterIsInstance<JournalEvent.Trigger>()
        "Prodromes" -> journal.filterIsInstance<JournalEvent.Prodrome>()
        "Medicines" -> journal.filterIsInstance<JournalEvent.Medicine>()
        "Reliefs" -> journal.filterIsInstance<JournalEvent.Relief>()
        "Activities" -> journal.filterIsInstance<JournalEvent.Activity>()
        "Missed Activities" -> journal.filterIsInstance<JournalEvent.MissedActivity>()
        "Locations" -> journal.filterIsInstance<JournalEvent.Location>()
        "Needs attention" -> journal.filter { needsAttention(it) }
        else -> journal
    }

    val scrollState = rememberScrollState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Filter Card (Hero style like Home)
            HeroCard {
                Text(
                    "Filter",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )

                Box(Modifier.fillMaxWidth()) {
                    OutlinedTextField(
                        value = selectedFilter,
                        onValueChange = {},
                        readOnly = true,
                        trailingIcon = {
                            IconButton(onClick = { filterOpen = true }) {
                                Text("▼", color = Color.White)
                            }
                        },
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                        )
                    )
                    DropdownMenu(
                        expanded = filterOpen,
                        onDismissRequest = { filterOpen = false },
                        modifier = Modifier.background(Color(0xFF1E0A2E))
                    ) {
                        filters.forEachIndexed { i, f ->
                            if (i == filters.size - 1) Divider(color = Color.White.copy(alpha = 0.1f))
                            DropdownMenuItem(
                                text = {
                                    Text(
                                        f,
                                        color = if (f == selectedFilter) AppTheme.AccentPurple else Color.White,
                                        style = MaterialTheme.typography.bodyMedium.copy(
                                            fontWeight = if (f == selectedFilter) FontWeight.SemiBold else FontWeight.Normal
                                        )
                                    )
                                },
                                onClick = {
                                    selectedFilter = f
                                    filterOpen = false
                                },
                                modifier = Modifier.background(
                                    if (f == selectedFilter) AppTheme.AccentPurple.copy(alpha = 0.1f) else Color.Transparent
                                )
                            )
                        }
                    }
                }

                Text(
                    "${filtered.size} entries",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            // Journal Entries
            if (filtered.isEmpty()) {
                BaseCard {
                    Text(
                        "No logs found",
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        "Start logging migraines, triggers, medicines, and reliefs to see them here.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            } else {
                filtered.forEach { ev ->
                    JournalEntryCard(
                        event = ev,
                        authState = authState,
                        navController = navController,
                        vm = vm,
                        triggerLabelMap = triggerLabelMap
                    )
                }
            }
        }
    }
}

@Composable
private fun JournalEntryCard(
    event: JournalEvent,
    authState: AuthState,
    navController: NavHostController,
    vm: LogViewModel,
    triggerLabelMap: Map<String, String> = emptyMap()
) {
    val needsAttn = needsAttention(event)
    var confirmDelete by rememberSaveable((event as? Any)?.hashCode() ?: 0) { mutableStateOf(false) }

    BaseCard {
        Box(Modifier.fillMaxWidth()) {
            Column(
                Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(6.dp)
            ) {
                when (event) {
                    is JournalEvent.Migraine -> {
                        Text(
                            "Migraine",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        JournalRowLine("Type", event.row.type ?: "-")
                        JournalRowLine("Severity", event.row.severity?.toString() ?: "Not set")
                        JournalRowTime("Start", event.row.startAt)
                        JournalRowTime("End", event.row.endAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)

                        // ── Linked items ──
                        val linked = event.linked
                        val hasLinked = linked.triggers.isNotEmpty() || linked.medicines.isNotEmpty() ||
                                linked.reliefs.isNotEmpty() || linked.prodromes.isNotEmpty() ||
                                linked.activities.isNotEmpty() || linked.locations.isNotEmpty()
                        if (hasLinked) {
                            Spacer(Modifier.height(4.dp))
                            Divider(color = Color.White.copy(alpha = 0.1f))
                            Spacer(Modifier.height(4.dp))
                            if (linked.triggers.isNotEmpty()) {
                                LinkedSection("Triggers", linked.triggers.mapNotNull { t ->
                                    val label = t.type?.let { triggerLabelMap[it] ?: it.replace("_", " ").replaceFirstChar { c -> c.uppercase() } }
                                    label
                                })
                            }
                            if (linked.prodromes.isNotEmpty()) {
                                LinkedSection("Prodromes", linked.prodromes.mapNotNull { it.type?.replace("_", " ")?.replaceFirstChar { c -> c.uppercase() } })
                            }
                            if (linked.medicines.isNotEmpty()) {
                                LinkedSection("Medicines", linked.medicines.mapNotNull { m ->
                                    listOfNotNull(m.name, m.amount?.let { "($it)" }).joinToString(" ")
                                })
                            }
                            if (linked.reliefs.isNotEmpty()) {
                                LinkedSection("Reliefs", linked.reliefs.mapNotNull { it.type?.replace("_", " ")?.replaceFirstChar { c -> c.uppercase() } })
                            }
                            if (linked.activities.isNotEmpty()) {
                                LinkedSection("Activities", linked.activities.mapNotNull { it.type?.replace("_", " ")?.replaceFirstChar { c -> c.uppercase() } })
                            }
                            if (linked.locations.isNotEmpty()) {
                                LinkedSection("Locations", linked.locations.mapNotNull { it.type?.replace("_", " ")?.replaceFirstChar { c -> c.uppercase() } })
                            }
                        }

                        JournalCardActions(
                            onEdit = { navController.navigate("${Routes.EDIT_MIGRAINE}/${event.row.id}") },
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeMigraine(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                    is JournalEvent.Trigger -> {
                        val isPredicted = event.row.type == "menstruation_predicted"
                        
                        Row(
                            Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "Trigger",
                                color = AppTheme.TitleColor,
                                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                            )
                            if (isPredicted) {
                                Text(
                                    "Predicted",
                                    color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.bodySmall
                                )
                            }
                        }
                        val triggerDisplayLabel = event.row.type?.let { t ->
                            triggerLabelMap[t] ?: t.replace("_", " ")
                                .replaceFirstChar { c -> c.uppercase() }
                        } ?: "-"
                        JournalRowLine("Type", triggerDisplayLabel)
                        if (event.row.source == "system") {
                            JournalRowLine("Source", "Auto-detected")
                        }
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        
                        // Only show Edit/Delete for non-predicted triggers
                        if (!isPredicted) {
                            JournalCardActions(
                                onEdit = { navController.navigate("${Routes.EDIT_TRIGGER}/${event.row.id}") },
                                onDelete = { confirmDelete = true }
                            )
                            if (confirmDelete) {
                                DeleteDialog(
                                    onDismiss = { confirmDelete = false },
                                    onConfirm = {
                                        val token = authState.accessToken
                                        if (!token.isNullOrBlank()) vm.removeTrigger(token, event.row.id)
                                        confirmDelete = false
                                    }
                                )
                            }
                        }
                    }
                    is JournalEvent.Medicine -> {
                        Text(
                            "Medicine",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        JournalRowLine("Name", event.row.name ?: "-")
                        JournalRowAmount("Amount", event.row.amount)
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        JournalCardActions(
                            onEdit = { navController.navigate("${Routes.EDIT_MEDICINE}/${event.row.id}") },
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeMedicine(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                    is JournalEvent.Relief -> {
                        Text(
                            "Relief",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        JournalRowLine("Type", event.row.type ?: "-")
                        JournalRowDuration("Duration", event.row.durationMinutes)
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.endAt.isNullOrBlank()) JournalRowTime("End", event.row.endAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        JournalCardActions(
                            onEdit = { navController.navigate("${Routes.EDIT_RELIEF}/${event.row.id}") },
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeRelief(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                    is JournalEvent.Prodrome -> {
                        Text("Prodrome", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                        JournalRowLine("Type", event.row.type?.replace("_", " ")?.replaceFirstChar { it.uppercase() } ?: "-")
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        JournalCardActions(
                            onEdit = { navController.navigate("${Routes.EDIT_PRODROME}/${event.row.id}") },
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeProdrome(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                    is JournalEvent.Location -> {
                        Text("Location", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                        JournalRowLine("Type", event.row.type?.replace("_", " ")?.replaceFirstChar { it.uppercase() } ?: "-")
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        JournalCardActions(
                            onEdit = { navController.navigate("${Routes.EDIT_LOCATION}/${event.row.id}") },
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeLocation(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                    is JournalEvent.Activity -> {
                        Text("Activity", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                        JournalRowLine("Type", event.row.type?.replace("_", " ")?.replaceFirstChar { it.uppercase() } ?: "-")
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.endAt.isNullOrBlank()) JournalRowTime("End", event.row.endAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        JournalCardActions(
                            onEdit = { navController.navigate("${Routes.EDIT_ACTIVITY}/${event.row.id}") },
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeActivity(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                    is JournalEvent.MissedActivity -> {
                        Text("Missed Activity", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                        JournalRowLine("Type", event.row.type?.replace("_", " ")?.replaceFirstChar { it.uppercase() } ?: "-")
                        JournalRowTime("Start", event.row.startAt)
                        if (!event.row.notes.isNullOrBlank()) JournalRowLine("Notes", event.row.notes!!)
                        JournalCardActions(
                            onEdit = null,
                            onDelete = { confirmDelete = true }
                        )
                        if (confirmDelete) {
                            DeleteDialog(
                                onDismiss = { confirmDelete = false },
                                onConfirm = {
                                    val token = authState.accessToken
                                    if (!token.isNullOrBlank()) vm.removeMissedActivity(token, event.row.id)
                                    confirmDelete = false
                                }
                            )
                        }
                    }
                }
            }

            if (needsAttn) {
                Icon(
                    imageVector = Icons.Filled.Error,
                    contentDescription = "Missing data",
                    tint = AppTheme.AccentPink,
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .padding(4.dp)
                )
            }
        }
    }
}

/* ---------- attention logic ---------- */

private fun needsAttention(ev: JournalEvent): Boolean {
    return when (ev) {
        is JournalEvent.Migraine -> ev.row.startAt.isNullOrBlank() || ev.row.endAt.isNullOrBlank() || ev.row.severity == null
        is JournalEvent.Trigger -> ev.row.startAt.isNullOrBlank()
        is JournalEvent.Medicine -> ev.row.amount.isNullOrBlank() || ev.row.startAt.isNullOrBlank()
        is JournalEvent.Relief -> ev.row.durationMinutes == null || ev.row.startAt.isNullOrBlank()
        is JournalEvent.Prodrome -> ev.row.startAt.isNullOrBlank()
        is JournalEvent.Location -> false
        is JournalEvent.Activity -> ev.row.startAt.isNullOrBlank()
        is JournalEvent.MissedActivity -> false
    }
}

/* ---------- UI helpers ---------- */

@Composable
private fun JournalCardActions(
    onEdit: (() -> Unit)?,
    onDelete: () -> Unit
) {
    Spacer(Modifier.height(8.dp))
    Divider(color = Color.White.copy(alpha = 0.1f))
    Spacer(Modifier.height(4.dp))
    Row(
        Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.End
    ) {
        if (onEdit != null) {
            TextButton(onClick = onEdit) {
                Text("Edit", color = AppTheme.AccentPurple)
            }
            Spacer(Modifier.width(8.dp))
        }
        TextButton(onClick = onDelete) {
            Text("Delete", color = Color(0xFFFF6B6B))
        }
    }
}

@Composable
private fun LinkedSection(label: String, items: List<String>) {
    if (items.isEmpty()) return
    Row(
        Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
        Text(
            items.joinToString(", "),
            color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelSmall,
            modifier = Modifier.padding(start = 16.dp)
        )
    }
}

@Composable
private fun JournalRowLine(label: String, value: String) {
    Row(
        Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
        Text(value, color = Color.White, style = MaterialTheme.typography.bodyMedium)
    }
}

@Composable
private fun JournalRowTime(label: String, isoTime: String?) {
    val display = isoTime?.let {
        try {
            val zdt = ZonedDateTime.parse(it)
            zdt.format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm"))
        } catch (_: Exception) {
            it
        }
    } ?: "-"
    JournalRowLine(label, display)
}

@Composable
private fun JournalRowAmount(label: String, amount: String?) {
    JournalRowLine(label, amount ?: "-")
}

@Composable
private fun JournalRowDuration(label: String, minutes: Int?) {
    val display = minutes?.let {
        when {
            it >= 60 -> "${it / 60}h ${it % 60}m"
            else -> "${it}m"
        }
    } ?: "-"
    JournalRowLine(label, display)
}

@Composable
private fun DeleteDialog(
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Delete Entry") },
        text = { Text("Are you sure you want to delete this entry? This cannot be undone.") },
        confirmButton = {
            TextButton(onClick = onConfirm) {
                Text("Delete", color = Color(0xFFFF6B6B))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}



title: JwtUtils.kt
text:
package com.migraineme

import android.util.Base64
import org.json.JSONObject

object JwtUtils {

    /**
     * Extracts the Supabase user id (UUID) from a JWT access token.
     * Supabase tokens include the user id in the "sub" claim.
     *
     * Returns null if the token is not a JWT or cannot be decoded.
     */
    fun extractUserIdFromAccessToken(accessToken: String?): String? {
        if (accessToken.isNullOrBlank()) return null

        return try {
            val parts = accessToken.split(".")
            if (parts.size < 2) return null

            val payloadB64Url = parts[1]
            val payloadJson = String(
                Base64.decode(
                    payloadB64Url
                        .replace('-', '+')
                        .replace('_', '/')
                        .padEnd(((payloadB64Url.length + 3) / 4) * 4, '='),
                    Base64.DEFAULT
                )
            )

            val obj = JSONObject(payloadJson)
            val sub = obj.optString("sub", null)
            if (sub.isNullOrBlank()) null else sub
        } catch (_: Exception) {
            null
        }
    }
}

title: LocationDailySyncWorker.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.location.LocationManager
import android.os.Looper
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.work.BackoffPolicy
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.CancellationTokenSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import java.time.LocalDate
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.util.concurrent.TimeUnit
import kotlin.coroutines.resume

/**
 * Worker that uploads device location to:
 * - user_location_hourly (every sync, with timestamp)
 * - user_location_daily (once per day, for weather)
 * 
 * Triggered by:
 * - FCM push notification (primary - server sends every hour)
 * - User toggles location ON in app
 * - Login (initial sync)
 * 
 * NO self-scheduling - FCM handles timing.
 */
class LocationDailySyncWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            Log.d(LOG_TAG, "---- Running LocationDailySyncWorker ----")

            val access = SessionStore.getValidAccessToken(applicationContext)
            if (access == null) {
                Log.w(LOG_TAG, "No valid access token; will retry")
                return@withContext Result.retry()
            }

            // Check Supabase metric_settings for location enabled
            val edge = EdgeFunctionsService()
            val settings = edge.getMetricSettings(applicationContext)
            val locationEnabled = settings.find { it.metric == "user_location_daily" }?.enabled ?: false

            if (!locationEnabled) {
                Log.d(LOG_TAG, "user_location_daily disabled in Supabase – skip")
                return@withContext Result.success()
            }

            val loc = getDeviceLocation(applicationContext)
            if (loc == null) {
                Log.w(LOG_TAG, "No location found; will retry")
                return@withContext Result.retry()
            }

            val lat = loc.latitude
            val lon = loc.longitude
            val altitudeM = if (loc.hasAltitude()) loc.altitude else null
            val deviceTimezone = ZoneId.systemDefault().id
            val now = ZonedDateTime.now()
            
            val svc = SupabasePersonalService(applicationContext)

            // 1. Always insert into user_location_hourly
            val hourlySuccess = insertHourlyLocation(
                svc = svc,
                accessToken = access,
                timestamp = now,
                latitude = lat,
                longitude = lon,
                altitudeM = altitudeM,
                timezone = deviceTimezone
            )
            
            if (hourlySuccess) {
                Log.d(LOG_TAG, "✅ Inserted hourly location for ${now.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)} alt=${altitudeM?.let { String.format("%.0fm", it) } ?: "N/A"}")
            } else {
                Log.w(LOG_TAG, "⚠️ Failed to insert hourly location")
            }

            // 2. Upsert into user_location_daily with altitude aggregation
            val today = LocalDate.now(ZoneId.systemDefault())

            // Fetch all hourly altitude readings for today to compute max/min/change
            val altAgg = fetchTodayAltitudeAgg(svc, access, today.toString())

            val dailySuccess = runCatching {
                svc.upsertUserLocationDaily(
                    accessToken = access,
                    date = today.toString(),
                    latitude = lat,
                    longitude = lon,
                    source = "device",
                    timezone = deviceTimezone,
                    altitudeM = altitudeM,
                    altitudeMaxM = altAgg?.max,
                    altitudeMinM = altAgg?.min,
                    altitudeChangeM = altAgg?.let { it.max - it.min }
                )
            }.onFailure { e ->
                Log.e(LOG_TAG, "Daily upsert error: ${e.message}")
            }.isSuccess
            
            if (dailySuccess) {
                val changeStr = altAgg?.let { "max=${String.format("%.0f", it.max)}m min=${String.format("%.0f", it.min)}m Δ${String.format("%.0f", it.max - it.min)}m" } ?: "no alt data"
                Log.d(LOG_TAG, "✅ Upserted daily location for $today ($changeStr)")
            } else {
                Log.w(LOG_TAG, "⚠️ Failed to upsert daily location")
            }

            Result.success()

        } catch (t: Throwable) {
            Log.w(LOG_TAG, "Worker error", t)
            Result.retry()
        }
    }

    private suspend fun insertHourlyLocation(
        svc: SupabasePersonalService,
        accessToken: String,
        timestamp: ZonedDateTime,
        latitude: Double,
        longitude: Double,
        altitudeM: Double?,
        timezone: String
    ): Boolean {
        return try {
            svc.insertUserLocationHourly(
                accessToken = accessToken,
                timestamp = timestamp.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME),
                latitude = latitude,
                longitude = longitude,
                timezone = timezone,
                altitudeM = altitudeM
            )
            true
        } catch (e: Exception) {
            Log.e(LOG_TAG, "Failed to insert hourly location", e)
            false
        }
    }

    private data class AltitudeAgg(val max: Double, val min: Double)

    /**
     * Fetch all hourly altitude readings for a given date and compute max/min.
     * Uses the hourly table to get running aggregation.
     */
    private suspend fun fetchTodayAltitudeAgg(
        svc: SupabasePersonalService,
        accessToken: String,
        date: String
    ): AltitudeAgg? {
        return try {
            val altitudes = svc.fetchHourlyAltitudesForDate(accessToken, date)
            if (altitudes.isEmpty()) return null
            AltitudeAgg(max = altitudes.max(), min = altitudes.min())
        } catch (e: Exception) {
            Log.e(LOG_TAG, "Failed to fetch altitude agg: ${e.message}")
            null
        }
    }

    companion object {
        private const val UNIQUE_WORK = "location_daily_worker"
        private const val LOG_TAG = "LocationDailySync"

        /**
         * Run location sync immediately.
         * Called from: FCM push, login, toggle ON
         */
        fun runOnceNow(context: Context) {
            Log.d(LOG_TAG, "runOnceNow called")
            val req = OneTimeWorkRequestBuilder<LocationDailySyncWorker>()
                .setInitialDelay(0, TimeUnit.MILLISECONDS)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 15, TimeUnit.MINUTES)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_WORK, ExistingWorkPolicy.REPLACE, req
            )
        }

        // Alias for FCM service
        fun runOnce(context: Context) = runOnceNow(context)

        /**
         * Cancel any pending work
         */
        fun cancelAll(context: Context) {
            Log.d(LOG_TAG, "Cancelling location worker")
            WorkManager.getInstance(context).cancelUniqueWork(UNIQUE_WORK)
        }

        /**
         * Get device location with multiple fallback strategies.
         * 
         * Uses PRIORITY_BALANCED_POWER_ACCURACY (cell/WiFi) instead of GPS because:
         * - Works instantly (no satellite acquisition needed)
         * - Works indoors
         * - ~100m accuracy is plenty for weather data
         * - Much better battery life
         * 
         * Fallback order:
         * 1. getCurrentLocation() (active request)
         * 2. lastLocation (cached)
         * 3. requestLocationUpdates with timeout
         * 4. Legacy LocationManager
         */
        suspend fun getDeviceLocation(context: Context): Location? {
            val hasFine = ContextCompat.checkSelfPermission(
                context, Manifest.permission.ACCESS_FINE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED

            val hasCoarse = ContextCompat.checkSelfPermission(
                context, Manifest.permission.ACCESS_COARSE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED

            if (!hasFine && !hasCoarse) {
                Log.w(LOG_TAG, "No location permission")
                return null
            }

            val client = LocationServices.getFusedLocationProviderClient(context)
            
            // Use balanced power (cell/WiFi) - works instantly, good enough for weather
            val priority = Priority.PRIORITY_BALANCED_POWER_ACCURACY

            // Strategy 1: getCurrentLocation (active request, best option)
            try {
                Log.d(LOG_TAG, "Trying getCurrentLocation (balanced/cell+WiFi)...")
                val cts = CancellationTokenSource()
                val loc = withTimeoutOrNull(10_000L) {
                    client.getCurrentLocation(priority, cts.token).await()
                }
                if (loc != null) {
                    Log.d(LOG_TAG, "✅ Got location via getCurrentLocation: ${loc.latitude}, ${loc.longitude}")
                    return loc
                }
                Log.d(LOG_TAG, "getCurrentLocation returned null")
            } catch (e: Exception) {
                Log.w(LOG_TAG, "getCurrentLocation failed: ${e.message}")
            }

            // Strategy 2: lastLocation (cached)
            try {
                Log.d(LOG_TAG, "Trying lastLocation (cached)...")
                val cached = client.lastLocation.await()
                if (cached != null) {
                    Log.d(LOG_TAG, "✅ Got cached location: ${cached.latitude}, ${cached.longitude}")
                    return cached
                }
                Log.d(LOG_TAG, "lastLocation returned null")
            } catch (e: Exception) {
                Log.w(LOG_TAG, "lastLocation failed: ${e.message}")
            }

            // Strategy 3: requestLocationUpdates with timeout
            try {
                Log.d(LOG_TAG, "Trying requestLocationUpdates...")
                val loc = withTimeoutOrNull(15_000L) {
                    requestSingleLocationUpdate(context, priority)
                }
                if (loc != null) {
                    Log.d(LOG_TAG, "✅ Got location via requestLocationUpdates: ${loc.latitude}, ${loc.longitude}")
                    return loc
                }
                Log.d(LOG_TAG, "requestLocationUpdates returned null")
            } catch (e: Exception) {
                Log.w(LOG_TAG, "requestLocationUpdates failed: ${e.message}")
            }

            // Strategy 4: Legacy LocationManager fallback (network provider preferred)
            try {
                Log.d(LOG_TAG, "Trying legacy LocationManager...")
                val loc = getLegacyLocation(context)
                if (loc != null) {
                    Log.d(LOG_TAG, "✅ Got location via LocationManager: ${loc.latitude}, ${loc.longitude}")
                    return loc
                }
                Log.d(LOG_TAG, "LocationManager returned null")
            } catch (e: Exception) {
                Log.w(LOG_TAG, "LocationManager failed: ${e.message}")
            }

            Log.e(LOG_TAG, "❌ All location strategies failed")
            return null
        }

        /**
         * Request a single location update using FusedLocationProviderClient
         */
        @Suppress("MissingPermission")
        private suspend fun requestSingleLocationUpdate(context: Context, priority: Int): Location? {
            return suspendCancellableCoroutine { cont ->
                val client = LocationServices.getFusedLocationProviderClient(context)
                
                val request = LocationRequest.Builder(priority, 0L)
                    .setMaxUpdates(1)
                    .setMinUpdateIntervalMillis(0)
                    .setWaitForAccurateLocation(false)
                    .build()

                val callback = object : LocationCallback() {
                    override fun onLocationResult(result: LocationResult) {
                        client.removeLocationUpdates(this)
                        if (cont.isActive) {
                            cont.resume(result.lastLocation)
                        }
                    }
                }

                try {
                    client.requestLocationUpdates(request, callback, Looper.getMainLooper())
                } catch (e: Exception) {
                    if (cont.isActive) {
                        cont.resume(null)
                    }
                }

                cont.invokeOnCancellation {
                    client.removeLocationUpdates(callback)
                }
            }
        }

        /**
         * Legacy LocationManager fallback - prioritizes network provider (cell/WiFi)
         * since we want fast, battery-efficient location for weather data.
         */
        @Suppress("MissingPermission")
        private fun getLegacyLocation(context: Context): Location? {
            val lm = context.getSystemService(Context.LOCATION_SERVICE) as? LocationManager
                ?: return null

            // Network provider first (cell/WiFi - fast, battery efficient)
            try {
                val network = lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)
                if (network != null) return network
            } catch (_: Exception) { }

            // Passive provider (uses locations from other apps)
            try {
                val passive = lm.getLastKnownLocation(LocationManager.PASSIVE_PROVIDER)
                if (passive != null) return passive
            } catch (_: Exception) { }

            // GPS last resort (might be stale but better than nothing)
            try {
                val gps = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER)
                if (gps != null) return gps
            } catch (_: Exception) { }

            return null
        }
    }
}


title: LocationIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

object LocationIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    // ─── EXERCISE ───────────────────────────────────────────

    /** gym — dumbbell */
    val Gym: ImageVector by lazy {
        ImageVector.Builder("Gym", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 9f); lineTo(6f, 15f); moveTo(4f, 10f); lineTo(4f, 14f); moveTo(2f, 11f); lineTo(2f, 13f)
                moveTo(18f, 9f); lineTo(18f, 15f); moveTo(20f, 10f); lineTo(20f, 14f); moveTo(22f, 11f); lineTo(22f, 13f)
                moveTo(6f, 12f); lineTo(18f, 12f)
            }
        }.build()
    }

    // ─── HOME ───────────────────────────────────────────────

    /** home — house */
    val Home: ImageVector by lazy {
        ImageVector.Builder("Home", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 10f); lineTo(12f, 3f); lineTo(21f, 10f)
                moveTo(5f, 10f); lineTo(5f, 20f); lineTo(19f, 20f); lineTo(19f, 10f)
                moveTo(10f, 20f); lineTo(10f, 14f); lineTo(14f, 14f); lineTo(14f, 20f)
            }
        }.build()
    }

    // ─── MEDICAL ────────────────────────────────────────────

    /** doctor — stethoscope */
    val Doctor: ImageVector by lazy {
        ImageVector.Builder("Doctor", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 3f); lineTo(6f, 8f); curveTo(6f, 12f, 9f, 14f, 12f, 14f)
                moveTo(18f, 3f); lineTo(18f, 8f); curveTo(18f, 12f, 15f, 14f, 12f, 14f)
                moveTo(12f, 14f); lineTo(12f, 17f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 19f); arcTo(2f, 2f, 0f, true, true, 10f, 19f); arcTo(2f, 2f, 0f, true, true, 14f, 19f)
            }
        }.build()
    }

    /** hospital — building with cross */
    val Hospital: ImageVector by lazy {
        ImageVector.Builder("Hospital", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 21f); lineTo(4f, 4f); lineTo(20f, 4f); lineTo(20f, 21f); close()
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 8f); lineTo(12f, 14f); moveTo(9f, 11f); lineTo(15f, 11f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(9f, 21f); lineTo(9f, 17f); lineTo(15f, 17f); lineTo(15f, 21f)
            }
        }.build()
    }

    // ─── OTHER ──────────────────────────────────────────────

    /** church — building with cross on top */
    val Church: ImageVector by lazy {
        ImageVector.Builder("Church", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 6f); moveTo(10f, 4f); lineTo(14f, 4f)
                moveTo(12f, 6f); lineTo(6f, 12f); lineTo(6f, 21f); lineTo(18f, 21f); lineTo(18f, 12f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 21f); lineTo(10f, 17f); curveTo(10f, 16f, 11f, 15f, 12f, 15f); curveTo(13f, 15f, 14f, 16f, 14f, 17f); lineTo(14f, 21f)
            }
        }.build()
    }

    /** school — graduation cap */
    val School: ImageVector by lazy {
        ImageVector.Builder("School", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 10f); lineTo(12f, 5f); lineTo(22f, 10f); lineTo(12f, 15f); close()
                moveTo(6f, 12f); lineTo(6f, 17f); curveTo(6f, 17f, 9f, 20f, 12f, 20f); curveTo(15f, 20f, 18f, 17f, 18f, 17f); lineTo(18f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(22f, 10f); lineTo(22f, 16f)
            }
        }.build()
    }

    /** shop — shopping bag */
    val Shop: ImageVector by lazy {
        ImageVector.Builder("Shop", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 8f); lineTo(5f, 20f); lineTo(19f, 20f); lineTo(19f, 8f); close()
                moveTo(8f, 8f); lineTo(8f, 6f); curveTo(8f, 4f, 10f, 2f, 12f, 2f); curveTo(14f, 2f, 16f, 4f, 16f, 6f); lineTo(16f, 8f)
            }
        }.build()
    }

    /** supermarket — shopping cart */
    val Supermarket: ImageVector by lazy {
        ImageVector.Builder("Supermarket", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 3f); lineTo(5f, 3f); lineTo(8f, 16f); lineTo(19f, 16f); lineTo(21f, 7f); lineTo(6f, 7f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 20f); arcTo(1f, 1f, 0f, true, true, 8f, 20f); arcTo(1f, 1f, 0f, true, true, 10f, 20f)
                moveTo(19f, 20f); arcTo(1f, 1f, 0f, true, true, 17f, 20f); arcTo(1f, 1f, 0f, true, true, 19f, 20f)
            }
        }.build()
    }

    // ─── OUTDOORS ───────────────────────────────────────────

    /** beach — sun + wave */
    val Beach: ImageVector by lazy {
        ImageVector.Builder("Beach", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 8f); arcTo(3f, 3f, 0f, true, true, 11f, 8f); arcTo(3f, 3f, 0f, true, true, 17f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 18f); curveTo(4f, 16f, 6f, 16f, 8f, 18f); curveTo(10f, 20f, 12f, 20f, 14f, 18f)
                curveTo(16f, 16f, 18f, 16f, 20f, 18f); curveTo(21f, 19f, 22f, 19f, 22f, 18f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(5f, 14f); lineTo(19f, 14f)
            }
        }.build()
    }

    /** outdoors — tree */
    val Outdoors: ImageVector by lazy {
        ImageVector.Builder("Outdoors", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 3f); lineTo(5f, 13f); lineTo(8f, 13f); lineTo(4f, 19f); lineTo(20f, 19f); lineTo(16f, 13f); lineTo(19f, 13f); close()
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 19f); lineTo(12f, 22f)
            }
        }.build()
    }

    /** park — bench */
    val Park: ImageVector by lazy {
        ImageVector.Builder("Park", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 12f); lineTo(20f, 12f)
                moveTo(6f, 12f); lineTo(4f, 20f); moveTo(18f, 12f); lineTo(20f, 20f)
                moveTo(4f, 8f); lineTo(4f, 12f); moveTo(20f, 8f); lineTo(20f, 12f)
                moveTo(8f, 12f); lineTo(8f, 16f); moveTo(16f, 12f); lineTo(16f, 16f)
                moveTo(8f, 16f); lineTo(16f, 16f)
            }
        }.build()
    }

    // ─── SOCIAL ─────────────────────────────────────────────

    /** bar — cocktail glass */
    val Bar: ImageVector by lazy {
        ImageVector.Builder("Bar", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 4f); lineTo(20f, 4f); lineTo(12f, 14f); close()
                moveTo(12f, 14f); lineTo(12f, 20f)
                moveTo(8f, 20f); lineTo(16f, 20f)
            }
        }.build()
    }

    /** cinema — film clapboard */
    val Cinema: ImageVector by lazy {
        ImageVector.Builder("Cinema", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 8f); lineTo(20f, 8f); lineTo(20f, 20f); lineTo(4f, 20f); close()
                moveTo(4f, 4f); lineTo(20f, 4f); lineTo(20f, 8f); lineTo(4f, 8f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 4f); lineTo(10f, 8f)
                moveTo(14f, 4f); lineTo(16f, 8f)
            }
        }.build()
    }

    /** restaurant — fork + knife */
    val Restaurant: ImageVector by lazy {
        ImageVector.Builder("Restaurant", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 2f); lineTo(7f, 9f); curveTo(7f, 11f, 8f, 12f, 10f, 12f); lineTo(10f, 22f)
                moveTo(7f, 6f); lineTo(4f, 6f); lineTo(4f, 2f)
                moveTo(7f, 6f); lineTo(10f, 6f); lineTo(10f, 2f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 2f); lineTo(17f, 8f); curveTo(17f, 10f, 19f, 12f, 20f, 12f)
                moveTo(17f, 12f); lineTo(17f, 22f)
            }
        }.build()
    }

    // ─── TRANSPORT ──────────────────────────────────────────

    /** bus */
    val Bus: ImageVector by lazy {
        ImageVector.Builder("Bus", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 4f); lineTo(19f, 4f); curveTo(20f, 4f, 21f, 5f, 21f, 6f); lineTo(21f, 17f); lineTo(3f, 17f); lineTo(3f, 6f); curveTo(3f, 5f, 4f, 4f, 5f, 4f)
                moveTo(3f, 12f); lineTo(21f, 12f)
                moveTo(5f, 17f); lineTo(5f, 20f); moveTo(19f, 17f); lineTo(19f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 15f); lineTo(7.1f, 15f); moveTo(17f, 15f); lineTo(17.1f, 15f)
            }
        }.build()
    }

    /** car */
    val Car: ImageVector by lazy {
        ImageVector.Builder("Car", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 11f); lineTo(7f, 5f); lineTo(17f, 5f); lineTo(19f, 11f)
                moveTo(3f, 11f); lineTo(21f, 11f); lineTo(21f, 17f); lineTo(3f, 17f); close()
                moveTo(5f, 17f); lineTo(5f, 19f); moveTo(19f, 17f); lineTo(19f, 19f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 14f); lineTo(7.1f, 14f); moveTo(17f, 14f); lineTo(17.1f, 14f)
            }
        }.build()
    }

    /** plane */
    val Plane: ImageVector by lazy {
        ImageVector.Builder("Plane", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 14f); lineTo(10f, 11f); lineTo(10f, 4f)
                curveTo(10f, 3f, 11f, 2f, 12f, 2f); curveTo(13f, 2f, 14f, 3f, 14f, 4f)
                lineTo(14f, 11f); lineTo(22f, 14f); lineTo(22f, 16f); lineTo(14f, 14f)
                lineTo(14f, 18f); lineTo(17f, 20f); lineTo(17f, 21f); lineTo(12f, 20f)
                lineTo(7f, 21f); lineTo(7f, 20f); lineTo(10f, 18f); lineTo(10f, 14f)
                lineTo(2f, 16f); close()
            }
        }.build()
    }

    /** train */
    val Train: ImageVector by lazy {
        ImageVector.Builder("Train", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 3f); lineTo(18f, 3f); curveTo(19f, 3f, 20f, 4f, 20f, 5f); lineTo(20f, 16f)
                curveTo(20f, 17f, 19f, 18f, 18f, 18f); lineTo(6f, 18f); curveTo(5f, 18f, 4f, 17f, 4f, 16f); lineTo(4f, 5f); curveTo(4f, 4f, 5f, 3f, 6f, 3f)
                moveTo(4f, 11f); lineTo(20f, 11f)
                moveTo(7f, 22f); lineTo(4f, 18f); moveTo(17f, 22f); lineTo(20f, 18f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 15f); lineTo(8.1f, 15f); moveTo(16f, 15f); lineTo(16.1f, 15f)
            }
        }.build()
    }

    // ─── WORK ───────────────────────────────────────────────

    /** office — desk with monitor */
    val Office: ImageVector by lazy {
        ImageVector.Builder("Office", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 4f); lineTo(18f, 4f); lineTo(18f, 14f); lineTo(6f, 14f); close()
                moveTo(12f, 14f); lineTo(12f, 17f)
                moveTo(8f, 17f); lineTo(16f, 17f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 20f); lineTo(21f, 20f)
            }
        }.build()
    }

    /** work — briefcase */
    val Work: ImageVector by lazy {
        ImageVector.Builder("Work", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 8f); lineTo(21f, 8f); lineTo(21f, 20f); lineTo(3f, 20f); close()
                moveTo(8f, 8f); lineTo(8f, 5f); curveTo(8f, 4f, 9f, 3f, 10f, 3f); lineTo(14f, 3f)
                curveTo(15f, 3f, 16f, 4f, 16f, 5f); lineTo(16f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 13f); lineTo(21f, 13f)
            }
        }.build()
    }

    /** other — map pin */
    val Other: ImageVector by lazy {
        ImageVector.Builder("LocationOther", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f); curveTo(12f, 22f, 19f, 16f, 19f, 10f); curveTo(19f, 6f, 16f, 3f, 12f, 3f)
                curveTo(8f, 3f, 5f, 6f, 5f, 10f); curveTo(5f, 16f, 12f, 22f, 12f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 10f); arcTo(2f, 2f, 0f, true, true, 10f, 10f); arcTo(2f, 2f, 0f, true, true, 14f, 10f)
            }
        }.build()
    }

    // ─── LOOKUP ────────────────────────────────────────────────

    data class LocationPickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<LocationPickerIcon> by lazy { listOf(
        LocationPickerIcon("gym", "Gym", Gym),
        LocationPickerIcon("home", "Home", Home),
        LocationPickerIcon("doctor", "Doctor", Doctor),
        LocationPickerIcon("hospital", "Hospital", Hospital),
        LocationPickerIcon("church", "Church", Church),
        LocationPickerIcon("school", "School", School),
        LocationPickerIcon("shop", "Shop", Shop),
        LocationPickerIcon("supermarket", "Supermarket", Supermarket),
        LocationPickerIcon("beach", "Beach", Beach),
        LocationPickerIcon("outdoors", "Outdoors", Outdoors),
        LocationPickerIcon("park", "Park", Park),
        LocationPickerIcon("bar", "Bar / Pub", Bar),
        LocationPickerIcon("cinema", "Cinema", Cinema),
        LocationPickerIcon("restaurant", "Restaurant", Restaurant),
        LocationPickerIcon("bus", "Bus", Bus),
        LocationPickerIcon("car", "Car", Car),
        LocationPickerIcon("plane", "Plane", Plane),
        LocationPickerIcon("train", "Train", Train),
        LocationPickerIcon("office", "Office", Office),
        LocationPickerIcon("work", "Work", Work),
        LocationPickerIcon("other", "Other", Other),
    ) }

    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: LocationsScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun LocationsScreen(
    navController: NavController,
    vm: LocationViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {},
    quickLogMode: Boolean = false,
    onSave: (() -> Unit)? = null,
    linkedMigraineId: String? = null,
    onMigraineSelect: ((String?) -> Unit)? = null
) {
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken) { authState.accessToken?.let { vm.loadAll(it) } }

    fun rebuildDraftWithLocations(locs: List<LocationDraft>) {
        logVm.replaceLocations(locs)
    }

    fun onTap(label: String) {
        val idx = draft.locations.indexOfFirst { it.type == label }
        if (idx >= 0) {
            rebuildDraftWithLocations(draft.locations.toMutableList().apply { removeAt(idx) })
        } else {
            rebuildDraftWithLocations(draft.locations + LocationDraft(type = label))
        }
    }

    val frequentLabels = remember(frequent) { frequent.mapNotNull { it.location?.label }.toSet() }
    val selectedLabels = remember(draft.locations) { draft.locations.map { it.type }.toSet() }
    val grouped = remember(pool) { pool.groupBy { it.category ?: "Other" }.toSortedMap() }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Reliefs", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Location", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) { Icon(Icons.Outlined.Close, "Close", tint = Color.White, modifier = Modifier.size(28.dp)) }
            }

            HeroCard {
                Box(Modifier.size(40.dp).drawBehind {
                    HubIcons.run { drawLocationPin(Color(0xFF64B5F6)) }
                })
                Text("Where were you?", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.locations.isEmpty()) "Log your location" else "${draft.locations.size} location${if (draft.locations.size > 1) "s" else ""} added",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center
                )
                if (draft.locations.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.locations.forEachIndexed { index, loc ->
                        Row(
                            Modifier.fillMaxWidth().padding(vertical = 3.dp).clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f)).padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(loc.type, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium), modifier = Modifier.weight(1f))
                            Icon(Icons.Outlined.Close, "Remove", tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                modifier = Modifier.size(18.dp).clickable {
                                    rebuildDraftWithLocations(draft.locations.toMutableList().apply { removeAt(index) })
                                })
                        }
                    }
                }
            }

            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Locations", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_LOCATIONS) })
                }
            }

            if (quickLogMode && onMigraineSelect != null) {
                val firstIso = draft.locations.firstOrNull()?.startAtIso
                MigrainePickerCard(itemStartAtIso = firstIso, authVm = authVm, selectedMigraineId = linkedMigraineId, onSelect = onMigraineSelect)
            }

            BaseCard {
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { loc ->
                            CircleButton(loc.label, loc.label in selectedLabels, Color(0xFF64B5F6), loc.iconKey) { onTap(loc.label) }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }
                val entries = grouped.entries.toList()
                entries.forEachIndexed { ci, (cat, items) ->
                    val nonFreq = items.filter { it.label !in frequentLabels }
                    if (nonFreq.isNotEmpty()) {
                        Text(cat, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreq.forEach { loc -> CircleButton(loc.label, loc.label in selectedLabels, Color(0xFF64B5F6), loc.iconKey) { onTap(loc.label) } }
                        }
                        if (entries.drop(ci + 1).any { (_, its) -> its.any { it.label !in frequentLabels } })
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                    }
                }
                if (pool.isEmpty()) Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }

            Row(Modifier.fillMaxWidth().padding(vertical = 8.dp), horizontalArrangement = Arrangement.SpaceBetween) {
                OutlinedButton(onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Cancel" else "Back") }
                Button(onClick = { if (quickLogMode) onSave?.invoke() else navController.navigate(Routes.ACTIVITIES) },
                    enabled = !quickLogMode || draft.locations.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Save" else "Next") }
            }
            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun CircleButton(label: String, isSelected: Boolean, accent: Color, iconKey: String? = null, onClick: () -> Unit) {
    val icon = LocationIcons.forKey(iconKey)
    val bg = if (isSelected) accent.copy(alpha = 0.40f) else Color.White.copy(alpha = 0.08f)
    val border = if (isSelected) accent.copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.width(72.dp).clickable(remember { MutableInteractionSource() }, null, onClick = onClick)
    ) {
        Box(Modifier.size(52.dp).clip(CircleShape).background(bg).border(1.5.dp, border, CircleShape), contentAlignment = Alignment.Center) {
            if (icon != null) {
                Icon(imageVector = icon, contentDescription = label, tint = if (isSelected) Color.White else AppTheme.SubtleTextColor, modifier = Modifier.size(24.dp))
            } else {
                Text(label.take(2).uppercase(), color = if (isSelected) Color.White else AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold))
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(label, color = if (isSelected) Color.White else AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelSmall, textAlign = TextAlign.Center, maxLines = 2, modifier = Modifier.fillMaxWidth())
    }
}

@Composable
private fun SimpleTimeDialog(title: String, initialIso: String? = null, onDismiss: () -> Unit, onSkip: (() -> Unit)?, onConfirm: (iso: String?) -> Unit) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E), titleContentColor = Color.White, textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Time: ${formatLocTime(pickedIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select time", onDateTimeSelected = { pickedIso = it })
            }
        },
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text(if (onSkip != null) "Add" else "Save", color = AppTheme.AccentPurple) } },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) { Text("Cancel", color = AppTheme.SubtleTextColor) }
                if (onSkip != null) TextButton(onClick = onSkip) { Text("Skip", color = Color(0xFF64B5F6)) }
            }
        }
    )
}

private fun formatLocTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull() ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) { "Not set" }
}


title: LocationViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class LocationViewModel : ViewModel() {

    private val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserLocationRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserLocationRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.LocationPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.LocationPrefRow>> = _frequent

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            runCatching {
                _pool.value = db.getAllLocationPool(accessToken)
                _frequent.value = db.getLocationPrefs(accessToken).sortedBy { it.position }
            }.onFailure { it.printStackTrace() }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null) {
        viewModelScope.launch {
            runCatching { db.upsertLocationToPool(accessToken, label, category); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun removeFromPool(accessToken: String, id: String) {
        viewModelScope.launch {
            runCatching { db.deleteLocationFromPool(accessToken, id); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun addToFrequent(accessToken: String, id: String) {
        viewModelScope.launch {
            runCatching {
                val pos = (_frequent.value.maxOfOrNull { it.position } ?: -1) + 1
                db.insertLocationPref(accessToken, id, pos, "frequent"); loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            runCatching { db.deleteLocationPref(accessToken, prefId); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun setCategory(accessToken: String, id: String, category: String?) {
        viewModelScope.launch {
            runCatching { db.setLocationCategory(accessToken, id, category); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun setAutomation(accessToken: String, id: String, enabled: Boolean) {
        viewModelScope.launch {
            runCatching { db.setLocationAutomation(accessToken, id, enabled); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }
}


title: LogHomeScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.ui.draw.clip
import androidx.compose.material.icons.Icons
import androidx.compose.ui.draw.drawBehind
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Notes
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun LogHomeScreen(
    navController: NavController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    symptomVm: SymptomViewModel,
    onClose: () -> Unit = {}
) {
    val draft by vm.draft.collectAsState()
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()

    // Load symptoms from Supabase
    val painCharacter by symptomVm.painCharacter.collectAsState()
    val accompanying by symptomVm.accompanying.collectAsState()
    val favorites by symptomVm.favorites.collectAsState()
    val favoriteIds by symptomVm.favoriteIds.collectAsState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { symptomVm.loadAll(it) }
    }

    // UI state — initialize from draft if available
    val selectedSymptoms = remember {
        mutableStateListOf<String>().apply {
            draft.migraine?.symptoms?.let { addAll(it) }
        }
    }
    var notes by rememberSaveable { mutableStateOf(draft.migraine?.note ?: "") }

    // Sync from existing draft when it changes
    LaunchedEffect(draft.migraine?.symptoms, draft.migraine?.note) {
        draft.migraine?.let { m ->
            if (selectedSymptoms.isEmpty() && m.symptoms.isNotEmpty()) {
                selectedSymptoms.addAll(m.symptoms)
            }
            if (notes.isEmpty() && !m.note.isNullOrBlank()) {
                notes = m.note ?: ""
            }
        }
    }

    // Auto-init draft
    LaunchedEffect(Unit) {
        if (draft.migraine == null) {
            vm.setMigraineDraft(type = "Migraine", severity = 5, beganAtIso = null, endedAtIso = null, note = null)
        }
    }

    fun syncDraft() {
        val typeLabel = if (selectedSymptoms.isEmpty()) "Migraine" else selectedSymptoms.joinToString(", ")
        vm.setMigraineDraft(
            type = typeLabel,
            note = notes.ifBlank { null },
            symptoms = selectedSymptoms.toList()
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { onClose() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Home", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Log Migraine", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawMigraineStarburst(AppTheme.AccentPink) } }
                )
                Text(
                    "What are you experiencing?",
                    color = Color.White,
                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                    textAlign = TextAlign.Center
                )
                Text(
                    if (selectedSymptoms.isEmpty()) "Select all that apply"
                    else "${selectedSymptoms.size} symptom${if (selectedSymptoms.size > 1) "s" else ""} selected",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // Manage card (always on top)
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Symptoms", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_SYMPTOMS) })
                }
            }

            // Split frequent by category
            val freqPainIds = favorites.filter { it.symptom?.category == "pain_character" }.mapNotNull { it.symptom?.label }.toSet()
            val freqAccompIds = favorites.filter { it.symptom?.category == "accompanying" }.mapNotNull { it.symptom?.label }.toSet()

            // Pain character card
            BaseCard {
                Text("Pain character", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))

                // Frequent pain symptoms first
                if (freqPainIds.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        painCharacter.filter { it.label in freqPainIds }.forEach { symptom ->
                            SymptomButton(symptom.label, symptom.label in selectedSymptoms, iconKey = symptom.iconKey) {
                                if (symptom.label in selectedSymptoms) selectedSymptoms.remove(symptom.label) else selectedSymptoms.add(symptom.label)
                                syncDraft()
                            }
                        }
                    }
                    // Divider between frequent and rest
                    val remainingPain = painCharacter.filter { it.label !in freqPainIds }
                    if (remainingPain.isNotEmpty()) {
                        HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                    }
                }

                // Remaining pain symptoms
                val remainingPain = painCharacter.filter { it.label !in freqPainIds }
                if (remainingPain.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        remainingPain.forEach { symptom ->
                            SymptomButton(symptom.label, symptom.label in selectedSymptoms, iconKey = symptom.iconKey) {
                                if (symptom.label in selectedSymptoms) selectedSymptoms.remove(symptom.label) else selectedSymptoms.add(symptom.label)
                                syncDraft()
                            }
                        }
                    }
                } else if (freqPainIds.isEmpty()) {
                    Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // Accompanying experience card
            BaseCard {
                Text("Accompanying experience", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))

                // Frequent accompanying symptoms first
                if (freqAccompIds.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        accompanying.filter { it.label in freqAccompIds }.forEach { symptom ->
                            SymptomButton(symptom.label, symptom.label in selectedSymptoms, iconKey = symptom.iconKey) {
                                if (symptom.label in selectedSymptoms) selectedSymptoms.remove(symptom.label) else selectedSymptoms.add(symptom.label)
                                syncDraft()
                            }
                        }
                    }
                    // Divider between frequent and rest
                    val remainingAccomp = accompanying.filter { it.label !in freqAccompIds }
                    if (remainingAccomp.isNotEmpty()) {
                        HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                    }
                }

                // Remaining accompanying symptoms
                val remainingAccomp = accompanying.filter { it.label !in freqAccompIds }
                if (remainingAccomp.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        remainingAccomp.forEach { symptom ->
                            SymptomButton(symptom.label, symptom.label in selectedSymptoms, iconKey = symptom.iconKey) {
                                if (symptom.label in selectedSymptoms) selectedSymptoms.remove(symptom.label) else selectedSymptoms.add(symptom.label)
                                syncDraft()
                            }
                        }
                    }
                } else if (freqAccompIds.isEmpty()) {
                    Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // Notes Card
            BaseCard {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.Notes, contentDescription = null, tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(8.dp))
                    Text("Notes", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                }
                OutlinedTextField(
                    value = notes,
                    onValueChange = { v -> notes = v; syncDraft() },
                    placeholder = { Text("Add notes about this migraine…", color = AppTheme.SubtleTextColor) },
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedTextColor = Color.White, unfocusedTextColor = AppTheme.BodyTextColor,
                        cursorColor = AppTheme.AccentPurple, focusedBorderColor = AppTheme.AccentPurple,
                        unfocusedBorderColor = Color.White.copy(alpha = 0.15f)
                    ),
                    minLines = 2
                )
            }

            // Navigation
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                Button(
                    onClick = { navController.navigate(Routes.TIMING) },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text("Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun SymptomButton(label: String, isSelected: Boolean, iconKey: String? = null, onClick: () -> Unit) {
    val icon = SymptomIcons.forLabel(label, iconKey)
    val circleColor = if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.40f) else Color.White.copy(alpha = 0.08f)
    val borderColor = if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(72.dp)
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            modifier = Modifier
                .size(52.dp)
                .clip(CircleShape)
                .background(circleColor)
                .then(
                    Modifier.border(width = 1.5.dp, color = borderColor, shape = CircleShape)
                ),
            contentAlignment = Alignment.Center
        ) {
            if (icon != null) {
                Icon(icon, contentDescription = null, tint = iconTint, modifier = Modifier.size(26.dp))
            } else {
                Text(
                    label.take(2).uppercase(),
                    color = iconTint,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(
            label,
            color = textColor,
            style = MaterialTheme.typography.labelSmall,
            textAlign = TextAlign.Center,
            maxLines = 2,
            modifier = Modifier.fillMaxWidth()
        )
    }
}


title: LoginScreen.kt
text:
package com.migraineme

import android.Manifest
import android.app.Activity
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import androidx.credentials.exceptions.GetCredentialException
import com.google.android.libraries.identity.googleid.GetGoogleIdOption
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import androidx.compose.foundation.layout.Spacer

private const val PASSWORD_RECOVERY_REDIRECT_URL = "https://www.andlane.co.uk/migraineme-recover"
private const val LOG_TAG = "LoginScreen"

@Composable
fun LoginScreen(
    authVm: AuthViewModel,
    onLoggedIn: () -> Unit,
    onNavigateToSignUp: () -> Unit
) {
    val scope = remember { CoroutineScope(Dispatchers.Main) }
    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext
    val snackbarHostState = remember { SnackbarHostState() }

    var needsPermissionPrompt by remember { mutableStateOf(false) }

    var showEmailForm by remember { mutableStateOf(false) }
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }

    var busy by remember { mutableStateOf(false) }
    var error by remember { mutableStateOf<String?>(null) }

    // Forgot password dialog state
    var showForgotDialog by remember { mutableStateOf(false) }
    var forgotEmail by remember { mutableStateOf("") }
    var forgotBusy by remember { mutableStateOf(false) }
    var forgotError by remember { mutableStateOf<String?>(null) }

    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { grants ->
        Log.d(LOG_TAG, "permissionLauncher callback: grants=$grants")
        val granted = grants[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
                grants[Manifest.permission.ACCESS_COARSE_LOCATION] == true

        if (granted) {
            Log.d(LOG_TAG, "Permission granted, enabling location metric")
            scope.launch {
                withContext(Dispatchers.IO) {
                    EdgeFunctionsService().upsertMetricSetting(
                        context = appCtx,
                        metric = "user_location_daily",
                        enabled = true
                    )
                }
                // Run location sync now (FCM handles hourly scheduling)
                Log.d(LOG_TAG, "Starting location worker from permissionLauncher")
                LocationDailySyncWorker.runOnceNow(appCtx)
                Log.d(LOG_TAG, "Calling onLoggedIn from permissionLauncher")
                onLoggedIn()
            }
        } else {
            Log.d(LOG_TAG, "Permission denied, calling onLoggedIn")
            onLoggedIn()
        }
    }

    // Only used to trigger permission prompt after login completes
    LaunchedEffect(needsPermissionPrompt) {
        if (!needsPermissionPrompt) return@LaunchedEffect
        Log.d(LOG_TAG, "Launching permission prompt")
        permissionLauncher.launch(
            arrayOf(
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.ACCESS_COARSE_LOCATION
            )
        )
    }

    fun handleSuccessfulSession(
        token: String,
        refreshToken: String? = null,
        expiresIn: Long? = null,
        displayNameHint: String? = null,
        avatarUrlHint: String? = null,
        providerHint: String? = null
    ) {
        Log.d(LOG_TAG, "handleSuccessfulSession called, provider=$providerHint")

        val userId = JwtUtils.extractUserIdFromAccessToken(token)
        if (userId.isNullOrBlank()) {
            Log.e(LOG_TAG, "No userId in access token")
            scope.launch {
                snackbarHostState.showSnackbar("Login failed: no userId in access token")
            }
            return
        }

        Log.d(LOG_TAG, "userId=$userId, saving session")
        SessionStore.saveSession(
            context = appCtx,
            accessToken = token,
            userId = userId,
            provider = providerHint,
            refreshToken = refreshToken,
            expiresIn = expiresIn,
            obtainedAtMs = System.currentTimeMillis()
        )
        authVm.setSession(token, userId)

        scope.launch {
            try {
                Log.d(LOG_TAG, "Ensuring profile")
                withContext(Dispatchers.IO) {
                    SupabaseProfileService.ensureProfile(
                        accessToken = token,
                        userId = userId,
                        displayNameHint = displayNameHint,
                        avatarUrlHint = avatarUrlHint
                    )
                }
                Log.d(LOG_TAG, "Profile ensured")
            } catch (t: Throwable) {
                Log.w(LOG_TAG, "Profile hydration failed (non-blocking)", t)
            }

            Log.d(LOG_TAG, "Calling MetricsSyncManager.onLogin")
            MetricsSyncManager.onLogin(appCtx, token, snackbarHostState)
            Log.d(LOG_TAG, "MetricsSyncManager.onLogin completed")

            // Check permissions and start worker
            val fine = ContextCompat.checkSelfPermission(
                appCtx,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED

            val coarse = ContextCompat.checkSelfPermission(
                appCtx,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED

            Log.d(LOG_TAG, "Permissions: fine=$fine, coarse=$coarse")

            if (fine || coarse) {
                Log.d(LOG_TAG, "Permission already granted, enabling location metric and starting worker")
                withContext(Dispatchers.IO) {
                    EdgeFunctionsService().upsertMetricSetting(
                        context = appCtx,
                        metric = "user_location_daily",
                        enabled = true
                    )
                }
                // Run location sync now (FCM handles hourly scheduling)
                LocationDailySyncWorker.runOnceNow(appCtx)
                Log.d(LOG_TAG, "Calling onLoggedIn")
                onLoggedIn()
            } else {
                Log.d(LOG_TAG, "No permission, will prompt")
                needsPermissionPrompt = true
            }
        }
    }

    fun parseFragmentParams(uri: Uri): Map<String, String> {
        val frag = uri.fragment ?: return emptyMap()
        if (frag.isBlank()) return emptyMap()

        return frag.split("&")
            .mapNotNull { kv ->
                val idx = kv.indexOf("=")
                if (idx <= 0) return@mapNotNull null
                val k = Uri.decode(kv.substring(0, idx))
                val v = Uri.decode(kv.substring(idx + 1))
                k to v
            }
            .toMap()
    }

    fun tryCompleteSupabaseOAuthReturn(): Boolean {
        val prefs = ctx.getSharedPreferences("supabase_oauth", android.content.Context.MODE_PRIVATE)
        val last = prefs.getString("last_uri", null) ?: return false

        prefs.edit().remove("last_uri").apply()

        val uri = Uri.parse(last)
        val frag = parseFragmentParams(uri)

        val accessToken = frag["access_token"]
        val refreshToken = frag["refresh_token"]
        val expiresIn = frag["expires_in"]?.toLongOrNull()

        val errDesc = frag["error_description"] ?: frag["error"]

        if (!errDesc.isNullOrBlank()) {
            error = errDesc
            return true
        }

        if (accessToken.isNullOrBlank()) {
            error = "Facebook sign-in failed (missing access token)."
            return true
        }

        handleSuccessfulSession(
            token = accessToken,
            refreshToken = refreshToken,
            expiresIn = expiresIn,
            displayNameHint = null,
            avatarUrlHint = null,
            providerHint = "facebook"
        )
        return true
    }

    LaunchedEffect(Unit) {
        tryCompleteSupabaseOAuthReturn()
    }

    fun signInWithGoogle() {
        Log.d(LOG_TAG, "signInWithGoogle called")
        error = null
        busy = true

        scope.launch {
            try {
                val credentialManager = CredentialManager.create(ctx)

                val googleIdOption = GetGoogleIdOption.Builder()
                    .setServerClientId(BuildConfig.GOOGLE_WEB_CLIENT_ID)
                    .setFilterByAuthorizedAccounts(false)
                    .setAutoSelectEnabled(true)
                    .build()

                val request = GetCredentialRequest.Builder()
                    .addCredentialOption(googleIdOption)
                    .build()

                val result = credentialManager.getCredential(
                    context = ctx,
                    request = request
                )

                val credential = result.credential

                val googleCred =
                    if (credential is CustomCredential &&
                        credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL
                    ) {
                        GoogleIdTokenCredential.createFrom(credential.data)
                    } else null

                val idToken = googleCred?.idToken

                if (idToken.isNullOrBlank()) {
                    Log.e(LOG_TAG, "Google sign-in failed: no idToken")
                    error = "Google sign-in failed."
                    return@launch
                }

                Log.d(LOG_TAG, "Got Google idToken, calling SupabaseAuthService.signInWithGoogleIdToken")
                val ses = SupabaseAuthService.signInWithGoogleIdToken(idToken)
                ses.accessToken?.let {
                    Log.d(LOG_TAG, "Got Supabase accessToken, calling handleSuccessfulSession")
                    handleSuccessfulSession(
                        token = it,
                        refreshToken = ses.refreshToken,
                        expiresIn = ses.expiresIn,
                        displayNameHint = googleCred?.displayName,
                        avatarUrlHint = googleCred?.profilePictureUri?.toString(),
                        providerHint = "google"
                    )
                } ?: run {
                    Log.e(LOG_TAG, "Invalid login response: no accessToken")
                    error = "Invalid login response."
                }
            } catch (e: GetCredentialException) {
                Log.e(LOG_TAG, "GetCredentialException", e)
                error = e.message
            } catch (t: Throwable) {
                Log.e(LOG_TAG, "Google sign-in error", t)
                error = t.message ?: "Google sign-in failed."
            } finally {
                busy = false
            }
        }
    }

    fun signInWithFacebook() {
        error = null

        val activity = ctx as? Activity
        if (activity == null) {
            error = "Facebook sign-in unavailable."
            return
        }

        FacebookAuthService().startAuth(activity)
    }

    if (showForgotDialog) {
        AlertDialog(
            onDismissRequest = {
                if (!forgotBusy) {
                    showForgotDialog = false
                    forgotError = null
                }
            },
            title = { Text("Reset password") },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text("Enter your email and we'll send you a reset link.")
                    OutlinedTextField(
                        value = forgotEmail,
                        onValueChange = { forgotEmail = it },
                        label = { Text("Email") },
                        singleLine = true,
                        enabled = !forgotBusy,
                        modifier = Modifier.fillMaxWidth()
                    )
                    forgotError?.let { Text(it, color = MaterialTheme.colorScheme.error) }
                }
            },
            confirmButton = {
                TextButton(
                    enabled = !forgotBusy,
                    onClick = {
                        val e = forgotEmail.trim()
                        if (e.isBlank()) {
                            forgotError = "Please enter your email."
                            return@TextButton
                        }

                        forgotBusy = true
                        forgotError = null

                        scope.launch {
                            try {
                                withContext(Dispatchers.IO) {
                                    SupabaseAuthService.requestPasswordReset(
                                        email = e,
                                        redirectTo = PASSWORD_RECOVERY_REDIRECT_URL
                                    )
                                }
                                showForgotDialog = false
                                snackbarHostState.showSnackbar("Password reset email sent (if the account exists).")
                            } catch (t: Throwable) {
                                forgotError = t.message ?: "Failed to send reset email."
                            } finally {
                                forgotBusy = false
                            }
                        }
                    }
                ) { Text(if (forgotBusy) "Sending." else "Send link") }
            },
            dismissButton = {
                TextButton(
                    enabled = !forgotBusy,
                    onClick = {
                        showForgotDialog = false
                        forgotError = null
                    }
                ) { Text("Cancel") }
            }
        )
    }

    Scaffold(snackbarHost = { SnackbarHost(snackbarHostState) }) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Image(
                    painter = painterResource(id = R.drawable.logo),
                    contentDescription = "MigraineMe",
                    modifier = Modifier.size(110.dp)
                )
            }

            if (!showEmailForm) {
                OutlinedButton(
                    onClick = { showEmailForm = true },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(52.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = "Email",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text("Continue with email")
                    }
                }

                OutlinedButton(
                    onClick = { signInWithFacebook() },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(52.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Image(
                            painter = painterResource(id = R.drawable.facebook_logo_primary),
                            contentDescription = "Facebook",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text("Continue with Facebook")
                    }
                }

                OutlinedButton(
                    onClick = { signInWithGoogle() },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(52.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Image(
                            painter = painterResource(id = R.drawable.ic_google_logo),
                            contentDescription = "Google",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text("Continue with Google")
                    }
                }

                Divider()

                TextButton(
                    onClick = onNavigateToSignUp,
                    enabled = !busy,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Create account")
                }
            }

            if (showEmailForm) {
                OutlinedTextField(
                    value = email,
                    onValueChange = { email = it },
                    label = { Text("Email") },
                    singleLine = true,
                    enabled = !busy,
                    modifier = Modifier.fillMaxWidth()
                )

                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("Password") },
                    singleLine = true,
                    enabled = !busy,
                    visualTransformation = PasswordVisualTransformation(),
                    modifier = Modifier.fillMaxWidth()
                )

                TextButton(
                    enabled = !busy,
                    onClick = {
                        forgotEmail = email.trim()
                        forgotError = null
                        showForgotDialog = true
                    }
                ) {
                    Text("Forgot password?")
                }

                Button(
                    onClick = {
                        busy = true
                        error = null
                        scope.launch {
                            try {
                                val ses = SupabaseAuthService.signInWithEmail(
                                    email.trim(),
                                    password
                                )
                                ses.accessToken?.let {
                                    handleSuccessfulSession(
                                        token = it,
                                        refreshToken = ses.refreshToken,
                                        expiresIn = ses.expiresIn,
                                        displayNameHint = null,
                                        avatarUrlHint = null,
                                        providerHint = "email"
                                    )
                                } ?: run {
                                    error = "Invalid login response."
                                }
                            } catch (t: Throwable) {
                                error = t.message ?: "Login failed."
                            } finally {
                                busy = false
                            }
                        }
                    },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(48.dp)
                ) {
                    Text("Continue")
                }

                TextButton(
                    onClick = { showEmailForm = false },
                    enabled = !busy,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Back")
                }
            }

            error?.let {
                Text(it, color = MaterialTheme.colorScheme.error)
            }
        }
    }
}

title: LogoutScreen.kt
text:
// FILE: app/src/main/java/com/migraineme/LogoutScreen.kt
package com.migraineme

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp

@Composable
fun LogoutScreen(
    authVm: AuthViewModel,   // passed from MainActivity so it's the SAME instance
    onLoggedOut: () -> Unit
) {
    val ctx = LocalContext.current
    val authState by authVm.state.collectAsState()

    // We only navigate away once we've confirmed the session is cleared
    val signOutRequested = remember { mutableStateOf(false) }

    LaunchedEffect(signOutRequested.value, authState.accessToken) {
        if (signOutRequested.value && authState.accessToken.isNullOrBlank()) {
            signOutRequested.value = false
            onLoggedOut()
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        Spacer(Modifier.height(12.dp))
        Text("Sign out of your account on this device.")
        Spacer(Modifier.height(16.dp))

        Button(
            onClick = {
                // Clear persisted session immediately (prevents any residual token usage)
                SessionStore.clear(ctx.applicationContext)

                signOutRequested.value = true
                authVm.signOut()
                // DO NOT call onLoggedOut() here; we wait for authState to reflect signed-out
            }
        ) {
            Text("Sign out")
        }
    }
}

title: LogViewModel.kt
text:
package com.migraineme

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.time.format.DateTimeFormatter

// --- drafts ---
data class MigraineDraft(
    val type: String? = null,
    val symptoms: List<String> = emptyList(),
    val severity: Int? = null,
    val beganAtIso: String? = null,
    val endedAtIso: String? = null,
    val note: String? = null
)

data class TriggerDraft(
    val type: String,
    val startAtIso: String? = null,
    val note: String? = null,
    val existingId: String? = null
)

data class MedicineDraft(
    val name: String? = null,
    val amount: String? = null,
    val notes: String? = null,
    val startAtIso: String? = null,
    val reliefScale: String? = "NONE",
    val existingId: String? = null
)

data class ReliefDraft(
    val type: String,
    val notes: String? = null,
    val startAtIso: String? = null,
    val endAtIso: String? = null,
    val reliefScale: String? = "NONE",
    val existingId: String? = null
)

data class ProdromeDraft(
    val type: String,
    val startAtIso: String? = null,
    val note: String? = null,
    val existingId: String? = null
)

data class LocationDraft(
    val type: String,
    val startAtIso: String? = null,
    val note: String? = null,
    val existingId: String? = null
)

data class ActivityDraft(
    val type: String,
    val startAtIso: String? = null,
    val endAtIso: String? = null,
    val note: String? = null,
    val existingId: String? = null
)

data class MissedActivityDraft(
    val type: String,
    val startAtIso: String? = null,
    val note: String? = null,
    val existingId: String? = null
)

data class Draft(
    val editMigraineId: String? = null,
    val migraine: MigraineDraft? = null,
    val painLocations: List<String> = emptyList(),
    val triggers: List<TriggerDraft> = emptyList(),
    val meds: List<MedicineDraft> = emptyList(),
    val rels: List<ReliefDraft> = emptyList(),
    val prodromes: List<ProdromeDraft> = emptyList(),
    val locations: List<LocationDraft> = emptyList(),
    val activities: List<ActivityDraft> = emptyList(),
    val missedActivities: List<MissedActivityDraft> = emptyList()
)

// --- journal event feed ---
sealed class JournalEvent {
    data class Migraine(val row: SupabaseDbService.MigraineRow, val linked: SupabaseDbService.MigraineLinkedItems = SupabaseDbService.MigraineLinkedItems()) : JournalEvent()
    data class Trigger(val row: SupabaseDbService.TriggerRow) : JournalEvent()
    data class Medicine(val row: SupabaseDbService.MedicineRow) : JournalEvent()
    data class Relief(val row: SupabaseDbService.ReliefRow) : JournalEvent()
    data class Prodrome(val row: SupabaseDbService.ProdromeLogRow) : JournalEvent()
    data class Location(val row: SupabaseDbService.LocationLogRow) : JournalEvent()
    data class Activity(val row: SupabaseDbService.ActivityLogRow) : JournalEvent()
    data class MissedActivity(val row: SupabaseDbService.MissedActivityLogRow) : JournalEvent()
}

class LogViewModel(application: Application) : AndroidViewModel(application) {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val edge = EdgeFunctionsService()

    private val _draft = MutableStateFlow(Draft())
    val draft: StateFlow<Draft> = _draft

    /** When non-null, the wizard is in "edit" mode for this migraine. Review will update instead of insert. */
    private val _editMigraineId = MutableStateFlow<String?>(null)
    val editMigraineId: StateFlow<String?> = _editMigraineId

    /** Pre-populate the draft from an existing migraine + all linked items (ignoring automated/system items). */
    fun prefillForEdit(accessToken: String, migraineId: String, onReady: () -> Unit) {
        viewModelScope.launch {
            try {
                val migraines = db.getMigraines(accessToken)
                val row = migraines.find { it.id == migraineId } ?: return@launch
                val linked = db.getLinkedItems(accessToken, migraineId)

                _editMigraineId.value = migraineId
                println("DEBUG prefillForEdit: setting editMigraineId=$migraineId")
                // The type field stores joined symptom labels like "Throbbing, Nausea"
                // Split back into individual symptoms for the picker
                val symptomLabels = row.type
                    ?.split(",")
                    ?.map { it.trim() }
                    ?.filter { it.isNotBlank() && it != "Migraine" }
                    ?: emptyList()

                _draft.value = Draft(
                    editMigraineId = migraineId,
                    migraine = MigraineDraft(
                        type = row.type,
                        symptoms = symptomLabels,
                        severity = row.severity,
                        beganAtIso = row.startAt,
                        endedAtIso = row.endAt,
                        note = row.notes
                    ),
                    painLocations = row.painLocations ?: emptyList(),
                    triggers = linked.triggers
                        .filter { it.source != "system" }
                        .map { TriggerDraft(it.type ?: "", it.startAt, it.notes, existingId = it.id) },
                    meds = linked.medicines.map { MedicineDraft(it.name, it.amount, it.notes, it.startAt, null, existingId = it.id) },
                    rels = linked.reliefs.map { ReliefDraft(it.type ?: "", it.notes, it.startAt, it.endAt, null, existingId = it.id) },
                    prodromes = linked.prodromes.map { ProdromeDraft(it.type ?: "", it.startAt, it.notes, existingId = it.id) },
                    locations = linked.locations.map { LocationDraft(it.type ?: "", it.startAt, it.notes, existingId = it.id) },
                    activities = linked.activities.map { ActivityDraft(it.type ?: "", it.startAt, it.endAt, it.notes, existingId = it.id) }
                )
                onReady()
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    private val _migraines = MutableStateFlow<List<SupabaseDbService.MigraineRow>>(emptyList())
    val migraines: StateFlow<List<SupabaseDbService.MigraineRow>> = _migraines

    private val _journal = MutableStateFlow<List<JournalEvent>>(emptyList())
    val journal: StateFlow<List<JournalEvent>> = _journal

    private val _triggerLabelMap = MutableStateFlow<Map<String, String>>(emptyMap())
    val triggerLabelMap: StateFlow<Map<String, String>> = _triggerLabelMap

    // --- single-entry edit state ---
    private val _editMigraine = MutableStateFlow<SupabaseDbService.MigraineRow?>(null)
    val editMigraine: StateFlow<SupabaseDbService.MigraineRow?> = _editMigraine

    private val _editTrigger = MutableStateFlow<SupabaseDbService.TriggerRow?>(null)
    val editTrigger: StateFlow<SupabaseDbService.TriggerRow?> = _editTrigger

    private val _editMedicine = MutableStateFlow<SupabaseDbService.MedicineRow?>(null)
    val editMedicine: StateFlow<SupabaseDbService.MedicineRow?> = _editMedicine

    private val _editRelief = MutableStateFlow<SupabaseDbService.ReliefRow?>(null)
    val editRelief: StateFlow<SupabaseDbService.ReliefRow?> = _editRelief

    // --- dropdown options (flat kept for compatibility) ---
    private val _migraineOptions = MutableStateFlow<List<String>>(emptyList())
    val migraineOptions: StateFlow<List<String>> = _migraineOptions

    private val _triggerOptions = MutableStateFlow<List<String>>(emptyList())
    val triggerOptions: StateFlow<List<String>> = _triggerOptions

    private val _medicineOptions = MutableStateFlow<List<String>>(emptyList())
    val medicineOptions: StateFlow<List<String>> = _medicineOptions

    private val _reliefOptions = MutableStateFlow<List<String>>(emptyList())
    val reliefOptions: StateFlow<List<String>> = _reliefOptions

    // --- sectioned options ---
    private val _migraineOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val migraineOptionsFrequent: StateFlow<List<String>> = _migraineOptionsFrequent
    private val _migraineOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val migraineOptionsAll: StateFlow<List<String>> = _migraineOptionsAll

    private val _triggerOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val triggerOptionsFrequent: StateFlow<List<String>> = _triggerOptionsFrequent
    private val _triggerOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val triggerOptionsAll: StateFlow<List<String>> = _triggerOptionsAll

    private val _medicineOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val medicineOptionsFrequent: StateFlow<List<String>> = _medicineOptionsFrequent
    private val _medicineOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val medicineOptionsAll: StateFlow<List<String>> = _medicineOptionsAll

    private val _reliefOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val reliefOptionsFrequent: StateFlow<List<String>> = _reliefOptionsFrequent
    private val _reliefOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val reliefOptionsAll: StateFlow<List<String>> = _reliefOptionsAll

    // ---- draft mutators ----
    fun setMigraineDraft(
        type: String? = null,
        severity: Int? = null,
        beganAtIso: String? = null,
        endedAtIso: String? = null,
        note: String? = null,
        symptoms: List<String>? = null,
        // Pass true to explicitly clear a nullable field to null
        clearBeganAt: Boolean = false,
        clearEndedAt: Boolean = false,
        clearNote: Boolean = false
    ) {
        val existing = _draft.value.migraine ?: MigraineDraft()
        _draft.value = _draft.value.copy(
            migraine = existing.copy(
                type = type ?: existing.type,
                symptoms = symptoms ?: existing.symptoms,
                severity = severity ?: existing.severity,
                beganAtIso = if (clearBeganAt) null else (beganAtIso ?: existing.beganAtIso),
                endedAtIso = if (clearEndedAt) null else (endedAtIso ?: existing.endedAtIso),
                note = if (clearNote) null else (note ?: existing.note)
            )
        )
    }

    fun setSymptomsDraft(symptoms: List<String>) {
        val existing = _draft.value.migraine ?: MigraineDraft()
        _draft.value = _draft.value.copy(
            migraine = existing.copy(symptoms = symptoms)
        )
    }

    fun setPainLocationsDraft(locations: List<String>) {
        _draft.value = _draft.value.copy(painLocations = locations)
    }

    fun addTriggerDraft(trigger: String, startAtIso: String? = null, note: String? = null) {
        _draft.value = _draft.value.copy(
            triggers = _draft.value.triggers + TriggerDraft(trigger, startAtIso, note)
        )
    }

    fun addMedicineDraft(name: String, amount: String?, notes: String?, startAtIso: String? = null, reliefScale: String? = "NONE") {
        _draft.value = _draft.value.copy(
            meds = _draft.value.meds + MedicineDraft(name, amount, notes, startAtIso, reliefScale)
        )
    }

    fun addReliefDraft(type: String, notes: String? = null, startAtIso: String? = null, endAtIso: String? = null, reliefScale: String? = "NONE") {
        _draft.value = _draft.value.copy(
            rels = _draft.value.rels + ReliefDraft(type, notes, startAtIso, endAtIso, reliefScale)
        )
    }

    fun addProdromeDraft(type: String, startAtIso: String? = null, note: String? = null) {
        _draft.value = _draft.value.copy(
            prodromes = _draft.value.prodromes + ProdromeDraft(type, startAtIso, note)
        )
    }

    fun addLocationDraft(type: String, startAtIso: String? = null, note: String? = null) {
        _draft.value = _draft.value.copy(
            locations = _draft.value.locations + LocationDraft(type, startAtIso, note)
        )
    }

    fun addActivityDraft(type: String, startAtIso: String? = null, endAtIso: String? = null, note: String? = null) {
        _draft.value = _draft.value.copy(
            activities = _draft.value.activities + ActivityDraft(type, startAtIso, endAtIso, note)
        )
    }

    fun addMissedActivityDraft(type: String, startAtIso: String? = null, note: String? = null) {
        _draft.value = _draft.value.copy(
            missedActivities = _draft.value.missedActivities + MissedActivityDraft(type, startAtIso, note)
        )
    }

    fun clearDraft() { _draft.value = Draft(); _editMigraineId.value = null }

    // Direct list replacements — preserves editMigraineId and existingIds on other lists
    fun replaceTriggers(triggers: List<TriggerDraft>) {
        _draft.value = _draft.value.copy(triggers = triggers)
    }
    fun replaceProdromes(prodromes: List<ProdromeDraft>) {
        _draft.value = _draft.value.copy(prodromes = prodromes)
    }
    fun replaceMedicines(meds: List<MedicineDraft>) {
        _draft.value = _draft.value.copy(meds = meds)
    }
    fun replaceReliefs(rels: List<ReliefDraft>) {
        _draft.value = _draft.value.copy(rels = rels)
    }
    fun replaceLocations(locations: List<LocationDraft>) {
        _draft.value = _draft.value.copy(locations = locations)
    }
    fun replaceActivities(activities: List<ActivityDraft>) {
        _draft.value = _draft.value.copy(activities = activities)
    }
    fun replaceMissedActivities(missedActivities: List<MissedActivityDraft>) {
        _draft.value = _draft.value.copy(missedActivities = missedActivities)
    }

    // ---- quick actions ----
    fun addMigraine(accessToken: String) {
        viewModelScope.launch {
            try {
                val nowIso = Instant.now().toString()
                db.insertMigraine(accessToken, type = "Migraine", severity = null, startAt = nowIso, endAt = null, notes = null)
                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addMedicine(accessToken: String, name: String, amount: String? = null, notes: String? = null) {
        viewModelScope.launch {
            try {
                val nowIso = Instant.now().toString()
                db.insertMedicine(accessToken, migraineId = null, name = name, amount = amount, startAt = nowIso, notes = notes)
                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addRelief(accessToken: String, type: String, notes: String? = null) {
        viewModelScope.launch {
            try {
                val nowIso = Instant.now().toString()
                db.insertRelief(accessToken, migraineId = null, type = type, startAt = nowIso, notes = notes)
                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    // ---- final save ----
    /** Update an existing migraine + update/insert/delete linked items. */
    fun updateFull(
        accessToken: String,
        migraineId: String,
        type: String?,
        severity: Int?,
        beganAtIso: String,
        endedAtIso: String?,
        note: String?,
        painLocations: List<String>,
        meds: List<MedicineDraft>,
        rels: List<ReliefDraft>
    ) {
        val triggersSnapshot = _draft.value.triggers
        val prodromesSnapshot = _draft.value.prodromes
        val locationsSnapshot = _draft.value.locations
        val activitiesSnapshot = _draft.value.activities
        val missedActivitiesSnapshot = _draft.value.missedActivities

        viewModelScope.launch {
            try {
                val migraineStart = beganAtIso.ifBlank {
                    DateTimeFormatter.ISO_INSTANT.format(Instant.now())
                }

                // Update migraine itself
                println("DEBUG updateFull: updating migraineId=$migraineId")
                db.updateMigraine(accessToken, migraineId, type, severity, migraineStart, endedAtIso, note, painLocations.takeIf { it.isNotEmpty() })

                // --- Triggers: delete removed, update existing, insert new ---
                val oldLinked = db.getLinkedItems(accessToken, migraineId)
                val keepTriggerIds = triggersSnapshot.mapNotNull { it.existingId }.toSet()
                oldLinked.triggers.filter { it.source != "system" && it.id !in keepTriggerIds }.forEach {
                    runCatching { db.deleteTrigger(accessToken, it.id) }
                }
                for (t in triggersSnapshot.filter { it.type.isNotBlank() }) {
                    if (t.existingId != null) {
                        runCatching { db.updateTrigger(accessToken, t.existingId, t.type, t.startAtIso ?: migraineStart, t.note) }
                    } else {
                        runCatching { db.insertTrigger(accessToken, migraineId, t.type, t.startAtIso ?: migraineStart, t.note) }
                    }
                }

                // --- Medicines ---
                val keepMedIds = meds.mapNotNull { it.existingId }.toSet()
                oldLinked.medicines.filter { it.source != "system" && it.id !in keepMedIds }.forEach {
                    runCatching { db.deleteMedicine(accessToken, it.id) }
                }
                for (m in meds.filter { !it.name.isNullOrBlank() }) {
                    if (m.existingId != null) {
                        runCatching { db.updateMedicine(accessToken, m.existingId, m.name, m.amount, m.startAtIso ?: migraineStart, m.notes) }
                    } else {
                        runCatching { db.insertMedicine(accessToken, migraineId, m.name, m.amount, m.startAtIso ?: migraineStart, m.notes, m.reliefScale) }
                    }
                }

                // --- Reliefs ---
                val keepRelIds = rels.mapNotNull { it.existingId }.toSet()
                oldLinked.reliefs.filter { it.source != "system" && it.id !in keepRelIds }.forEach {
                    runCatching { db.deleteRelief(accessToken, it.id) }
                }
                for (r in rels.filter { it.type.isNotBlank() }) {
                    val rStart = r.startAtIso ?: migraineStart
                    val rEnd = r.endAtIso ?: rStart
                    if (r.existingId != null) {
                        runCatching { db.updateRelief(accessToken, r.existingId, r.type, rStart, r.notes, endAt = rEnd) }
                    } else {
                        runCatching { db.insertRelief(accessToken, migraineId, r.type, rStart, r.notes, rEnd, r.reliefScale) }
                    }
                }

                // --- Prodromes ---
                val keepProdIds = prodromesSnapshot.mapNotNull { it.existingId }.toSet()
                oldLinked.prodromes.filter { it.source != "system" && it.id !in keepProdIds }.forEach {
                    runCatching { db.deleteProdromeLog(accessToken, it.id) }
                }
                for (p in prodromesSnapshot.filter { it.type.isNotBlank() }) {
                    if (p.existingId != null) {
                        runCatching { db.updateProdromeLog(accessToken, p.existingId, p.type, p.startAtIso ?: migraineStart, p.note) }
                    } else {
                        runCatching { db.insertProdrome(accessToken, migraineId, p.type, p.startAtIso ?: migraineStart, p.note) }
                    }
                }

                // --- Locations ---
                val keepLocIds = locationsSnapshot.mapNotNull { it.existingId }.toSet()
                oldLinked.locations.filter { it.source != "system" && it.id !in keepLocIds }.forEach {
                    runCatching { db.deleteLocationLog(accessToken, it.id) }
                }
                for (loc in locationsSnapshot.filter { it.type.isNotBlank() }) {
                    if (loc.existingId != null) {
                        runCatching { db.updateLocationLog(accessToken, loc.existingId, loc.type, loc.startAtIso ?: migraineStart, loc.note) }
                    } else {
                        runCatching { db.insertLocation(accessToken, migraineId, loc.type, loc.startAtIso ?: migraineStart, loc.note) }
                    }
                }

                // --- Activities ---
                val keepActIds = activitiesSnapshot.mapNotNull { it.existingId }.toSet()
                oldLinked.activities.filter { it.source != "system" && it.id !in keepActIds }.forEach {
                    runCatching { db.deleteActivityLog(accessToken, it.id) }
                }
                for (act in activitiesSnapshot.filter { it.type.isNotBlank() }) {
                    val aStart = act.startAtIso ?: migraineStart
                    val aEnd = act.endAtIso ?: aStart
                    if (act.existingId != null) {
                        runCatching { db.updateActivityLog(accessToken, act.existingId, act.type, aStart, aEnd, act.note) }
                    } else {
                        runCatching { db.insertActivity(accessToken, migraineId, act.type, aStart, aEnd, act.note) }
                    }
                }

                // --- Missed Activities ---
                for (ma in missedActivitiesSnapshot.filter { it.type.isNotBlank() }) {
                    if (ma.existingId != null) {
                        runCatching { db.updateMissedActivityLog(accessToken, ma.existingId, ma.type, ma.startAtIso ?: migraineStart, ma.note) }
                    } else {
                        runCatching { db.insertMissedActivity(accessToken, migraineId, ma.type, ma.startAtIso ?: migraineStart, ma.note) }
                    }
                }

                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun addFull(
        accessToken: String,
        type: String?,
        severity: Int?,
        beganAtIso: String,
        endedAtIso: String?,
        note: String?,
        painLocations: List<String>,
        meds: List<MedicineDraft>,
        rels: List<ReliefDraft>
    ) {
        val triggersSnapshot = _draft.value.triggers
        val prodromesSnapshot = _draft.value.prodromes
        val locationsSnapshot = _draft.value.locations
        val activitiesSnapshot = _draft.value.activities
        val missedActivitiesSnapshot = _draft.value.missedActivities

        viewModelScope.launch {
            try {
                val migraineStart = beganAtIso.ifBlank {
                    DateTimeFormatter.ISO_INSTANT.format(Instant.now())
                }

                val migraine = db.insertMigraine(
                    accessToken = accessToken,
                    type = type,
                    severity = severity,
                    startAt = migraineStart,
                    endAt = endedAtIso,
                    notes = note,
                    painLocations = painLocations.takeIf { it.isNotEmpty() }
                )

                // Auto-detected triggers/prodromes are pre-selected in the UI and already
                // included in the draft snapshots below — no separate linking needed.

                for (t in triggersSnapshot.filter { it.type.isNotBlank() }) {
                    try {
                        db.insertTrigger(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = t.type,
                            startAt = t.startAtIso ?: migraineStart,
                            notes = t.note
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (m in meds.filter { !it.name.isNullOrBlank() }) {
                    try {
                        db.insertMedicine(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            name = m.name,
                            amount = m.amount,
                            startAt = m.startAtIso ?: migraineStart,
                            notes = m.notes,
                            reliefScale = m.reliefScale
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (r in rels.filter { it.type.isNotBlank() }) {
                    try {
                        val rStart = r.startAtIso ?: migraineStart
                        db.insertRelief(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = r.type,
                            startAt = rStart,
                            notes = r.notes,
                            endAt = r.endAtIso ?: rStart,
                            reliefScale = r.reliefScale
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (p in prodromesSnapshot.filter { it.type.isNotBlank() }) {
                    try {
                        db.insertProdrome(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = p.type,
                            startAt = p.startAtIso ?: migraineStart,
                            notes = p.note
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (loc in locationsSnapshot.filter { it.type.isNotBlank() }) {
                    try {
                        db.insertLocation(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = loc.type,
                            startAt = loc.startAtIso ?: migraineStart,
                            notes = loc.note
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (act in activitiesSnapshot.filter { it.type.isNotBlank() }) {
                    try {
                        val aStart = act.startAtIso ?: migraineStart
                        db.insertActivity(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = act.type,
                            startAt = aStart,
                            endAt = act.endAtIso ?: aStart,
                            notes = act.note
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (ma in missedActivitiesSnapshot.filter { it.type.isNotBlank() }) {
                    try {
                        db.insertMissedActivity(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = ma.type,
                            startAt = ma.startAtIso ?: migraineStart,
                            notes = ma.note
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    // ---- fetch only migraines ----
    fun loadMigraines(accessToken: String) {
        viewModelScope.launch {
            try {
                val rows = db.getMigraines(accessToken)
                _migraines.value = rows
                println("DEBUG loadMigraines: count=${rows.size}")
            } catch (e: Exception) {
                e.printStackTrace()
                _migraines.value = emptyList()
            }
        }
    }

    // ---- unified journal feed ----
    fun loadJournal(accessToken: String) {
        viewModelScope.launch {
            try {
                val migraineRows = db.getMigraines(accessToken)
                val migraines = migraineRows.map { row ->
                    val linked = try { db.getLinkedItems(accessToken, row.id) } catch (_: Exception) { SupabaseDbService.MigraineLinkedItems() }
                    JournalEvent.Migraine(row, linked)
                }
                val triggers = db.getAllTriggers(accessToken).map { JournalEvent.Trigger(it) }
                val medicines = db.getAllMedicines(accessToken).map { JournalEvent.Medicine(it) }
                val reliefs = db.getAllReliefs(accessToken).map { JournalEvent.Relief(it) }
                val prodromes = db.getAllProdromeLog(accessToken).map { JournalEvent.Prodrome(it) }
                val locations = db.getAllLocationLog(accessToken).map { JournalEvent.Location(it) }
                val activities = db.getAllActivityLog(accessToken).map { JournalEvent.Activity(it) }
                val missedActivities = db.getAllMissedActivityLog(accessToken).map { JournalEvent.MissedActivity(it) }

                // Load trigger definitions for label lookup
                val context = getApplication<android.app.Application>().applicationContext
                val defs = edge.getTriggerDefinitions(context)
                _triggerLabelMap.value = defs.associate { it.triggerType to it.label }

                val merged = (migraines + triggers + medicines + reliefs + prodromes + locations + activities + missedActivities).sortedByDescending { ev ->
                    when (ev) {
                        is JournalEvent.Migraine -> ev.row.startAt
                        is JournalEvent.Trigger -> ev.row.startAt
                        is JournalEvent.Medicine -> ev.row.startAt
                        is JournalEvent.Relief -> ev.row.startAt
                        is JournalEvent.Prodrome -> ev.row.startAt
                        is JournalEvent.Location -> ev.row.startAt
                        is JournalEvent.Activity -> ev.row.startAt
                        is JournalEvent.MissedActivity -> ev.row.startAt
                    }
                }
                _journal.value = merged
                println("DEBUG loadJournal: count=${merged.size}")
            } catch (e: Exception) {
                e.printStackTrace()
                _journal.value = emptyList()
            }
        }
    }

    // ---- removals ----
    fun removeMigraine(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                // Unlink ALL linked items first (set migraine_id = null)
                val linked = db.getLinkedItems(accessToken, id)
                linked.triggers.forEach { runCatching { db.updateTrigger(accessToken, it.id, clearMigraineId = true) } }
                linked.medicines.forEach { runCatching { db.updateMedicine(accessToken, it.id, clearMigraineId = true) } }
                linked.reliefs.forEach { runCatching { db.updateRelief(accessToken, it.id, clearMigraineId = true) } }
                linked.prodromes.forEach { runCatching { db.unlinkFromMigraine(accessToken, "prodromes", it.id) } }
                linked.activities.forEach { runCatching { db.unlinkFromMigraine(accessToken, "time_in_high_hr_zones_daily", it.id) } }
                linked.locations.forEach { runCatching { db.unlinkFromMigraine(accessToken, "locations", it.id) } }
                // Now delete the migraine itself
                db.deleteMigraine(accessToken, id)
                // Then delete manual linked items (system items survive via RLS + app filter)
                linked.triggers.filter { it.source != "system" }.forEach { runCatching { db.deleteTrigger(accessToken, it.id) } }
                linked.medicines.filter { it.source != "system" }.forEach { runCatching { db.deleteMedicine(accessToken, it.id) } }
                linked.reliefs.filter { it.source != "system" }.forEach { runCatching { db.deleteRelief(accessToken, it.id) } }
                linked.prodromes.filter { it.source != "system" }.forEach { runCatching { db.deleteProdromeLog(accessToken, it.id) } }
                linked.activities.filter { it.source != "system" }.forEach { runCatching { db.deleteActivityLog(accessToken, it.id) } }
                linked.locations.filter { it.source != "system" }.forEach { runCatching { db.deleteLocationLog(accessToken, it.id) } }
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeTrigger(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteTrigger(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeMedicine(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteMedicine(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeRelief(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteRelief(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeProdrome(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteProdromeLog(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeLocation(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteLocationLog(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeActivity(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteActivityLog(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeMissedActivity(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteMissedActivityLog(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    // ---- load single by id for edit ----
    fun loadMigraineById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editMigraine.value = db.getMigraineById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editMigraine.value = null }
        }
    }

    fun loadTriggerById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editTrigger.value = db.getTriggerById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editTrigger.value = null }
        }
    }

    fun loadMedicineById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editMedicine.value = db.getMedicineById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editMedicine.value = null }
        }
    }

    fun loadReliefById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editRelief.value = db.getReliefById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editRelief.value = null }
        }
    }

    // ---- updates for edit screens ----
    fun updateMigraine(
        accessToken: String,
        id: String,
        type: String? = null,
        severity: Int? = null,
        startAt: String? = null,
        endAt: String? = null,
        notes: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateMigraine(accessToken, id, type, severity, startAt, endAt, notes)
                _editMigraine.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun updateTrigger(
        accessToken: String,
        id: String,
        type: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateTrigger(accessToken, id, type, startAt, notes, migraineId)
                _editTrigger.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun updateMedicine(
        accessToken: String,
        id: String,
        name: String? = null,
        amount: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateMedicine(accessToken, id, name, amount, startAt, notes, migraineId)
                _editMedicine.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun updateRelief(
        accessToken: String,
        id: String,
        type: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateRelief(accessToken, id, type, startAt, notes, migraineId)
                _editRelief.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    // ---- option loaders for dropdowns ----
    fun loadMigraineOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getMigrainePrefs(accessToken)
                val pool = db.getAllMigrainePool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.migraine?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _migraineOptionsFrequent.value = frequent
                _migraineOptionsAll.value = allMinusFrequent
                _migraineOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _migraineOptionsFrequent.value = emptyList()
                _migraineOptionsAll.value = emptyList()
                _migraineOptions.value = emptyList()
            }
        }
    }

    fun loadTriggerOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getTriggerPrefs(accessToken)
                val pool = db.getAllTriggerPool(accessToken)

                // Show all triggers in the logging wizard (including NONE prediction)
                // so system-detected anomalies (e.g. HRV 2SD) are surfaced for the user
                val visiblePool = pool

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.trigger?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = visiblePool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _triggerOptionsFrequent.value = frequent
                _triggerOptionsAll.value = allMinusFrequent
                _triggerOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _triggerOptionsFrequent.value = emptyList()
                _triggerOptionsAll.value = emptyList()
                _triggerOptions.value = emptyList()
            }
        }
    }

    fun loadMedicineOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getMedicinePrefs(accessToken)
                val pool = db.getAllMedicinePool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.medicine?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _medicineOptionsFrequent.value = frequent
                _medicineOptionsAll.value = allMinusFrequent
                _medicineOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _medicineOptionsFrequent.value = emptyList()
                _medicineOptionsAll.value = emptyList()
                _medicineOptions.value = emptyList()
            }
        }
    }

    fun loadReliefOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getReliefPrefs(accessToken)
                val pool = db.getAllReliefPool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.relief?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _reliefOptionsFrequent.value = frequent
                _reliefOptionsAll.value = allMinusFrequent
                _reliefOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _reliefOptionsFrequent.value = emptyList()
                _reliefOptionsAll.value = emptyList()
                _reliefOptions.value = emptyList()
            }
        }
    }
}





title: MainActivity.kt
text:
package com.migraineme

import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import com.google.firebase.messaging.FirebaseMessaging
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.ui.Alignment
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.TextButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.outlined.Logout
import androidx.compose.material.icons.outlined.BarChart
import androidx.compose.material.icons.outlined.Groups
import androidx.compose.material.icons.outlined.History
import androidx.compose.material.icons.outlined.Home
import androidx.compose.material.icons.outlined.Link
import androidx.compose.material.icons.outlined.Person
import androidx.compose.material.icons.outlined.Psychology
import androidx.compose.material.icons.outlined.Settings
import androidx.compose.material.icons.outlined.Storage
import androidx.compose.material.icons.outlined.Speed
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material.icons.outlined.Timeline
import androidx.compose.material3.Badge
import androidx.compose.material3.BadgedBox
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.NavigationBar
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.NavigationDrawerItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material3.rememberDrawerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.core.view.WindowCompat
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import androidx.compose.ui.input.nestedscroll.nestedScroll
import androidx.compose.animation.core.rememberInfiniteTransition
import androidx.compose.animation.core.animateFloat
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.infiniteRepeatable
import androidx.compose.animation.core.tween
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.RepeatMode
import androidx.compose.material.icons.outlined.Analytics
import androidx.compose.material.icons.outlined.Star
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.text.style.TextAlign
import io.ktor.client.statement.bodyAsText
import io.ktor.client.request.get
import io.ktor.client.request.header


object Routes {
    const val HOME = "home"
    const val PROFILE = "profile"
    const val DATA = "data"
    const val MENSTRUATION_SETTINGS = "menstruation_settings"
    const val COMMUNITY = "community"
    const val INSIGHTS = "insights"
    const val INSIGHTS_DETAIL = "insights_detail"
    const val INSIGHTS_REPORT = "insights_report"
    const val INSIGHTS_BREAKDOWN = "insights_breakdown"
    const val MONITOR = "monitor"
    const val MONITOR_CONFIG = "monitor_config"
    const val JOURNAL = "journal"

    const val MIGRAINE = "migraine"
    const val LOG_MIGRAINE = "log_migraine"  // Full migraine wizard
    const val PAIN_LOCATION = "pain_location"  // Pain location picker (wizard page 2)
    const val PRODROMES_LOG = "prodromes_log"  // Prodromes picker (wizard page 3)
    const val QUICK_LOG_TRIGGER = "quick_log_trigger"
    const val QUICK_LOG_MEDICINE = "quick_log_medicine"
    const val QUICK_LOG_RELIEF = "quick_log_relief"
    const val QUICK_LOG_ACTIVITY = "quick_log_activity"
    const val QUICK_LOG_PRODROME = "quick_log_prodrome"
    const val QUICK_LOG_MIGRAINE = "quick_log_migraine"
    
    const val MONITOR_NUTRITION = "monitor_nutrition"
    const val NUTRITION_CONFIG = "nutrition_config"
    const val NUTRITION_HISTORY = "nutrition_history"
    const val WEATHER_CONFIG = "weather_config"
    const val SLEEP_DATA_HISTORY = "sleep_data_history"
    const val ENV_DATA_HISTORY = "env_data_history"
    const val MONITOR_PHYSICAL = "monitor_physical"
    const val PHYSICAL_CONFIG = "physical_config"
    const val PHYSICAL_DATA_HISTORY = "physical_data_history"
    const val FULL_GRAPH_PHYSICAL = "full_graph_physical"
    const val MONITOR_SLEEP = "monitor_sleep"
    const val SLEEP_CONFIG = "sleep_config"
    const val FULL_GRAPH = "full_graph"
    const val FULL_GRAPH_SLEEP = "full_graph_sleep"
    const val FULL_GRAPH_WEATHER = "full_graph_weather"
    const val FULL_GRAPH_NUTRITION = "full_graph_nutrition"
    const val MONITOR_MENTAL = "monitor_mental"
    const val MENTAL_CONFIG = "mental_config"
    const val MENTAL_DATA_HISTORY = "mental_data_history"
    const val FULL_GRAPH_MENTAL = "full_graph_mental"
    const val MONITOR_ENVIRONMENT = "monitor_environment"
    
    const val TRIGGERS = "triggers"
    const val ADJUST_TRIGGERS = "adjust_triggers"
    const val MEDICINES = "medicines"
    const val ADJUST_MEDICINES = "adjust_medicines"
    const val RELIEFS = "reliefs"
    const val ADJUST_RELIEFS = "adjust_reliefs"
    const val REVIEW = "review"
    const val NOTES = "notes"

    const val LOGIN = "login"
    const val SIGNUP = "signup"
    const val LOGOUT = "logout"

    const val EDIT_MIGRAINE = "edit_migraine"
    const val EDIT_TRIGGER = "edit_trigger"
    const val EDIT_MEDICINE = "edit_medicine"
    const val EDIT_RELIEF = "edit_relief"
    const val EDIT_PRODROME = "edit_prodrome"
    const val EDIT_ACTIVITY = "edit_activity"
    const val EDIT_LOCATION = "edit_location"

    const val ADJUST_MIGRAINES = "adjust_migraines"
    const val MANAGE_SYMPTOMS = "manage_symptoms"
    const val MANAGE_ITEMS = "manage_items"
    const val MANAGE_TRIGGERS = "manage_triggers"
    const val MANAGE_MEDICINES = "manage_medicines"
    const val MANAGE_RELIEFS = "manage_reliefs"
    const val MANAGE_PRODROMES = "manage_prodromes"
    const val LOCATIONS = "locations"
    const val ACTIVITIES = "activities"
    const val MANAGE_LOCATIONS = "manage_locations"
    const val MANAGE_ACTIVITIES = "manage_activities"
    const val MISSED_ACTIVITIES = "missed_activities"
    const val MANAGE_MISSED_ACTIVITIES = "manage_missed_activities"
    const val TIMING = "timing"


    const val THIRD_PARTY_CONNECTIONS = "third_party_connections"

    const val CHANGE_PASSWORD = "change_password"
    
    const val TRIGGERS_SETTINGS = "triggers_settings"
    const val RISK_WEIGHTS = "risk_weights"
    const val RISK_DETAIL = "risk_detail"
    const val TESTING = "testing"
    const val ONBOARDING = "onboarding"
    const val AI_SETUP = "ai_setup"
    const val CUSTOMIZE_TRIGGERS = "customize_triggers"
    const val EVENING_CHECKIN = "evening_checkin"
}

class MainActivity : ComponentActivity() {

    // Deep link route from notification tap
    private var pendingNavigationRoute = mutableStateOf<String?>(null)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        WindowCompat.setDecorFitsSystemWindows(window, false)
        window.statusBarColor = android.graphics.Color.TRANSPARENT
        window.navigationBarColor = android.graphics.Color.TRANSPARENT
        WindowCompat.getInsetsController(window, window.decorView).apply {
            isAppearanceLightStatusBars = false
            isAppearanceLightNavigationBars = false
        }

        window.setBackgroundDrawable(null)

        handleWhoopOAuthIntent(intent)
        handleSupabaseOAuthIntent(intent)
        handleNavigationIntent(intent)

        setContent {
            MaterialTheme {
                AppRoot(pendingNavigationRoute = pendingNavigationRoute)
            }
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        handleWhoopOAuthIntent(intent)
        handleSupabaseOAuthIntent(intent)
        handleNavigationIntent(intent)
    }

    private fun handleWhoopOAuthIntent(intent: Intent?) {
        val data: Uri? = intent?.data
        if (data?.scheme == "whoop" && data.host == "migraineme" && data.path == "/callback") {

            val code = data.getQueryParameter("code")
            val state = data.getQueryParameter("state")
            val error = data.getQueryParameter("error")

            val prefs = getSharedPreferences("whoop_oauth", MODE_PRIVATE)
            prefs.edit()
                .putString("last_uri", data.toString())
                .putString("code", code)
                .putString("state", state)
                .putString("error", error)
                .apply()

            when {
                !error.isNullOrBlank() -> {
                    Toast.makeText(this, "WHOOP auth error: $error", Toast.LENGTH_SHORT).show()
                }

                !code.isNullOrBlank() -> {
                    Toast.makeText(this, "Returning from WHOOP…", Toast.LENGTH_SHORT).show()
                }

                else -> {
                    Toast.makeText(this, "WHOOP callback opened.", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun handleSupabaseOAuthIntent(intent: Intent?) {
        val data: Uri? = intent?.data
        if (data?.scheme == "migraineme" && data.host == "auth" && data.path == "/callback") {
            val prefs = getSharedPreferences("supabase_oauth", MODE_PRIVATE)
            prefs.edit()
                .putString("last_uri", data.toString())
                .apply()

            Toast.makeText(this, "Returning from sign-in…", Toast.LENGTH_SHORT).show()
        }
    }

    private fun handleNavigationIntent(intent: Intent?) {
        intent?.getStringExtra("navigate_to")?.let { route ->
            pendingNavigationRoute.value = route
            // Clear so it doesn't re-trigger
            intent.removeExtra("navigate_to")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AppRoot(pendingNavigationRoute: MutableState<String?> = mutableStateOf(null)) {
    val nav = rememberNavController()
    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()
    val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()

    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext
    val lifecycleOwner = LocalLifecycleOwner.current

    val authVm: AuthViewModel = viewModel()
    val logVm: LogViewModel = viewModel()
    val triggerVm: TriggerViewModel = viewModel()
    val medVm: MedicineViewModel = viewModel()
    val reliefVm: ReliefViewModel = viewModel()
    val migraineVm: MigraineViewModel = viewModel()
    val symptomVm: SymptomViewModel = viewModel()
    val homeVm: HomeViewModel = viewModel()

    val authState by authVm.state.collectAsState()
    val token = authState.accessToken

    var lastPreloadedToken by remember { mutableStateOf<String?>(null) }

    LaunchedEffect(Unit) {
        authVm.syncFromSessionStore(appCtx)
        
        // Get and save FCM token
        FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->
            if (task.isSuccessful) {
                val token = task.result
                android.util.Log.d("FCM", "FCM Token: $token")
                // Save token locally
                SessionStore.saveFcmToken(appCtx, token)
                // Save to Supabase (needs to be done after login, handled in MigraineMeFirebaseService)
            } else {
                android.util.Log.e("FCM", "Failed to get FCM token", task.exception)
            }
        }
    }

    DisposableEffect(lifecycleOwner) {
        val obs = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_RESUME) {
                scope.launch {
                    authVm.syncFromSessionStore(appCtx)
                }
                // Run location sync on app resume
                LocationDailySyncWorker.runOnceNow(appCtx)
                
                // Run Health Connect sync on app resume
                // This is the primary sync method - always works when app is open
                // FCM-triggered syncs are secondary (only work when app is in foreground)
                HealthConnectSyncManager.triggerSyncIfEnabled(appCtx)
            }
        }
        lifecycleOwner.lifecycle.addObserver(obs)
        onDispose { lifecycleOwner.lifecycle.removeObserver(obs) }
    }

    LaunchedEffect(token) {
        if (token.isNullOrBlank()) {
            lastPreloadedToken = null
            return@LaunchedEffect
        }

        val valid = authVm.getValidAccessToken(appCtx)
        if (valid.isNullOrBlank()) {
            lastPreloadedToken = null
            return@LaunchedEffect
        }

        if (lastPreloadedToken != valid) {
            logVm.loadJournal(valid)
            lastPreloadedToken = valid
            
            // Save FCM token to Supabase now that we have a valid access token
            val fcmToken = SessionStore.readFcmToken(appCtx)
            if (!fcmToken.isNullOrBlank()) {
                scope.launch(Dispatchers.IO) {
                    try {
                        val userId = SessionStore.readUserId(appCtx)
                        if (!userId.isNullOrBlank()) {
                            val client = okhttp3.OkHttpClient()
                            val json = org.json.JSONObject().apply {
                                put("fcm_token", fcmToken)
                            }
                            val request = okhttp3.Request.Builder()
                                .url("${BuildConfig.SUPABASE_URL}/rest/v1/profiles?user_id=eq.$userId")
                                .header("Authorization", "Bearer $valid")
                                .header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                                .header("Content-Type", "application/json")
                                .header("Prefer", "return=minimal")
                                .patch(okhttp3.RequestBody.create(
                                    "application/json".toMediaTypeOrNull(),
                                    json.toString()
                                ))
                                .build()
                            client.newCall(request).execute().use { response ->
                                if (response.isSuccessful) {
                                    android.util.Log.d("FCM", "FCM token saved to Supabase")
                                } else {
                                    android.util.Log.e("FCM", "Failed to save FCM token: ${response.code}")
                                }
                            }
                        }
                    } catch (e: Exception) {
                        android.util.Log.e("FCM", "Error saving FCM token to Supabase", e)
                    }
                }
            }
        }
    }

    val journal by logVm.journal.collectAsState()
    val attentionCount = remember(journal) { journal.count { needsAttention(it) } }

    // Handle deep link navigation from notification tap
    LaunchedEffect(pendingNavigationRoute.value, token) {
        val route = pendingNavigationRoute.value ?: return@LaunchedEffect
        // Wait until user is authenticated before navigating
        if (!token.isNullOrBlank()) {
            nav.navigate(route) { launchSingleTop = true }
            pendingNavigationRoute.value = null
        }
    }

    data class DrawerItem(val title: String, val route: String, val icon: ImageVector)

    val drawerItems = listOf(
        DrawerItem("Profile", Routes.PROFILE, Icons.Outlined.Person),
        DrawerItem("Connections", Routes.THIRD_PARTY_CONNECTIONS, Icons.Outlined.Link),
        DrawerItem("Data", Routes.DATA, Icons.Outlined.Storage),
        DrawerItem("Risk Model", Routes.RISK_WEIGHTS, Icons.Outlined.Speed),
        DrawerItem("Testing", Routes.TESTING, Icons.Outlined.BarChart),
        DrawerItem("Manage Items", Routes.MANAGE_ITEMS, Icons.Outlined.Tune),
        DrawerItem("Logout", Routes.LOGOUT, Icons.AutoMirrored.Outlined.Logout)
    )

    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            ModalDrawerSheet {
                Text(
                    "Settings",
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 20.dp)
                )
                drawerItems.forEach { item ->
                    NavigationDrawerItem(
                        label = { Text(item.title) },
                        selected = false,
                        onClick = {
                            scope.launch { drawerState.close() }
                            nav.navigate(item.route) { launchSingleTop = true }
                        },
                        icon = { Icon(item.icon, contentDescription = item.title) }
                    )
                }
            }
        }
    ) {
        val backStack by nav.currentBackStackEntryAsState()
        val current = backStack?.destination?.route ?: Routes.LOGIN
        
        // Updated to include JOURNAL and Migraine screens
        val showHomeBackground =
            current == Routes.HOME || 
            current == Routes.INSIGHTS || 
            current == Routes.INSIGHTS_DETAIL ||
            current == Routes.INSIGHTS_REPORT ||
            current?.startsWith(Routes.INSIGHTS_BREAKDOWN) == true ||
            current == Routes.JOURNAL ||
            current == Routes.MIGRAINE ||
            current == Routes.QUICK_LOG_TRIGGER ||
            current == Routes.QUICK_LOG_MEDICINE ||
            current == Routes.QUICK_LOG_RELIEF ||
            current == Routes.QUICK_LOG_ACTIVITY ||
            current == Routes.QUICK_LOG_PRODROME ||
            current == Routes.QUICK_LOG_MIGRAINE ||
            current == Routes.LOG_MIGRAINE ||
            current == Routes.PAIN_LOCATION ||
            current == Routes.TRIGGERS ||
            current == Routes.MEDICINES ||
            current == Routes.RELIEFS ||
            current == Routes.NOTES ||
            current == Routes.REVIEW ||
            current == Routes.TIMING ||
            current == Routes.MANAGE_SYMPTOMS ||
            current == Routes.MANAGE_ITEMS ||
            current == Routes.MANAGE_TRIGGERS ||
            current == Routes.MANAGE_MEDICINES ||
            current == Routes.MANAGE_RELIEFS ||
            current == Routes.MANAGE_PRODROMES ||
            current == Routes.LOCATIONS ||
            current == Routes.ACTIVITIES ||
            current == Routes.MANAGE_LOCATIONS ||
            current == Routes.MANAGE_ACTIVITIES ||
            current == Routes.MISSED_ACTIVITIES ||
            current == Routes.MANAGE_MISSED_ACTIVITIES ||
            current == Routes.MONITOR ||
            current == Routes.MONITOR_CONFIG ||
            current == Routes.MONITOR_NUTRITION ||
            current == Routes.NUTRITION_CONFIG ||
            current == Routes.NUTRITION_HISTORY ||
            current == Routes.WEATHER_CONFIG ||
            current == Routes.SLEEP_DATA_HISTORY ||
            current == Routes.ENV_DATA_HISTORY ||
            current == Routes.MONITOR_PHYSICAL ||
            current == Routes.PHYSICAL_CONFIG ||
            current == Routes.PHYSICAL_DATA_HISTORY ||
            current == Routes.FULL_GRAPH_PHYSICAL ||
            current == Routes.MONITOR_SLEEP ||
            current == Routes.SLEEP_CONFIG ||
            current == Routes.FULL_GRAPH_SLEEP ||
            current == Routes.FULL_GRAPH_WEATHER ||
            current == Routes.FULL_GRAPH_NUTRITION ||
            current == Routes.MONITOR_MENTAL ||
            current == Routes.MENTAL_CONFIG ||
            current == Routes.MENTAL_DATA_HISTORY ||
            current == Routes.FULL_GRAPH_MENTAL ||
            current == Routes.MONITOR_ENVIRONMENT ||
            current == Routes.THIRD_PARTY_CONNECTIONS ||
            current == Routes.EVENING_CHECKIN

        // Wizard fullscreen: hide top bar + bottom nav for immersive logging
        val isWizardFullscreen = current in setOf(
            Routes.LOG_MIGRAINE, Routes.TIMING, Routes.PAIN_LOCATION,
            Routes.TRIGGERS, Routes.MEDICINES,
            Routes.RELIEFS, Routes.LOCATIONS, Routes.ACTIVITIES, Routes.MISSED_ACTIVITIES,
            Routes.NOTES, Routes.REVIEW,
            Routes.MANAGE_ITEMS, Routes.MANAGE_SYMPTOMS,
            Routes.MANAGE_TRIGGERS, Routes.MANAGE_MEDICINES, Routes.MANAGE_RELIEFS, Routes.MANAGE_PRODROMES,
            Routes.MANAGE_LOCATIONS, Routes.MANAGE_ACTIVITIES, Routes.MANAGE_MISSED_ACTIVITIES,
            Routes.ONBOARDING, Routes.AI_SETUP, "${Routes.ONBOARDING}/setup",
            Routes.EVENING_CHECKIN, "backfill_loading", "subscribe"
        )

        // Insights background
        val insightsBgResId = remember {
            ctx.resources.getIdentifier("purple_sky_bg_insights", "drawable", ctx.packageName)
        }
        var insightsBgBitmap by remember { mutableStateOf<Bitmap?>(null) }

        LaunchedEffect(current, insightsBgResId) {
            val isInsights = current == Routes.INSIGHTS || current == Routes.INSIGHTS_DETAIL || current == Routes.INSIGHTS_REPORT || current?.startsWith(Routes.INSIGHTS_BREAKDOWN) == true
            if (!isInsights) return@LaunchedEffect
            if (insightsBgResId != 0) return@LaunchedEffect
            if (insightsBgBitmap != null) return@LaunchedEffect

            insightsBgBitmap = withContext(Dispatchers.IO) {
                try {
                    appCtx.assets.open("purple_sky_bg_insights.png").use { input ->
                        BitmapFactory.decodeStream(input)
                    }
                } catch (_: Throwable) {
                    null
                }
            }
        }

        // Migraine background
        val migraineBgResId = remember {
            ctx.resources.getIdentifier("purple_sky_bg_migraine", "drawable", ctx.packageName)
        }
        var migraineBgBitmap by remember { mutableStateOf<Bitmap?>(null) }

        LaunchedEffect(current, migraineBgResId) {
            val isMigraine = current == Routes.MIGRAINE || 
                current == Routes.QUICK_LOG_TRIGGER || 
                current == Routes.QUICK_LOG_MEDICINE || 
                current == Routes.QUICK_LOG_RELIEF ||
                current == Routes.QUICK_LOG_ACTIVITY ||
                current == Routes.QUICK_LOG_PRODROME ||
                current == Routes.QUICK_LOG_MIGRAINE ||
                current == Routes.LOG_MIGRAINE ||
                current == Routes.PAIN_LOCATION ||
                current == Routes.TRIGGERS ||
                current == Routes.MEDICINES ||
                current == Routes.RELIEFS ||
                current == Routes.NOTES ||
                current == Routes.REVIEW ||
                current == Routes.TIMING ||
                current == Routes.MANAGE_SYMPTOMS ||
                current == Routes.EVENING_CHECKIN
            val isManageItems = current == Routes.MANAGE_ITEMS ||
                current == Routes.MANAGE_TRIGGERS ||
                current == Routes.MANAGE_MEDICINES ||
                current == Routes.MANAGE_RELIEFS ||
                current == Routes.MANAGE_PRODROMES
            if (!isMigraine && !isManageItems) return@LaunchedEffect
            if (migraineBgResId != 0) return@LaunchedEffect
            if (migraineBgBitmap != null) return@LaunchedEffect

            migraineBgBitmap = withContext(Dispatchers.IO) {
                try {
                    appCtx.assets.open("purple_sky_bg_migraine.png").use { input ->
                        BitmapFactory.decodeStream(input)
                    }
                } catch (_: Throwable) {
                    null
                }
            }
        }

        // Monitor background
        val monitorBgResId = remember {
            ctx.resources.getIdentifier("purple_sky_bg_monitor", "drawable", ctx.packageName)
        }
        var monitorBgBitmap by remember { mutableStateOf<Bitmap?>(null) }

        LaunchedEffect(current, monitorBgResId) {
            val isMonitor = current == Routes.MONITOR || 
                current == Routes.MONITOR_CONFIG ||
                current == Routes.MONITOR_NUTRITION ||
                current == Routes.NUTRITION_CONFIG ||
                current == Routes.NUTRITION_HISTORY ||
                current == Routes.WEATHER_CONFIG ||
                current == Routes.SLEEP_DATA_HISTORY ||
                current == Routes.ENV_DATA_HISTORY ||
                current == Routes.MONITOR_PHYSICAL ||
                current == Routes.PHYSICAL_CONFIG ||
                current == Routes.PHYSICAL_DATA_HISTORY ||
                current == Routes.FULL_GRAPH_PHYSICAL ||
                current == Routes.MONITOR_SLEEP ||
                current == Routes.SLEEP_CONFIG ||
                current == Routes.FULL_GRAPH_SLEEP ||
                current == Routes.FULL_GRAPH_WEATHER ||
                current == Routes.FULL_GRAPH_NUTRITION ||
                current == Routes.MONITOR_MENTAL ||
                current == Routes.MENTAL_CONFIG ||
                current == Routes.MENTAL_DATA_HISTORY ||
                current == Routes.FULL_GRAPH_MENTAL ||
                current == Routes.MONITOR_ENVIRONMENT ||
            current == Routes.THIRD_PARTY_CONNECTIONS
            if (!isMonitor) return@LaunchedEffect
            if (monitorBgResId != 0) return@LaunchedEffect
            if (monitorBgBitmap != null) return@LaunchedEffect

            monitorBgBitmap = withContext(Dispatchers.IO) {
                try {
                    appCtx.assets.open("purple_sky_bg_monitor.png").use { input ->
                        BitmapFactory.decodeStream(input)
                    }
                } catch (_: Throwable) {
                    null
                }
            }
        }

        // Journal background
        val journalBgResId = remember {
            ctx.resources.getIdentifier("purple_sky_bg_journal", "drawable", ctx.packageName)
        }
        var journalBgBitmap by remember { mutableStateOf<Bitmap?>(null) }

        LaunchedEffect(current, journalBgResId) {
            if (current != Routes.JOURNAL) return@LaunchedEffect
            if (journalBgResId != 0) return@LaunchedEffect
            if (journalBgBitmap != null) return@LaunchedEffect

            journalBgBitmap = withContext(Dispatchers.IO) {
                try {
                    appCtx.assets.open("purple_sky_bg_journal.png").use { input ->
                        BitmapFactory.decodeStream(input)
                    }
                } catch (_: Throwable) {
                    null
                }
            }
        }


        // Connections background
        val connectionsBgResId = remember {
            ctx.resources.getIdentifier("purple_sky_bg_3rd_connection", "drawable", ctx.packageName)
        }
        var connectionsBgBitmap by remember { mutableStateOf<Bitmap?>(null) }

        LaunchedEffect(current, connectionsBgResId) {
            if (current != Routes.THIRD_PARTY_CONNECTIONS) return@LaunchedEffect
            if (connectionsBgResId != 0) return@LaunchedEffect
            if (connectionsBgBitmap != null) return@LaunchedEffect

            connectionsBgBitmap = withContext(Dispatchers.IO) {
                try {
                    appCtx.assets.open("purple_sky_bg_3rd_connection.png").use { input ->
                        BitmapFactory.decodeStream(input)
                    }
                } catch (_: Throwable) {
                    null
                }
            }
        }
        Box(modifier = Modifier.fillMaxSize()) {
            when (current) {
                Routes.HOME -> {
                    Image(
                        painter = painterResource(R.drawable.purple_sky_bg),
                        contentDescription = null,
                        modifier = Modifier.fillMaxSize(),
                        contentScale = ContentScale.Crop
                    )
                }

                Routes.MIGRAINE, Routes.QUICK_LOG_TRIGGER, Routes.QUICK_LOG_MEDICINE, Routes.QUICK_LOG_RELIEF, Routes.QUICK_LOG_ACTIVITY, Routes.QUICK_LOG_PRODROME, Routes.QUICK_LOG_MIGRAINE,
                Routes.LOG_MIGRAINE, Routes.TIMING, Routes.PAIN_LOCATION, Routes.PRODROMES_LOG, Routes.TRIGGERS, Routes.MEDICINES, Routes.RELIEFS, Routes.LOCATIONS, Routes.ACTIVITIES, Routes.MISSED_ACTIVITIES, Routes.NOTES, Routes.REVIEW, Routes.MANAGE_SYMPTOMS, Routes.MANAGE_ITEMS, Routes.MANAGE_TRIGGERS, Routes.MANAGE_MEDICINES, Routes.MANAGE_RELIEFS, Routes.MANAGE_PRODROMES, Routes.MANAGE_LOCATIONS, Routes.MANAGE_ACTIVITIES, Routes.MANAGE_MISSED_ACTIVITIES -> {
                    when {
                        migraineBgResId != 0 -> {
                            Image(
                                painter = painterResource(migraineBgResId),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        migraineBgBitmap != null -> {
                            Image(
                                bitmap = migraineBgBitmap!!.asImageBitmap(),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        else -> {
                            // Fallback to home background
                            Image(
                                painter = painterResource(R.drawable.purple_sky_bg),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }
                    }
                }

                Routes.JOURNAL -> {
                    when {
                        journalBgResId != 0 -> {
                            Image(
                                painter = painterResource(journalBgResId),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        journalBgBitmap != null -> {
                            Image(
                                bitmap = journalBgBitmap!!.asImageBitmap(),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        else -> {
                            // Fallback to home background
                            Image(
                                painter = painterResource(R.drawable.purple_sky_bg),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }
                    }
                }

                Routes.MONITOR, Routes.MONITOR_CONFIG, Routes.MONITOR_NUTRITION, Routes.NUTRITION_CONFIG, Routes.NUTRITION_HISTORY, Routes.WEATHER_CONFIG, Routes.SLEEP_DATA_HISTORY, Routes.ENV_DATA_HISTORY, Routes.MONITOR_PHYSICAL, Routes.PHYSICAL_CONFIG, Routes.PHYSICAL_DATA_HISTORY, Routes.FULL_GRAPH_PHYSICAL, Routes.MONITOR_SLEEP, Routes.SLEEP_CONFIG, Routes.FULL_GRAPH_SLEEP, Routes.FULL_GRAPH_WEATHER, Routes.FULL_GRAPH_NUTRITION, Routes.MONITOR_MENTAL, Routes.MENTAL_CONFIG, Routes.MENTAL_DATA_HISTORY, Routes.FULL_GRAPH_MENTAL, Routes.MONITOR_ENVIRONMENT -> {
                    when {
                        monitorBgResId != 0 -> {
                            Image(
                                painter = painterResource(monitorBgResId),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        monitorBgBitmap != null -> {
                            Image(
                                bitmap = monitorBgBitmap!!.asImageBitmap(),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        else -> {
                            // Fallback to home background
                            Image(
                                painter = painterResource(R.drawable.purple_sky_bg),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }
                    }
                }

                Routes.THIRD_PARTY_CONNECTIONS -> {
                    when {
                        connectionsBgResId != 0 -> {
                            Image(
                                painter = painterResource(connectionsBgResId),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        connectionsBgBitmap != null -> {
                            Image(
                                bitmap = connectionsBgBitmap!!.asImageBitmap(),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        else -> {
                            // Fallback to home background
                            Image(
                                painter = painterResource(R.drawable.purple_sky_bg),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }
                    }
                }

                Routes.INSIGHTS, Routes.INSIGHTS_DETAIL, Routes.INSIGHTS_REPORT, "${Routes.INSIGHTS_BREAKDOWN}/{logType}" -> {
                    when {
                        insightsBgResId != 0 -> {
                            Image(
                                painter = painterResource(insightsBgResId),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        insightsBgBitmap != null -> {
                            Image(
                                bitmap = insightsBgBitmap!!.asImageBitmap(),
                                contentDescription = null,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop
                            )
                        }

                        else -> {
                            Box(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .background(MaterialTheme.colorScheme.background)
                            )
                        }
                    }
                }

                else -> {
                    Box(
                        modifier = Modifier
                            .fillMaxSize()
                            .background(MaterialTheme.colorScheme.background)
                    )
                }
            }

            Scaffold(
                modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
                containerColor = Color.Transparent,
                topBar = {
                    if (!isWizardFullscreen) {
                    CenterAlignedTopAppBar(
                        scrollBehavior = scrollBehavior,
                        colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                            containerColor = Color.Transparent,
                            scrolledContainerColor = Color(0xFF2A003D),
                            titleContentColor = if (showHomeBackground) Color.White else MaterialTheme.colorScheme.onSurface,
                            navigationIconContentColor = if (showHomeBackground) Color.White else MaterialTheme.colorScheme.onSurface,
                            actionIconContentColor = if (showHomeBackground) Color.White else MaterialTheme.colorScheme.onSurface
                        ),
                        title = {
                            Text(
                                when (current) {
                                    Routes.MONITOR -> "Monitor"
                                    Routes.MONITOR_CONFIG -> "Configure Monitor"
                                    Routes.INSIGHTS -> "Insights"
                                    Routes.INSIGHTS_DETAIL -> "Insights"
                                    Routes.INSIGHTS_REPORT -> "Insights"
                                    "${Routes.INSIGHTS_BREAKDOWN}/{logType}" -> "Insights"
                                    Routes.HOME -> "Home"
                                    Routes.MIGRAINE -> "Migraine"
                                    Routes.LOG_MIGRAINE -> "Log Migraine"
                                    Routes.PAIN_LOCATION -> "Pain Location"
                                    Routes.QUICK_LOG_TRIGGER -> "Log Trigger"
                                    Routes.QUICK_LOG_MEDICINE -> "Log Medicine"
                                    Routes.QUICK_LOG_RELIEF -> "Log Relief"
                                    Routes.QUICK_LOG_ACTIVITY -> "Log Activity"
                                    Routes.QUICK_LOG_PRODROME -> "Log Prodrome"
                                    Routes.QUICK_LOG_MIGRAINE -> "Quick Migraine"
                                    Routes.MONITOR_NUTRITION -> "Nutrition"
                                    Routes.NUTRITION_CONFIG -> "Customize Nutrition"
                                    Routes.NUTRITION_HISTORY -> "Nutrition History"
                                    Routes.MONITOR_ENVIRONMENT -> "Environment"
                                    Routes.WEATHER_CONFIG -> "Customize Environment"
                                    Routes.SLEEP_DATA_HISTORY -> "Sleep Data"
                                    Routes.ENV_DATA_HISTORY -> "Environment Data"
                                    Routes.SLEEP_CONFIG -> "Customize Sleep"
                                    Routes.FULL_GRAPH_SLEEP -> "Sleep History"
                                    Routes.FULL_GRAPH_WEATHER -> "Environment History"
                                    Routes.FULL_GRAPH_NUTRITION -> "Nutrition History"
                                    Routes.MONITOR_PHYSICAL -> "Physical Health"
                                    Routes.MONITOR_SLEEP -> "Sleep"
                                    Routes.MONITOR_MENTAL -> "Mental Health"
                                    Routes.COMMUNITY -> "Community"
                                    Routes.JOURNAL -> "Journal"
                                    Routes.LOGIN -> "Sign in"
                                    Routes.SIGNUP -> "Create account"
                                    Routes.PROFILE -> "Profile"
                                    Routes.DATA -> "Data"
                                    Routes.MENSTRUATION_SETTINGS -> "Menstruation Settings"
                                    Routes.LOGOUT -> "Logout"
                                    Routes.MEDICINES -> "Medicines"
                                    Routes.ADJUST_MEDICINES -> "Adjust Medicines"
                                    Routes.RELIEFS -> "Reliefs"
                                    Routes.NOTES -> "Notes"
                                    Routes.ADJUST_RELIEFS -> "Adjust Reliefs"
                                    Routes.TRIGGERS -> "Triggers"
                                    Routes.ADJUST_TRIGGERS -> "Adjust Triggers"
                                    Routes.REVIEW -> "Review Log"
                                    Routes.EDIT_MIGRAINE -> "Edit Migraine"
                                    Routes.EDIT_TRIGGER -> "Edit Trigger"
                                    Routes.EDIT_MEDICINE -> "Edit Medicine"
                                    Routes.EDIT_RELIEF -> "Edit Relief"
                                    Routes.EDIT_PRODROME -> "Edit Prodrome"
                                    Routes.EDIT_ACTIVITY -> "Edit Activity"
                                    Routes.EDIT_LOCATION -> "Edit Location"
                                    Routes.ADJUST_MIGRAINES -> "Adjust Migraines"
                                    Routes.MANAGE_SYMPTOMS -> "Manage Symptoms"
                                    Routes.MANAGE_ITEMS -> "Manage Items"
                                    Routes.MANAGE_TRIGGERS -> "Manage Triggers"
                                    Routes.MANAGE_MEDICINES -> "Manage Medicines"
                                    Routes.MANAGE_RELIEFS -> "Manage Reliefs"
                                    Routes.MANAGE_PRODROMES -> "Manage Prodromes"
                                    Routes.TIMING -> "Timing"
                                    Routes.THIRD_PARTY_CONNECTIONS -> "Connections"
                                    Routes.CHANGE_PASSWORD -> "Change password"
                                    else -> ""
                                }
                            )
                        },
                        navigationIcon = {
                            if (current != Routes.LOGIN && current != Routes.SIGNUP) {
                                IconButton(onClick = { scope.launch { drawerState.open() } }) {
                                    Icon(Icons.Outlined.Settings, contentDescription = "Settings")
                                }
                            }
                        },
                        actions = {
                            if (current != Routes.LOGIN && current != Routes.SIGNUP) {
                                IconButton(onClick = { nav.navigate(Routes.COMMUNITY) }) {
                                    Icon(Icons.Outlined.Groups, contentDescription = "Community")
                                }
                            }
                        }
                    )
                    } // end !isWizardFullscreen
                },
                bottomBar = {
                    if (current != Routes.LOGIN && current != Routes.SIGNUP && !isWizardFullscreen) {
                        BottomBar(nav, attentionCount)
                    }
                }
            ) { inner ->
                Box(modifier = Modifier.fillMaxSize().padding(inner)) {
                NavHost(
                    navController = nav,
                    startDestination = Routes.LOGIN,
                    modifier = Modifier
                        .fillMaxSize()
                ) {
                    composable(Routes.MONITOR) { MonitorScreen(navController = nav, authVm = authVm) }
                    composable(Routes.MONITOR_CONFIG) { MonitorConfigScreen(onBack = { nav.popBackStack() }) }
                    
                    // Monitor detail screens (placeholders for now)
                    composable(Routes.MONITOR_NUTRITION) { MonitorNutritionScreen(navController = nav, authVm = authVm) }
                    composable(Routes.NUTRITION_CONFIG) { NutritionConfigScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.NUTRITION_HISTORY) { NutritionHistoryScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.WEATHER_CONFIG) { WeatherConfigScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.SLEEP_DATA_HISTORY) { SleepDataHistoryScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.ENV_DATA_HISTORY) { EnvironmentDataHistoryScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.MONITOR_PHYSICAL) { MonitorPhysicalScreen(navController = nav, authVm = authVm) }
                    composable(Routes.PHYSICAL_CONFIG) { PhysicalConfigScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.PHYSICAL_DATA_HISTORY) { PhysicalDataHistoryScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.FULL_GRAPH_PHYSICAL) { FullScreenGraphScreen(graphType = "physical", onBack = { nav.popBackStack() }) }
                    composable(Routes.MONITOR_SLEEP) { MonitorSleepScreen(navController = nav, authVm = authVm) }
                    composable(Routes.SLEEP_CONFIG) { SleepConfigScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.FULL_GRAPH_SLEEP) { FullScreenGraphScreen(graphType = "sleep", onBack = { nav.popBackStack() }) }
                    composable(Routes.FULL_GRAPH_WEATHER) { FullScreenGraphScreen(graphType = "weather", onBack = { nav.popBackStack() }) }
                    composable(Routes.FULL_GRAPH_NUTRITION) { FullScreenGraphScreen(graphType = "nutrition", onBack = { nav.popBackStack() }) }
                    composable(Routes.MONITOR_MENTAL) { MonitorMentalScreen(navController = nav, authVm = authVm) }
                    composable(Routes.MENTAL_CONFIG) { MentalConfigScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.MENTAL_DATA_HISTORY) { MentalDataHistoryScreen(onBack = { nav.popBackStack() }) }
                    composable(Routes.FULL_GRAPH_MENTAL) { FullScreenGraphScreen(graphType = "mental", onBack = { nav.popBackStack() }) }
                    composable(Routes.MONITOR_ENVIRONMENT) { MonitorEnvironmentScreen(navController = nav, authVm = authVm) }
                    
                    composable(Routes.INSIGHTS) {
                        val owner = androidx.compose.ui.platform.LocalContext.current as androidx.lifecycle.ViewModelStoreOwner
                        val insightsVm: InsightsViewModel = androidx.lifecycle.viewmodel.compose.viewModel(owner)
                        InsightsScreen(navController = nav, vm = insightsVm)
                    }
                    composable(Routes.INSIGHTS_DETAIL) {
                        val owner = androidx.compose.ui.platform.LocalContext.current as androidx.lifecycle.ViewModelStoreOwner
                        val insightsVm: InsightsViewModel = androidx.lifecycle.viewmodel.compose.viewModel(owner)
                        InsightsDetailScreen(navController = nav, vm = insightsVm)
                    }
                    composable(Routes.INSIGHTS_REPORT) {
                        val owner = androidx.compose.ui.platform.LocalContext.current as androidx.lifecycle.ViewModelStoreOwner
                        val insightsVm: InsightsViewModel = androidx.lifecycle.viewmodel.compose.viewModel(owner)
                        InsightsReportScreen(navController = nav, vm = insightsVm)
                    }
                    composable("${Routes.INSIGHTS_BREAKDOWN}/{logType}") { backStack ->
                        val logType = backStack.arguments?.getString("logType") ?: "Triggers"
                        val owner = androidx.compose.ui.platform.LocalContext.current as androidx.lifecycle.ViewModelStoreOwner
                        val insightsVm: InsightsViewModel = androidx.lifecycle.viewmodel.compose.viewModel(owner)
                        InsightsBreakdownScreen(logType = logType, navController = nav, vm = insightsVm)
                    }
                    composable(Routes.TRIGGERS_SETTINGS) { TriggersSettingsScreen(navController = nav, authVm = authVm) }
                    composable(Routes.CUSTOMIZE_TRIGGERS) { CustomizeTriggersScreen() }
                    composable(Routes.HOME) {
                        HomeScreenRoot(
                            onLogout = { nav.navigate(Routes.LOGOUT) { launchSingleTop = true } },
                            onNavigateToMigraine = { nav.navigate(Routes.MIGRAINE) },
                            onNavigateToRiskDetail = { nav.navigate(Routes.RISK_DETAIL) },
                            authVm = authVm,
                            logVm = logVm,
                            vm = homeVm,
                            triggerVm = triggerVm,
                            medicineVm = medVm,
                            reliefVm = reliefVm,
                            symptomVm = symptomVm,
                        )
                    }
                    composable(Routes.COMMUNITY) { CommunityScreen() }
                    composable(Routes.JOURNAL) { JournalScreen(navController = nav, authVm = authVm, vm = logVm) }

                    // Migraine Hub (main migraine tab)
                    composable(Routes.MIGRAINE) { MigraineHubScreen(navController = nav) }
                    
                    // Full migraine wizard flow
                    val wizardClose: () -> Unit = {
                        logVm.clearDraft()
                        nav.popBackStack(Routes.MIGRAINE, inclusive = false)
                    }
                    composable(Routes.LOG_MIGRAINE) { LogHomeScreen(navController = nav, authVm = authVm, vm = logVm, symptomVm = symptomVm, onClose = wizardClose) }
                    composable(Routes.TIMING) { TimingScreen(navController = nav, vm = logVm, onClose = wizardClose) }
                    composable(Routes.PAIN_LOCATION) { PainLocationScreen(navController = nav, vm = logVm, onClose = wizardClose) }
                    composable(Routes.PRODROMES_LOG) {
                        val prodromeVm: ProdromeViewModel = viewModel()
                        ProdromeLogScreen(navController = nav, vm = prodromeVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }

                    // Quick log screens (standalone)
                    composable(Routes.QUICK_LOG_TRIGGER) {
                        val triggerVm: TriggerViewModel = viewModel()
                        val quickLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        TriggersScreen(
                            navController = nav, vm = triggerVm, authVm = authVm, logVm = quickLogVm,
                            quickLogMode = true,
                            linkedMigraineId = linkedMigraineId,
                            onMigraineSelect = { linkedMigraineId = it },
                            onSave = {
                                scope.launch {
                                    val token = authVm.state.value.accessToken ?: return@launch
                                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                    quickLogVm.draft.value.triggers.forEach { t ->
                                        runCatching { db.insertTrigger(token, linkedMigraineId, t.type, t.startAtIso ?: java.time.Instant.now().toString(), t.note) }
                                    }
                                    quickLogVm.clearDraft()
                                    nav.popBackStack()
                                }
                            }
                        )
                    }
                    composable(Routes.QUICK_LOG_MEDICINE) {
                        val medVm: MedicineViewModel = viewModel()
                        val quickLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        MedicinesScreen(
                            navController = nav, vm = medVm, authVm = authVm, logVm = quickLogVm,
                            quickLogMode = true,
                            linkedMigraineId = linkedMigraineId,
                            onMigraineSelect = { linkedMigraineId = it },
                            onSave = {
                                scope.launch {
                                    val token = authVm.state.value.accessToken ?: return@launch
                                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                    quickLogVm.draft.value.meds.forEach { m ->
                                        runCatching { db.insertMedicine(token, linkedMigraineId, m.name, m.amount, m.startAtIso ?: java.time.Instant.now().toString(), m.notes) }
                                    }
                                    quickLogVm.clearDraft()
                                    nav.popBackStack()
                                }
                            }
                        )
                    }
                    composable(Routes.QUICK_LOG_RELIEF) {
                        val reliefVm: ReliefViewModel = viewModel()
                        val quickLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        ReliefsScreen(
                            navController = nav, vm = reliefVm, authVm = authVm, logVm = quickLogVm,
                            quickLogMode = true,
                            linkedMigraineId = linkedMigraineId,
                            onMigraineSelect = { linkedMigraineId = it },
                            onSave = {
                                scope.launch {
                                    val token = authVm.state.value.accessToken ?: return@launch
                                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                    quickLogVm.draft.value.rels.forEach { r ->
                                        runCatching { db.insertRelief(token, linkedMigraineId, r.type, r.startAtIso ?: java.time.Instant.now().toString(), r.endAtIso, r.notes, r.reliefScale) }
                                    }
                                    quickLogVm.clearDraft()
                                    nav.popBackStack()
                                }
                            }
                        )
                    }
                    composable(Routes.QUICK_LOG_ACTIVITY) {
                        val activityVm: ActivityViewModel = viewModel()
                        val quickLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        ActivitiesScreen(
                            navController = nav, vm = activityVm, authVm = authVm, logVm = quickLogVm,
                            quickLogMode = true,
                            linkedMigraineId = linkedMigraineId,
                            onMigraineSelect = { linkedMigraineId = it },
                            onSave = {
                                scope.launch {
                                    val token = authVm.state.value.accessToken ?: return@launch
                                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                    quickLogVm.draft.value.activities.forEach { a ->
                                        runCatching { db.insertActivity(token, linkedMigraineId, a.type, a.startAtIso ?: java.time.Instant.now().toString(), a.endAtIso, a.note) }
                                    }
                                    quickLogVm.clearDraft()
                                    nav.popBackStack()
                                }
                            }
                        )
                    }
                    composable(Routes.QUICK_LOG_PRODROME) {
                        val prodromeVm: ProdromeViewModel = viewModel()
                        val quickLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        ProdromeLogScreen(
                            navController = nav, vm = prodromeVm, authVm = authVm, logVm = quickLogVm,
                            quickLogMode = true,
                            linkedMigraineId = linkedMigraineId,
                            onMigraineSelect = { linkedMigraineId = it },
                            onSave = {
                                scope.launch {
                                    val token = authVm.state.value.accessToken ?: return@launch
                                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                    quickLogVm.draft.value.prodromes.forEach { p ->
                                        runCatching { db.insertProdrome(token, linkedMigraineId, p.type, p.startAtIso, p.note) }
                                    }
                                    quickLogVm.clearDraft()
                                    nav.popBackStack()
                                }
                            }
                        )
                    }

                    composable(Routes.QUICK_LOG_MIGRAINE) {
                        val symptomVmLocal: SymptomViewModel = viewModel()
                        QuickMigraineScreen(
                            navController = nav, authVm = authVm, symptomVm = symptomVmLocal,
                            onClose = { nav.popBackStack() }
                        )
                    }

                    composable(Routes.TRIGGERS) {
                        TriggersScreen(navController = nav, vm = triggerVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }
                    composable(Routes.ADJUST_TRIGGERS) {
                        AdjustTriggersScreen(navController = nav, vm = triggerVm, authVm = authVm)
                    }

                    composable(Routes.MEDICINES) {
                        MedicinesScreen(navController = nav, vm = medVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }
                    composable(Routes.ADJUST_MEDICINES) {
                        AdjustMedicinesScreen(navController = nav, vm = medVm, authVm = authVm)
                    }

                    composable(Routes.RELIEFS) {
                        ReliefsScreen(navController = nav, vm = reliefVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }
                    composable(Routes.ADJUST_RELIEFS) {
                        AdjustReliefsScreen(navController = nav, vm = reliefVm, authVm = authVm)
                    }

                    composable(Routes.LOCATIONS) {
                        val locationVm: LocationViewModel = viewModel()
                        LocationsScreen(navController = nav, vm = locationVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }
                    composable(Routes.ACTIVITIES) {
                        val activityVm: ActivityViewModel = viewModel()
                        ActivitiesScreen(navController = nav, vm = activityVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }
                    composable(Routes.MISSED_ACTIVITIES) {
                        val missedVm: MissedActivityViewModel = viewModel()
                        MissedActivitiesScreen(navController = nav, vm = missedVm, authVm = authVm, logVm = logVm, onClose = wizardClose)
                    }

                    composable(Routes.NOTES) { NotesScreen(navController = nav, vm = logVm, onClose = wizardClose) }
                    composable(Routes.REVIEW) { ReviewLogScreen(navController = nav, authVm = authVm, vm = logVm, onClose = wizardClose) }

                    composable("${Routes.EDIT_MIGRAINE}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val authState by authVm.state.collectAsState()
                        var prefilling by remember { mutableStateOf(true) }
                        LaunchedEffect(id) {
                            val token = authState.accessToken ?: return@LaunchedEffect
                            logVm.prefillForEdit(token, id) {
                                prefilling = false
                            }
                        }
                        if (!prefilling) {
                            // Navigate to wizard, replacing this route
                            LaunchedEffect(Unit) {
                                nav.navigate(Routes.LOG_MIGRAINE) {
                                    popUpTo("${Routes.EDIT_MIGRAINE}/{id}") { inclusive = true }
                                }
                            }
                        } else {
                            // Loading indicator
                            Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                                CircularProgressIndicator(color = AppTheme.AccentPurple)
                            }
                        }
                    }
                    composable("${Routes.EDIT_TRIGGER}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val triggerVm: TriggerViewModel = viewModel()
                        val editLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        var loaded by remember { mutableStateOf(false) }
                        LaunchedEffect(id) {
                            val token = authVm.state.value.accessToken ?: return@LaunchedEffect
                            val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                            try {
                                val rows = db.getAllTriggers(token)
                                val row = rows.find { it.id == id }
                                if (row != null) {
                                    editLogVm.addTriggerDraft(row.type ?: "", row.startAt, row.notes)
                                    linkedMigraineId = row.migraineId
                                }
                            } catch (_: Exception) {}
                            loaded = true
                        }
                        if (loaded) {
                            TriggersScreen(
                                navController = nav, vm = triggerVm, authVm = authVm, logVm = editLogVm,
                                quickLogMode = true,
                                linkedMigraineId = linkedMigraineId,
                                onMigraineSelect = { linkedMigraineId = it },
                                onSave = {
                                    scope.launch {
                                        val token = authVm.state.value.accessToken ?: return@launch
                                        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                        // Delete old, insert new
                                        runCatching { db.deleteTrigger(token, id) }
                                        editLogVm.draft.value.triggers.forEach { t ->
                                            runCatching { db.insertTrigger(token, linkedMigraineId, t.type, t.startAtIso ?: java.time.Instant.now().toString(), t.note) }
                                        }
                                        editLogVm.clearDraft()
                                        nav.popBackStack()
                                    }
                                }
                            )
                        }
                    }
                    composable("${Routes.EDIT_MEDICINE}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val medVm: MedicineViewModel = viewModel()
                        val editLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        var loaded by remember { mutableStateOf(false) }
                        LaunchedEffect(id) {
                            val token = authVm.state.value.accessToken ?: return@LaunchedEffect
                            val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                            try {
                                val rows = db.getAllMedicines(token)
                                val row = rows.find { it.id == id }
                                if (row != null) {
                                    editLogVm.addMedicineDraft(row.name ?: "", row.amount, row.notes, row.startAt, null)
                                    linkedMigraineId = row.migraineId
                                }
                            } catch (_: Exception) {}
                            loaded = true
                        }
                        if (loaded) {
                            MedicinesScreen(
                                navController = nav, vm = medVm, authVm = authVm, logVm = editLogVm,
                                quickLogMode = true,
                                linkedMigraineId = linkedMigraineId,
                                onMigraineSelect = { linkedMigraineId = it },
                                onSave = {
                                    scope.launch {
                                        val token = authVm.state.value.accessToken ?: return@launch
                                        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                        runCatching { db.deleteMedicine(token, id) }
                                        editLogVm.draft.value.meds.forEach { m ->
                                            runCatching { db.insertMedicine(token, linkedMigraineId, m.name, m.amount, m.startAtIso ?: java.time.Instant.now().toString(), m.notes) }
                                        }
                                        editLogVm.clearDraft()
                                        nav.popBackStack()
                                    }
                                }
                            )
                        }
                    }
                    composable("${Routes.EDIT_RELIEF}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val reliefVm: ReliefViewModel = viewModel()
                        val editLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        var loaded by remember { mutableStateOf(false) }
                        LaunchedEffect(id) {
                            val token = authVm.state.value.accessToken ?: return@LaunchedEffect
                            val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                            try {
                                val rows = db.getAllReliefs(token)
                                val row = rows.find { it.id == id }
                                if (row != null) {
                                    editLogVm.addReliefDraft(row.type ?: "", row.notes, row.startAt, row.endAt, null)
                                    linkedMigraineId = row.migraineId
                                }
                            } catch (_: Exception) {}
                            loaded = true
                        }
                        if (loaded) {
                            ReliefsScreen(
                                navController = nav, vm = reliefVm, authVm = authVm, logVm = editLogVm,
                                quickLogMode = true,
                                linkedMigraineId = linkedMigraineId,
                                onMigraineSelect = { linkedMigraineId = it },
                                onSave = {
                                    scope.launch {
                                        val token = authVm.state.value.accessToken ?: return@launch
                                        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                        runCatching { db.deleteRelief(token, id) }
                                        editLogVm.draft.value.rels.forEach { r ->
                                            runCatching { db.insertRelief(token, linkedMigraineId, r.type, r.startAtIso ?: java.time.Instant.now().toString(), r.endAtIso, r.notes, r.reliefScale) }
                                        }
                                        editLogVm.clearDraft()
                                        nav.popBackStack()
                                    }
                                }
                            )
                        }
                    }
                    composable("${Routes.EDIT_PRODROME}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val prodromeVm: ProdromeViewModel = viewModel()
                        val editLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        var loaded by remember { mutableStateOf(false) }
                        LaunchedEffect(id) {
                            val token = authVm.state.value.accessToken ?: return@LaunchedEffect
                            val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                            try {
                                val rows = db.getAllProdromeLog(token)
                                val row = rows.find { it.id == id }
                                if (row != null) {
                                    editLogVm.addProdromeDraft(row.type ?: "", row.startAt, row.notes)
                                    linkedMigraineId = row.migraineId
                                }
                            } catch (_: Exception) {}
                            loaded = true
                        }
                        if (loaded) {
                            ProdromeLogScreen(
                                navController = nav, vm = prodromeVm, authVm = authVm, logVm = editLogVm,
                                quickLogMode = true,
                                linkedMigraineId = linkedMigraineId,
                                onMigraineSelect = { linkedMigraineId = it },
                                onSave = {
                                    scope.launch {
                                        val token = authVm.state.value.accessToken ?: return@launch
                                        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                        runCatching { db.deleteProdromeLog(token, id) }
                                        editLogVm.draft.value.prodromes.forEach { p ->
                                            runCatching { db.insertProdrome(token, linkedMigraineId, p.type, p.startAtIso, p.note) }
                                        }
                                        editLogVm.clearDraft()
                                        nav.popBackStack()
                                    }
                                }
                            )
                        }
                    }
                    composable("${Routes.EDIT_ACTIVITY}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val activityVm: ActivityViewModel = viewModel()
                        val editLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        var loaded by remember { mutableStateOf(false) }
                        LaunchedEffect(id) {
                            val token = authVm.state.value.accessToken ?: return@LaunchedEffect
                            val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                            try {
                                val rows = db.getAllActivityLog(token)
                                val row = rows.find { it.id == id }
                                if (row != null) {
                                    editLogVm.addActivityDraft(row.type ?: "", row.startAt, row.notes)
                                    linkedMigraineId = row.migraineId
                                }
                            } catch (_: Exception) {}
                            loaded = true
                        }
                        if (loaded) {
                            ActivitiesScreen(
                                navController = nav, vm = activityVm, authVm = authVm, logVm = editLogVm,
                                quickLogMode = true,
                                linkedMigraineId = linkedMigraineId,
                                onMigraineSelect = { linkedMigraineId = it },
                                onSave = {
                                    scope.launch {
                                        val token = authVm.state.value.accessToken ?: return@launch
                                        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                        runCatching { db.deleteActivityLog(token, id) }
                                        editLogVm.draft.value.activities.forEach { a ->
                                            runCatching { db.insertActivity(token, linkedMigraineId, a.type, a.startAtIso ?: java.time.Instant.now().toString(), a.endAtIso, a.note) }
                                        }
                                        editLogVm.clearDraft()
                                        nav.popBackStack()
                                    }
                                }
                            )
                        }
                    }
                    composable("${Routes.EDIT_LOCATION}/{id}") {
                        val id = it.arguments?.getString("id") ?: return@composable
                        val locationVm: LocationViewModel = viewModel()
                        val editLogVm: LogViewModel = viewModel()
                        val scope = rememberCoroutineScope()
                        var linkedMigraineId by remember { mutableStateOf<String?>(null) }
                        var loaded by remember { mutableStateOf(false) }
                        LaunchedEffect(id) {
                            val token = authVm.state.value.accessToken ?: return@LaunchedEffect
                            val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                            try {
                                val rows = db.getAllLocationLog(token)
                                val row = rows.find { it.id == id }
                                if (row != null) {
                                    editLogVm.addLocationDraft(row.type ?: "", row.startAt, row.notes)
                                    linkedMigraineId = row.migraineId
                                }
                            } catch (_: Exception) {}
                            loaded = true
                        }
                        if (loaded) {
                            LocationsScreen(
                                navController = nav, vm = locationVm, authVm = authVm, logVm = editLogVm,
                                quickLogMode = true,
                                linkedMigraineId = linkedMigraineId,
                                onMigraineSelect = { linkedMigraineId = it },
                                onSave = {
                                    scope.launch {
                                        val token = authVm.state.value.accessToken ?: return@launch
                                        val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                                        runCatching { db.deleteLocationLog(token, id) }
                                        editLogVm.draft.value.locations.forEach { l ->
                                            runCatching { db.insertLocation(token, linkedMigraineId, l.type, l.startAtIso ?: java.time.Instant.now().toString(), l.note) }
                                        }
                                        editLogVm.clearDraft()
                                        nav.popBackStack()
                                    }
                                }
                            )
                        }
                    }

                    composable(Routes.ADJUST_MIGRAINES) {
                        AdjustMigrainesScreen(navController = nav, vm = migraineVm, authVm = authVm)
                    }
                    composable(Routes.MANAGE_SYMPTOMS) {
                        ManageSymptomsScreen(navController = nav, vm = symptomVm, authVm = authVm)
                    }
                    composable(Routes.MANAGE_ITEMS) {
                        ManageItemsScreen(navController = nav)
                    }
                    composable(Routes.MANAGE_TRIGGERS) {
                        val triggerVm: TriggerViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by triggerVm.pool.collectAsState()
                        val frequent by triggerVm.frequent.collectAsState()
                        val ctx = androidx.compose.ui.platform.LocalContext.current.applicationContext
                        val edge = remember { EdgeFunctionsService() }
                        val scope = rememberCoroutineScope()

                        // Trigger automation settings: label -> full setting (enabled + threshold)
                        var triggerSettings by remember { mutableStateOf<Map<String, EdgeFunctionsService.TriggerSettingResponse>>(emptyMap()) }

                        // Build automatableMap dynamically from pool:
                        // any trigger with direction != null is automatable
                        // label is used as the key in trigger_settings
                        val automatableMap = remember(pool) {
                            pool.filter { it.direction != null }
                                .associate { it.label to it.label }
                        }

                        LaunchedEffect(authState.accessToken) {
                            authState.accessToken?.let { triggerVm.loadAll(it) }
                            kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                                runCatching { edge.getTriggerSettings(ctx) }
                                    .onSuccess { list ->
                                        triggerSettings = list.associate { it.triggerType to it }
                                    }
                            }
                        }

                        val frequentIds = remember(frequent) { frequent.map { it.triggerId }.toSet() }
                        val items = remember(pool, frequentIds, triggerSettings) {
                            pool.map { row ->
                                val autoKey = automatableMap[row.label]
                                val setting = autoKey?.let { triggerSettings[it] }
                                PoolItem(
                                    id = row.id,
                                    label = row.label,
                                    iconKey = row.iconKey,
                                    category = row.category,
                                    isFavorite = row.id in frequentIds,
                                    prediction = PredictionValue.fromString(row.predictionValue),
                                    isAutomatable = autoKey != null,
                                    isAutomated = setting?.enabled ?: row.enabledByDefault,
                                    threshold = setting?.threshold,
                                    defaultThreshold = row.defaultThreshold,
                                    unit = row.unit,
                                    direction = row.direction,
                                    displayGroup = row.displayGroup
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Triggers",
                                subtitle = "Add, star, or remove triggers",
                                iconColor = Color(0xFFFFB74D),
                                drawHeroIcon = { HubIcons.run { drawTriggerBolt(it) } },
                                items = items,
                                showPrediction = true,
                                categories = listOf("Body", "Cognitive", "Diet", "Environment", "Menstrual Cycle", "Physical", "Sleep"),
                                iconResolver = { key -> TriggerIcons.forKey(key) },
                                pickerIcons = TriggerIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, prediction ->
                                    authState.accessToken?.let { triggerVm.addNewToPool(it, label, category, prediction.name) }
                                },
                                onDelete = { id -> authState.accessToken?.let { triggerVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) triggerVm.addToFrequent(token, id)
                                    else {
                                        val pref = frequent.find { it.triggerId == id }
                                        pref?.let { triggerVm.removeFromFrequent(token, it.id) }
                                    }
                                },
                                onSetPrediction = { id, pv ->
                                    authState.accessToken?.let { triggerVm.setPrediction(it, id, pv.name) }
                                },
                                onToggleAutomation = { id, enabled ->
                                    val label = pool.find { it.id == id }?.label ?: return@PoolConfig
                                    val autoKey = automatableMap[label] ?: return@PoolConfig
                                    scope.launch(kotlinx.coroutines.Dispatchers.IO) {
                                        val ok = edge.upsertTriggerSetting(ctx, autoKey, enabled)
                                        if (ok) {
                                            runCatching { edge.getTriggerSettings(ctx) }
                                                .onSuccess { list ->
                                                    triggerSettings = list.associate { it.triggerType to it }
                                                }
                                        }
                                    }
                                },
                                onThresholdChange = { id, threshold ->
                                    val label = pool.find { it.id == id }?.label ?: return@PoolConfig
                                    val autoKey = automatableMap[label] ?: return@PoolConfig
                                    val currentEnabled = triggerSettings[autoKey]?.enabled
                                        ?: pool.find { it.id == id }?.enabledByDefault ?: true
                                    scope.launch(kotlinx.coroutines.Dispatchers.IO) {
                                        val ok = edge.upsertTriggerSetting(ctx, autoKey, currentEnabled, threshold)
                                        if (ok) {
                                            runCatching { edge.getTriggerSettings(ctx) }
                                                .onSuccess { list ->
                                                    triggerSettings = list.associate { it.triggerType to it }
                                                }
                                        }
                                    }
                                },
                                onSetCategory = { id, category ->
                                    authState.accessToken?.let { triggerVm.setCategory(it, id, category) }
                                },
                                onSave = {
                                    edge.triggerRecalc(ctx)
                                    authState.accessToken?.let { triggerVm.loadAll(it) }
                                }
                            )
                        )
                    }
                    composable(Routes.MANAGE_MEDICINES) {
                        val medicineVm: MedicineViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by medicineVm.pool.collectAsState()
                        val frequent by medicineVm.frequent.collectAsState()

                        LaunchedEffect(authState.accessToken) {
                            authState.accessToken?.let { medicineVm.loadAll(it) }
                        }

                        val frequentIds = remember(frequent) { frequent.map { it.medicineId }.toSet() }
                        val items = remember(pool, frequentIds) {
                            pool.map { row ->
                                PoolItem(
                                    id = row.id,
                                    label = row.label,
                                    iconKey = row.category,
                                    category = row.category,
                                    isFavorite = row.id in frequentIds
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Medicines",
                                subtitle = "Add, star, or remove medicines",
                                iconColor = Color(0xFF4FC3F7),
                                drawHeroIcon = { HubIcons.run { drawMedicinePill(it) } },
                                items = items,
                                categories = listOf("Analgesic", "Anti-Nausea", "CGRP", "Preventive", "Supplement", "Triptan", "Other"),
                                iconResolver = { key -> MedicineIcons.forKey(key) },
                                pickerIcons = MedicineIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, _ ->
                                    authState.accessToken?.let { medicineVm.addNewToPool(it, label, category) }
                                },
                                onDelete = { id -> authState.accessToken?.let { medicineVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) medicineVm.addToFrequent(token, id)
                                    else {
                                        val pref = frequent.find { it.medicineId == id }
                                        pref?.let { medicineVm.removeFromFrequent(token, it.id) }
                                    }
                                },
                                onSetCategory = { id, category ->
                                    authState.accessToken?.let { medicineVm.setCategory(it, id, category) }
                                }
                            )
                        )
                    }
                    composable(Routes.MANAGE_RELIEFS) {
                        val reliefVm: ReliefViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by reliefVm.pool.collectAsState()
                        val frequent by reliefVm.frequent.collectAsState()

                        LaunchedEffect(authState.accessToken) {
                            authState.accessToken?.let { reliefVm.loadAll(it) }
                        }

                        val frequentIds = remember(frequent) { frequent.map { it.reliefId }.toSet() }
                        val items = remember(pool, frequentIds) {
                            pool.map { row ->
                                PoolItem(
                                    id = row.id,
                                    label = row.label,
                                    iconKey = row.iconKey,
                                    category = row.category,
                                    isFavorite = row.id in frequentIds,
                                    isAutomatable = row.isAutomatable,
                                    isAutomated = row.isAutomated
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Reliefs",
                                subtitle = "Add, star, or remove reliefs",
                                iconColor = Color(0xFF81C784),
                                drawHeroIcon = { HubIcons.run { drawReliefLeaf(it) } },
                                items = items,
                                categories = listOf("Breathing", "Cold/Heat", "Darkness", "Hydration", "Massage", "Meditation", "Movement", "Rest", "Supplement", "Other"),
                                iconResolver = { key -> ReliefIcons.forKey(key) },
                                pickerIcons = ReliefIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, _ ->
                                    authState.accessToken?.let { reliefVm.addNewToPool(it, label, category) }
                                },
                                onDelete = { id -> authState.accessToken?.let { reliefVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) reliefVm.addToFrequent(token, id)
                                    else {
                                        val pref = frequent.find { it.reliefId == id }
                                        pref?.let { reliefVm.removeFromFrequent(token, it.id) }
                                    }
                                },
                                onSetCategory = { id, category ->
                                    authState.accessToken?.let { reliefVm.setCategory(it, id, category) }
                                },
                                onToggleAutomation = { id, enabled ->
                                    authState.accessToken?.let { reliefVm.setAutomation(it, id, enabled) }
                                }
                            )
                        )
                    }

                    composable(Routes.MANAGE_PRODROMES) {
                        val prodromeVm: ProdromeViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by prodromeVm.pool.collectAsState()
                        val frequent by prodromeVm.frequent.collectAsState()
                        val ctx = androidx.compose.ui.platform.LocalContext.current.applicationContext
                        val edge = remember { EdgeFunctionsService() }
                        val scope = rememberCoroutineScope()

                        // Prodrome settings: prodromeType -> ProdromeSettingResponse (includes threshold)
                        var prodromeSettings by remember { mutableStateOf<Map<String, EdgeFunctionsService.ProdromeSettingResponse>>(emptyMap()) }

                        // Build automatable map dynamically from pool (direction != null = auto-detectable)
                        val automatableMap = remember(pool) {
                            pool.filter { it.direction != null }
                                .associate { it.label to it.label }
                        }

                        LaunchedEffect(authState.accessToken) {
                            authState.accessToken?.let { prodromeVm.loadAll(it) }
                            kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                                runCatching { edge.getProdromeSettings(ctx) }
                                    .onSuccess { list ->
                                        prodromeSettings = list.associate { it.prodromeType to it }
                                    }
                            }
                        }

                        val frequentIds = remember(frequent) { frequent.map { it.prodromeId }.toSet() }
                        val items = remember(pool, frequentIds, prodromeSettings) {
                            pool.map { row ->
                                val autoKey = automatableMap[row.label]
                                val setting = autoKey?.let { prodromeSettings[it] }
                                PoolItem(
                                    id = row.id,
                                    label = row.label,
                                    iconKey = row.iconKey,
                                    category = row.category,
                                    isFavorite = row.id in frequentIds,
                                    prediction = PredictionValue.fromString(row.predictionValue),
                                    isAutomatable = autoKey != null,
                                    isAutomated = setting?.enabled ?: row.enabledByDefault,
                                    threshold = setting?.threshold,
                                    defaultThreshold = row.defaultThreshold,
                                    unit = row.unit,
                                    direction = row.direction,
                                    displayGroup = row.displayGroup
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Prodromes",
                                subtitle = "Early warning signs before a migraine",
                                iconColor = Color(0xFFCE93D8),
                                drawHeroIcon = { HubIcons.run { drawProdromeEye(it) } },
                                items = items,
                                showPrediction = true,
                                categories = listOf("Autonomic", "Cognitive", "Digestive", "Mood", "Physical", "Sensitivity", "Sensory", "Sleep", "Speech", "Visual"),
                                iconResolver = { key -> ProdromeIcons.forKey(key) },
                                pickerIcons = ProdromeIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, prediction ->
                                    authState.accessToken?.let { prodromeVm.addNewToPool(it, label, category, prediction.name) }
                                },
                                onDelete = { id -> authState.accessToken?.let { prodromeVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) prodromeVm.addToFrequent(token, id)
                                    else {
                                        val pref = frequent.find { it.prodromeId == id }
                                        pref?.let { prodromeVm.removeFromFrequent(token, it.id) }
                                    }
                                },
                                onSetPrediction = { id, pv ->
                                    authState.accessToken?.let { prodromeVm.setPrediction(it, id, pv.name) }
                                },
                                onSetCategory = { id, category ->
                                    authState.accessToken?.let { prodromeVm.setCategory(it, id, category) }
                                },
                                onToggleAutomation = { id, enabled ->
                                    val label = pool.find { it.id == id }?.label ?: return@PoolConfig
                                    val autoKey = automatableMap[label] ?: return@PoolConfig
                                    scope.launch(kotlinx.coroutines.Dispatchers.IO) {
                                        val ok = edge.upsertProdromeSetting(ctx, autoKey, enabled)
                                        if (ok) {
                                            runCatching { edge.getProdromeSettings(ctx) }
                                                .onSuccess { list ->
                                                    prodromeSettings = list.associate { it.prodromeType to it }
                                                }
                                        }
                                    }
                                },
                                onThresholdChange = { id, newThreshold ->
                                    val label = pool.find { it.id == id }?.label ?: return@PoolConfig
                                    val autoKey = automatableMap[label] ?: return@PoolConfig
                                    scope.launch(kotlinx.coroutines.Dispatchers.IO) {
                                        edge.upsertProdromeSetting(ctx, autoKey, true, newThreshold)
                                        runCatching { edge.getProdromeSettings(ctx) }
                                            .onSuccess { list ->
                                                prodromeSettings = list.associate { it.prodromeType to it }
                                            }
                                    }
                                },
                                onSave = {
                                    edge.triggerRecalc(ctx)
                                    authState.accessToken?.let { prodromeVm.loadAll(it) }
                                }
                            )
                        )
                    }

                    composable(Routes.MANAGE_LOCATIONS) {
                        val locationVm: LocationViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by locationVm.pool.collectAsState()
                        val frequent by locationVm.frequent.collectAsState()

                        LaunchedEffect(authState.accessToken) { authState.accessToken?.let { locationVm.loadAll(it) } }

                        val frequentIds = remember(frequent) { frequent.map { it.locationId }.toSet() }
                        val items = remember(pool, frequentIds) {
                            pool.map { row ->
                                PoolItem(
                                    id = row.id, label = row.label, iconKey = row.iconKey, category = row.category,
                                    isFavorite = row.id in frequentIds,
                                    isAutomatable = row.isAutomatable, isAutomated = row.isAutomated
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Locations",
                                subtitle = "Where were you?",
                                iconColor = Color(0xFF64B5F6),
                                drawHeroIcon = { HubIcons.run { drawLocationPin(it) } },
                                items = items,
                                categories = listOf("Exercise", "Home", "Medical", "Outdoors", "Social", "Transport", "Work", "Other"),
                                iconResolver = { key -> LocationIcons.forKey(key) },
                                pickerIcons = LocationIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, _ -> authState.accessToken?.let { locationVm.addNewToPool(it, label, category) } },
                                onDelete = { id -> authState.accessToken?.let { locationVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) locationVm.addToFrequent(token, id)
                                    else frequent.find { it.locationId == id }?.let { locationVm.removeFromFrequent(token, it.id) }
                                },
                                onSetCategory = { id, cat -> authState.accessToken?.let { locationVm.setCategory(it, id, cat) } },
                                onToggleAutomation = { id, en -> authState.accessToken?.let { locationVm.setAutomation(it, id, en) } }
                            )
                        )
                    }

                    composable(Routes.MANAGE_ACTIVITIES) {
                        val activityVm: ActivityViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by activityVm.pool.collectAsState()
                        val frequent by activityVm.frequent.collectAsState()

                        LaunchedEffect(authState.accessToken) { authState.accessToken?.let { activityVm.loadAll(it) } }

                        val frequentIds = remember(frequent) { frequent.map { it.activityId }.toSet() }
                        val items = remember(pool, frequentIds) {
                            pool.map { row ->
                                PoolItem(
                                    id = row.id, label = row.label, iconKey = row.iconKey, category = row.category,
                                    isFavorite = row.id in frequentIds,
                                    isAutomatable = row.isAutomatable, isAutomated = row.isAutomated
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Activities",
                                subtitle = "What were you doing?",
                                iconColor = Color(0xFFFF8A65),
                                drawHeroIcon = { HubIcons.run { drawActivityPulse(it) } },
                                items = items,
                                categories = listOf("Exercise", "Leisure", "Screen", "Sleep", "Social", "Travel", "Work", "Other"),
                                iconResolver = { key -> ActivityIcons.forKey(key) },
                                pickerIcons = ActivityIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, _ -> authState.accessToken?.let { activityVm.addNewToPool(it, label, category) } },
                                onDelete = { id -> authState.accessToken?.let { activityVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) activityVm.addToFrequent(token, id)
                                    else frequent.find { it.activityId == id }?.let { activityVm.removeFromFrequent(token, it.id) }
                                },
                                onSetCategory = { id, cat -> authState.accessToken?.let { activityVm.setCategory(it, id, cat) } },
                                onToggleAutomation = { id, en -> authState.accessToken?.let { activityVm.setAutomation(it, id, en) } }
                            )
                        )
                    }

                    composable(Routes.MANAGE_MISSED_ACTIVITIES) {
                        val missedVm: MissedActivityViewModel = viewModel()
                        val authState by authVm.state.collectAsState()
                        val pool by missedVm.pool.collectAsState()
                        val frequent by missedVm.frequent.collectAsState()

                        LaunchedEffect(authState.accessToken) { authState.accessToken?.let { missedVm.loadAll(it) } }

                        val frequentIds = remember(frequent) { frequent.map { it.missedActivityId }.toSet() }
                        val items = remember(pool, frequentIds) {
                            pool.map { row ->
                                PoolItem(
                                    id = row.id, label = row.label, iconKey = row.iconKey, category = row.category,
                                    isFavorite = row.id in frequentIds,
                                    isAutomatable = row.isAutomatable, isAutomated = row.isAutomated
                                )
                            }
                        }

                        ManagePoolScreen(
                            navController = nav,
                            config = PoolConfig(
                                title = "Missed Activities",
                                subtitle = "What did you miss?",
                                iconColor = Color(0xFFEF9A9A),
                                drawHeroIcon = { HubIcons.run { drawMissedActivity(it) } },
                                items = items,
                                categories = listOf("Care", "Exercise", "Leisure", "Screen", "Sleep", "Social", "Travel", "Work", "Other"),
                                iconResolver = { key -> MissedActivityIcons.forKey(key) },
                                pickerIcons = MissedActivityIcons.ALL_ICONS.map { PickerIconEntry(it.key, it.label, it.icon) },
                                onAdd = { label, category, _ -> authState.accessToken?.let { missedVm.addNewToPool(it, label, category) } },
                                onDelete = { id -> authState.accessToken?.let { missedVm.removeFromPool(it, id) } },
                                onToggleFavorite = { id, starred ->
                                    val token = authState.accessToken ?: return@PoolConfig
                                    if (starred) missedVm.addToFrequent(token, id)
                                    else frequent.find { it.missedActivityId == id }?.let { missedVm.removeFromFrequent(token, it.id) }
                                },
                                onSetCategory = { id, cat -> authState.accessToken?.let { missedVm.setCategory(it, id, cat) } },
                                onToggleAutomation = { id, en -> authState.accessToken?.let { missedVm.setAutomation(it, id, en) } }
                            )
                        )
                    }

                    composable(Routes.LOGIN) {
                        val a by authVm.state.collectAsState()
                        val loginCtx = LocalContext.current
                        LaunchedEffect(a.accessToken) {
                            if (!a.accessToken.isNullOrBlank()) {
                                // If returning from WHOOP OAuth during setup, go back to Connections
                                val whoopPrefs = loginCtx.getSharedPreferences("whoop_oauth", android.content.Context.MODE_PRIVATE)
                                val returnToSetup = whoopPrefs.getBoolean("return_to_setup", false)
                                if (returnToSetup) {
                                    whoopPrefs.edit().putBoolean("return_to_setup", false).apply()
                                    nav.navigate(Routes.THIRD_PARTY_CONNECTIONS) {
                                        popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                        launchSingleTop = true
                                    }
                                } else {
                                    val dest = if (OnboardingPrefs.isCompleted(loginCtx)) Routes.HOME else Routes.ONBOARDING
                                    nav.navigate(dest) {
                                        popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                        launchSingleTop = true
                                    }
                                }
                            }
                        }
                        LoginScreen(
                            authVm = authVm,
                            onLoggedIn = {
                                val dest = if (OnboardingPrefs.isCompleted(loginCtx)) Routes.HOME else Routes.ONBOARDING
                                nav.navigate(dest) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            },
                            onNavigateToSignUp = { nav.navigate(Routes.SIGNUP) { launchSingleTop = true } }
                        )
                    }

                    composable(Routes.SIGNUP) {
                        val signupCtx = LocalContext.current
                        SignupScreen(
                            authVm = authVm,
                            onSignedUpAndLoggedIn = {
                                nav.navigate(Routes.ONBOARDING) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            },
                            onNavigateToLogin = { nav.navigate(Routes.LOGIN) { launchSingleTop = true } }
                        )
                    }

                    composable(Routes.PROFILE) {
                        ProfileScreen(
                            authVm = authVm,
                            onNavigateChangePassword = { nav.navigate(Routes.CHANGE_PASSWORD) }
                        )
                    }

                    composable(Routes.CHANGE_PASSWORD) {
                        ChangePasswordScreen(authVm = authVm, onDone = { nav.popBackStack() })
                    }

                    composable(Routes.THIRD_PARTY_CONNECTIONS) {
                        ThirdPartyConnectionsScreen(onBack = { nav.popBackStack() })
                    }

                    composable(Routes.DATA) {
                        DataSettingsScreen(onOpenMenstruationSettings = { nav.navigate(Routes.MENSTRUATION_SETTINGS) })
                    }

                    composable(Routes.RISK_WEIGHTS) {
                        RiskWeightsScreen(onBack = { nav.popBackStack() })
                    }

                    composable(Routes.RISK_DETAIL) {
                        val homeState by homeVm.state.collectAsState()
                        RiskDetailScreen(
                            navController = nav,
                            state = homeState
                        )
                    }

                    composable(Routes.TESTING) {
                        TestingScreen(
                            authVm = authVm,
                            onNavigateToOnboarding = {
                                nav.navigate(Routes.ONBOARDING) {
                                    launchSingleTop = true
                                }
                            },
                            onNavigateToHome = {
                                nav.navigate(Routes.HOME) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            },
                            onNavigateToCheckIn = {
                                nav.navigate(Routes.EVENING_CHECKIN) {
                                    launchSingleTop = true
                                }
                            }
                        )
                    }

                    composable(Routes.ONBOARDING) {
                        OnboardingScreen(
                            startAtSetup = false,
                            onComplete = {
                                nav.navigate(Routes.HOME) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            },
                            onStartTour = {
                                nav.navigate(Routes.HOME) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                                TourManager.startTour()
                            },
                            onStartSetup = {
                                nav.navigate(Routes.THIRD_PARTY_CONNECTIONS) {
                                    launchSingleTop = true
                                }
                                TourManager.startSetup()
                            },
                            onTourSkipped = {
                                nav.navigate("${Routes.ONBOARDING}/setup") {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            }
                        )
                    }

                    composable("${Routes.ONBOARDING}/setup") {
                        OnboardingScreen(
                            startAtSetup = true,
                            onComplete = {
                                nav.navigate(Routes.AI_SETUP) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            },
                            onStartTour = { /* already done */ },
                            onStartSetup = {
                                nav.navigate(Routes.THIRD_PARTY_CONNECTIONS) {
                                    launchSingleTop = true
                                }
                                TourManager.startSetup()
                            }
                        )
                    }

                    composable(Routes.AI_SETUP) {
                        AiSetupScreen(
                            onComplete = {
                                scope.launch(Dispatchers.IO) {
                                    try { EdgeFunctionsService().enqueueLoginBackfill(appCtx) } catch (_: Exception) {}
                                    kotlinx.coroutines.withContext(Dispatchers.Main) {
                                        nav.navigate("backfill_loading") {
                                            popUpTo(Routes.AI_SETUP) { inclusive = true }
                                            launchSingleTop = true
                                        }
                                    }
                                }
                            },
                            onSkip = {
                                scope.launch(Dispatchers.IO) {
                                    try { EdgeFunctionsService().enqueueLoginBackfill(appCtx) } catch (_: Exception) {}
                                    kotlinx.coroutines.withContext(Dispatchers.Main) {
                                        nav.navigate("backfill_loading") {
                                            popUpTo(Routes.AI_SETUP) { inclusive = true }
                                            launchSingleTop = true
                                        }
                                    }
                                }
                            }
                        )
                    }

                    // ── Backfill loading: polls edge_audit until backfill-all completes (max 60s) ──
                    composable("backfill_loading") {
                        val ctx = LocalContext.current
                        var progress by remember { mutableFloatStateOf(0f) }
                        var statusText by remember { mutableStateOf("Analyzing your data...") }
                        var showContinueButton by remember { mutableStateOf(false) }

                        LaunchedEffect(Unit) {
                            kotlinx.coroutines.withContext(Dispatchers.IO) {
                                val token = SessionStore.readAccessToken(ctx) ?: ""
                                val userId = SessionStore.readUserId(ctx) ?: ""
                                val base = BuildConfig.SUPABASE_URL
                                val key = BuildConfig.SUPABASE_ANON_KEY
                                val client = io.ktor.client.HttpClient()
                                val startTime = System.currentTimeMillis()
                                val startIso = java.time.Instant.now().toString()
                                val timeoutMs = 120_000L
                                var done = false

                                // Wait a few seconds before first poll to let backfill start
                                kotlinx.coroutines.delay(5000)

                                try {
                                    while (!done && (System.currentTimeMillis() - startTime) < timeoutMs) {
                                        val elapsed = System.currentTimeMillis() - startTime
                                        progress = (elapsed.toFloat() / timeoutMs).coerceAtMost(0.95f)

                                        // Update status text based on progress
                                        statusText = when {
                                            elapsed < 12_000 -> "Fetching your WHOOP data..."
                                            elapsed < 22_000 -> "Loading weather patterns..."
                                            elapsed < 38_000 -> "Evaluating your triggers..."
                                            elapsed < 52_000 -> "Calculating risk scores..."
                                            else -> "Almost there..."
                                        }

                                        try {
                                            val resp = client.get("$base/rest/v1/edge_audit?fn=eq.backfill-all&user_id=eq.$userId&ok=eq.true&created_at=gte.$startIso&order=created_at.desc&limit=1") {
                                                header("Authorization", "Bearer $token")
                                                header("apikey", key)
                                            }
                                            val body = resp.bodyAsText()
                                            // Non-empty array means a matching row was found
                                            if (body.startsWith("[") && body.length > 5 && !body.startsWith("[]")) {
                                                done = true
                                                progress = 1f
                                                statusText = "All set!"
                                            }
                                        } catch (_: Exception) {}

                                        if (!done) kotlinx.coroutines.delay(3000)
                                    }
                                } finally { client.close() }

                                if (!done) { progress = 1f; statusText = "Taking longer than expected..." }
                                kotlinx.coroutines.delay(800) // Brief pause to show final status
                            }

                            if (statusText == "All set!") {
                                // Backfill completed — go to subscribe
                                nav.navigate("subscribe") {
                                    popUpTo("backfill_loading") { inclusive = true }
                                    launchSingleTop = true
                                }
                            } else {
                                // Backfill still running — show retry/continue option
                                statusText = "Still setting up in the background"
                                showContinueButton = true
                            }
                        }

                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(AppTheme.FadeColor)
                                .padding(32.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Column(
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.spacedBy(24.dp)
                            ) {
                                // Animated brain/pulse icon
                                val infiniteTransition = rememberInfiniteTransition(label = "pulse")
                                val pulseScale by infiniteTransition.animateFloat(
                                    initialValue = 0.9f, targetValue = 1.1f,
                                    animationSpec = infiniteRepeatable(
                                        tween(1000, easing = FastOutSlowInEasing),
                                        RepeatMode.Reverse
                                    ), label = "scale"
                                )
                                val animatedProgress by animateFloatAsState(progress, tween(500), label = "prog")
                                Icon(
                                    Icons.Outlined.Analytics, contentDescription = null,
                                    tint = AppTheme.AccentPink,
                                    modifier = Modifier
                                        .size(64.dp)
                                        .scale(pulseScale)
                                )

                                Text(
                                    statusText,
                                    style = MaterialTheme.typography.titleMedium,
                                    color = AppTheme.TitleColor,
                                    textAlign = TextAlign.Center
                                )

                                LinearProgressIndicator(
                                    progress = { animatedProgress },
                                    modifier = Modifier
                                        .fillMaxWidth(0.7f)
                                        .height(6.dp)
                                        .clip(RoundedCornerShape(3.dp)),
                                    color = AppTheme.AccentPink,
                                    trackColor = AppTheme.TrackColor
                                )

                                Text(
                                    if (showContinueButton) "Your data is still being processed.\nThis will complete in the background."
                                    else "Setting up your personalised migraine predictions",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = AppTheme.SubtleTextColor,
                                    textAlign = TextAlign.Center
                                )

                                if (showContinueButton) {
                                    Spacer(Modifier.height(8.dp))
                                    Button(
                                        onClick = {
                                            nav.navigate("subscribe") {
                                                popUpTo("backfill_loading") { inclusive = true }
                                                launchSingleTop = true
                                            }
                                        },
                                        colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                                        shape = RoundedCornerShape(12.dp)
                                    ) {
                                        Text("Continue")
                                    }
                                }
                            }
                        }
                    }

                    // ── Subscribe placeholder ──
                    composable("subscribe") {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(AppTheme.FadeColor)
                                .padding(32.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Column(
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.spacedBy(24.dp)
                            ) {
                                Icon(
                                    Icons.Outlined.Star, contentDescription = null,
                                    tint = AppTheme.AccentPink,
                                    modifier = Modifier.size(64.dp)
                                )
                                Text(
                                    "Subscribe to MigraineMe",
                                    style = MaterialTheme.typography.headlineSmall,
                                    color = AppTheme.TitleColor,
                                    textAlign = TextAlign.Center
                                )
                                Text(
                                    "Unlock personalised migraine predictions, detailed insights, and AI-powered analysis.",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = AppTheme.SubtleTextColor,
                                    textAlign = TextAlign.Center
                                )
                                Spacer(Modifier.height(16.dp))
                                Button(
                                    onClick = {
                                        nav.navigate(Routes.HOME) {
                                            popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                            launchSingleTop = true
                                        }
                                    },
                                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                                    shape = RoundedCornerShape(12.dp),
                                    modifier = Modifier.fillMaxWidth(0.7f).height(48.dp)
                                ) {
                                    Text("Subscribe Now", style = MaterialTheme.typography.titleSmall)
                                }
                                TextButton(onClick = {
                                    nav.navigate(Routes.HOME) {
                                        popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                        launchSingleTop = true
                                    }
                                }) {
                                    Text("Maybe later", color = AppTheme.SubtleTextColor)
                                }
                            }
                        }
                    }

                    composable(Routes.MENSTRUATION_SETTINGS) {
                        MenstruationSettingsScreen(onBack = { nav.popBackStack() })
                    }

                    composable(Routes.EVENING_CHECKIN) {
                        EveningCheckInScreen(
                            navController = nav,
                            authVm = authVm,
                            triggerVm = triggerVm,
                            prodromeVm = viewModel(),
                            medicineVm = medVm,
                            reliefVm = reliefVm,
                        )
                    }

                    composable(Routes.LOGOUT) {
                        LogoutScreen(
                            authVm = authVm,
                            onLoggedOut = {
                                nav.navigate(Routes.LOGIN) {
                                    popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                    launchSingleTop = true
                                }
                            }
                        )
                    }

                }

                    // Coach overlay for feature tour (floats on top of real screens)
                    CoachOverlay(
                        navigateTo = { route ->
                            nav.navigate(route) {
                                launchSingleTop = true
                            }
                        },
                        onTourFinished = {
                            nav.navigate("${Routes.ONBOARDING}/setup") {
                                popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                launchSingleTop = true
                            }
                        },
                        onSetupFinished = {
                            nav.navigate(Routes.AI_SETUP) {
                                popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                launchSingleTop = true
                            }
                        }
                    )
                } // end Box wrapper
            }
        }
    }
}

private fun needsAttention(ev: JournalEvent): Boolean {
    return when (ev) {
        is JournalEvent.Migraine ->
            ev.row.startAt.isNullOrBlank() || ev.row.endAt.isNullOrBlank() || ev.row.severity == null

        is JournalEvent.Trigger ->
            ev.row.startAt.isNullOrBlank()

        is JournalEvent.Medicine ->
            ev.row.amount.isNullOrBlank() || ev.row.startAt.isNullOrBlank()

        is JournalEvent.Relief ->
            ev.row.durationMinutes == null || ev.row.startAt.isNullOrBlank()

        is JournalEvent.Prodrome -> ev.row.startAt.isNullOrBlank()
        is JournalEvent.Activity -> ev.row.startAt.isNullOrBlank()
        is JournalEvent.Location -> false
        is JournalEvent.MissedActivity -> false
    }
}

@Composable
private fun BottomBar(
    nav: androidx.navigation.NavHostController,
    journalBadgeCount: Int
) {
    data class BottomItem(val route: String, val label: String, val icon: ImageVector)

    val items = listOf(
        BottomItem(Routes.MONITOR, "Monitor", Icons.Outlined.Timeline),
        BottomItem(Routes.INSIGHTS, "Insights", Icons.Outlined.BarChart),
        BottomItem(Routes.HOME, "Home", Icons.Outlined.Home),
        BottomItem(Routes.MIGRAINE, "Migraine", Icons.Outlined.Psychology),
        BottomItem(Routes.JOURNAL, "Journal", Icons.Outlined.History)
    )

    NavigationBar(
        containerColor = Color(0xFF2A003D),
        tonalElevation = 0.dp
    ) {
        val backStack by nav.currentBackStackEntryAsState()
        val currentRoute = backStack?.destination?.route

        items.forEach { item ->
            val showBadge = item.route == Routes.JOURNAL && journalBadgeCount > 0
            val selected = currentRoute == item.route ||
                    (item.route == Routes.INSIGHTS && currentRoute == Routes.INSIGHTS_DETAIL) ||
                    (item.route == Routes.INSIGHTS && currentRoute == Routes.INSIGHTS_REPORT) ||
                    (item.route == Routes.INSIGHTS && currentRoute?.startsWith(Routes.INSIGHTS_BREAKDOWN) == true) ||
                    (item.route == Routes.MONITOR && currentRoute == Routes.MONITOR_CONFIG)

            NavigationBarItem(
                selected = selected,
                onClick = {
                    nav.navigate(item.route) {
                        popUpTo(nav.graph.findStartDestination().id) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                },
                icon = {
                    if (showBadge) {
                        BadgedBox(badge = { Badge { Text(journalBadgeCount.toString()) } }) {
                            Icon(item.icon, contentDescription = item.label)
                        }
                    } else {
                        Icon(item.icon, contentDescription = item.label)
                    }
                },
                label = { Text(item.label) },
                alwaysShowLabel = true
            )
        }
    }
}

title: ManageItemsScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.ChevronRight
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@Composable
fun ManageItemsScreen(navController: NavController) {
    val scrollState = rememberScrollState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Close bar
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Text("Manage Items", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawMigraineStarburst(AppTheme.AccentPink) } }
                )
                Text("Manage Items", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    "Add, remove, or organise your triggers, medicines, reliefs and symptoms",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // Manage cards
            ManageItemRow(
                title = "Symptoms",
                subtitle = "Pain character & accompanying experiences",
                iconColor = AppTheme.AccentPink,
                drawIcon = { HubIcons.run { drawMigraineStarburst(it) } },
                onClick = { navController.navigate(Routes.MANAGE_SYMPTOMS) }
            )

            ManageItemRow(
                title = "Triggers",
                subtitle = "Manage your trigger pool",
                iconColor = Color(0xFFFFB74D),
                drawIcon = { HubIcons.run { drawTriggerBolt(it) } },
                onClick = { navController.navigate(Routes.MANAGE_TRIGGERS) }
            )

            ManageItemRow(
                title = "Medicines",
                subtitle = "Manage your medicine pool",
                iconColor = Color(0xFF4FC3F7),
                drawIcon = { HubIcons.run { drawMedicinePill(it) } },
                onClick = { navController.navigate(Routes.MANAGE_MEDICINES) }
            )

            ManageItemRow(
                title = "Reliefs",
                subtitle = "Manage your relief pool",
                iconColor = Color(0xFF81C784),
                drawIcon = { HubIcons.run { drawReliefLeaf(it) } },
                onClick = { navController.navigate(Routes.MANAGE_RELIEFS) }
            )

            ManageItemRow(
                title = "Prodromes",
                subtitle = "Early warning signs",
                iconColor = Color(0xFFCE93D8),
                drawIcon = { HubIcons.run { drawProdromeEye(it) } },
                onClick = { navController.navigate(Routes.MANAGE_PRODROMES) }
            )

            ManageItemRow(
                title = "Locations",
                subtitle = "Where were you?",
                iconColor = Color(0xFF64B5F6),
                drawIcon = { HubIcons.run { drawLocationPin(it) } },
                onClick = { navController.navigate(Routes.MANAGE_LOCATIONS) }
            )

            ManageItemRow(
                title = "Activities",
                subtitle = "What were you doing?",
                iconColor = Color(0xFFFF8A65),
                drawIcon = { HubIcons.run { drawActivityPulse(it) } },
                onClick = { navController.navigate(Routes.MANAGE_ACTIVITIES) }
            )

            ManageItemRow(
                title = "Missed Activities",
                subtitle = "What did you miss?",
                iconColor = Color(0xFFEF9A9A),
                drawIcon = { HubIcons.run { drawMissedActivity(it) } },
                onClick = { navController.navigate(Routes.MANAGE_MISSED_ACTIVITIES) }
            )

            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun ManageItemRow(
    title: String,
    subtitle: String,
    iconColor: Color,
    drawIcon: DrawScope.(Color) -> Unit,
    enabled: Boolean = true,
    onClick: () -> Unit
) {
    val actualColor = if (enabled) iconColor else iconColor.copy(alpha = 0.4f)

    BaseCard(
        modifier = if (enabled) Modifier.clickable(onClick = onClick) else Modifier
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Round icon circle
            Box(
                modifier = Modifier
                    .size(46.dp)
                    .clip(CircleShape)
                    .background(actualColor.copy(alpha = 0.15f))
                    .border(1.5.dp, actualColor.copy(alpha = 0.3f), CircleShape),
                contentAlignment = Alignment.Center
            ) {
                Box(
                    modifier = Modifier
                        .size(24.dp)
                        .drawBehind { drawIcon(actualColor) }
                )
            }

            Spacer(Modifier.width(14.dp))

            Column(modifier = Modifier.weight(1f)) {
                Text(
                    title,
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                )
                Text(
                    subtitle,
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            Icon(
                Icons.Outlined.ChevronRight,
                contentDescription = null,
                tint = AppTheme.SubtleTextColor,
                modifier = Modifier.size(22.dp)
            )
        }
    }
}

title: ManagePoolScreen.kt
text:
package com.migraineme

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Add
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Delete
import androidx.compose.material.icons.outlined.ExpandLess
import androidx.compose.material.icons.outlined.ExpandMore
import androidx.compose.material.icons.outlined.Star
import androidx.compose.material.icons.outlined.StarBorder
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/* ────────────────────────────────────────────────
 *  Data models
 * ──────────────────────────────────────────────── */

enum class PredictionValue(val display: String, val chipColor: Color) {
    NONE("None",  Color(0xFF666666)),
    LOW("Low",    Color(0xFF81C784)),
    MILD("Mild",  Color(0xFFFFB74D)),
    HIGH("High",  Color(0xFFE57373));

    companion object {
        fun fromString(s: String?): PredictionValue =
            entries.find { it.name.equals(s, ignoreCase = true) } ?: NONE
    }
}

data class PoolItem(
    val id: String,
    val label: String,
    val iconKey: String? = null,
    val category: String? = null,
    val isFavorite: Boolean = false,
    val prediction: PredictionValue = PredictionValue.NONE,
    val isAutomatable: Boolean = false,
    val isAutomated: Boolean = false,
    val threshold: Double? = null,
    val defaultThreshold: Double? = null,
    val unit: String? = null,
    val direction: String? = null,
    val displayGroup: String? = null
)

/** Icon entry for the add-dialog picker grid */
data class PickerIconEntry(val key: String, val label: String, val icon: ImageVector)

data class PoolConfig(
    val title: String,
    val subtitle: String,
    val iconColor: Color,
    val drawHeroIcon: DrawScope.(Color) -> Unit,
    val items: List<PoolItem>,
    val categories: List<String> = emptyList(),
    val showPrediction: Boolean = false,
    val iconResolver: ((String?) -> ImageVector?)? = null,
    val pickerIcons: List<PickerIconEntry> = emptyList(),
    val onAdd: (label: String, category: String?, prediction: PredictionValue) -> Unit,
    val onDelete: (itemId: String) -> Unit,
    val onToggleFavorite: (itemId: String, starred: Boolean) -> Unit,
    val onSetPrediction: (itemId: String, prediction: PredictionValue) -> Unit = { _, _ -> },
    val onToggleAutomation: (itemId: String, enabled: Boolean) -> Unit = { _, _ -> },
    val onSetCategory: (itemId: String, category: String?) -> Unit = { _, _ -> },
    val onThresholdChange: (itemId: String, threshold: Double?) -> Unit = { _, _ -> },
    val onSave: (suspend () -> Unit)? = null
)

/* ────────────────────────────────────────────────
 *  Screen
 * ──────────────────────────────────────────────── */

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun ManagePoolScreen(
    navController: NavController,
    config: PoolConfig
) {
    val scrollState = rememberScrollState()
    var showAddDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf<PoolItem?>(null) }
    val scope = rememberCoroutineScope()

    // ── Local change tracking (prediction + threshold) ──
    var pendingPredictions by remember { mutableStateOf(mapOf<String, PredictionValue>()) }
    var pendingThresholds by remember { mutableStateOf(mapOf<String, Double?>()) }
    val isDirty = pendingPredictions.isNotEmpty() || pendingThresholds.isNotEmpty()
    var isSaving by remember { mutableStateOf(false) }
    var showUnsavedDialog by remember { mutableStateOf(false) }

    // ── Overlay pending changes onto items for display ──
    val displayItems = remember(config.items, pendingPredictions, pendingThresholds) {
        config.items.map { item ->
            item.copy(
                prediction = pendingPredictions[item.id] ?: item.prediction,
                threshold = if (item.id in pendingThresholds) pendingThresholds[item.id] else item.threshold
            )
        }
    }

    // ── Build effective config: intercepts prediction/threshold locally,
    //    passes all other callbacks through immediately ──
    val effectiveConfig = remember(config, displayItems) {
        config.copy(
            items = displayItems,
            onSetPrediction = { id, pv ->
                pendingPredictions = pendingPredictions + (id to pv)
            },
            onThresholdChange = { id, threshold ->
                pendingThresholds = pendingThresholds + (id to threshold)
            }
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Close bar — check for unsaved changes
            Row(
                Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(effectiveConfig.title, color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = {
                    if (isDirty) showUnsavedDialog = true
                    else navController.popBackStack()
                }) {
                    Icon(Icons.Outlined.Close, "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(44.dp)
                        .drawBehind { effectiveConfig.drawHeroIcon(this, effectiveConfig.iconColor) }
                )
                Spacer(Modifier.height(6.dp))
                Text(effectiveConfig.title, color = AppTheme.TitleColor, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(effectiveConfig.subtitle, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center)
            }

            // Pool card
            BaseCard {
                Row(
                    Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text("Pool", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    IconButton(onClick = { showAddDialog = true }) {
                        Icon(Icons.Outlined.Add, "Add", tint = effectiveConfig.iconColor, modifier = Modifier.size(20.dp))
                    }
                }

                if (effectiveConfig.items.isEmpty()) {
                    Text("No items yet — tap + to add", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                } else {
                    // Group items by category, with uncategorized at the end
                    val grouped = effectiveConfig.items.groupBy { it.category ?: "Other" }
                    val sortedCategories = grouped.keys.sortedWith(compareBy { if (it == "Other") "zzz" else it })
                    var expandedCategories by remember { mutableStateOf(setOf<String>()) }
                    var expandedGroups by remember { mutableStateOf(setOf<String>()) }

                    sortedCategories.forEach { category ->
                        val isExpanded = category in expandedCategories
                        val categoryItems = grouped[category] ?: emptyList()
                        val itemCount = categoryItems.size

                        // Section header — clickable to expand/collapse
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { expandedCategories = if (isExpanded) expandedCategories - category else expandedCategories + category }
                                .padding(top = 12.dp, bottom = 4.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "${category.replaceFirstChar { c -> c.uppercase() }} ($itemCount)",
                                color = effectiveConfig.iconColor.copy(alpha = 0.8f),
                                style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold)
                            )
                            Icon(
                                if (isExpanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore,
                                contentDescription = if (isExpanded) "Collapse" else "Expand",
                                tint = effectiveConfig.iconColor.copy(alpha = 0.5f),
                                modifier = Modifier.size(20.dp)
                            )
                        }
                        HorizontalDivider(color = effectiveConfig.iconColor.copy(alpha = 0.15f), thickness = 0.5.dp, modifier = Modifier.padding(bottom = 4.dp))

                    AnimatedVisibility(visible = isExpanded) {
                        Column {
                        // Within category, separate grouped vs standalone items
                        val withGroup = categoryItems.filter { it.displayGroup != null }
                        val standalone = categoryItems.filter { it.displayGroup == null }

                        // Render display_groups first
                        val displayGroups = withGroup.groupBy { it.displayGroup!! }
                        displayGroups.forEach { (groupName, members) ->
                            val isGroupExpanded = groupName in expandedGroups
                            // Use first member's icon as group icon
                            val groupIcon = effectiveConfig.iconResolver?.invoke(members.firstOrNull()?.iconKey)
                            // Group-level prediction = highest among members
                            val groupPrediction = members.map { it.prediction }
                                .maxByOrNull { it.ordinal } ?: PredictionValue.NONE
                            val groupIsFavorite = members.any { it.isFavorite }

                            // ── Group header row ──
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .clip(RoundedCornerShape(8.dp))
                                    .background(effectiveConfig.iconColor.copy(alpha = 0.06f))
                                    .clickable { expandedGroups = if (isGroupExpanded) expandedGroups - groupName else expandedGroups + groupName }
                                    .padding(vertical = 8.dp, horizontal = 8.dp),
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                // Icon circle
                                Box(
                                    modifier = Modifier
                                        .size(38.dp)
                                        .clip(CircleShape)
                                        .background(Color.White.copy(alpha = 0.08f))
                                        .border(1.dp, Color.White.copy(alpha = 0.12f), CircleShape),
                                    contentAlignment = Alignment.Center
                                ) {
                                    if (groupIcon != null) {
                                        Icon(groupIcon, groupName, tint = effectiveConfig.iconColor, modifier = Modifier.size(20.dp))
                                    } else {
                                        Text(groupName.take(2).uppercase(), color = effectiveConfig.iconColor,
                                            style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold))
                                    }
                                }

                                // Group name + member count
                                Column(Modifier.weight(1f)) {
                                    Text(groupName, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold))
                                    Text("${members.size} metrics", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                                }

                                // Expand indicator
                                Icon(
                                    if (isGroupExpanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore,
                                    contentDescription = if (isGroupExpanded) "Collapse" else "Expand",
                                    tint = AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                                    modifier = Modifier.size(18.dp)
                                )
                            }

                            // Group-level prediction chips
                            if (effectiveConfig.showPrediction) {
                                Row(
                                    modifier = Modifier.padding(start = 46.dp, top = 4.dp, bottom = 4.dp),
                                    horizontalArrangement = Arrangement.spacedBy(6.dp)
                                ) {
                                    PredictionValue.entries.forEach { pv ->
                                        PredictionChip(
                                            value = pv,
                                            isSelected = groupPrediction == pv,
                                            onClick = {
                                                // Set prediction on ALL members of the group — stored locally
                                                members.forEach { member -> effectiveConfig.onSetPrediction(member.id, pv) }
                                            }
                                        )
                                    }
                                }
                            }

                            // ── Expanded: show individual members ──
                            AnimatedVisibility(visible = isGroupExpanded) {
                                Column(Modifier.padding(start = 20.dp, top = 4.dp)) {
                                    members.forEach { item ->
                                        PoolItemRow(item = item, config = effectiveConfig, showDeleteDialog = { showDeleteDialog = it }, indent = 26.dp)
                                        if (item != members.last()) {
                                            HorizontalDivider(color = Color.White.copy(alpha = 0.04f), thickness = 0.5.dp, modifier = Modifier.padding(vertical = 2.dp))
                                        }
                                    }
                                }
                            }
                            Spacer(Modifier.height(4.dp))
                        }

                        // Render standalone items (no displayGroup)
                        standalone.forEach { item ->
                            PoolItemRow(item = item, config = effectiveConfig, showDeleteDialog = { showDeleteDialog = it })
                            if (item != standalone.last()) {
                                HorizontalDivider(color = Color.White.copy(alpha = 0.06f), thickness = 0.5.dp, modifier = Modifier.padding(vertical = 2.dp))
                            }
                        }
                        } // end Column
                    } // end AnimatedVisibility
                    } // end categories forEach
                }
            }

            // ── Save & Back buttons ──
            Row(
                Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                OutlinedButton(
                    onClick = {
                        if (isDirty) showUnsavedDialog = true
                        else navController.popBackStack()
                    },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }

                if (isDirty) {
                    Button(
                        onClick = {
                            isSaving = true
                            scope.launch {
                                withContext(Dispatchers.IO) {
                                    // 1. Write all pending prediction changes to Supabase
                                    for ((id, pv) in pendingPredictions) {
                                        config.onSetPrediction(id, pv)
                                    }
                                    // 2. Write all pending threshold changes to Supabase
                                    for ((id, thresh) in pendingThresholds) {
                                        config.onThresholdChange(id, thresh)
                                    }
                                    // 3. Call recalc edge function
                                    config.onSave?.invoke()
                                }
                                // 4. Clear dirty state
                                pendingPredictions = emptyMap()
                                pendingThresholds = emptyMap()
                                isSaving = false
                            }
                        },
                        enabled = !isSaving,
                        colors = ButtonDefaults.buttonColors(containerColor = effectiveConfig.iconColor)
                    ) {
                        if (isSaving) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(16.dp),
                                color = Color.White,
                                strokeWidth = 2.dp
                            )
                            Spacer(Modifier.width(8.dp))
                            Text("Saving...", color = Color.White)
                        } else {
                            Text("Save & Recalculate", color = Color.White)
                        }
                    }
                }
            }

            Spacer(Modifier.height(32.dp))
        }
    }

    // ── Unsaved changes dialog ──
    if (showUnsavedDialog) {
        AlertDialog(
            onDismissRequest = { showUnsavedDialog = false },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            title = { Text("Unsaved Changes") },
            text = { Text("You have unsaved changes to prediction values or thresholds. Discard them?") },
            confirmButton = {
                TextButton(onClick = {
                    showUnsavedDialog = false
                    navController.popBackStack()
                }) { Text("Discard", color = AppTheme.AccentPink) }
            },
            dismissButton = {
                TextButton(onClick = { showUnsavedDialog = false }) { Text("Keep Editing", color = AppTheme.SubtleTextColor) }
            }
        )
    }

    // ── Add dialog ──
    if (showAddDialog) {
        var newLabel by remember { mutableStateOf("") }
        var newCategory by remember { mutableStateOf<String?>(null) }
        var newPrediction by remember { mutableStateOf(PredictionValue.NONE) }
        var newIconKey by remember { mutableStateOf<String?>(null) }
        var categoryExpanded by remember { mutableStateOf(false) }

        AlertDialog(
            onDismissRequest = { showAddDialog = false },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            title = { Text("Add ${config.title.lowercase().removeSuffix("s")}") },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(14.dp)) {
                    // Name
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        placeholder = { Text("Name", color = AppTheme.SubtleTextColor) },
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            cursorColor = config.iconColor,
                            focusedBorderColor = config.iconColor,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.15f)
                        )
                    )

                    // Category dropdown
                    if (config.categories.isNotEmpty()) {
                        Text("Category", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        ExposedDropdownMenuBox(
                            expanded = categoryExpanded,
                            onExpandedChange = { categoryExpanded = it }
                        ) {
                            OutlinedTextField(
                                value = newCategory ?: "Select...",
                                onValueChange = {},
                                readOnly = true,
                                singleLine = true,
                                modifier = Modifier.fillMaxWidth().menuAnchor(),
                                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = categoryExpanded) },
                                colors = OutlinedTextFieldDefaults.colors(
                                    focusedTextColor = Color.White,
                                    unfocusedTextColor = if (newCategory != null) Color.White else AppTheme.SubtleTextColor,
                                    cursorColor = config.iconColor,
                                    focusedBorderColor = config.iconColor,
                                    unfocusedBorderColor = Color.White.copy(alpha = 0.15f)
                                )
                            )
                            ExposedDropdownMenu(
                                expanded = categoryExpanded,
                                onDismissRequest = { categoryExpanded = false },
                                modifier = Modifier.background(Color(0xFF2A0C3C))
                            ) {
                                config.categories.forEach { cat ->
                                    DropdownMenuItem(
                                        text = { Text(cat, color = Color.White) },
                                        onClick = { newCategory = cat; categoryExpanded = false },
                                        colors = MenuDefaults.itemColors(
                                            textColor = Color.White
                                        ),
                                        modifier = if (newCategory == cat) Modifier.background(config.iconColor.copy(alpha = 0.15f)) else Modifier
                                    )
                                }
                            }
                        }
                    }

                    // Prediction value
                    if (config.showPrediction) {
                        Text("Prediction value", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Row(horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                            PredictionValue.entries.forEach { pv ->
                                PredictionChip(
                                    value = pv,
                                    isSelected = newPrediction == pv,
                                    onClick = { newPrediction = pv }
                                )
                            }
                        }
                    }

                    // ── Icon picker (only shown when pickerIcons is provided) ──
                    if (config.pickerIcons.isNotEmpty()) {
                        Text("Pick an icon", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        FlowRow(
                            horizontalArrangement = Arrangement.spacedBy(8.dp),
                            verticalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            config.pickerIcons.forEach { picker ->
                                val isChosen = newIconKey == picker.key
                                Box(
                                    modifier = Modifier
                                        .size(42.dp)
                                        .clip(CircleShape)
                                        .background(
                                            if (isChosen) config.iconColor.copy(alpha = 0.40f)
                                            else Color.White.copy(alpha = 0.08f)
                                        )
                                        .border(
                                            1.5.dp,
                                            if (isChosen) config.iconColor.copy(alpha = 0.7f)
                                            else Color.White.copy(alpha = 0.12f),
                                            CircleShape
                                        )
                                        .clickable { newIconKey = if (isChosen) null else picker.key },
                                    contentAlignment = Alignment.Center
                                ) {
                                    Icon(
                                        picker.icon, contentDescription = picker.label,
                                        tint = if (isChosen) Color.White else AppTheme.SubtleTextColor,
                                        modifier = Modifier.size(22.dp)
                                    )
                                }
                            }
                        }
                    }
                }
            },
            confirmButton = {
                TextButton(
                    onClick = {
                        if (newLabel.isNotBlank()) {
                            config.onAdd(newLabel.trim(), newCategory, newPrediction)
                            showAddDialog = false
                        }
                    },
                    enabled = newLabel.isNotBlank()
                ) { Text("Add", color = if (newLabel.isNotBlank()) config.iconColor else AppTheme.SubtleTextColor) }
            },
            dismissButton = {
                TextButton(onClick = { showAddDialog = false }) { Text("Cancel", color = AppTheme.SubtleTextColor) }
            }
        )
    }

    // ── Delete dialog ──
    showDeleteDialog?.let { item ->
        AlertDialog(
            onDismissRequest = { showDeleteDialog = null },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            title = { Text("Remove \"${item.label}\"?") },
            text = { Text("This will remove it from your pool. Past logged entries won't be affected.") },
            confirmButton = {
                TextButton(onClick = { config.onDelete(item.id); showDeleteDialog = null }) { Text("Delete", color = AppTheme.AccentPink) }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = null }) { Text("Cancel", color = AppTheme.SubtleTextColor) }
            }
        )
    }
}

/* ────────────────────────────────────────────────
 *  Prediction chip
 * ──────────────────────────────────────────────── */

@Composable
private fun PredictionChip(
    value: PredictionValue,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    val bg = if (isSelected) value.chipColor.copy(alpha = 0.25f) else Color.White.copy(alpha = 0.06f)
    val border = if (isSelected) value.chipColor.copy(alpha = 0.6f) else Color.White.copy(alpha = 0.10f)
    val textColor = if (isSelected) value.chipColor else AppTheme.SubtleTextColor

    Box(
        modifier = Modifier
            .clip(RoundedCornerShape(20.dp))
            .background(bg)
            .border(1.dp, border, RoundedCornerShape(20.dp))
            .clickable(onClick = onClick)
            .padding(horizontal = 12.dp, vertical = 5.dp)
    ) {
        Text(value.display, color = textColor, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
    }
}

/* ────────────────────────────────────────────────
 *  Pool item row
 * ──────────────────────────────────────────────── */

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun PoolItemRow(
    item: PoolItem,
    config: PoolConfig,
    showDeleteDialog: (PoolItem) -> Unit,
    indent: Dp = 0.dp
) {
    var expanded by remember { mutableStateOf(false) }

    Column(modifier = Modifier.padding(start = indent)) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .clickable { expanded = !expanded }
                .padding(vertical = 6.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            // Icon circle
            val icon = config.iconResolver?.invoke(item.iconKey)
            Box(
                modifier = Modifier
                    .size(34.dp)
                    .clip(CircleShape)
                    .background(Color.White.copy(alpha = 0.07f))
                    .border(1.dp, Color.White.copy(alpha = 0.10f), CircleShape),
                contentAlignment = Alignment.Center
            ) {
                if (icon != null) {
                    Icon(icon, item.label, tint = config.iconColor.copy(alpha = 0.8f), modifier = Modifier.size(18.dp))
                } else {
                    Text(item.label.take(2).uppercase(), color = config.iconColor.copy(alpha = 0.8f),
                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold))
                }
            }

            // Label
            Text(item.label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium, modifier = Modifier.weight(1f))

            // Prediction badge
            if (config.showPrediction && item.prediction != PredictionValue.NONE) {
                Box(
                    modifier = Modifier
                        .clip(RoundedCornerShape(12.dp))
                        .background(item.prediction.chipColor.copy(alpha = 0.20f))
                        .padding(horizontal = 8.dp, vertical = 2.dp)
                ) {
                    Text(item.prediction.display, color = item.prediction.chipColor, style = MaterialTheme.typography.labelSmall)
                }
            }

            // Favorite star
            IconButton(onClick = { config.onToggleFavorite(item.id, !item.isFavorite) }, modifier = Modifier.size(28.dp)) {
                Icon(
                    if (item.isFavorite) Icons.Outlined.Star else Icons.Outlined.StarBorder,
                    contentDescription = if (item.isFavorite) "Unstar" else "Star",
                    tint = if (item.isFavorite) Color(0xFFFDD835) else AppTheme.SubtleTextColor.copy(alpha = 0.4f),
                    modifier = Modifier.size(18.dp)
                )
            }

            // Delete
            IconButton(onClick = { showDeleteDialog(item) }, modifier = Modifier.size(28.dp)) {
                Icon(Icons.Outlined.Delete, "Delete", tint = AppTheme.SubtleTextColor.copy(alpha = 0.4f), modifier = Modifier.size(18.dp))
            }
        }

        // ── Expanded detail section ──
        AnimatedVisibility(visible = expanded) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(start = 42.dp, bottom = 8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                // Prediction chips
                if (config.showPrediction) {
                    Text("Prediction", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    Row(horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                        PredictionValue.entries.forEach { pv ->
                            PredictionChip(value = pv, isSelected = item.prediction == pv, onClick = { config.onSetPrediction(item.id, pv) })
                        }
                    }
                }

                // Category selector
                if (config.categories.isNotEmpty()) {
                    Text("Category", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    var catExpanded by remember { mutableStateOf(false) }
                    ExposedDropdownMenuBox(expanded = catExpanded, onExpandedChange = { catExpanded = it }) {
                        OutlinedTextField(
                            value = item.category ?: "None",
                            onValueChange = {},
                            readOnly = true,
                            singleLine = true,
                            modifier = Modifier.fillMaxWidth().menuAnchor(),
                            textStyle = MaterialTheme.typography.bodySmall,
                            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = catExpanded) },
                            colors = OutlinedTextFieldDefaults.colors(
                                focusedTextColor = Color.White, unfocusedTextColor = Color.White,
                                focusedBorderColor = config.iconColor, unfocusedBorderColor = Color.White.copy(alpha = 0.12f)
                            )
                        )
                        ExposedDropdownMenu(expanded = catExpanded, onDismissRequest = { catExpanded = false }, modifier = Modifier.background(Color(0xFF2A0C3C))) {
                            config.categories.forEach { cat ->
                                DropdownMenuItem(
                                    text = { Text(cat, color = Color.White, style = MaterialTheme.typography.bodySmall) },
                                    onClick = { config.onSetCategory(item.id, cat); catExpanded = false },
                                    modifier = if (item.category == cat) Modifier.background(config.iconColor.copy(alpha = 0.15f)) else Modifier
                                )
                            }
                        }
                    }
                }

                // Automation toggle
                if (item.isAutomatable) {
                    Row(
                        Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Auto-detect", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                        Switch(
                            checked = item.isAutomated,
                            onCheckedChange = { config.onToggleAutomation(item.id, it) },
                            colors = SwitchDefaults.colors(
                                checkedThumbColor = config.iconColor,
                                checkedTrackColor = config.iconColor.copy(alpha = 0.3f),
                                uncheckedThumbColor = AppTheme.SubtleTextColor,
                                uncheckedTrackColor = Color.White.copy(alpha = 0.08f)
                            )
                        )
                    }

                    // Threshold editor
                    if (item.isAutomated && item.direction != null) {
                        val currentThreshold = item.threshold ?: item.defaultThreshold
                        val dimAlpha = if (currentThreshold != null) 1f else 0.4f
                        var textValue by remember(currentThreshold) {
                            mutableStateOf(currentThreshold?.let { formatThresholdForDisplay(it, item.unit) } ?: "")
                        }

                        Row(
                            Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                if (item.direction == "high") "Fires above" else "Fires below",
                                color = AppTheme.SubtleTextColor.copy(alpha = dimAlpha),
                                style = MaterialTheme.typography.labelSmall
                            )
                            Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                                OutlinedTextField(
                                    value = textValue, onValueChange = { newText -> textValue = newText; newText.toDoubleOrNull()?.let { config.onThresholdChange(item.id, it) } },
                                    singleLine = true,
                                    modifier = Modifier.width(80.dp),
                                    textStyle = MaterialTheme.typography.bodySmall.copy(color = Color.White, textAlign = TextAlign.End),
                                    keyboardOptions = KeyboardOptions(keyboardType = androidx.compose.ui.text.input.KeyboardType.Decimal),
                                    colors = OutlinedTextFieldDefaults.colors(
                                        focusedBorderColor = config.iconColor, unfocusedBorderColor = Color.White.copy(alpha = 0.12f),
                                        cursorColor = config.iconColor
                                    )
                                )
                                Text(when (item.unit) { "hours" -> "h"; "%" -> "%"; "count" -> ""; "time" -> ""; else -> item.unit ?: "" },
                                    color = AppTheme.SubtleTextColor.copy(alpha = dimAlpha), style = MaterialTheme.typography.labelSmall)
                            }
                        }
                    }
                }
            }
        }
    }
}

private fun formatThresholdForDisplay(value: Double, unit: String?): String {
    return when (unit) {
        "hours" -> String.format("%.1f", value)
        "%" -> String.format("%.0f", value)
        "count" -> String.format("%.0f", value)
        "time" -> {
            val h = value.toInt()
            String.format("%d:%02d", h, 0)
        }
        else -> String.format("%.1f", value)
    }
}

title: ManageSymptomsScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.ui.draw.clip
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Add
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Delete
import androidx.compose.material.icons.outlined.Psychology
import androidx.compose.material.icons.outlined.Star
import androidx.compose.material.icons.outlined.StarBorder
import androidx.compose.material3.AssistChip
import androidx.compose.material3.AssistChipDefaults
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.AlertDialog
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun ManageSymptomsScreen(
    navController: NavController,
    vm: SymptomViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val painCharacter by vm.painCharacter.collectAsState()
    val accompanying by vm.accompanying.collectAsState()
    val favorites by vm.favorites.collectAsState()
    val favoriteIds by vm.favoriteIds.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    // Add dialog
    var showAddDialog by remember { mutableStateOf(false) }
    var addCategory by remember { mutableStateOf("pain_character") }
    var addSubCategory by remember { mutableStateOf("pain_character") }
    var addLabel by remember { mutableStateOf("") }
    var addIconKey by remember { mutableStateOf<String?>(null) }

    if (showAddDialog) {
        AlertDialog(
            onDismissRequest = { showAddDialog = false; addLabel = ""; addIconKey = null; addSubCategory = addCategory },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            confirmButton = {
                TextButton(
                    onClick = {
                        val token = authState.accessToken ?: return@TextButton
                        if (addLabel.isNotBlank()) {
                            vm.addNewToPool(token, addLabel.trim(), addSubCategory, addIconKey)
                            addLabel = ""
                            addIconKey = null
                            showAddDialog = false
                        }
                    },
                    enabled = addLabel.isNotBlank()
                ) { Text("Add", color = if (addLabel.isNotBlank()) AppTheme.AccentPurple else AppTheme.SubtleTextColor) }
            },
            dismissButton = {
                TextButton(onClick = { showAddDialog = false; addLabel = ""; addIconKey = null }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            title = { Text(if (addCategory == "pain_character") "Add Pain Character" else "Add Accompanying Experience") },
            text = {
                Column {
                    OutlinedTextField(
                        value = addLabel,
                        onValueChange = { addLabel = it },
                        label = { Text("Symptom name") },
                        singleLine = true,
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            cursorColor = AppTheme.AccentPurple,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.2f),
                            focusedLabelColor = AppTheme.AccentPurple,
                            unfocusedLabelColor = AppTheme.SubtleTextColor
                        )
                    )
                    Spacer(Modifier.height(12.dp))
                    Text("Category", style = MaterialTheme.typography.bodySmall, color = AppTheme.SubtleTextColor)
                    Spacer(Modifier.height(6.dp))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(6.dp), verticalArrangement = Arrangement.spacedBy(6.dp)) {
                        val categories = if (addCategory == "pain_character")
                            listOf("pain_character")
                        else
                            listOf("accompanying", "Cognitive", "Digestive", "Emotional", "Motor", "Sensory", "Visual", "Other")
                        categories.forEach { cat ->
                            val displayName = when (cat) {
                                "pain_character" -> "Pain character"
                                "accompanying" -> "Accompanying"
                                else -> cat
                            }
                            val selected = addSubCategory == cat
                            AssistChip(
                                onClick = { addSubCategory = cat },
                                label = { Text(displayName, style = MaterialTheme.typography.labelSmall) },
                                colors = AssistChipDefaults.assistChipColors(
                                    containerColor = if (selected) AppTheme.AccentPurple.copy(alpha = 0.3f) else Color.White.copy(alpha = 0.06f),
                                    labelColor = if (selected) Color.White else AppTheme.SubtleTextColor
                                ),
                                border = AssistChipDefaults.assistChipBorder(
                                    enabled = true,
                                    borderColor = if (selected) AppTheme.AccentPurple.copy(alpha = 0.6f) else Color.White.copy(alpha = 0.12f)
                                )
                            )
                        }
                    }
                    Spacer(Modifier.height(16.dp))
                    Text("Pick an icon", style = MaterialTheme.typography.bodySmall, color = AppTheme.SubtleTextColor)
                    Spacer(Modifier.height(10.dp))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(8.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                        SymptomIcons.PICKER_ICONS.forEach { picker ->
                            val isChosen = addIconKey == picker.key
                            Box(
                                modifier = Modifier
                                    .size(42.dp)
                                    .clip(CircleShape)
                                    .background(
                                        if (isChosen) AppTheme.AccentPurple.copy(alpha = 0.40f)
                                        else Color.White.copy(alpha = 0.08f)
                                    )
                                    .border(
                                        1.5.dp,
                                        if (isChosen) AppTheme.AccentPurple.copy(alpha = 0.7f)
                                        else Color.White.copy(alpha = 0.12f),
                                        CircleShape
                                    )
                                    .clickable { addIconKey = if (isChosen) null else picker.key },
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(
                                    picker.icon, contentDescription = picker.label,
                                    tint = if (isChosen) Color.White else AppTheme.SubtleTextColor,
                                    modifier = Modifier.size(22.dp)
                                )
                            }
                        }
                    }
                }
            }
        )
    }

    // Delete confirmation
    var showDeleteDialog by remember { mutableStateOf(false) }
    var deleteTarget by remember { mutableStateOf<SupabaseDbService.UserSymptomRow?>(null) }

    if (showDeleteDialog && deleteTarget != null) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            confirmButton = {
                TextButton(onClick = {
                    val token = authState.accessToken ?: return@TextButton
                    vm.removeFromPool(token, deleteTarget!!.id)
                    showDeleteDialog = false; deleteTarget = null
                }) { Text("Delete", color = AppTheme.AccentPink) }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            title = { Text("Remove symptom?") },
            text = { Text("Remove \"${deleteTarget?.label}\"? This can't be undone.") }
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Close bar
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Text("Manage Symptoms", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Icon(Icons.Outlined.Psychology, contentDescription = null, tint = AppTheme.AccentPink, modifier = Modifier.size(40.dp))
                Text("Symptoms", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    "Add, remove, or star frequent symptoms",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // Pain Character section
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Pain character", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    IconButton(onClick = { addCategory = "pain_character"; addSubCategory = "pain_character"; showAddDialog = true }) {
                        Icon(Icons.Outlined.Add, contentDescription = "Add", tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
                    }
                }
                if (painCharacter.isEmpty()) {
                    Text("No symptoms yet", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                } else {
                    painCharacter.forEach { symptom ->
                        val isFav = symptom.id in favoriteIds
                        val prefId = favorites.find { it.symptomId == symptom.id }?.id
                        SymptomRow(
                            label = symptom.label,
                            iconKey = symptom.iconKey,
                            isFavorite = isFav,
                            onToggleFavorite = {
                                val token = authState.accessToken ?: return@SymptomRow
                                if (isFav && prefId != null) vm.removeFromFavorites(token, prefId)
                                else vm.addToFavorites(token, symptom.id)
                            },
                            onDelete = { deleteTarget = symptom; showDeleteDialog = true }
                        )
                    }
                }
            }

            // Accompanying Experience section
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Accompanying experience", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    IconButton(onClick = { addCategory = "accompanying"; addSubCategory = "accompanying"; showAddDialog = true }) {
                        Icon(Icons.Outlined.Add, contentDescription = "Add", tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
                    }
                }
                if (accompanying.isEmpty()) {
                    Text("No symptoms yet", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                } else {
                    val grouped = accompanying.groupBy { it.category ?: "Other" }.toSortedMap()
                    grouped.forEach { (cat, symptoms) ->
                        val displayCat = when (cat) {
                            "accompanying" -> "General"
                            else -> cat
                        }
                        Text(displayCat, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold), modifier = Modifier.padding(top = 8.dp))
                        symptoms.forEach { symptom ->
                            val isFav = symptom.id in favoriteIds
                            val prefId = favorites.find { it.symptomId == symptom.id }?.id
                            SymptomRow(
                                label = symptom.label,
                                iconKey = symptom.iconKey,
                                isFavorite = isFav,
                                onToggleFavorite = {
                                    val token = authState.accessToken ?: return@SymptomRow
                                    if (isFav && prefId != null) vm.removeFromFavorites(token, prefId)
                                    else vm.addToFavorites(token, symptom.id)
                                },
                                onDelete = { deleteTarget = symptom; showDeleteDialog = true }
                            )
                        }
                    }
                }
            }

            // Back
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun SymptomRow(
    label: String,
    iconKey: String? = null,
    isFavorite: Boolean,
    onToggleFavorite: () -> Unit,
    onDelete: () -> Unit
) {
    val icon = SymptomIcons.forLabel(label, iconKey)
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.spacedBy(10.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Round icon circle
        Box(
            modifier = Modifier
                .size(38.dp)
                .clip(CircleShape)
                .background(Color.White.copy(alpha = 0.08f))
                .border(1.dp, Color.White.copy(alpha = 0.12f), CircleShape),
            contentAlignment = Alignment.Center
        ) {
            if (icon != null) {
                Icon(icon, contentDescription = null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(20.dp))
            } else {
                Text(
                    label.take(2).uppercase(),
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        // Label
        Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium, modifier = Modifier.weight(1f))
        // Star
        IconButton(onClick = onToggleFavorite, modifier = Modifier.size(32.dp)) {
            Icon(
                if (isFavorite) Icons.Outlined.Star else Icons.Outlined.StarBorder,
                contentDescription = if (isFavorite) "Remove from frequent" else "Add to frequent",
                tint = if (isFavorite) Color(0xFFFFD54F) else AppTheme.SubtleTextColor,
                modifier = Modifier.size(18.dp)
            )
        }
        // Delete
        IconButton(onClick = onDelete, modifier = Modifier.size(32.dp)) {
            Icon(Icons.Outlined.Delete, contentDescription = "Delete", tint = AppTheme.AccentPink.copy(alpha = 0.7f), modifier = Modifier.size(18.dp))
        }
    }
}


title: MedicineIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

/**
 * Medicine icons for MigraineMe — one per category.
 * Style: 24dp viewport, 2dp stroke, rounded caps/joins, no fill.
 * Categories: Analgesic, Anti-Nausea, CGRP, Preventive, Supplement, Triptan, Other
 */
object MedicineIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    /** analgesic — pill tablet with cross */
    val Analgesic: ImageVector by lazy {
        ImageVector.Builder("Analgesic", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Rounded pill shape
                moveTo(7f, 4f); lineTo(17f, 4f)
                curveTo(19f, 4f, 20f, 5f, 20f, 7f)
                lineTo(20f, 17f)
                curveTo(20f, 19f, 19f, 20f, 17f, 20f)
                lineTo(7f, 20f)
                curveTo(5f, 20f, 4f, 19f, 4f, 17f)
                lineTo(4f, 7f)
                curveTo(4f, 5f, 5f, 4f, 7f, 4f)
            }
            // Cross
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 9f); lineTo(12f, 15f)
                moveTo(9f, 12f); lineTo(15f, 12f)
            }
        }.build()
    }

    /** anti_nausea — stomach with calm wave */
    val AntiNausea: ImageVector by lazy {
        ImageVector.Builder("AntiNausea", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Stomach shape
                moveTo(8f, 4f)
                curveTo(12f, 4f, 16f, 4f, 17f, 7f)
                curveTo(18f, 10f, 18f, 14f, 16f, 16f)
                curveTo(14f, 18f, 11f, 18f, 9f, 20f)
                moveTo(8f, 4f)
                curveTo(6f, 4f, 5f, 6f, 5f, 8f)
                curveTo(5f, 10f, 6f, 11f, 8f, 11f)
            }
            // Calm wave inside
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(9f, 13f)
                curveTo(10f, 11.5f, 11f, 14.5f, 12f, 13f)
                curveTo(13f, 11.5f, 14f, 14.5f, 15f, 13f)
            }
        }.build()
    }

    /** cgrp — antibody / Y-shape molecule */
    val Cgrp: ImageVector by lazy {
        ImageVector.Builder("Cgrp", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Y-shape antibody
                moveTo(12f, 22f); lineTo(12f, 12f)
                moveTo(12f, 12f); lineTo(6f, 4f)
                moveTo(12f, 12f); lineTo(18f, 4f)
            }
            // Binding tips
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 3f); lineTo(8f, 5f)
                moveTo(20f, 3f); lineTo(16f, 5f)
            }
            // Base dot
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 22f); lineTo(12.1f, 22f)
            }
        }.build()
    }

    /** preventive — shield with check */
    val Preventive: ImageVector by lazy {
        ImageVector.Builder("Preventive", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Shield
                moveTo(12f, 2f)
                lineTo(20f, 6f)
                lineTo(20f, 12f)
                curveTo(20f, 17f, 16f, 20f, 12f, 22f)
                curveTo(8f, 20f, 4f, 17f, 4f, 12f)
                lineTo(4f, 6f)
                close()
            }
            // Checkmark
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(8f, 12f); lineTo(11f, 15f); lineTo(16f, 9f)
            }
        }.build()
    }

    /** supplement — leaf / natural */
    val Supplement: ImageVector by lazy {
        ImageVector.Builder("Supplement", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Leaf shape
                moveTo(12f, 22f)
                curveTo(12f, 22f, 4f, 16f, 4f, 10f)
                curveTo(4f, 4f, 12f, 2f, 12f, 2f)
                curveTo(12f, 2f, 20f, 4f, 20f, 10f)
                curveTo(20f, 16f, 12f, 22f, 12f, 22f)
            }
            // Center vein
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 6f); lineTo(12f, 18f)
            }
            // Side veins
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 10f); lineTo(12f, 12f)
                moveTo(16f, 10f); lineTo(12f, 12f)
            }
        }.build()
    }

    /** triptan — lightning bolt (fast acting) */
    val Triptan: ImageVector by lazy {
        ImageVector.Builder("Triptan", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(13f, 2f)
                lineTo(6f, 13f)
                lineTo(12f, 13f)
                lineTo(11f, 22f)
                lineTo(18f, 11f)
                lineTo(12f, 11f)
                close()
            }
        }.build()
    }

    /** other — generic capsule */
    val Other: ImageVector by lazy {
        ImageVector.Builder("Other", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Capsule outline
                moveTo(9f, 2f)
                curveTo(6f, 2f, 4f, 4f, 4f, 7f)
                lineTo(4f, 17f)
                curveTo(4f, 20f, 6f, 22f, 9f, 22f)
                lineTo(15f, 22f)
                curveTo(18f, 22f, 20f, 20f, 20f, 17f)
                lineTo(20f, 7f)
                curveTo(20f, 4f, 18f, 2f, 15f, 2f)
                close()
            }
            // Divider line
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(4f, 12f); lineTo(20f, 12f)
            }
        }.build()
    }

    // ─── LOOKUP ────────────────────────────────────────────────

    data class MedicinePickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<MedicinePickerIcon> by lazy { listOf(
        MedicinePickerIcon("Analgesic", "Analgesic", Analgesic),
        MedicinePickerIcon("Anti-Nausea", "Anti-Nausea", AntiNausea),
        MedicinePickerIcon("CGRP", "CGRP", Cgrp),
        MedicinePickerIcon("Preventive", "Preventive", Preventive),
        MedicinePickerIcon("Supplement", "Supplement", Supplement),
        MedicinePickerIcon("Triptan", "Triptan", Triptan),
        MedicinePickerIcon("Other", "Other", Other),
    ) }

    /** Look up icon by category name */
    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: MedicinesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/* ────────────────────────────────────────────────
 *  Relief scale enum (mirrors DB CHECK constraint)
 * ──────────────────────────────────────────────── */

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun MedicinesScreen(
    navController: NavController,
    vm: MedicineViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {},
    quickLogMode: Boolean = false,
    onSave: (() -> Unit)? = null,
    linkedMigraineId: String? = null,
    onMigraineSelect: ((String?) -> Unit)? = null
) {
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    // ── Rebuild helpers ──
    fun rebuildDraftWithMeds(meds: List<MedicineDraft>) {
        logVm.replaceMedicines(meds)
    }

    // ── Add dialog state ──
    var showAddDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }

    // ── Edit dialog state ──
    var showEditDialog by remember { mutableStateOf(false) }
    var editIndex by remember { mutableStateOf<Int?>(null) }

    fun onMedicineTap(label: String) {
        val existingIdx = draft.meds.indexOfFirst { it.name == label }
        if (existingIdx >= 0) {
            // Deselect
            val updated = draft.meds.toMutableList().apply { removeAt(existingIdx) }
            rebuildDraftWithMeds(updated)
        } else {
            pendingLabel = label
            showAddDialog = true
        }
    }

    // Add dialog
    if (showAddDialog && pendingLabel != null) {
        MedicineAddDialog(
            title = pendingLabel!!,
            onDismiss = { showAddDialog = false },
            onSkip = {
                val updated = draft.meds + MedicineDraft(name = pendingLabel!!, startAtIso = null, reliefScale = "NONE")
                rebuildDraftWithMeds(updated)
                showAddDialog = false
            },
            onConfirm = { amount, iso, relief ->
                val updated = draft.meds + MedicineDraft(name = pendingLabel!!, amount = amount.ifBlank { null }, startAtIso = iso, reliefScale = relief)
                rebuildDraftWithMeds(updated)
                showAddDialog = false
            }
        )
    }

    // Edit dialog
    if (showEditDialog && editIndex != null && editIndex!! in draft.meds.indices) {
        val editing = draft.meds[editIndex!!]
        MedicineEditDialog(
            title = editing.name ?: "",
            initialAmount = editing.amount ?: "",
            initialIso = editing.startAtIso,
            initialRelief = editing.reliefScale ?: "NONE",
            onDismiss = { showEditDialog = false },
            onConfirm = { amount, iso, relief ->
                val updated = draft.meds.toMutableList().apply {
                    set(editIndex!!, editing.copy(amount = amount.ifBlank { null }, startAtIso = iso, reliefScale = relief))
                }
                rebuildDraftWithMeds(updated)
                showEditDialog = false
            }
        )
    }

    // Frequent labels
    val frequentLabels = remember(frequent) { frequent.mapNotNull { it.medicine?.label }.toSet() }
    val selectedLabels = remember(draft.meds) { draft.meds.mapNotNull { it.name }.toSet() }

    // Group pool by category
    val grouped = remember(pool) {
        pool.groupBy { it.category ?: "Other" }.toSortedMap()
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                if (!quickLogMode) {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                        Spacer(Modifier.width(4.dp))
                        Text("Triggers", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                    }
                } else {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    }
                }
                Text("Medicines", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                if (!quickLogMode) {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                    }
                } else {
                    Spacer(Modifier.size(28.dp))
                }
            }

            // ── HeroCard: icon + title + subtitle + selected list ──
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawMedicinePill(Color(0xFF4FC3F7)) } }
                )
                Text("Medicines", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.meds.isEmpty()) "Add medicines you've taken"
                    else "${draft.meds.size} medicine${if (draft.meds.size > 1) "s" else ""} added",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
                if (draft.meds.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.meds.forEachIndexed { index, m ->
                        val relief = ReliefScale.fromString(m.reliefScale)
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 3.dp)
                                .clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f))
                                .padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    m.name ?: "",
                                    color = AppTheme.BodyTextColor,
                                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
                                )
                                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                    Text(
                                        if (m.startAtIso == null) "Same as migraine start"
                                        else formatMedTime(m.startAtIso),
                                        color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                        style = MaterialTheme.typography.labelSmall
                                    )
                                    if (!m.amount.isNullOrBlank()) {
                                        Text(
                                            "• ${m.amount}",
                                            color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                            style = MaterialTheme.typography.labelSmall
                                        )
                                    }
                                }
                                // Relief scale chip
                                Text(
                                    "Relief: ${relief.display}",
                                    color = relief.color,
                                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold)
                                )
                            }
                            Icon(
                                Icons.Outlined.Edit,
                                contentDescription = "Edit",
                                tint = AppTheme.AccentPurple.copy(alpha = 0.7f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        editIndex = index
                                        showEditDialog = true
                                    }
                            )
                            Spacer(Modifier.width(8.dp))
                            Icon(
                                Icons.Outlined.Close,
                                contentDescription = "Remove",
                                tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        val updated = draft.meds.toMutableList().apply { removeAt(index) }
                                        rebuildDraftWithMeds(updated)
                                    }
                            )
                        }
                    }
                }
            }

            // Manage card (own card)
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Medicines", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_MEDICINES) })
                }
            }

            if (quickLogMode && onMigraineSelect != null) {
                val firstIso = draft.meds.firstOrNull()?.startAtIso
                MigrainePickerCard(itemStartAtIso = firstIso, authVm = authVm, selectedMigraineId = linkedMigraineId, onSelect = onMigraineSelect)
            }

            // ── Single medicines card: Frequent → divider → categories ──
            BaseCard {
                // Frequent section
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { med ->
                            MedicineButton(med.label, med.label in selectedLabels) {
                                onMedicineTap(med.label)
                            }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }

                // Category sections with dividers
                val categoryEntries = grouped.entries.toList()
                categoryEntries.forEachIndexed { catIndex, (category, items) ->
                    val nonFreqItems = items.filter { it.label !in frequentLabels }
                    if (nonFreqItems.isNotEmpty()) {
                        Text(category, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreqItems.forEach { med ->
                                MedicineButton(med.label, med.label in selectedLabels) {
                                    onMedicineTap(med.label)
                                }
                            }
                        }
                        val hasMore = categoryEntries.drop(catIndex + 1).any { (_, its) -> its.any { it.label !in frequentLabels } }
                        if (hasMore) {
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                        }
                    }
                }

                if (pool.isEmpty()) {
                    Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // Navigation
            Row(
                Modifier.fillMaxWidth().padding(vertical = 8.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Cancel" else "Back") }
                Button(
                    onClick = { if (quickLogMode) onSave?.invoke() else navController.navigate(Routes.RELIEFS) },
                    enabled = !quickLogMode || draft.meds.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Save" else "Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

/* ────────────────────────────────────────────────
 *  Add dialog: amount + time + relief scale
 * ──────────────────────────────────────────────── */

@Composable
private fun MedicineAddDialog(
    title: String,
    onDismiss: () -> Unit,
    onSkip: () -> Unit,
    onConfirm: (amount: String, iso: String?, relief: String) -> Unit
) {
    var amount by remember { mutableStateOf("") }
    var pickedIso by remember { mutableStateOf<String?>(null) }
    var selectedRelief by remember { mutableStateOf(ReliefScale.NONE) }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                // Amount
                OutlinedTextField(
                    value = amount,
                    onValueChange = { amount = it },
                    label = { Text("Amount (e.g. 50mg, 2 tablets)") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = AppTheme.AccentPurple,
                        unfocusedBorderColor = Color.White.copy(alpha = 0.2f),
                        focusedLabelColor = AppTheme.AccentPurple,
                        unfocusedLabelColor = AppTheme.SubtleTextColor,
                        cursorColor = Color.White,
                        focusedTextColor = Color.White,
                        unfocusedTextColor = Color.White
                    )
                )

                // Time
                Text("When did you take it?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Text("Time: ${formatMedTime(pickedIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select time", onDateTimeSelected = { iso -> pickedIso = iso })

                // Relief scale
                Text("How much relief?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    ReliefScale.entries.forEach { scale ->
                        FilterChip(
                            selected = selectedRelief == scale,
                            onClick = { selectedRelief = scale },
                            label = { Text(scale.display, style = MaterialTheme.typography.labelSmall) },
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = scale.color.copy(alpha = 0.3f),
                                selectedLabelColor = Color.White,
                                containerColor = Color.White.copy(alpha = 0.06f),
                                labelColor = AppTheme.SubtleTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                enabled = true,
                                selected = selectedRelief == scale,
                                borderColor = Color.White.copy(alpha = 0.12f),
                                selectedBorderColor = scale.color.copy(alpha = 0.6f)
                            )
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = { onConfirm(amount.trim(), pickedIso, selectedRelief.name) }) {
                Text("Add", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
                TextButton(onClick = onSkip) {
                    Text("Skip", color = Color(0xFF4FC3F7))
                }
            }
        }
    )
}

/* ────────────────────────────────────────────────
 *  Edit dialog: amount + time + relief scale
 * ──────────────────────────────────────────────── */

@Composable
private fun MedicineEditDialog(
    title: String,
    initialAmount: String,
    initialIso: String?,
    initialRelief: String,
    onDismiss: () -> Unit,
    onConfirm: (amount: String, iso: String?, relief: String) -> Unit
) {
    var amount by remember { mutableStateOf(initialAmount) }
    var pickedIso by remember { mutableStateOf(initialIso) }
    var selectedRelief by remember { mutableStateOf(ReliefScale.fromString(initialRelief)) }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text("Edit $title") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                OutlinedTextField(
                    value = amount,
                    onValueChange = { amount = it },
                    label = { Text("Amount") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = AppTheme.AccentPurple,
                        unfocusedBorderColor = Color.White.copy(alpha = 0.2f),
                        focusedLabelColor = AppTheme.AccentPurple,
                        unfocusedLabelColor = AppTheme.SubtleTextColor,
                        cursorColor = Color.White,
                        focusedTextColor = Color.White,
                        unfocusedTextColor = Color.White
                    )
                )

                Text("Time: ${formatMedTime(pickedIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select time", onDateTimeSelected = { iso -> pickedIso = iso })

                Text("How much relief?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    ReliefScale.entries.forEach { scale ->
                        FilterChip(
                            selected = selectedRelief == scale,
                            onClick = { selectedRelief = scale },
                            label = { Text(scale.display, style = MaterialTheme.typography.labelSmall) },
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = scale.color.copy(alpha = 0.3f),
                                selectedLabelColor = Color.White,
                                containerColor = Color.White.copy(alpha = 0.06f),
                                labelColor = AppTheme.SubtleTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                enabled = true,
                                selected = selectedRelief == scale,
                                borderColor = Color.White.copy(alpha = 0.12f),
                                selectedBorderColor = scale.color.copy(alpha = 0.6f)
                            )
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = { onConfirm(amount.trim(), pickedIso, selectedRelief.name) }) {
                Text("Save", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = AppTheme.SubtleTextColor)
            }
        }
    )
}

/* ────────────────────────────────────────────────
 *  Medicine circle button
 * ──────────────────────────────────────────────── */

@Composable
private fun MedicineButton(label: String, isSelected: Boolean, onClick: () -> Unit) {
    val circleColor = if (isSelected) Color(0xFF4FC3F7).copy(alpha = 0.40f) else Color.White.copy(alpha = 0.08f)
    val borderColor = if (isSelected) Color(0xFF4FC3F7).copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(72.dp)
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            modifier = Modifier
                .size(52.dp)
                .clip(CircleShape)
                .background(circleColor)
                .border(width = 1.5.dp, color = borderColor, shape = CircleShape),
            contentAlignment = Alignment.Center
        ) {
            Text(
                label.take(2).uppercase(),
                color = iconTint,
                style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
            )
        }
        Spacer(Modifier.height(4.dp))
        Text(
            label,
            color = textColor,
            style = MaterialTheme.typography.labelSmall,
            textAlign = TextAlign.Center,
            maxLines = 2,
            modifier = Modifier.fillMaxWidth()
        )
    }
}

/* ────────────────────────────────────────────────
 *  Format helper
 * ──────────────────────────────────────────────── */

private fun formatMedTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime()
            ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull()
            ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}


title: MedicineViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MedicineViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserMedicineRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserMedicineRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.MedicinePrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.MedicinePrefRow>> = _frequent

    private fun sortPrefs(prefs: List<SupabaseDbService.MedicinePrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllMedicinePool(accessToken)
                val prefs = db.getMedicinePrefs(accessToken)
                _pool.value = p
                _frequent.value = sortPrefs(prefs.filter { it.status == "frequent" })
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null) {
        viewModelScope.launch {
            try {
                db.upsertMedicineToPool(accessToken, label.trim(), category)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addNewToPoolAndFrequent(accessToken: String, label: String) {
        viewModelScope.launch {
            try {
                val added = db.upsertMedicineToPool(accessToken, label.trim())
                val pos = _frequent.value.size
                db.insertMedicinePref(accessToken, added.id, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, medicineId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertMedicinePref(accessToken, medicineId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteMedicinePref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, medicineId: String) {
        viewModelScope.launch {
            try {
                db.deleteMedicineFromPool(accessToken, medicineId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun setCategory(accessToken: String, medicineId: String, category: String?) {
        viewModelScope.launch {
            try {
                db.setMedicineCategory(accessToken, medicineId, category)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


title: MenstruationCalculator.kt
text:
package com.migraineme

import java.time.LocalDate
import java.time.temporal.ChronoUnit
import kotlin.math.roundToInt

/**
 * Utilities for menstruation cycle calculations and predictions
 */
object MenstruationCalculator {
    
    /**
     * Calculate weighted average cycle length from last 6 cycles
     * More recent cycles have higher weight
     * 
     * @param periods List of periods (must be sorted by date ascending)
     * @return Weighted average cycle length in days, or 28 if insufficient data
     */
    fun calculateWeightedAverage(periods: List<MenstruationPeriod>): Int {
        if (periods.size < 2) return 28 // Default cycle length
        
        // Take last 6 periods
        val last6 = periods.takeLast(6)
        
        // Calculate cycle lengths (days between period starts)
        val cycleLengths = last6.zipWithNext { current, next ->
            ChronoUnit.DAYS.between(current.startDate, next.startDate).toInt()
        }
        
        if (cycleLengths.isEmpty()) return 28
        
        // Weights: Most recent cycle gets highest weight
        // Example with 5 cycles: weights = [1, 2, 3, 4, 5]
        val weights = (1..cycleLengths.size).toList()
        
        // Calculate weighted average
        val weightedSum = cycleLengths.zip(weights) { length, weight ->
            length * weight
        }.sum()
        
        val totalWeight = weights.sum()
        
        return (weightedSum.toDouble() / totalWeight).roundToInt()
    }
    
    /**
     * Calculate simple average cycle length
     * 
     * @param periods List of periods (must be sorted by date ascending)
     * @return Average cycle length in days, or 28 if insufficient data
     */
    fun calculateSimpleAverage(periods: List<MenstruationPeriod>): Int {
        if (periods.size < 2) return 28
        
        val cycleLengths = periods.zipWithNext { current, next ->
            ChronoUnit.DAYS.between(current.startDate, next.startDate).toInt()
        }
        
        if (cycleLengths.isEmpty()) return 28
        
        return (cycleLengths.average()).roundToInt()
    }
    
    /**
     * Predict next period start date
     * 
     * @param lastPeriodDate Date of last period start
     * @param avgCycleLength Average cycle length in days
     * @return Predicted next period start date
     */
    fun predictNextPeriod(lastPeriodDate: LocalDate, avgCycleLength: Int): LocalDate {
        return lastPeriodDate.plusDays(avgCycleLength.toLong())
    }
    
    /**
     * Predict ovulation date (typically 14 days before next period)
     * 
     * @param nextPeriodDate Predicted next period start date
     * @return Predicted ovulation date
     */
    fun predictOvulation(nextPeriodDate: LocalDate): LocalDate {
        return nextPeriodDate.minusDays(14)
    }
    
    /**
     * Calculate cycle day (which day of cycle user is currently on)
     * 
     * @param lastPeriodDate Date of last period start
     * @param currentDate Today's date
     * @return Cycle day number (1-based)
     */
    fun calculateCycleDay(lastPeriodDate: LocalDate, currentDate: LocalDate): Int {
        val daysSinceStart = ChronoUnit.DAYS.between(lastPeriodDate, currentDate).toInt()
        return daysSinceStart + 1 // Day 1 = first day of period
    }
    
    /**
     * Calculate cycle length between two periods
     * 
     * @param previousPeriod Previous period start date
     * @param currentPeriod Current period start date
     * @return Number of days in cycle
     */
    fun calculateCycleLength(previousPeriod: LocalDate, currentPeriod: LocalDate): Int {
        return ChronoUnit.DAYS.between(previousPeriod, currentPeriod).toInt()
    }
    
    /**
     * Determine if cycle is regular (cycle lengths vary by less than 3 days)
     * 
     * @param periods List of periods
     * @return true if cycle is regular, false otherwise
     */
    fun isRegularCycle(periods: List<MenstruationPeriod>): Boolean {
        if (periods.size < 3) return false
        
        val cycleLengths = periods.zipWithNext { current, next ->
            ChronoUnit.DAYS.between(current.startDate, next.startDate).toInt()
        }
        
        val min = cycleLengths.minOrNull() ?: return false
        val max = cycleLengths.maxOrNull() ?: return false
        
        return (max - min) <= 3 // Regular if variation is 3 days or less
    }
}

/**
 * Simple data class for menstruation period
 */
data class MenstruationPeriod(
    val startDate: LocalDate,
    val endDate: LocalDate? = null
)

title: MenstruationEditDialog.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import java.time.LocalDate

@Composable
fun MenstruationEditDialog(
    currentSettings: MenstruationSettings,
    onConfirm: (lastDate: LocalDate?, avgCycle: Int) -> Unit,
    onDismiss: () -> Unit
) {
    var lastDateInput by remember(currentSettings) {
        mutableStateOf(currentSettings.lastMenstruationDate?.toString() ?: "")
    }
    var avgCycleInput by remember(currentSettings) {
        mutableStateOf(currentSettings.avgCycleLength.toString())
    }
    var errorMessage by remember { mutableStateOf<String?>(null) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Menstruation Settings") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedTextField(
                    value = lastDateInput,
                    onValueChange = {
                        lastDateInput = it
                        errorMessage = null
                    },
                    label = { Text("Last Period Date") },
                    placeholder = { Text("YYYY-MM-DD (e.g., 2026-01-15)") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    isError = errorMessage != null
                )

                OutlinedTextField(
                    value = avgCycleInput,
                    onValueChange = {
                        if (it.all { char -> char.isDigit() } && it.length <= 2) {
                            avgCycleInput = it
                            errorMessage = null
                        }
                    },
                    label = { Text("Average Cycle (days)") },
                    placeholder = { Text("28") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                Text(
                    "Weighted average of last 6 cycles",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                if (errorMessage != null) {
                    Text(
                        errorMessage!!,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    val lastDate = try {
                        if (lastDateInput.isNotBlank()) {
                            LocalDate.parse(lastDateInput)
                        } else {
                            null
                        }
                    } catch (e: Exception) {
                        errorMessage = "Invalid date format. Use YYYY-MM-DD"
                        return@TextButton
                    }

                    val avgCycle = avgCycleInput.toIntOrNull()
                    if (avgCycle == null || avgCycle < 21 || avgCycle > 45) {
                        errorMessage = "Cycle length must be between 21-45 days"
                        return@TextButton
                    }

                    if (lastDate != null && lastDate.isAfter(LocalDate.now())) {
                        errorMessage = "Last period date cannot be in the future"
                        return@TextButton
                    }

                    onConfirm(lastDate, avgCycle)
                }
            ) {
                Text("Save")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}

title: MenstruationOutboxPushWorker.kt
text:
package com.migraineme

import android.content.Context
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneOffset

/**
 * Worker that pushes menstruation periods from local outbox to Supabase
 *
 * Runs every 15 minutes to upload:
 * - New periods
 * - Updated periods
 * - Deleted periods
 *
 * NOTE: Settings update (avg cycle, last date, predicted) is now handled by
 * a database trigger (trigger_update_menstruation_prediction) which fires
 * automatically when a menstruation trigger is inserted. No need to update
 * settings from Android code.
 */
class MenstruationOutboxPushWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private const val TAG = "MenstruationOutboxPush"
        private val REQUIRED_PERMISSIONS = setOf(
            HealthPermission.getReadPermission(MenstruationPeriodRecord::class)
        )
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            android.util.Log.d(TAG, "Starting menstruation push")

            val accessToken = SessionStore.getValidAccessToken(applicationContext)
                ?: return@withContext Result.retry()

            val hc = HealthConnectClient.getOrCreate(applicationContext)
            val granted = hc.permissionController.getGrantedPermissions()

            if (!REQUIRED_PERMISSIONS.all { it in granted }) {
                android.util.Log.e(TAG, "Missing permissions")
                return@withContext Result.failure()
            }

            val db = MenstruationSyncDatabase.get(applicationContext)
            val dao = db.dao()

            val batch = dao.getOutboxBatch(limit = 200)
            if (batch.isEmpty()) {
                dao.markPushRun(System.currentTimeMillis())
                android.util.Log.d(TAG, "Outbox empty, nothing to push")
                return@withContext Result.success()
            }

            val service = SupabaseMenstruationService(applicationContext)

            val upserts = batch.filter { it.operation == "UPSERT" }
            val deletes = batch.filter { it.operation == "DELETE" }

            val succeededIds = mutableListOf<String>()
            val failedIds = mutableListOf<String>()

            // 1) Push UPSERTs
            for (item in upserts) {
                try {
                    val record = hc.readRecord(MenstruationPeriodRecord::class, item.healthConnectId).record
                    val startDate: LocalDate = record.startTime.atZone(ZoneOffset.UTC).toLocalDate()
                    val endDate: LocalDate? = record.endTime?.atZone(ZoneOffset.UTC)?.toLocalDate()

                    service.upsertHealthConnectMenstruationTrigger(
                        accessToken = accessToken,
                        healthConnectId = item.healthConnectId,
                        startDate = startDate,
                        endDate = endDate
                    )
                    succeededIds.add(item.healthConnectId)

                    android.util.Log.d(TAG, "Upserted menstruation trigger: $startDate to $endDate")
                } catch (e: Exception) {
                    failedIds.add(item.healthConnectId)
                    android.util.Log.e(TAG, "Failed UPSERT id=${item.healthConnectId}: ${e.message}", e)
                }
            }

            // 2) Push DELETEs
            if (deletes.isNotEmpty()) {
                val idsToDelete = deletes.map { it.healthConnectId }
                try {
                    service.deleteHealthConnectMenstruationTriggersByIds(
                        accessToken = accessToken,
                        healthConnectIds = idsToDelete
                    )
                    succeededIds.addAll(idsToDelete)
                    android.util.Log.d(TAG, "Deleted ${idsToDelete.size} menstruation trigger(s)")
                } catch (e: Exception) {
                    failedIds.addAll(idsToDelete)
                    android.util.Log.e(TAG, "Failed DELETE batch: ${e.message}", e)
                }
            }

            // NOTE: No need to call updateMenstruationSettings() here anymore.
            // The database trigger (trigger_update_menstruation_prediction) automatically:
            // - Updates menstruation_settings.last_menstruation_date
            // - Recalculates avg_cycle_length (if auto_update_average is ON)
            // - Updates/creates the menstruation_predicted trigger
            // This happens automatically when the INSERT into triggers table completes.

            // 3) Clean up outbox
            if (succeededIds.isNotEmpty()) {
                dao.deleteOutboxByIds(succeededIds.distinct())
            }
            if (failedIds.isNotEmpty()) {
                dao.incrementRetry(failedIds.distinct())
            }

            dao.markPushRun(System.currentTimeMillis())

            android.util.Log.d(TAG, "Push complete - succeeded: ${succeededIds.size}, failed: ${failedIds.size}")

            if (succeededIds.isEmpty() && failedIds.isNotEmpty()) {
                return@withContext Result.retry()
            }

            Result.success()
        } catch (e: Exception) {
            android.util.Log.e(TAG, "Push worker failed: ${e.message}", e)
            Result.retry()
        }
    }
}

title: MenstruationScreen.kt
text:
package com.migraineme

import android.app.DatePickerDialog
import android.widget.Toast
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Switch
import androidx.compose.material3.SwitchDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit

/**
 * Menstruation tracking screen accessible from Monitor or DataSettings.
 * Shows current data and allows editing via expandable form.
 * 
 * When opened from DataSettings toggle (first time setup), will automatically
 * enable the menstruation metric after user saves settings.
 * 
 * Background: purple_sky_bg_menstruation.png (set in MainActivity)
 */
@Composable
fun MenstruationScreen() {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    var loading by remember { mutableStateOf(true) }
    var saving by remember { mutableStateOf(false) }
    var loggingPeriod by remember { mutableStateOf(false) }
    var errorText by remember { mutableStateOf<String?>(null) }
    var settings by remember { mutableStateOf<MenstruationSettings?>(null) }
    var menstruationEnabled by remember { mutableStateOf(false) }

    // Edit mode
    var showEditForm by remember { mutableStateOf(false) }
    
    // Log period dialog
    var showLogPeriodDialog by remember { mutableStateOf(false) }
    var logPeriodDate by remember { mutableStateOf(LocalDate.now().toString()) }

    // Editable fields
    var lastDateText by remember { mutableStateOf("") }
    var avgCycleText by remember { mutableStateOf("28") }
    var autoUpdateAvg by remember { mutableStateOf(true) }
    
    // Refresh trigger
    var refreshTrigger by remember { mutableStateOf(0) }

    // Load settings and check if enabled
    LaunchedEffect(refreshTrigger) {
        loading = true
        errorText = null

        val result = withContext(Dispatchers.IO) {
            runCatching {
                val token = SessionStore.getValidAccessToken(context.applicationContext)
                    ?: return@runCatching Triple<MenstruationSettings?, Boolean, String?>(
                        null,
                        false,
                        "Please sign in to view menstruation settings."
                    )

                val service = SupabaseMenstruationService(context.applicationContext)
                val s = service.getSettings(token)
                
                // Check if menstruation metric is enabled
                val edge = EdgeFunctionsService()
                val metricSettings = edge.getMetricSettings(context.applicationContext)
                val enabled = metricSettings.any { it.metric == "menstruation" && it.enabled }
                
                Triple(s, enabled, null)
            }.getOrElse { e ->
                Triple<MenstruationSettings?, Boolean, String?>(
                    null,
                    false,
                    "Failed to load: ${e.message ?: "Unknown error"}"
                )
            }
        }

        settings = result.first
        menstruationEnabled = result.second
        errorText = result.third

        result.first?.let { s ->
            lastDateText = s.lastMenstruationDate?.toString() ?: ""
            avgCycleText = s.avgCycleLength.toString()
            autoUpdateAvg = s.autoUpdateAverage
        }
        
        // If not enabled and no settings, show edit form for first time setup
        if (!menstruationEnabled && (result.first == null || result.first?.lastMenstruationDate == null)) {
            showEditForm = true
        }

        loading = false
    }

    fun saveSettings() {
        scope.launch {
            saving = true

            val (parsedLast, parsedAvg, validationError) = validateMenstruationInputs(
                lastDateText = lastDateText,
                avgCycleText = avgCycleText
            )

            if (validationError != null) {
                withContext(Dispatchers.Main) {
                    saving = false
                    Toast.makeText(context, validationError, Toast.LENGTH_LONG).show()
                }
                return@launch
            }

            val ok = withContext(Dispatchers.IO) {
                // Just update settings - the toggle in DataSettings handles enable/disable
                MenstruationTrackingHelper.updateSettingsOnly(
                    context = context.applicationContext,
                    lastDate = parsedLast,
                    avgCycle = parsedAvg,
                    autoUpdate = autoUpdateAvg
                )
            }

            withContext(Dispatchers.Main) {
                saving = false
                if (ok) {
                    settings = MenstruationSettings(
                        lastMenstruationDate = parsedLast,
                        avgCycleLength = parsedAvg,
                        autoUpdateAverage = autoUpdateAvg
                    )
                    showEditForm = false
                    Toast.makeText(context, "Settings saved", Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(context, "Failed to save. Please try again.", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    
    fun logPeriod(dateStr: String) {
        scope.launch {
            loggingPeriod = true
            
            val date = try {
                LocalDate.parse(dateStr, DateTimeFormatter.ISO_LOCAL_DATE)
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    loggingPeriod = false
                    Toast.makeText(context, "Invalid date format", Toast.LENGTH_LONG).show()
                }
                return@launch
            }
            
            val ok = withContext(Dispatchers.IO) {
                try {
                    val token = SessionStore.getValidAccessToken(context.applicationContext)
                        ?: return@withContext false
                    
                    // Insert trigger directly - DB trigger handles settings + predicted update
                    val db = SupabaseDbService(
                        BuildConfig.SUPABASE_URL,
                        BuildConfig.SUPABASE_ANON_KEY
                    )
                    
                    db.insertTrigger(
                        accessToken = token,
                        migraineId = null,
                        type = "menstruation",
                        startAt = "${date}T09:00:00Z",
                        notes = "Logged from app"
                    )
                    true
                } catch (e: Exception) {
                    android.util.Log.e("MenstruationScreen", "Failed to log period: ${e.message}", e)
                    false
                }
            }
            
            withContext(Dispatchers.Main) {
                loggingPeriod = false
                showLogPeriodDialog = false
                if (ok) {
                    Toast.makeText(context, "Period logged!", Toast.LENGTH_SHORT).show()
                    // Refresh to show updated data
                    refreshTrigger++
                } else {
                    Toast.makeText(context, "Failed to log period", Toast.LENGTH_LONG).show()
                }
            }
        }
    }

    // Log Period Dialog
    if (showLogPeriodDialog) {
        AlertDialog(
            onDismissRequest = { showLogPeriodDialog = false },
            title = { Text("Log Period") },
            text = {
                Column {
                    Text("When did your period start?")
                    Spacer(Modifier.height(16.dp))
                    MenstruationDatePicker(
                        isoDate = logPeriodDate,
                        enabled = !loggingPeriod,
                        onDateSelected = { logPeriodDate = it },
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            },
            confirmButton = {
                Button(
                    onClick = { logPeriod(logPeriodDate) },
                    enabled = !loggingPeriod
                ) {
                    Text(if (loggingPeriod) "Logging..." else "Log Period")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = { showLogPeriodDialog = false },
                    enabled = !loggingPeriod
                ) {
                    Text("Cancel")
                }
            }
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Main card
            HeroCard {
                Text(
                    "Menstruation Tracking",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold)
                )

                Spacer(Modifier.height(20.dp))

                if (loading) {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 32.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        CircularProgressIndicator(color = AppTheme.AccentPurple)
                    }
                } else if (errorText != null) {
                    Text(
                        errorText!!,
                        color = Color(0xFFFF6B6B),
                        style = MaterialTheme.typography.bodyMedium
                    )
                } else if (!menstruationEnabled || settings?.lastMenstruationDate == null) {
                    // First time setup
                    Text(
                        "Set up cycle tracking",
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodyMedium
                    )
                    Text(
                        "Track your menstrual cycle to identify migraine patterns.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    
                    Spacer(Modifier.height(16.dp))
                    
                    // Show edit form expanded for first time setup
                    EditFormContent(
                        lastDateText = lastDateText,
                        onLastDateChange = { lastDateText = it },
                        avgCycleText = avgCycleText,
                        onAvgCycleChange = { avgCycleText = it },
                        autoUpdateAvg = autoUpdateAvg,
                        onAutoUpdateChange = { autoUpdateAvg = it },
                        saving = saving,
                        showCancel = false,
                        onCancel = {},
                        onSave = { saveSettings() },
                        saveButtonText = "Enable Tracking"
                    )
                } else {
                    val s = settings!!

                    // Current values display
                    CurrentValuesSection(
                        settings = s,
                        onLogPeriod = { 
                            logPeriodDate = LocalDate.now().toString()
                            showLogPeriodDialog = true 
                        }
                    )

                    Spacer(Modifier.height(20.dp))

                    // Configure button
                    OutlinedButton(
                        onClick = { showEditForm = !showEditForm },
                        modifier = Modifier.fillMaxWidth(),
                        shape = RoundedCornerShape(12.dp)
                    ) {
                        Text(
                            if (showEditForm) "Hide Settings" else "Configure Settings",
                            color = Color.White
                        )
                    }

                    // Expandable edit form
                    AnimatedVisibility(
                        visible = showEditForm,
                        enter = expandVertically(),
                        exit = shrinkVertically()
                    ) {
                        Column(modifier = Modifier.padding(top = 20.dp)) {
                            EditFormContent(
                                lastDateText = lastDateText,
                                onLastDateChange = { lastDateText = it },
                                avgCycleText = avgCycleText,
                                onAvgCycleChange = { avgCycleText = it },
                                autoUpdateAvg = autoUpdateAvg,
                                onAutoUpdateChange = { autoUpdateAvg = it },
                                saving = saving,
                                showCancel = true,
                                onCancel = {
                                    // Reset to current values
                                    settings?.let { s ->
                                        lastDateText = s.lastMenstruationDate?.toString() ?: ""
                                        avgCycleText = s.avgCycleLength.toString()
                                        autoUpdateAvg = s.autoUpdateAverage
                                    }
                                    showEditForm = false
                                },
                                onSave = { saveSettings() },
                                saveButtonText = "Save"
                            )
                        }
                    }
                }
            }

            // Info card
            BaseCard {
                Text(
                    "About Cycle Tracking",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(8.dp))
                Text(
                    "Menstrual cycles can affect migraine patterns. Many women experience migraines around their period due to hormonal fluctuations, particularly drops in estrogen.",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
                Spacer(Modifier.height(12.dp))
                Text(
                    "Tracking your cycle helps identify patterns and predict high-risk days for migraines.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

@Composable
private fun CurrentValuesSection(
    settings: MenstruationSettings,
    onLogPeriod: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Last Period
        DataRow(
            label = "Last Period",
            value = settings.lastMenstruationDate?.toString() ?: "Not set"
        )

        // Average Cycle
        DataRow(
            label = "Average Cycle",
            value = "${settings.avgCycleLength} days"
        )

        // Auto-update
        DataRow(
            label = "Auto-update",
            value = if (settings.autoUpdateAverage) "On" else "Off"
        )

        // Next expected (if we have last date)
        settings.lastMenstruationDate?.let { lastDate ->
            val nextExpected = lastDate.plusDays(settings.avgCycleLength.toLong())
            val today = LocalDate.now()
            val daysUntil = ChronoUnit.DAYS.between(today, nextExpected)

            Spacer(Modifier.height(4.dp))
            Divider(color = Color.White.copy(alpha = 0.2f))
            Spacer(Modifier.height(12.dp))

            DataRow(
                label = "Next Expected",
                value = nextExpected.toString()
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = when {
                        daysUntil < 0 -> "${-daysUntil} days ago"
                        daysUntil == 0L -> "Today"
                        daysUntil == 1L -> "Tomorrow"
                        else -> "In $daysUntil days"
                    },
                    color = when {
                        daysUntil in -2..2 -> Color(0xFFFF6B6B) // Red when close
                        daysUntil in 3..7 -> Color(0xFFFFB74D) // Orange when approaching
                        else -> AppTheme.SubtleTextColor
                    },
                    style = MaterialTheme.typography.bodySmall
                )
                
                // Show Log Period button prominently when expected/overdue
                if (daysUntil <= 2) {
                    Button(
                        onClick = onLogPeriod,
                        shape = RoundedCornerShape(8.dp),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = Color(0xFFE57373)
                        )
                    ) {
                        Text("Log Period", style = MaterialTheme.typography.bodySmall)
                    }
                }
            }
        }
        
        // Always show a way to log period (if not already showing the red button)
        val showOutlinedButton = settings.lastMenstruationDate == null || 
            ChronoUnit.DAYS.between(
                LocalDate.now(), 
                settings.lastMenstruationDate!!.plusDays(settings.avgCycleLength.toLong())
            ) > 2
            
        if (showOutlinedButton) {
            Spacer(Modifier.height(8.dp))
            OutlinedButton(
                onClick = onLogPeriod,
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp)
            ) {
                Text("Log Period", color = Color.White)
            }
        }
    }
}

@Composable
private fun EditFormContent(
    lastDateText: String,
    onLastDateChange: (String) -> Unit,
    avgCycleText: String,
    onAvgCycleChange: (String) -> Unit,
    autoUpdateAvg: Boolean,
    onAutoUpdateChange: (Boolean) -> Unit,
    saving: Boolean,
    showCancel: Boolean,
    onCancel: () -> Unit,
    onSave: () -> Unit,
    saveButtonText: String
) {
    Column {
        if (showCancel) {
            Divider(color = Color.White.copy(alpha = 0.2f))
            Spacer(Modifier.height(20.dp))

            Text(
                "Edit Settings",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
            )

            Spacer(Modifier.height(16.dp))
        }

        // Last period date picker
        Text(
            "Last Period Date",
            color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelLarge
        )
        Spacer(Modifier.height(8.dp))
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            MenstruationDatePicker(
                isoDate = lastDateText,
                enabled = !saving,
                onDateSelected = onLastDateChange,
                modifier = Modifier.weight(1f)
            )
            if (lastDateText.isNotBlank()) {
                TextButton(
                    onClick = { onLastDateChange("") },
                    enabled = !saving
                ) {
                    Text("Clear", color = AppTheme.BodyTextColor)
                }
            }
        }

        Spacer(Modifier.height(16.dp))

        // Average cycle length
        Text(
            "Average Cycle Length (days)",
            color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelLarge
        )
        Spacer(Modifier.height(8.dp))
        OutlinedTextField(
            value = avgCycleText,
            onValueChange = { new ->
                if (new.isEmpty() || new.all { it.isDigit() }) {
                    onAvgCycleChange(new)
                }
            },
            placeholder = { Text("28", color = Color.White.copy(alpha = 0.5f)) },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            enabled = !saving,
            colors = OutlinedTextFieldDefaults.colors(
                focusedTextColor = Color.White,
                unfocusedTextColor = Color.White,
                focusedBorderColor = AppTheme.AccentPurple,
                unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
            )
        )
        Text(
            "Typical range: 21–35 days",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.bodySmall
        )

        Spacer(Modifier.height(16.dp))

        // Auto-update toggle
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    "Auto-update Average",
                    color = Color.White,
                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Text(
                    "Recalculate from logged periods",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
            Switch(
                checked = autoUpdateAvg,
                onCheckedChange = onAutoUpdateChange,
                enabled = !saving,
                colors = SwitchDefaults.colors(
                    checkedThumbColor = Color.White,
                    checkedTrackColor = AppTheme.AccentPurple
                )
            )
        }

        Spacer(Modifier.height(24.dp))

        // Save / Cancel buttons
        if (showCancel) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = onCancel,
                    modifier = Modifier.weight(1f),
                    enabled = !saving,
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text("Cancel", color = Color.White)
                }

                Button(
                    onClick = onSave,
                    modifier = Modifier.weight(1f),
                    enabled = !saving,
                    shape = RoundedCornerShape(12.dp),
                    colors = ButtonDefaults.buttonColors(
                        containerColor = AppTheme.AccentPurple
                    )
                ) {
                    Text(if (saving) "Saving..." else saveButtonText)
                }
            }
        } else {
            // First time setup - just save button
            Button(
                onClick = onSave,
                modifier = Modifier.fillMaxWidth(),
                enabled = !saving,
                shape = RoundedCornerShape(12.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = AppTheme.AccentPurple
                )
            ) {
                Text(if (saving) "Saving..." else saveButtonText)
            }
        }
    }
}

@Composable
private fun DataRow(
    label: String,
    value: String
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            label,
            color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.bodyMedium
        )
        Text(
            value,
            color = Color.White,
            style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.SemiBold)
        )
    }
}

@Composable
private fun MenstruationDatePicker(
    isoDate: String,
    enabled: Boolean,
    onDateSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val ctx = LocalContext.current

    val parsed = isoDate.trim().takeIf { it.isNotBlank() }?.let { raw ->
        runCatching { LocalDate.parse(raw, DateTimeFormatter.ISO_LOCAL_DATE) }.getOrNull()
    }

    val initial = parsed ?: LocalDate.now()
    val displayText = if (isoDate.isBlank()) "Select date" else isoDate

    OutlinedButton(
        onClick = {
            DatePickerDialog(
                ctx,
                { _, y, m, d ->
                    val picked = "%04d-%02d-%02d".format(y, m + 1, d)
                    onDateSelected(picked)
                },
                initial.year,
                initial.monthValue - 1,
                initial.dayOfMonth
            ).show()
        },
        enabled = enabled,
        modifier = modifier,
        shape = RoundedCornerShape(12.dp)
    ) {
        Text(displayText, color = Color.White)
    }
}

private fun validateMenstruationInputs(
    lastDateText: String,
    avgCycleText: String
): Triple<LocalDate?, Int, String?> {
    val lastDate = lastDateText.trim().takeIf { it.isNotBlank() }?.let { raw ->
        try {
            LocalDate.parse(raw, DateTimeFormatter.ISO_LOCAL_DATE)
        } catch (_: Exception) {
            return Triple(null, 0, "Invalid date format. Use YYYY-MM-DD.")
        }
    }

    val avg = avgCycleText.trim().toIntOrNull()
        ?: return Triple(null, 0, "Average cycle length must be a number.")

    if (avg < 15 || avg > 60) {
        return Triple(null, 0, "Cycle length should be between 15 and 60 days.")
    }

    return Triple(lastDate, avg, null)
}

title: MenstruationSettings.kt
text:
package com.migraineme

import java.time.LocalDate

/**
 * Data class for menstruation settings
 *
 * Stored in Supabase menstruation_settings table
 */
data class MenstruationSettings(
    val lastMenstruationDate: LocalDate?,
    val avgCycleLength: Int,
    val autoUpdateAverage: Boolean
)

title: MenstruationSettingsManager.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate

class MenstruationSettingsManager(private val context: Context) {

    private val service = SupabaseMenstruationService(context)
    private val edge = EdgeFunctionsService()

    suspend fun loadSettings(): Result<MenstruationSettings?> {
        return withContext(Dispatchers.IO) {
            try {
                val token = SessionStore.getValidAccessToken(context)
                if (token == null) {
                    Log.w(TAG, "No access token")
                    return@withContext Result.success(null)
                }

                val settings = service.getSettings(token)
                Log.d(TAG, "Loaded: $settings")
                Result.success(settings)
            } catch (e: Exception) {
                Log.e(TAG, "Load failed: ${e.message}", e)
                Result.failure(e)
            }
        }
    }

    suspend fun updateSettings(
        lastDate: LocalDate?,
        avgCycle: Int,
        autoUpdate: Boolean
    ): Result<MenstruationSettings> {
        return withContext(Dispatchers.IO) {
            try {
                val token = SessionStore.getValidAccessToken(context)
                    ?: return@withContext Result.failure(Exception("No access token"))

                service.updateSettings(
                    accessToken = token,
                    lastMenstruationDate = lastDate,
                    avgCycleLength = avgCycle,
                    autoUpdateAverage = autoUpdate
                )

                edge.upsertMetricSetting(
                    context = context,
                    metric = "menstruation",
                    enabled = true,
                    preferredSource = null
                )

                MetricToggleHelper.toggle(context, "menstruation", true)

                Log.d(TAG, "Updated successfully")
                Result.success(MenstruationSettings(lastDate, avgCycle, autoUpdate))
            } catch (e: Exception) {
                Log.e(TAG, "Update failed: ${e.message}", e)
                Result.failure(e)
            }
        }
    }

    companion object {
        private const val TAG = "MenstruationManager"
    }
}

title: MenstruationSettingsScreen.kt
text:
package com.migraineme

import android.app.DatePickerDialog
import android.widget.Toast
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

/**
 * Screen to view/edit menstruation_settings.
 *
 * Uses existing patterns:
 * - Token retrieval: SessionStore.getValidAccessToken(context)
 * - Read: SupabaseMenstruationService.getSettings(accessToken)
 * - Write: MenstruationTrackingHelper.updateSettingsOnly(...)
 *
 * This screen does NOT enable/disable tracking or schedule workers; it only edits settings.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MenstruationSettingsScreen(
    onBack: (() -> Unit)? = null
) {
    val context = androidx.compose.ui.platform.LocalContext.current
    val scope = rememberCoroutineScope()

    val loading = remember { mutableStateOf(true) }
    val saving = remember { mutableStateOf(false) }
    val errorText = remember { mutableStateOf<String?>(null) }

    val loadedSettings: MutableState<MenstruationSettings?> = remember { mutableStateOf(null) }

    // Editable UI state
    val lastDateText = remember { mutableStateOf("") }
    val avgCycleText = remember { mutableStateOf("28") }
    val autoUpdateAvg = remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        loading.value = true
        errorText.value = null

        val result = withContext(Dispatchers.IO) {
            runCatching {
                val token = SessionStore.getValidAccessToken(context.applicationContext)
                    ?: return@runCatching Pair<MenstruationSettings?, String?>(
                        null,
                        "Please sign in again to load menstruation settings."
                    )

                val service = SupabaseMenstruationService(context.applicationContext)
                val s = service.getSettings(token)
                Pair(s, null)
            }.getOrElse { e ->
                Pair<MenstruationSettings?, String?>(
                    null,
                    "Failed to load menstruation settings: ${e.message ?: "Unknown error"}"
                )
            }
        }

        val settings = result.first
        val err = result.second

        loadedSettings.value = settings
        errorText.value = err

        if (settings != null) {
            lastDateText.value = settings.lastMenstruationDate?.toString() ?: ""
            avgCycleText.value = settings.avgCycleLength.toString()
            autoUpdateAvg.value = settings.autoUpdateAverage
        }

        loading.value = false
    }

    Scaffold(
        topBar = {
            CenterAlignedTopAppBar(
                title = { Text("Menstruation Settings") },
                navigationIcon = {
                    if (onBack != null) {
                        IconButton(onClick = onBack) {
                            Icon(Icons.Outlined.ArrowBack, contentDescription = "Back")
                        }
                    }
                },
                colors = TopAppBarDefaults.centerAlignedTopAppBarColors()
            )
        }
    ) { inner ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(inner)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(14.dp)
        ) {
            if (loading.value) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Center
                ) {
                    CircularProgressIndicator()
                }
                return@Column
            }

            errorText.value?.let { msg ->
                Text(
                    text = msg,
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodyMedium
                )
            }

            Text(
                text = "Edit the values stored in menstruation_settings.",
                style = MaterialTheme.typography.bodyMedium
            )

            Divider()

            // Date picker (like the migraine date picker pattern), stored as ISO yyyy-MM-dd in lastDateText.
            Column(modifier = Modifier.fillMaxWidth()) {
                Text(
                    text = "Last period date",
                    style = MaterialTheme.typography.labelLarge
                )
                Spacer(Modifier.height(6.dp))
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(10.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    AppDatePicker(
                        isoDate = lastDateText.value,
                        enabled = !saving.value,
                        onDateSelected = { lastDateText.value = it },
                        modifier = Modifier.weight(1f)
                    )
                    if (lastDateText.value.isNotBlank()) {
                        TextButton(
                            onClick = { lastDateText.value = "" },
                            enabled = !saving.value
                        ) {
                            Text("Clear")
                        }
                    }
                }
                Text(
                    text = "Optional. Leave blank if unknown.",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            OutlinedTextField(
                value = avgCycleText.value,
                onValueChange = { new ->
                    if (new.isEmpty() || new.all { it.isDigit() }) {
                        // Keep it simple; validation happens on Save.
                        avgCycleText.value = new
                    }
                },
                label = { Text("Average cycle length (days)") },
                placeholder = { Text("28") },
                supportingText = { Text("Used for prediction and averaging. Typical range 15–60.") },
                modifier = Modifier.fillMaxWidth(),
                singleLine = true,
                enabled = !saving.value
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = "Auto-update average",
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.SemiBold
                    )
                    Text(
                        text = "When enabled, background sync can recompute avg cycle length from recent periods.",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                Switch(
                    checked = autoUpdateAvg.value,
                    onCheckedChange = { autoUpdateAvg.value = it },
                    enabled = !saving.value
                )
            }

            Spacer(Modifier.height(6.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                Button(
                    onClick = {
                        scope.launch(Dispatchers.IO) {
                            saving.value = true
                            val (parsedLast, parsedAvg, validationError) =
                                validateInputs(
                                    lastDateText = lastDateText.value,
                                    avgCycleText = avgCycleText.value
                                )

                            if (validationError != null) {
                                withContext(Dispatchers.Main) {
                                    saving.value = false
                                    Toast.makeText(context, validationError, Toast.LENGTH_LONG).show()
                                }
                                return@launch
                            }

                            val ok = MenstruationTrackingHelper.updateSettingsOnly(
                                context = context.applicationContext,
                                lastDate = parsedLast,
                                avgCycle = parsedAvg,
                                autoUpdate = autoUpdateAvg.value
                            )

                            withContext(Dispatchers.Main) {
                                saving.value = false
                                if (ok) {
                                    loadedSettings.value = MenstruationSettings(
                                        lastMenstruationDate = parsedLast,
                                        avgCycleLength = parsedAvg,
                                        autoUpdateAverage = autoUpdateAvg.value
                                    )
                                    Toast.makeText(context, "Menstruation settings saved.", Toast.LENGTH_SHORT).show()
                                } else {
                                    Toast.makeText(
                                        context,
                                        "Failed to save. Please sign in again and retry.",
                                        Toast.LENGTH_LONG
                                    ).show()
                                }
                            }
                        }
                    },
                    enabled = !saving.value,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(if (saving.value) "Saving..." else "Save")
                }

                TextButton(
                    onClick = {
                        // Reset to last loaded values
                        val s = loadedSettings.value
                        if (s != null) {
                            lastDateText.value = s.lastMenstruationDate?.toString() ?: ""
                            avgCycleText.value = s.avgCycleLength.toString()
                            autoUpdateAvg.value = s.autoUpdateAverage
                        } else {
                            lastDateText.value = ""
                            avgCycleText.value = "28"
                            autoUpdateAvg.value = true
                        }
                    },
                    enabled = !saving.value,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Reset")
                }
            }

            loadedSettings.value?.let { s ->
                Spacer(Modifier.height(10.dp))
                Divider()
                Text(
                    text = "Current saved values",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.SemiBold
                )
                Text("Last period: ${s.lastMenstruationDate ?: "—"}", style = MaterialTheme.typography.bodySmall)
                Text("Avg cycle: ${s.avgCycleLength} days", style = MaterialTheme.typography.bodySmall)
                Text(
                    "Auto-update average: ${if (s.autoUpdateAverage) "On" else "Off"}",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

@Composable
private fun AppDatePicker(
    isoDate: String,
    enabled: Boolean,
    onDateSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val ctx = androidx.compose.ui.platform.LocalContext.current

    val parsed = isoDate.trim().takeIf { it.isNotBlank() }?.let { raw ->
        runCatching { LocalDate.parse(raw, DateTimeFormatter.ISO_LOCAL_DATE) }.getOrNull()
    }

    val initial = parsed ?: LocalDate.now()
    val displayText = if (isoDate.isBlank()) "Select date" else isoDate

    OutlinedButton(
        onClick = {
            DatePickerDialog(
                ctx,
                { _, y, m, d ->
                    val picked = "%04d-%02d-%02d".format(y, m + 1, d)
                    onDateSelected(picked)
                },
                initial.year,
                initial.monthValue - 1,
                initial.dayOfMonth
            ).show()
        },
        enabled = enabled,
        modifier = modifier.fillMaxWidth()
    ) {
        Text(displayText)
    }
}

private fun validateInputs(
    lastDateText: String,
    avgCycleText: String
): Triple<LocalDate?, Int, String?> {
    val lastDate = lastDateText.trim().takeIf { it.isNotBlank() }?.let { raw ->
        // Expect ISO (YYYY-MM-DD) consistent with existing dialogs / toString()
        try {
            LocalDate.parse(raw, DateTimeFormatter.ISO_LOCAL_DATE)
        } catch (_: Exception) {
            return Triple(null, 0, "Invalid last period date. Use YYYY-MM-DD (e.g. 2026-01-15).")
        }
    }

    val avg = avgCycleText.trim().toIntOrNull()
        ?: return Triple(null, 0, "Average cycle length must be a number (e.g. 28).")

    if (avg < 15 || avg > 60) {
        return Triple(null, 0, "Average cycle length looks wrong. Use a value between 15 and 60.")
    }

    return Triple(lastDate, avg, null)
}

title: MenstruationSetupDialog.kt
text:
package com.migraineme

import android.app.DatePickerDialog
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.util.Calendar

/**
 * Setup dialog for menstruation tracking with date picker
 */
@Composable
fun MenstruationSetupDialog(
    onConfirm: (LocalDate?, Int, Boolean) -> Unit,
    onDismiss: () -> Unit,
    autoFetchHistory: Boolean = false
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    // Loading state
    var isLoading by remember { mutableStateOf(autoFetchHistory) }
    var historicalData by remember { mutableStateOf<HealthConnectMenstruationHistoryFetcher.HistoricalData?>(null) }

    // Form state
    var lastDate by remember { mutableStateOf<LocalDate?>(null) }
    var lastDateDisplay by remember { mutableStateOf("Tap to select date") }
    var avgCycleText by remember { mutableStateOf("28") }
    var autoUpdate by remember { mutableStateOf(true) }
    var error by remember { mutableStateOf<String?>(null) }

    // Fetch historical data on launch if requested
    LaunchedEffect(autoFetchHistory) {
        if (autoFetchHistory) {
            isLoading = true
            withContext(Dispatchers.IO) {
                try {
                    val data = HealthConnectMenstruationHistoryFetcher.fetchHistoricalData(context)
                    historicalData = data

                    // Pre-fill form with suggestions
                    withContext(Dispatchers.Main) {
                        if (data.suggestedLastDate != null) {
                            lastDate = data.suggestedLastDate
                            lastDateDisplay = data.suggestedLastDate.toString()
                        }
                        if (data.suggestedAvgCycle != null) {
                            avgCycleText = data.suggestedAvgCycle.toString()
                        }
                    }
                } catch (e: Exception) {
                    android.util.Log.e("MenstruationSetup", "Failed to fetch history: ${e.message}")
                } finally {
                    withContext(Dispatchers.Main) {
                        isLoading = false
                    }
                }
            }
        }
    }

    AlertDialog(
        onDismissRequest = { if (!isLoading) onDismiss() },
        title = { Text("Menstruation Tracking Setup") },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                if (isLoading) {
                    // Loading state
                    Column(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        CircularProgressIndicator()
                        Text(
                            "Analyzing your cycle history...",
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Text(
                            "This may take up to 30 seconds",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                } else {
                    // Show result message
                    if (historicalData != null) {
                        val data = historicalData!!
                        if (data.periods.isNotEmpty()) {
                            Card(
                                colors = CardDefaults.cardColors(
                                    containerColor = MaterialTheme.colorScheme.primaryContainer
                                )
                            ) {
                                Column(modifier = Modifier.padding(12.dp)) {
                                    Text(
                                        "✓ Found ${data.periods.size} periods in your history!",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = MaterialTheme.colorScheme.onPrimaryContainer
                                    )
                                    Spacer(Modifier.height(4.dp))
                                    Text(
                                        "We've pre-filled your information below. You can edit if needed.",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.onPrimaryContainer
                                    )
                                }
                            }
                        } else {
                            Card(
                                colors = CardDefaults.cardColors(
                                    containerColor = MaterialTheme.colorScheme.errorContainer
                                )
                            ) {
                                Column(modifier = Modifier.padding(12.dp)) {
                                    Text(
                                        "We couldn't find any period data",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = MaterialTheme.colorScheme.onErrorContainer
                                    )
                                    Spacer(Modifier.height(4.dp))
                                    Text(
                                        "Please enter your information manually below.",
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.onErrorContainer
                                    )
                                }
                            }
                        }
                        Spacer(Modifier.height(8.dp))
                    }

                    // Form fields
                    Text(
                        "Help us track your cycle by providing some basic information:",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    // Date picker button for last period
                    Column {
                        Text(
                            "Last Period Start Date",
                            style = MaterialTheme.typography.labelMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Spacer(Modifier.height(4.dp))
                        OutlinedButton(
                            onClick = {
                                val cal = Calendar.getInstance()
                                if (lastDate != null) {
                                    cal.set(lastDate!!.year, lastDate!!.monthValue - 1, lastDate!!.dayOfMonth)
                                }

                                DatePickerDialog(
                                    context,
                                    { _, year, month, day ->
                                        lastDate = LocalDate.of(year, month + 1, day)
                                        lastDateDisplay = lastDate.toString()
                                        error = null
                                    },
                                    cal.get(Calendar.YEAR),
                                    cal.get(Calendar.MONTH),
                                    cal.get(Calendar.DAY_OF_MONTH)
                                ).show()
                            },
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Text(lastDateDisplay)
                        }
                    }

                    OutlinedTextField(
                        value = avgCycleText,
                        onValueChange = {
                            avgCycleText = it
                            error = null
                        },
                        label = { Text("Average Cycle Length (days)") },
                        placeholder = { Text("28") },
                        modifier = Modifier.fillMaxWidth(),
                        isError = error != null
                    )

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                "Auto-update average",
                                style = MaterialTheme.typography.bodyMedium
                            )
                            Text(
                                "Recalculate when new periods are logged",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                        Switch(
                            checked = autoUpdate,
                            onCheckedChange = { autoUpdate = it }
                        )
                    }

                    if (error != null) {
                        Text(
                            error!!,
                            color = MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }
        },
        confirmButton = {
            if (!isLoading) {
                TextButton(
                    onClick = {
                        // Validate
                        val avgCycle = avgCycleText.toIntOrNull()
                        if (avgCycle == null || avgCycle !in 14..60) {
                            error = "Average cycle must be between 14-60 days"
                            return@TextButton
                        }

                        onConfirm(lastDate, avgCycle, autoUpdate)
                    }
                ) {
                    Text("Start Tracking")
                }
            }
        },
        dismissButton = {
            if (!isLoading) {
                TextButton(onClick = onDismiss) {
                    Text("Cancel")
                }
            }
        }
    )
}

title: MenstruationSyncDatabase.kt
text:
package com.migraineme

import android.content.Context
import androidx.room.*

/**
 * Local database for menstruation sync (similar to nutrition sync)
 * 
 * Tracks:
 * - Sync state (changes token, last run times)
 * - Outbox (periods waiting to upload to Supabase)
 */
@Database(
    entities = [
        MenstruationSyncStateEntity::class,
        MenstruationOutboxEntity::class
    ],
    version = 1,
    exportSchema = false
)
abstract class MenstruationSyncDatabase : RoomDatabase() {
    
    abstract fun dao(): MenstruationSyncDao
    
    companion object {
        @Volatile
        private var INSTANCE: MenstruationSyncDatabase? = null
        
        fun get(context: Context): MenstruationSyncDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    MenstruationSyncDatabase::class.java,
                    "menstruation_sync.db"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}

/**
 * Sync state - tracks changes token and last run times
 */
@Entity(tableName = "menstruation_sync_state")
data class MenstruationSyncStateEntity(
    @PrimaryKey val id: Int = 1,
    val changesToken: String? = null,
    val lastHourlyRunAtEpochMs: Long? = null,
    val lastPushRunAtEpochMs: Long? = null
)

/**
 * Outbox - periods waiting to upload to Supabase
 */
@Entity(tableName = "menstruation_outbox")
data class MenstruationOutboxEntity(
    @PrimaryKey val healthConnectId: String,
    val operation: String,  // "UPSERT" or "DELETE"
    val createdAtEpochMs: Long,
    val retryCount: Int = 0
)

/**
 * DAO for menstruation sync operations
 */
@Dao
interface MenstruationSyncDao {
    
    // Sync state operations
    @Query("SELECT * FROM menstruation_sync_state WHERE id = 1")
    suspend fun getSyncState(): MenstruationSyncStateEntity?
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertSyncState(state: MenstruationSyncStateEntity)
    
    @Query("UPDATE menstruation_sync_state SET lastHourlyRunAtEpochMs = :epochMs WHERE id = 1")
    suspend fun markHourlyRun(epochMs: Long)
    
    @Query("UPDATE menstruation_sync_state SET lastPushRunAtEpochMs = :epochMs WHERE id = 1")
    suspend fun markPushRun(epochMs: Long)
    
    // Outbox operations
    @Query("SELECT * FROM menstruation_outbox ORDER BY createdAtEpochMs ASC LIMIT :limit")
    suspend fun getOutboxBatch(limit: Int): List<MenstruationOutboxEntity>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertOutbox(item: MenstruationOutboxEntity)
    
    @Query("DELETE FROM menstruation_outbox WHERE healthConnectId IN (:ids)")
    suspend fun deleteOutboxByIds(ids: List<String>)
    
    @Query("UPDATE menstruation_outbox SET retryCount = retryCount + 1 WHERE healthConnectId IN (:ids)")
    suspend fun incrementRetry(ids: List<String>)
    
    @Query("DELETE FROM menstruation_outbox")
    suspend fun clearOutbox()
    
    @Query("DELETE FROM menstruation_sync_state")
    suspend fun clearSyncState()
}

title: MenstruationSyncScheduler.kt
text:
package com.migraineme

import android.content.Context
import androidx.work.Constraints
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.NetworkType
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkManager
import java.util.concurrent.TimeUnit

/**
 * Schedules menstruation sync workers
 *
 * - Changes worker: Runs every 15 minutes (detects new/updated/deleted periods)
 * - Push worker: Runs every 15 minutes (uploads to Supabase)
 *
 * Total max delay: ~30 minutes (15 min to detect + 15 min to upload)
 */
object MenstruationSyncScheduler {

    private const val CHANGES_WORK_NAME = "hc_menstruation_changes_15m"
    private const val PUSH_WORK_NAME = "menstruation_outbox_push_15m"

    /**
     * Schedule both menstruation workers
     */
    fun schedule(context: Context) {
        val wm = WorkManager.getInstance(context)

        val changesConstraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.NOT_REQUIRED)
            .build()

        val pushConstraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val changes = PeriodicWorkRequestBuilder<HealthConnectMenstruationChangesWorker>(
            15, TimeUnit.MINUTES
        )
            .setConstraints(changesConstraints)
            .addTag("menstruation")
            .addTag("health_connect")
            .build()

        val push = PeriodicWorkRequestBuilder<MenstruationOutboxPushWorker>(
            15, TimeUnit.MINUTES
        )
            .setConstraints(pushConstraints)
            .addTag("menstruation")
            .addTag("supabase")
            .build()

        wm.enqueueUniquePeriodicWork(
            CHANGES_WORK_NAME,
            ExistingPeriodicWorkPolicy.UPDATE,
            changes
        )

        wm.enqueueUniquePeriodicWork(
            PUSH_WORK_NAME,
            ExistingPeriodicWorkPolicy.UPDATE,
            push
        )

        android.util.Log.d("MenstruationSync", "Scheduled workers - 15 min intervals")
    }

    /**
     * Cancel both menstruation workers
     */
    fun cancel(context: Context) {
        val wm = WorkManager.getInstance(context)
        wm.cancelUniqueWork(CHANGES_WORK_NAME)
        wm.cancelUniqueWork(PUSH_WORK_NAME)

        android.util.Log.d("MenstruationSync", "Cancelled workers")
    }
}

title: MenstruationTrackingHelper.kt
text:
package com.migraineme

import android.content.Context
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate

/**
 * Centralized helper for menstruation tracking:
 * - Writes menstruation_settings via SupabaseMenstruationService
 * - Enables/disables metric_settings via EdgeFunctionsService
 * - Manages local helpers (PredictedMenstruationHelper, MetricToggleHelper, MenstruationSyncScheduler)
 *
 * UI (dialogs, toasts) stays in the calling screens.
 */
object MenstruationTrackingHelper {

    /**
     * Enable menstruation metric in Supabase + local toggle/scheduler WITHOUT writing menstruation_settings.
     * Useful when Health Connect permission is granted and you want to show setup dialog next.
     */
    suspend fun enableMetricOnly(
        context: Context,
        preferredSource: String?
    ): Boolean = withContext(Dispatchers.IO) {
        runCatching {
            val edge = EdgeFunctionsService()
            val ok = edge.upsertMetricSetting(
                context = context.applicationContext,
                metric = "menstruation",
                enabled = true,
                preferredSource = preferredSource
            )
            if (ok) {
                MetricToggleHelper.toggle(context.applicationContext, "menstruation", true)
            }
            ok
        }.getOrElse {
            android.util.Log.e("MenstruationHelper", "enableMetricOnly failed: ${it.message}", it)
            false
        }
    }

    /**
     * Disable menstruation metric in Supabase + local toggle/scheduler cleanup.
     */
    suspend fun disableTracking(
        context: Context,
        preferredSource: String?
    ): Boolean = withContext(Dispatchers.IO) {
        runCatching {
            PredictedMenstruationHelper.delete(context.applicationContext)
            MetricToggleHelper.toggle(context.applicationContext, "menstruation", false)

            val edge = EdgeFunctionsService()
            edge.upsertMetricSetting(
                context = context.applicationContext,
                metric = "menstruation",
                enabled = false,
                preferredSource = preferredSource
            )
        }.onFailure {
            android.util.Log.e("MenstruationHelper", "disableTracking failed: ${it.message}", it)
        }.isSuccess
    }

    /**
     * Save menstruation_settings to Supabase and fully enable tracking (Supabase + local).
     */
    suspend fun saveSettingsAndEnableTracking(
        context: Context,
        lastDate: LocalDate?,
        avgCycle: Int,
        autoUpdate: Boolean,
        preferredSource: String?
    ): Boolean = withContext(Dispatchers.IO) {
        runCatching {
            val accessToken = SessionStore.getValidAccessToken(context.applicationContext)
                ?: return@withContext false

            val service = SupabaseMenstruationService(context.applicationContext)
            service.updateSettings(
                accessToken = accessToken,
                lastMenstruationDate = lastDate,
                avgCycleLength = avgCycle,
                autoUpdateAverage = autoUpdate
            )

            // Persist manual log as a trigger (used by prediction + backend conversion logic)
            ensureManualMenstruationTrigger(
                accessToken = accessToken,
                lastDate = lastDate
            )

            PredictedMenstruationHelper.ensureExists(context.applicationContext)
            MetricToggleHelper.toggle(context.applicationContext, "menstruation", true)
            MenstruationSyncScheduler.schedule(context.applicationContext)

            val edge = EdgeFunctionsService()
            edge.upsertMetricSetting(
                context = context.applicationContext,
                metric = "menstruation",
                enabled = true,
                preferredSource = preferredSource
            )
        }.onFailure {
            android.util.Log.e("MenstruationHelper", "saveSettingsAndEnableTracking failed: ${it.message}", it)
        }.getOrDefault(false)
    }

    /**
     * Update menstruation_settings only (no metric toggling).
     */
    suspend fun updateSettingsOnly(
        context: Context,
        lastDate: LocalDate?,
        avgCycle: Int,
        autoUpdate: Boolean
    ): Boolean = withContext(Dispatchers.IO) {
        runCatching {
            val accessToken = SessionStore.getValidAccessToken(context.applicationContext)
                ?: return@withContext false

            val service = SupabaseMenstruationService(context.applicationContext)
            service.updateSettings(
                accessToken = accessToken,
                lastMenstruationDate = lastDate,
                avgCycleLength = avgCycle,
                autoUpdateAverage = autoUpdate
            )

            // Persist manual log as a trigger (used by prediction + backend conversion logic)
            ensureManualMenstruationTrigger(
                accessToken = accessToken,
                lastDate = lastDate
            )

            true
        }.onFailure {
            android.util.Log.e("MenstruationHelper", "updateSettingsOnly failed: ${it.message}", it)
        }.getOrDefault(false)
    }

    /**
     * When the user logs a "last period date" via the menstruation settings UI, persist it as a real trigger.
     *
     * This supports:
     * - prediction logic that looks at last real "menstruation" triggers
     * - backend jobs (e.g., convert-predicted-menstruations) that skip auto-conversion if a manual period was logged
     */
    private suspend fun ensureManualMenstruationTrigger(
        accessToken: String,
        lastDate: LocalDate?
    ) {
        if (lastDate == null) return

        val db = SupabaseDbService(
            BuildConfig.SUPABASE_URL,
            BuildConfig.SUPABASE_ANON_KEY
        )

        val day = lastDate.toString()

        // Avoid duplicates if user taps Save multiple times for the same date.
        val alreadyLogged = db.getAllTriggers(accessToken).any { t ->
            t.type == "menstruation" &&
                    (t.source ?: "manual") == "manual" &&
                    t.startAt.startsWith(day)
        }

        if (alreadyLogged) return

        db.insertTrigger(
            accessToken = accessToken,
            migraineId = null,
            type = "menstruation",
            startAt = "${day}T09:00:00Z",
            notes = "Logged via menstruation settings"
        )
    }
}

title: MentalCardConfig.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color

object MentalCardConfig {
    // Metric keys
    const val METRIC_STRESS = "stress"
    const val METRIC_SCREEN_TIME = "screen_time"
    const val METRIC_LATE_SCREEN_TIME = "late_screen_time"
    const val METRIC_NOISE = "noise"
    const val METRIC_NOISE_HIGH = "noise_high"
    const val METRIC_NOISE_AVG = "noise_avg"
    const val METRIC_NOISE_LOW = "noise_low"
    const val METRIC_BRIGHTNESS = "brightness"
    const val METRIC_VOLUME = "volume"
    const val METRIC_DARK_MODE = "dark_mode"
    const val METRIC_UNLOCKS = "unlocks"

    val ALL_MENTAL_METRICS: List<String> = listOf(
        METRIC_STRESS, METRIC_SCREEN_TIME, METRIC_LATE_SCREEN_TIME,
        METRIC_NOISE, METRIC_BRIGHTNESS, METRIC_VOLUME,
        METRIC_DARK_MODE, METRIC_UNLOCKS
    )

    val DEFAULT_DISPLAY_METRICS: List<String> = listOf(
        METRIC_STRESS, METRIC_SCREEN_TIME, METRIC_UNLOCKS
    )

    val GRAPHABLE_METRICS: List<String> = listOf(
        METRIC_STRESS, METRIC_SCREEN_TIME, METRIC_LATE_SCREEN_TIME,
        METRIC_NOISE_HIGH, METRIC_NOISE_AVG, METRIC_NOISE_LOW,
        METRIC_BRIGHTNESS, METRIC_VOLUME,
        METRIC_DARK_MODE, METRIC_UNLOCKS
    )

    fun labelFor(metric: String): String = when (metric) {
        METRIC_STRESS -> "Stress"
        METRIC_SCREEN_TIME -> "Screen Time"
        METRIC_LATE_SCREEN_TIME -> "Late Screen"
        METRIC_NOISE -> "Noise"
        METRIC_NOISE_HIGH -> "Noise High"
        METRIC_NOISE_AVG -> "Noise Avg"
        METRIC_NOISE_LOW -> "Noise Low"
        METRIC_BRIGHTNESS -> "Brightness"
        METRIC_VOLUME -> "Volume"
        METRIC_DARK_MODE -> "Dark Mode"
        METRIC_UNLOCKS -> "Unlocks"
        else -> metric
    }

    fun unitFor(metric: String): String = when (metric) {
        METRIC_STRESS -> ""
        METRIC_SCREEN_TIME -> "h"
        METRIC_LATE_SCREEN_TIME -> "h"
        METRIC_NOISE, METRIC_NOISE_HIGH, METRIC_NOISE_AVG, METRIC_NOISE_LOW -> "dB"
        METRIC_BRIGHTNESS -> ""
        METRIC_VOLUME -> "%"
        METRIC_DARK_MODE -> "h"
        METRIC_UNLOCKS -> ""
        else -> ""
    }

    fun colorFor(metric: String): Color = when (metric) {
        METRIC_STRESS -> Color(0xFFE57373)
        METRIC_SCREEN_TIME -> Color(0xFF4FC3F7)
        METRIC_LATE_SCREEN_TIME -> Color(0xFF7986CB)
        METRIC_NOISE -> Color(0xFFFFB74D)
        METRIC_NOISE_HIGH -> Color(0xFFFF7043)
        METRIC_NOISE_AVG -> Color(0xFFFFB74D)
        METRIC_NOISE_LOW -> Color(0xFF66BB6A)
        METRIC_BRIGHTNESS -> Color(0xFFFFD54F)
        METRIC_VOLUME -> Color(0xFF9575CD)
        METRIC_DARK_MODE -> Color(0xFF78909C)
        METRIC_UNLOCKS -> Color(0xFFFF8A65)
        else -> Color(0xFFBA68C8)
    }

    /** Maps config metric key to Supabase table name for metric_settings lookup */
    fun metricToTable(metric: String): String = when (metric) {
        METRIC_STRESS -> "stress_index_daily"
        METRIC_SCREEN_TIME -> "screen_time_daily"
        METRIC_LATE_SCREEN_TIME -> "screen_time_late_night"
        METRIC_NOISE, METRIC_NOISE_HIGH, METRIC_NOISE_AVG, METRIC_NOISE_LOW -> "ambient_noise_index_daily"
        METRIC_BRIGHTNESS -> "phone_brightness_daily"
        METRIC_VOLUME -> "phone_volume_daily"
        METRIC_DARK_MODE -> "phone_dark_mode_daily"
        METRIC_UNLOCKS -> "phone_unlock_daily"
        else -> ""
    }
}

title: MentalCardConfigStore.kt
text:
package com.migraineme

import android.content.Context

data class MentalCardConfigData(
    val mentalDisplayMetrics: List<String>
)

object MentalCardConfigStore {
    private const val PREFS_NAME = "mental_card_config"
    private const val KEY_DISPLAY_METRICS = "mental_display_metrics"

    fun load(context: Context): MentalCardConfigData {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val metricsStr = prefs.getString(KEY_DISPLAY_METRICS, null)
        val metrics: List<String> = if (metricsStr.isNullOrBlank()) {
            MentalCardConfig.DEFAULT_DISPLAY_METRICS
        } else {
            metricsStr.split(",").filter { it.isNotBlank() }
        }
        return MentalCardConfigData(mentalDisplayMetrics = metrics)
    }

    fun save(context: Context, config: MentalCardConfigData) {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit()
            .putString(KEY_DISPLAY_METRICS, config.mentalDisplayMetrics.joinToString(","))
            .apply()
    }
}

title: MentalConfigScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun MentalConfigScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    val initialConfig = remember { MentalCardConfigStore.load(context) }
    var selectedMetrics by remember { mutableStateOf<Set<String>>(initialConfig.mentalDisplayMetrics.toSet()) }

    var metricSettings by remember {
        mutableStateOf<Map<String, EdgeFunctionsService.MetricSettingResponse>>(emptyMap())
    }
    var settingsLoaded by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        scope.launch {
            try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(context)
                metricSettings = settings.associateBy { it.metric }
            } catch (_: Exception) { }
            settingsLoaded = true
        }
    }

    fun saveConfig() {
        MentalCardConfigStore.save(
            context,
            MentalCardConfigData(mentalDisplayMetrics = selectedMetrics.toList())
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = {
                    saveConfig()
                    onBack()
                }) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }

            HeroCard {
                Text(
                    text = "Customize Mental Health",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Choose which mental health metrics to display on the Monitor screen.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            BaseCard {
                Text(
                    text = "Display Metrics (${selectedMetrics.size}/3)",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Select up to 3 metrics to show on the Monitor card.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
                Spacer(Modifier.height(12.dp))

                FlowRow(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (metric in MentalCardConfig.ALL_MENTAL_METRICS) {
                        val table = MentalCardConfig.metricToTable(metric)
                        val setting = metricSettings[table]

                        if (settingsLoaded && setting != null && !setting.enabled) continue

                        val isSelected = metric in selectedMetrics
                        val label = MentalCardConfig.labelFor(metric)
                        val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                        val slotIndex = if (isSelected) selectedMetrics.toList().indexOf(metric) else -1
                        val chipColor = if (slotIndex in slotColors.indices) slotColors[slotIndex] else AppTheme.AccentPurple
                        FilterChip(
                            selected = isSelected,
                            onClick = {
                                if (isSelected) {
                                    selectedMetrics = selectedMetrics.minus(metric)
                                } else if (selectedMetrics.size < 3) {
                                    selectedMetrics = selectedMetrics.plus(metric)
                                }
                                saveConfig()
                            },
                            label = {
                                Text(
                                    text = label,
                                    style = MaterialTheme.typography.labelSmall
                                )
                            },
                            leadingIcon = if (isSelected) {
                                {
                                    Icon(
                                        Icons.Default.Check,
                                        contentDescription = null,
                                        modifier = Modifier.size(18.dp)
                                    )
                                }
                            } else null,
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = chipColor.copy(alpha = 0.3f),
                                selectedLabelColor = chipColor,
                                containerColor = AppTheme.BaseCardContainer,
                                labelColor = AppTheme.BodyTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                                selectedBorderColor = chipColor,
                                enabled = true,
                                selected = isSelected
                            )
                        )
                    }
                }
            }
        }
    }
}

title: MentalDataHistoryScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.ChevronLeft
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// ─── Data model ──────────────────────────────────────────────────────────────

data class MentalDataEntry(
    val table: String,
    val label: String,
    val value: String,
    val source: String
)

// ─── Screen ──────────────────────────────────────────────────────────────────

@Composable
fun MentalDataHistoryScreen(onBack: () -> Unit) {
    val context = LocalContext.current
    val scrollState = rememberSaveable(saver = ScrollState.Saver) { ScrollState(0) }
    val scope = rememberCoroutineScope()

    var selectedDateStr by rememberSaveable { mutableStateOf(LocalDate.now().toString()) }
    val selectedDate = LocalDate.parse(selectedDateStr)
    val today = LocalDate.now()

    var entries by remember { mutableStateOf<List<MentalDataEntry>>(emptyList()) }
    val mentalConfig = remember { MentalCardConfigStore.load(context) }
    var isLoading by remember { mutableStateOf(true) }

    val dateFormatter = DateTimeFormatter.ofPattern("EEEE, MMM d")

    fun loadEntries() {
        scope.launch {
            isLoading = true
            val token = SessionStore.readAccessToken(context) ?: return@launch
            val userId = SessionStore.readUserId(context) ?: return@launch
            entries = fetchMentalEntriesForDate(selectedDateStr, token, userId)
            isLoading = false
        }
    }

    LaunchedEffect(selectedDateStr) { loadEntries() }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.Start
        ) {
            IconButton(onClick = onBack) {
                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
            }
        }

        HeroCard {
            Text(
                "Mental Health Data",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.height(4.dp))
            Text(
                "View mental health entries by day",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
        }

        // Date navigation
        BaseCard {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = { selectedDateStr = selectedDate.minusDays(1).toString() }) {
                    Icon(Icons.Default.ChevronLeft, contentDescription = "Previous day", tint = AppTheme.AccentPurple)
                }
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text(
                        when {
                            selectedDate == today -> "Today"
                            selectedDate == today.minusDays(1) -> "Yesterday"
                            else -> selectedDate.format(dateFormatter)
                        },
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                }
                IconButton(
                    onClick = { selectedDateStr = selectedDate.plusDays(1).toString() },
                    enabled = selectedDate < today
                ) {
                    Icon(
                        Icons.Default.ChevronRight,
                        contentDescription = "Next day",
                        tint = if (selectedDate < today) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f)
                    )
                }
            }
        }

        // Entries
        BaseCard {
            if (isLoading) {
                Row(
                    modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp),
                    horizontalArrangement = Arrangement.Center
                ) {
                    CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                }
            } else {
                val tableToMetric = mapOf(
                    "stress_index_daily" to MentalCardConfig.METRIC_STRESS,
                    "screen_time_daily" to MentalCardConfig.METRIC_SCREEN_TIME,
                    "screen_time_late_night" to MentalCardConfig.METRIC_LATE_SCREEN_TIME,
                    "ambient_noise_index_daily" to MentalCardConfig.METRIC_NOISE,
                    "phone_brightness_daily" to MentalCardConfig.METRIC_BRIGHTNESS,
                    "phone_volume_daily" to MentalCardConfig.METRIC_VOLUME,
                    "phone_dark_mode_daily" to MentalCardConfig.METRIC_DARK_MODE,
                    "phone_unlock_daily" to MentalCardConfig.METRIC_UNLOCKS
                )

                val bestByMetric = mutableMapOf<String, MentalDataEntry>()
                entries.forEach { entry ->
                    val metricKey = tableToMetric[entry.table] ?: return@forEach
                    val existing = bestByMetric[metricKey]
                    if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                        bestByMetric[metricKey] = entry
                    }
                }

                val selectedMetrics = mentalConfig.mentalDisplayMetrics.take(3)
                val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                // Top 3 selected metrics
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                    selectedMetrics.forEachIndexed { index, metric ->
                        val entry = bestByMetric[metric]
                        val value = entry?.value ?: "—"
                        val label = MentalCardConfig.labelFor(metric)
                        Column(horizontalAlignment = Alignment.CenterHorizontally) {
                            Text(value, color = slotColors.getOrElse(index) { slotColors.last() }, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
                            Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        }
                    }
                }

                Spacer(Modifier.height(4.dp))
                HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                Spacer(Modifier.height(8.dp))
                Text("All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                Spacer(Modifier.height(4.dp))

                val bestByTable = mutableMapOf<String, MentalDataEntry>()
                entries.forEach { entry ->
                    val existing = bestByTable[entry.table]
                    if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                        bestByTable[entry.table] = entry
                    }
                }

                // Show ALL metrics (not just ones with data), with "—" for missing
                val allMetricsExceptSelected = MentalCardConfig.ALL_MENTAL_METRICS
                    .filter { it !in selectedMetrics.toSet() }

                allMetricsExceptSelected.forEach { metric ->
                    val table = MentalCardConfig.metricToTable(metric)
                    val entry = bestByTable[table]
                    MentalDataRow(
                        entry = entry ?: MentalDataEntry(
                            table = table,
                            label = MentalCardConfig.labelFor(metric),
                            value = "—",
                            source = ""
                        )
                    )
                }
            }
        }
    }
}

@Composable
private fun MentalDataRow(entry: MentalDataEntry) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(entry.label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
            Text(entry.value, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
        }
    }
}

// ─── Supabase fetch ──────────────────────────────────────────────────────────

private suspend fun fetchMentalEntriesForDate(
    date: String,
    accessToken: String,
    userId: String
): List<MentalDataEntry> = withContext(Dispatchers.IO) {
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val key = BuildConfig.SUPABASE_ANON_KEY
    val entries = mutableListOf<MentalDataEntry>()
    val client = okhttp3.OkHttpClient()

    data class TableDef(val table: String, val label: String, val select: String)

    val tables = listOf(
        TableDef("stress_index_daily", "Stress", "date,value"),
        TableDef("screen_time_daily", "Screen Time", "date,source,total_hours"),
        TableDef("screen_time_late_night", "Late Screen Time", "date,source,value_hours"),
        TableDef("ambient_noise_index_daily", "Noise", "date,source,day_max_lmax,day_mean_lmean,day_min_lmean"),
        TableDef("phone_brightness_daily", "Brightness", "date,source,value_mean"),
        TableDef("phone_volume_daily", "Volume", "date,source,value_mean_pct"),
        TableDef("phone_dark_mode_daily", "Dark Mode", "date,source,value_hours"),
        TableDef("phone_unlock_daily", "Unlocks", "date,source,value_count")
    )

    for (td in tables) {
        try {
            val url = "$base/rest/v1/${td.table}?user_id=eq.$userId&date=eq.$date&select=${td.select}"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $accessToken")
                .build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                for (i in 0 until arr.length()) {
                    val obj = arr.getJSONObject(i)
                    val src = obj.optString("source", "unknown")
                    val value = formatMentalEntryValue(td.table, obj)
                    entries.add(MentalDataEntry(td.table, td.label, value, src))
                }
            }
        } catch (e: Exception) {
            Log.e("MentalDataHistory", "Failed to fetch ${td.table}: ${e.message}")
        }
    }

    // Live samples fallback for today — phone behavior + noise
    val today = java.time.LocalDate.now().toString()
    if (date == today) {
        val existingTables = entries.map { it.table }.toSet()

        // Screen time: fall back to screen_time_live for today
        if ("screen_time_daily" !in existingTables) {
            try {
                val url = "$base/rest/v1/screen_time_live?user_id=eq.$userId&date=eq.$date&select=value_hours"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $accessToken")
                    .build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    if (arr.length() > 0) {
                        val v = arr.getJSONObject(0).optDouble("value_hours")
                        if (!v.isNaN()) {
                            entries.add(MentalDataEntry("screen_time_daily", "Screen Time", String.format("%.1fh", v), "live"))
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e("MentalDataHistory", "screen_time_live fallback failed: ${e.message}")
            }
        }

        data class SamplesDef(
            val dailyTable: String,
            val samplesTable: String,
            val label: String,
            val tsColumn: String,
            val aggregation: String, // "avg", "max_int", "dark_mode", "noise"
            val column: String
        )

        val sampleFallbacks = listOf(
            SamplesDef("phone_brightness_daily", "phone_brightness_samples", "Brightness", "sampled_at", "avg", "value"),
            SamplesDef("phone_volume_daily", "phone_volume_samples", "Volume", "sampled_at", "avg", "value_pct"),
            SamplesDef("phone_unlock_daily", "phone_unlock_samples", "Unlocks", "sampled_at", "max_int", "value_count"),
            SamplesDef("phone_dark_mode_daily", "phone_dark_mode_samples", "Dark Mode", "sampled_at", "dark_mode", "is_dark"),
            SamplesDef("ambient_noise_index_daily", "ambient_noise_samples", "Noise", "start_ts", "noise", "l_mean")
        )

        for (sf in sampleFallbacks) {
            if (sf.dailyTable in existingTables) continue
            try {
                val url = "$base/rest/v1/${sf.samplesTable}?user_id=eq.$userId&${sf.tsColumn}=gte.${date}T00:00:00&${sf.tsColumn}=lt.${date}T23:59:59&select=${sf.column}"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $accessToken")
                    .build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    if (arr.length() > 0) {
                        val value = when (sf.aggregation) {
                            "avg" -> {
                                val vals = (0 until arr.length()).mapNotNull {
                                    arr.getJSONObject(it).optDouble(sf.column).takeIf { v -> !v.isNaN() }
                                }
                                if (vals.isNotEmpty()) {
                                    if (sf.dailyTable == "phone_volume_daily") "${vals.average().toInt()}%"
                                    else String.format("%.0f", vals.average())
                                } else null
                            }
                            "max_int" -> {
                                val vals = (0 until arr.length()).mapNotNull {
                                    val v = arr.getJSONObject(it).optInt(sf.column, Int.MIN_VALUE)
                                    if (v != Int.MIN_VALUE) v else null
                                }
                                vals.maxOrNull()?.toString()
                            }
                            "dark_mode" -> {
                                val total = arr.length()
                                val darkCount = (0 until total).count { arr.getJSONObject(it).optBoolean("is_dark", false) }
                                val hours = (darkCount.toDouble() / total) * 24.0
                                String.format("%.1fh", hours)
                            }
                            "noise" -> {
                                val lMeans = (0 until arr.length()).mapNotNull {
                                    arr.getJSONObject(it).optDouble("l_mean").takeIf { v -> !v.isNaN() }
                                }
                                if (lMeans.isNotEmpty()) {
                                    String.format("Avg: %.0f dB", lMeans.average())
                                } else null
                            }
                            else -> null
                        }
                        if (value != null) {
                            entries.add(MentalDataEntry(sf.dailyTable, sf.label, value, "live"))
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e("MentalDataHistory", "Samples fallback failed for ${sf.samplesTable}: ${e.message}")
            }
        }
    }

    entries
}

private fun formatMentalEntryValue(table: String, obj: org.json.JSONObject): String {
    return when (table) {
        "stress_index_daily" -> {
            val v = obj.optDouble("value")
            if (!v.isNaN()) String.format("%.0f", v) else "—"
        }
        "screen_time_daily" -> {
            val v = obj.optDouble("total_hours")
            if (!v.isNaN()) String.format("%.1fh", v) else "—"
        }
        "screen_time_late_night" -> {
            val v = obj.optDouble("value_hours")
            if (!v.isNaN()) String.format("%.1fh", v) else "—"
        }
        "ambient_noise_index_daily" -> {
            val high = obj.optDouble("day_max_lmax")
            val avg = obj.optDouble("day_mean_lmean")
            val low = obj.optDouble("day_min_lmean")
            if (!avg.isNaN()) {
                val parts = mutableListOf<String>()
                if (!low.isNaN()) parts.add("Low: ${String.format("%.0f", low)} dB")
                parts.add("Avg: ${String.format("%.0f", avg)} dB")
                if (!high.isNaN()) parts.add("High: ${String.format("%.0f", high)} dB")
                parts.joinToString(" • ")
            } else "—"
        }
        "phone_brightness_daily" -> {
            val v = obj.optDouble("value_mean")
            if (!v.isNaN()) String.format("%.0f", v) else "—"
        }
        "phone_volume_daily" -> {
            val v = obj.optDouble("value_mean_pct")
            if (!v.isNaN()) "${v.toInt()}%" else "—"
        }
        "phone_dark_mode_daily" -> {
            val v = obj.optDouble("value_hours")
            if (!v.isNaN()) String.format("%.1fh", v) else "—"
        }
        "phone_unlock_daily" -> {
            val v = obj.optInt("value_count", -1)
            if (v >= 0) "$v" else "—"
        }
        else -> "—"
    }
}

title: MentalHistoryGraph.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

data class MentalGraphDay(
    val date: String,
    val stress: Double?,
    val screenTimeHours: Double?,
    val lateScreenTimeHours: Double?,
    val noiseHigh: Double?,
    val noiseAvg: Double?,
    val noiseLow: Double?,
    val brightness: Double?,
    val volumePct: Double?,
    val darkModeHours: Double?,
    val unlockCount: Double?
)

data class MentalGraphResult(
    val days: List<MentalGraphDay>,
    val allTimeMin: Map<String, Float>,
    val allTimeMax: Map<String, Float>
)

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun MentalHistoryGraph(
    days: Int = 14,
    endDate: LocalDate = LocalDate.now(),
    onClick: (() -> Unit)? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    var graphResult by remember { mutableStateOf<MentalGraphResult?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    var selectedMetrics by remember { mutableStateOf<Set<String>>(setOf(MentalCardConfig.METRIC_STRESS)) }
    var migraineDates by remember { mutableStateOf<Set<String>>(emptySet()) }

    LaunchedEffect(days, endDate) {
        scope.launch {
            graphResult = loadMentalGraphData(context, days, endDate)
            migraineDates = MigraineOverlayHelper.fetchMigraineDates(context, days, endDate)
            isLoading = false
        }
    }

    val historyData: List<MentalGraphDay> = graphResult?.days ?: emptyList()
    val allTimeMin: Map<String, Float> = graphResult?.allTimeMin ?: emptyMap()
    val allTimeMax: Map<String, Float> = graphResult?.allTimeMax ?: emptyMap()
    val isNormalized = selectedMetrics.size >= 2
    val daysWithData: List<MentalGraphDay> = historyData.filter { day ->
        MentalCardConfig.GRAPHABLE_METRICS.any { getMentalDayValue(day, it) != null }
    }

    BaseCard(modifier = if (onClick != null) Modifier.clickable { onClick() } else Modifier) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "$days-Day Mental Health History",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            if (onClick != null) {
                Text("View Full →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
            }
        }

        Spacer(Modifier.height(8.dp))

        if (isLoading) {
            Row(
                modifier = Modifier.fillMaxWidth().height(150.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
            }
        } else if (historyData.isEmpty() || daysWithData.isEmpty()) {
            Text(
                text = "No mental health data available",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else if (selectedMetrics.isEmpty()) {
            Text(
                text = "Select a metric below",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else {
            // Legend
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                for (metric in selectedMetrics) {
                    val color = MentalCardConfig.colorFor(metric)
                    val label = MentalCardConfig.labelFor(metric)
                    val unit = MentalCardConfig.unitFor(metric)
                    val values: List<Float> = daysWithData.mapNotNull { getMentalDayValue(it, metric) }

                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Canvas(Modifier.size(8.dp)) { drawCircle(color) }
                        Spacer(Modifier.width(4.dp))
                        if (isNormalized) {
                            val minVal = allTimeMin[metric] ?: 0f
                            val maxVal = allTimeMax[metric] ?: 1f
                            Text(
                                text = "$label [${formatMentalValue(minVal, unit)}-${formatMentalValue(maxVal, unit)}]",
                                color = color,
                                style = MaterialTheme.typography.labelSmall
                            )
                        } else {
                            val avg = if (values.isNotEmpty()) values.average().toFloat() else 0f
                            Text(
                                text = "$label (avg: ${formatMentalValue(avg, unit)})",
                                color = color,
                                style = MaterialTheme.typography.labelSmall
                            )
                        }
                    }
                }
            }

            if (isNormalized) {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "⚠️ Normalized 0-1 scale • Dotted = $days days avg",
                    color = Color(0xFFFFB74D),
                    style = MaterialTheme.typography.labelSmall
                )
            } else if (daysWithData.isNotEmpty()) {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Dotted line = $days-day average",
                    color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                    style = MaterialTheme.typography.labelSmall
                )
            }

            if (migraineDates.isNotEmpty()) {
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Canvas(Modifier.size(8.dp)) { drawRect(Color(0xFFE57373).copy(alpha = 0.35f)) }
                    Spacer(Modifier.width(4.dp))
                    Text(
                        text = "Red bands = migraine days",
                        color = Color(0xFFE57373),
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            }

            Spacer(Modifier.height(8.dp))

            if (daysWithData.isEmpty()) {
                Text(
                    text = "No logged days in this period",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(vertical = 16.dp)
                )
            } else {
                val yAxisWidth = 50.dp

                val yTop: String
                val yMid: String
                val yBot: String

                if (isNormalized) {
                    yTop = "1.0"
                    yMid = "0.5"
                    yBot = "0.0"
                } else {
                    val metric = selectedMetrics.first()
                    val unit = MentalCardConfig.unitFor(metric)
                    val values: List<Float> = daysWithData.mapNotNull { getMentalDayValue(it, metric) }
                    val max = values.maxOrNull() ?: 1f
                    val min = values.minOrNull() ?: 0f
                    yTop = formatMentalValue(max, unit)
                    yMid = formatMentalValue((max + min) / 2, unit)
                    yBot = formatMentalValue(min, unit)
                }

                Row(modifier = Modifier.fillMaxWidth().height(150.dp)) {
                    Column(
                        modifier = Modifier.width(yAxisWidth).fillMaxHeight(),
                        verticalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(text = yTop, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = yMid, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = yBot, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }

                    Canvas(modifier = Modifier.weight(1f).fillMaxHeight()) {
                        val padding = 8.dp.toPx()
                        val graphWidth = size.width - padding * 2
                        val graphHeight = size.height - padding * 2
                        val dashWidth = 6.dp.toPx()
                        val gapWidth = 4.dp.toPx()

                        // Draw migraine bands
                        with(MigraineOverlayHelper) {
                            drawMigraineBands(
                                dateList = historyData.map { it.date },
                                migraineDates = migraineDates,
                                padding = padding,
                                graphWidth = graphWidth,
                                graphHeight = graphHeight
                            )
                        }

                        for (metric in selectedMetrics) {
                            val color = MentalCardConfig.colorFor(metric)

                            val indexedValues: List<Pair<Int, Float>> = historyData.mapIndexedNotNull { i, day ->
                                val value = getMentalDayValue(day, metric)
                                if (value != null) Pair(i, value) else null
                            }

                            if (indexedValues.isEmpty()) continue

                            val values: List<Float> = indexedValues.map { it.second }

                            val minVal: Float
                            val maxVal: Float
                            if (isNormalized) {
                                minVal = allTimeMin[metric] ?: 0f
                                maxVal = (allTimeMax[metric] ?: 1f).coerceAtLeast(minVal + 0.1f)
                            } else {
                                minVal = values.minOrNull() ?: 0f
                                maxVal = (values.maxOrNull() ?: 1f).coerceAtLeast(minVal + 0.1f)
                            }
                            val range = maxVal - minVal

                            val plotPoints: List<Pair<Int, Float>> = indexedValues.map { (idx, value) ->
                                Pair(idx, ((value - minVal) / range).coerceIn(0f, 1f))
                            }

                            // Dotted average
                            if (plotPoints.isNotEmpty()) {
                                val avgNormalized = plotPoints.map { it.second }.average().toFloat()
                                val avgY = padding + graphHeight - (avgNormalized * graphHeight)
                                var x = padding
                                while (x < size.width - padding) {
                                    drawLine(
                                        color.copy(alpha = 0.5f),
                                        Offset(x, avgY),
                                        Offset((x + dashWidth).coerceAtMost(size.width - padding), avgY),
                                        strokeWidth = 1.5.dp.toPx()
                                    )
                                    x += dashWidth + gapWidth
                                }
                            }

                            // Line
                            if (plotPoints.size > 1) {
                                val path = Path()
                                plotPoints.forEachIndexed { i, pair ->
                                    val x = padding + (pair.first.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                    val y = padding + graphHeight - (pair.second * graphHeight)
                                    if (i == 0) path.moveTo(x, y) else path.lineTo(x, y)
                                }
                                drawPath(path, color, style = Stroke(2.dp.toPx(), cap = StrokeCap.Round, join = StrokeJoin.Round))
                            }

                            // Dots
                            for (pair in plotPoints) {
                                val x = padding + (pair.first.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                val y = padding + graphHeight - (pair.second * graphHeight)
                                drawCircle(color, 4.dp.toPx(), Offset(x, y))
                            }
                        }
                    }
                }

                // Date labels
                Spacer(Modifier.height(4.dp))
                Row(
                    modifier = Modifier.fillMaxWidth().padding(start = yAxisWidth),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    val fmt = DateTimeFormatter.ofPattern("MMM d")
                    if (historyData.isNotEmpty()) {
                        val firstLabel = try { LocalDate.parse(historyData.first().date).format(fmt) } catch (_: Exception) { historyData.first().date }
                        val lastLabel = try { LocalDate.parse(historyData.last().date).format(fmt) } catch (_: Exception) { historyData.last().date }
                        Text(text = firstLabel, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = lastLabel, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }

        Spacer(Modifier.height(12.dp))

        Text(
            text = "Select Metrics" + if (selectedMetrics.size > 1) " (${selectedMetrics.size} selected)" else "",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )
        Spacer(Modifier.height(8.dp))

        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(6.dp),
            verticalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            for (metric in MentalCardConfig.GRAPHABLE_METRICS) {
                val isSelected = metric in selectedMetrics
                val chipColor = MentalCardConfig.colorFor(metric)
                val chipLabel = MentalCardConfig.labelFor(metric)

                FilterChip(
                    selected = isSelected,
                    onClick = {
                        selectedMetrics = if (isSelected) {
                            selectedMetrics.minus(metric)
                        } else {
                            selectedMetrics.plus(metric)
                        }
                    },
                    label = { Text(text = chipLabel, style = MaterialTheme.typography.labelSmall) },
                    colors = FilterChipDefaults.filterChipColors(
                        selectedContainerColor = chipColor.copy(alpha = 0.3f),
                        selectedLabelColor = chipColor,
                        containerColor = AppTheme.BaseCardContainer,
                        labelColor = AppTheme.SubtleTextColor
                    ),
                    border = FilterChipDefaults.filterChipBorder(
                        borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        selectedBorderColor = chipColor,
                        enabled = true,
                        selected = isSelected
                    )
                )
            }
        }
    }
}

private fun getMentalDayValue(day: MentalGraphDay, metric: String): Float? {
    return when (metric) {
        MentalCardConfig.METRIC_STRESS -> day.stress?.toFloat()
        MentalCardConfig.METRIC_SCREEN_TIME -> day.screenTimeHours?.toFloat()
        MentalCardConfig.METRIC_LATE_SCREEN_TIME -> day.lateScreenTimeHours?.toFloat()
        MentalCardConfig.METRIC_NOISE_HIGH -> day.noiseHigh?.toFloat()
        MentalCardConfig.METRIC_NOISE_AVG -> day.noiseAvg?.toFloat()
        MentalCardConfig.METRIC_NOISE_LOW -> day.noiseLow?.toFloat()
        MentalCardConfig.METRIC_BRIGHTNESS -> day.brightness?.toFloat()
        MentalCardConfig.METRIC_VOLUME -> day.volumePct?.toFloat()
        MentalCardConfig.METRIC_DARK_MODE -> day.darkModeHours?.toFloat()
        MentalCardConfig.METRIC_UNLOCKS -> day.unlockCount?.toFloat()
        else -> null
    }
}

private fun formatMentalValue(value: Float, unit: String): String {
    return when (unit) {
        "%" -> "${value.toInt()}%"
        "h" -> String.format("%.1fh", value)
        "" -> "%,d".format(value.toInt())
        else -> String.format("%.1f%s", value, unit)
    }
}

private suspend fun loadMentalGraphData(
    ctx: android.content.Context,
    days: Int,
    endDate: LocalDate = LocalDate.now()
): MentalGraphResult = withContext(Dispatchers.IO) {
    try {
        val token = SessionStore.getValidAccessToken(ctx) ?: return@withContext MentalGraphResult(emptyList(), emptyMap(), emptyMap())
        val userId = SessionStore.readUserId(ctx) ?: return@withContext MentalGraphResult(emptyList(), emptyMap(), emptyMap())

        val startDate = endDate.minusDays(days.toLong() - 1)
        val startStr = startDate.toString()
        val endStr = endDate.toString()
        val fetchLimit = days + 14

        val client = okhttp3.OkHttpClient()

        fun fetchDailyDoubles(table: String, column: String): List<Pair<String, Double>> {
            return try {
                val url = "${BuildConfig.SUPABASE_URL}/rest/v1/$table?user_id=eq.$userId&select=date,$column&order=date.desc&limit=$fetchLimit"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    .addHeader("Authorization", "Bearer $token").build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    (0 until arr.length()).mapNotNull { i ->
                        val obj = arr.getJSONObject(i)
                        val date = obj.optString("date", "")
                        val value = obj.optDouble(column)
                        if (date.isNotBlank() && !value.isNaN()) Pair(date, value) else null
                    }
                } else emptyList()
            } catch (_: Exception) { emptyList() }
        }

        val stressList = fetchDailyDoubles("stress_index_daily", "value")
        val screenTimeList = fetchDailyDoubles("screen_time_daily", "total_hours")
        val lateScreenList = fetchDailyDoubles("screen_time_late_night", "value_hours")
        val noiseHighList = fetchDailyDoubles("ambient_noise_index_daily", "day_max_lmax")
        val noiseAvgList = fetchDailyDoubles("ambient_noise_index_daily", "day_mean_lmean")
        val noiseLowList = fetchDailyDoubles("ambient_noise_index_daily", "day_min_lmean")
        val brightnessList = fetchDailyDoubles("phone_brightness_daily", "value_mean")
        val volumeList = fetchDailyDoubles("phone_volume_daily", "value_mean_pct")
        val darkModeList = fetchDailyDoubles("phone_dark_mode_daily", "value_hours")
        val unlockList = fetchDailyDoubles("phone_unlock_daily", "value_count")

        // Live samples fallback for today — if no daily row exists yet
        val todayStr = LocalDate.now().toString()
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val key = BuildConfig.SUPABASE_ANON_KEY

        fun fetchTodaySamplesAvg(table: String, column: String, tsColumn: String = "sampled_at"): Double? {
            return try {
                val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${todayStr}T00:00:00&${tsColumn}=lt.${todayStr}T23:59:59&select=$column"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $token").build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    if (arr.length() > 0) {
                        val values = (0 until arr.length()).mapNotNull {
                            arr.getJSONObject(it).optDouble(column).takeIf { v -> !v.isNaN() }
                        }
                        if (values.isNotEmpty()) values.average() else null
                    } else null
                } else null
            } catch (_: Exception) { null }
        }

        fun fetchTodaySamplesMax(table: String, column: String, tsColumn: String = "sampled_at"): Double? {
            return try {
                val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${todayStr}T00:00:00&${tsColumn}=lt.${todayStr}T23:59:59&select=$column"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $token").build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    if (arr.length() > 0) {
                        val values = (0 until arr.length()).mapNotNull {
                            val v = arr.getJSONObject(it).optInt(column, Int.MIN_VALUE)
                            if (v != Int.MIN_VALUE) v.toDouble() else null
                        }
                        values.maxOrNull()
                    } else null
                } else null
            } catch (_: Exception) { null }
        }

        fun fetchTodayDarkModeHours(): Double? {
            return try {
                val url = "$base/rest/v1/phone_dark_mode_samples?user_id=eq.$userId&sampled_at=gte.${todayStr}T00:00:00&sampled_at=lt.${todayStr}T23:59:59&select=is_dark"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $token").build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    val total = arr.length()
                    if (total > 0) {
                        val darkCount = (0 until total).count { arr.getJSONObject(it).optBoolean("is_dark", false) }
                        (darkCount.toDouble() / total) * 24.0
                    } else null
                } else null
            } catch (_: Exception) { null }
        }

        fun fetchTodaySamplesMin(table: String, column: String, tsColumn: String = "sampled_at"): Double? {
            return try {
                val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${todayStr}T00:00:00&${tsColumn}=lt.${todayStr}T23:59:59&select=$column"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $token").build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    if (arr.length() > 0) {
                        val values = (0 until arr.length()).mapNotNull {
                            arr.getJSONObject(it).optDouble(column).takeIf { v -> !v.isNaN() }
                        }
                        values.minOrNull()
                    } else null
                } else null
            } catch (_: Exception) { null }
        }

        fun fetchTodaySamplesMaxDouble(table: String, column: String, tsColumn: String = "sampled_at"): Double? {
            return try {
                val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${todayStr}T00:00:00&${tsColumn}=lt.${todayStr}T23:59:59&select=$column"
                val request = okhttp3.Request.Builder().url(url).get()
                    .addHeader("apikey", key)
                    .addHeader("Authorization", "Bearer $token").build()
                val response = client.newCall(request).execute()
                val body = response.body?.string()
                if (response.isSuccessful && !body.isNullOrBlank()) {
                    val arr = org.json.JSONArray(body)
                    if (arr.length() > 0) {
                        val values = (0 until arr.length()).mapNotNull {
                            arr.getJSONObject(it).optDouble(column).takeIf { v -> !v.isNaN() }
                        }
                        values.maxOrNull()
                    } else null
                } else null
            } catch (_: Exception) { null }
        }

        // Merge live samples into the lists if today has no daily row
        val mutableBrightness = brightnessList.toMutableList()
        val mutableVolume = volumeList.toMutableList()
        val mutableDarkMode = darkModeList.toMutableList()
        val mutableUnlocks = unlockList.toMutableList()
        val mutableNoiseHigh = noiseHighList.toMutableList()
        val mutableNoiseAvg = noiseAvgList.toMutableList()
        val mutableNoiseLow = noiseLowList.toMutableList()
        val mutableScreenTime = screenTimeList.toMutableList()

        if (todayStr >= startStr && todayStr <= endStr) {
            // Screen time: fall back to screen_time_live
            if (mutableScreenTime.none { it.first == todayStr }) {
                fetchDailyDoubles("screen_time_live", "value_hours")
                    .find { it.first == todayStr }?.let {
                        mutableScreenTime.add(it)
                    }
            }
            if (mutableBrightness.none { it.first == todayStr }) {
                fetchTodaySamplesAvg("phone_brightness_samples", "value")?.let {
                    mutableBrightness.add(Pair(todayStr, it))
                }
            }
            if (mutableVolume.none { it.first == todayStr }) {
                fetchTodaySamplesAvg("phone_volume_samples", "value_pct")?.let {
                    mutableVolume.add(Pair(todayStr, it))
                }
            }
            if (mutableDarkMode.none { it.first == todayStr }) {
                fetchTodayDarkModeHours()?.let {
                    mutableDarkMode.add(Pair(todayStr, it))
                }
            }
            if (mutableUnlocks.none { it.first == todayStr }) {
                fetchTodaySamplesMax("phone_unlock_samples", "value_count")?.let {
                    mutableUnlocks.add(Pair(todayStr, it))
                }
            }
            // Noise: high = max of l_max, avg = avg of l_mean, low = min of l_mean
            if (mutableNoiseHigh.none { it.first == todayStr }) {
                fetchTodaySamplesMaxDouble("ambient_noise_samples", "l_max", "start_ts")?.let {
                    mutableNoiseHigh.add(Pair(todayStr, it))
                }
            }
            if (mutableNoiseAvg.none { it.first == todayStr }) {
                fetchTodaySamplesAvg("ambient_noise_samples", "l_mean", "start_ts")?.let {
                    mutableNoiseAvg.add(Pair(todayStr, it))
                }
            }
            if (mutableNoiseLow.none { it.first == todayStr }) {
                fetchTodaySamplesMin("ambient_noise_samples", "l_mean", "start_ts")?.let {
                    mutableNoiseLow.add(Pair(todayStr, it))
                }
            }
        }

        val stressMap = stressList.associateBy { it.first }
        val screenTimeMap = mutableScreenTime.associateBy { it.first }
        val lateScreenMap = lateScreenList.associateBy { it.first }
        val noiseHighMap = mutableNoiseHigh.associateBy { it.first }
        val noiseAvgMap = mutableNoiseAvg.associateBy { it.first }
        val noiseLowMap = mutableNoiseLow.associateBy { it.first }
        val brightnessMap = mutableBrightness.associateBy { it.first }
        val volumeMap = mutableVolume.associateBy { it.first }
        val darkModeMap = mutableDarkMode.associateBy { it.first }
        val unlockMap = mutableUnlocks.associateBy { it.first }

        val allDates = mutableSetOf<String>()
        listOf(stressMap, screenTimeMap, lateScreenMap, noiseHighMap, noiseAvgMap, noiseLowMap, brightnessMap, volumeMap, darkModeMap, unlockMap).forEach {
            allDates.addAll(it.keys)
        }

        val graphDays = allDates
            .filter { it >= startStr && it <= endStr }
            .sorted()
            .map { date ->
                MentalGraphDay(
                    date = date,
                    stress = stressMap[date]?.second,
                    screenTimeHours = screenTimeMap[date]?.second,
                    lateScreenTimeHours = lateScreenMap[date]?.second,
                    noiseHigh = noiseHighMap[date]?.second,
                    noiseAvg = noiseAvgMap[date]?.second,
                    noiseLow = noiseLowMap[date]?.second,
                    brightness = brightnessMap[date]?.second,
                    volumePct = volumeMap[date]?.second,
                    darkModeHours = darkModeMap[date]?.second,
                    unlockCount = unlockMap[date]?.second
                )
            }

        val allTimeMin = mutableMapOf<String, Float>()
        val allTimeMax = mutableMapOf<String, Float>()

        for (metric in MentalCardConfig.GRAPHABLE_METRICS) {
            val values: List<Float> = graphDays.mapNotNull { getMentalDayValue(it, metric) }
            if (values.isNotEmpty()) {
                allTimeMin[metric] = values.minOrNull() ?: 0f
                allTimeMax[metric] = values.maxOrNull() ?: 1f
            }
        }

        MentalGraphResult(graphDays, allTimeMin, allTimeMax)
    } catch (_: Exception) {
        MentalGraphResult(emptyList(), emptyMap(), emptyMap())
    }
}

title: MetricSettingsMapHelper.kt
text:
package com.migraineme

object MetricSettingsMapHelper {

    fun mapKey(metric: String, preferredSource: String?): String {
        return if (preferredSource != null) {
            "${metric}_${preferredSource}"
        } else {
            "${metric}_null"
        }
    }

    fun toMap(
        settings: List<EdgeFunctionsService.MetricSettingResponse>
    ): Map<String, EdgeFunctionsService.MetricSettingResponse> {
        return settings.associateBy { mapKey(it.metric, it.preferredSource) }
    }

    fun isEnabled(
        map: Map<String, EdgeFunctionsService.MetricSettingResponse>,
        metric: String,
        preferredSource: String?,
        defaultValue: Boolean
    ): Boolean {
        return map[mapKey(metric, preferredSource)]?.enabled ?: defaultValue
    }
}

title: MetricSourceSupport.kt
text:
package com.migraineme

/**
 * Defines which wearable sources support which metrics.
 * Used to filter the source picker options in DataSettingsScreen.
 *
 * SINGLE SOURCE OF TRUTH for metric-to-source mapping.
 * Update this file when adding new metrics or sources.
 */
object MetricSourceSupport {

    // Metrics that WHOOP provides
    private val whoopMetrics = setOf(
        "sleep_duration_daily",
        "sleep_score_daily",
        "sleep_efficiency_daily",
        "sleep_stages_daily",
        "sleep_disturbances_daily",
        "fell_asleep_time_daily",
        "woke_up_time_daily",
        "recovery_score_daily",
        "resting_hr_daily",
        "hrv_daily",
        "skin_temp_daily",
        "spo2_daily",
        "time_in_high_hr_zones_daily",
        "activity_hr_zones_sessions",
        "stress_index_daily"
    )

    // Metrics that Health Connect provides
    private val healthConnectMetrics = setOf(
        "sleep_duration_daily",
        "sleep_stages_daily",
        "fell_asleep_time_daily",
        "woke_up_time_daily",
        "resting_hr_daily",
        "hrv_daily",
        "skin_temp_daily",
        "spo2_daily",
        "time_in_high_hr_zones_daily",
        "steps_daily",
        "weight_daily",
        "body_fat_daily",
        "hydration_daily",
        "blood_pressure_daily",
        "blood_glucose_daily",
        "respiratory_rate_daily",
        "stress_index_daily"
    )

    fun supportsMetric(source: WearableSource, metric: String): Boolean {
        return when (source) {
            WearableSource.WHOOP -> metric in whoopMetrics
            WearableSource.HEALTH_CONNECT -> metric in healthConnectMetrics
        }
    }

    fun getSupportedSources(metric: String): List<WearableSource> {
        return buildList {
            if (metric in whoopMetrics) add(WearableSource.WHOOP)
            if (metric in healthConnectMetrics) add(WearableSource.HEALTH_CONNECT)
        }
    }
}

title: MetricsSyncManager.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHostState
import io.ktor.client.HttpClient
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.util.Date

/**
 * Called from LoginScreen after successful auth.
 *
 * Responsibilities:
 * - Upload WHOOP token to Supabase (server worker source of truth)
 * - Seed default metric settings for new users
 * - Seed default trigger settings for new users
 *
 * Does NOT:
 * - Change Supabase auth
 * - Change Whoop auth structure
 * - Refresh WHOOP tokens (server handles all refreshes)
 * - Run/schedule on-device WHOOP daily sync workers (WHOOP ingestion is backend-driven now)
 */
object MetricsSyncManager {

    private val baseUrl: String = BuildConfig.SUPABASE_URL.trimEnd('/')
    private val anonKey: String = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient(Android) {
        install(ContentNegotiation) {
            json(
                Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                    encodeDefaults = true
                    explicitNulls = false
                }
            )
        }
    }

    @Serializable
    private data class EmptyBody(val ok: Boolean = true)

    @Serializable
    private data class UpsertWhoopTokenBody(
        val access_token: String,
        val refresh_token: String,
        val token_type: String,
        val expires_at: String?
    )

    private suspend fun enqueueLoginBackfillBestEffort(accessToken: String) {
        val url = "$baseUrl/functions/v1/enqueue-login-backfill"

        try {
            val resp = client.post(url) {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", anonKey)
                contentType(ContentType.Application.Json)
                setBody(EmptyBody())
            }

            if (!resp.status.isSuccess()) {
                val txt = runCatching { resp.bodyAsText() }.getOrNull()
                Log.w(
                    "MetricsSyncManager",
                    "enqueue-login-backfill failed: HTTP ${resp.status.value} ${txt ?: ""}".trim()
                )
            } else {
                Log.d("MetricsSyncManager", "enqueue-login-backfill ok")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "enqueue-login-backfill error: ${t.message}")
        }
    }

    private suspend fun upsertWhoopTokenToSupabaseBestEffort(
        context: Context,
        accessToken: String
    ) {
        val appCtx = context.applicationContext
        val localTok = runCatching { WhoopTokenStore(appCtx).load() }.getOrNull() ?: return

        val url = "$baseUrl/functions/v1/upsert-whoop-token"

        val expiresAtIso = if (localTok.expiresAtMillis > 0L) {
            runCatching { Date(localTok.expiresAtMillis).toInstant().toString() }.getOrNull()
        } else {
            null
        }

        val body = UpsertWhoopTokenBody(
            access_token = localTok.accessToken,
            refresh_token = localTok.refreshToken,
            token_type = localTok.tokenType.ifBlank { "Bearer" },
            expires_at = expiresAtIso
        )

        try {
            val resp = client.post(url) {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", anonKey)
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            if (!resp.status.isSuccess()) {
                val txt = runCatching { resp.bodyAsText() }.getOrNull()
                Log.w(
                    "MetricsSyncManager",
                    "upsert-whoop-token failed: HTTP ${resp.status.value} ${txt ?: ""}".trim()
                )
            } else {
                Log.d("MetricsSyncManager", "upsert-whoop-token ok")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "upsert-whoop-token error: ${t.message}")
        }
    }

    private suspend fun seedMetricSettingsBestEffort(context: Context) {
        try {
            val ok = EdgeFunctionsService().seedDefaultMetricSettings(context)
            if (ok) {
                Log.d("MetricsSyncManager", "seedDefaultMetricSettings ok")
            } else {
                Log.w("MetricsSyncManager", "seedDefaultMetricSettings partial failure")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "seedDefaultMetricSettings error: ${t.message}")
        }
    }

    private suspend fun seedTriggerSettingsBestEffort(context: Context) {
        try {
            val ok = EdgeFunctionsService().seedDefaultTriggerSettings(context)
            if (ok) {
                Log.d("MetricsSyncManager", "seedDefaultTriggerSettings ok")
            } else {
                Log.w("MetricsSyncManager", "seedDefaultTriggerSettings partial failure")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "seedDefaultTriggerSettings error: ${t.message}")
        }
    }

    private suspend fun seedRiskDecayWeightsBestEffort(context: Context) {
        try {
            val ok = EdgeFunctionsService().seedDefaultRiskDecayWeights(context)
            if (ok) {
                Log.d("MetricsSyncManager", "seedDefaultRiskDecayWeights ok")
            } else {
                Log.w("MetricsSyncManager", "seedDefaultRiskDecayWeights partial failure")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "seedDefaultRiskDecayWeights error: ${t.message}")
        }
    }

    private suspend fun seedRiskGaugeThresholdsBestEffort(context: Context) {
        try {
            val ok = EdgeFunctionsService().seedDefaultRiskGaugeThresholds(context)
            if (ok) {
                Log.d("MetricsSyncManager", "seedDefaultRiskGaugeThresholds ok")
            } else {
                Log.w("MetricsSyncManager", "seedDefaultRiskGaugeThresholds partial failure")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "seedDefaultRiskGaugeThresholds error: ${t.message}")
        }
    }

    private fun isWhoopMetricEnabled(
        settings: List<EdgeFunctionsService.MetricSettingResponse>,
        metric: String
    ): Boolean {
        val setting = settings.find { it.metric == metric } ?: return false
        return setting.enabled && setting.preferredSource == "whoop"
    }

    suspend fun onLogin(
        context: Context,
        token: String,
        snackbarHostState: SnackbarHostState
    ) {
        val appCtx = context.applicationContext

        withContext(Dispatchers.IO) {
            try {
                // Enqueue backfill jobs on login (best-effort)
                enqueueLoginBackfillBestEffort(token)

                // If WHOOP token exists locally, upload it to Supabase (best-effort)
                upsertWhoopTokenToSupabaseBestEffort(appCtx, token)

                // Seed default metric settings (best-effort, ignores duplicates)
                seedMetricSettingsBestEffort(appCtx)

                // Seed default trigger settings (best-effort, ignores duplicates)
                seedTriggerSettingsBestEffort(appCtx)

                // Seed default risk decay weights (best-effort, ignores duplicates)
                seedRiskDecayWeightsBestEffort(appCtx)

                // Seed default risk gauge thresholds (best-effort, ignores duplicates)
                seedRiskGaugeThresholdsBestEffort(appCtx)

                // WHOOP connection = token exists locally
                val whoopConnected = runCatching { WhoopTokenStore(appCtx).load() != null }.getOrDefault(false)

                // Get metric settings from Supabase
                val settings = try {
                    EdgeFunctionsService().getMetricSettings(appCtx)
                } catch (e: Exception) {
                    Log.w("MetricsSyncManager", "Failed to get metric settings: ${e.message}")
                    emptyList()
                }

                val whoopSleepEnabled =
                    isWhoopMetricEnabled(settings, "sleep_duration_daily") ||
                            isWhoopMetricEnabled(settings, "sleep_score_daily") ||
                            isWhoopMetricEnabled(settings, "sleep_efficiency_daily") ||
                            isWhoopMetricEnabled(settings, "sleep_stages_daily") ||
                            isWhoopMetricEnabled(settings, "sleep_disturbances_daily") ||
                            isWhoopMetricEnabled(settings, "fell_asleep_time_daily") ||
                            isWhoopMetricEnabled(settings, "woke_up_time_daily")

                val whoopPhysicalEnabled =
                    isWhoopMetricEnabled(settings, "recovery_score_daily") ||
                            isWhoopMetricEnabled(settings, "resting_hr_daily") ||
                            isWhoopMetricEnabled(settings, "hrv_daily") ||
                            isWhoopMetricEnabled(settings, "skin_temp_daily") ||
                            isWhoopMetricEnabled(settings, "spo2_daily") ||
                            isWhoopMetricEnabled(settings, "time_in_high_hr_zones_daily") ||
                            isWhoopMetricEnabled(settings, "steps_daily")

                if (whoopConnected && (whoopSleepEnabled || whoopPhysicalEnabled)) {
                    // Server (sync-worker) handles all WHOOP token refreshes and data sync.
                    // App must never refresh locally to avoid racing and burning the refresh token.
                    Log.d("MetricsSyncManager", "WHOOP connected and metrics enabled — server handles sync")
                } else if (!whoopConnected && (whoopSleepEnabled || whoopPhysicalEnabled)) {
                    withContext(Dispatchers.Main) {
                        snackbarHostState.showSnackbar(
                            message = "Whoop not connected — connect Whoop to collect data.",
                            duration = SnackbarDuration.Short
                        )
                    }
                }

            } catch (t: Throwable) {
                Log.w("MetricsSyncManager", "onLogin error: ${t.message}")
            }

            Unit
        }
    }
}

title: MetricToggleHelper.kt
text:
package com.migraineme

import android.content.Context

object MetricToggleHelper {

    /**
     * Toggle a metric ON or OFF
     *
     * This function ONLY schedules or cancels workers.
     * State management is handled separately via Supabase.
     *
     * @param context Application context
     * @param metric The metric name (e.g., "nutrition", "menstruation")
     * @param enabled True to enable, false to disable
     */
    fun toggle(
        context: Context,
        metric: String,
        enabled: Boolean
    ) {
        android.util.Log.d("MetricToggle", "Toggling $metric to ${if (enabled) "ON" else "OFF"}")

        // Schedule or cancel workers based on metric type
        if (enabled) {
            when (metric) {
                "nutrition" -> {
                    NutritionSyncScheduler.schedule(context)
                    android.util.Log.d("MetricToggle", "Scheduled nutrition workers")
                }
                "menstruation" -> {
                    MenstruationSyncScheduler.schedule(context)
                    android.util.Log.d("MetricToggle", "Scheduled menstruation workers")
                }
                "ambient_noise_samples" -> {
                    AmbientNoiseSampleWorker.schedule(context)
                    AmbientNoiseWatchdogWorker.schedule(context)
                    android.util.Log.d("MetricToggle", "Scheduled ambient noise workers")
                }
                "screen_time_daily" -> {

                    android.util.Log.d("MetricToggle", "Scheduled screen time workers")
                }
                "phone_brightness_daily",
                "phone_volume_daily",
                "phone_dark_mode_daily",
                "phone_unlock_daily" -> {
                    // No dedicated worker to schedule — collected by PhoneBehaviorSyncWorker
                    // which is triggered by FCM sync_hourly
                    android.util.Log.d("MetricToggle", "Phone behavior metric $metric enabled (uses FCM sync)")
                }
            }
        } else {
            when (metric) {
                "nutrition" -> {
                    NutritionSyncScheduler.cancel(context)
                    android.util.Log.d("MetricToggle", "Cancelled nutrition workers")
                }
                "menstruation" -> {
                    MenstruationSyncScheduler.cancel(context)
                    android.util.Log.d("MetricToggle", "Cancelled menstruation workers")
                }
                "ambient_noise_samples" -> {
                    AmbientNoiseSampleWorker.cancel(context)
                    AmbientNoiseWatchdogWorker.cancel(context)
                    android.util.Log.d("MetricToggle", "Cancelled ambient noise workers")
                }
                "screen_time_daily" -> {

                    android.util.Log.d("MetricToggle", "Cancelled screen time workers")
                }
                "phone_brightness_daily",
                "phone_volume_daily",
                "phone_dark_mode_daily",
                "phone_unlock_daily" -> {
                    // No dedicated worker to cancel — PhoneBehaviorSyncWorker checks
                    // metric_settings each run and skips disabled metrics
                    android.util.Log.d("MetricToggle", "Phone behavior metric $metric disabled")
                }
            }
        }
    }
}

title: MicrophonePermissionHelper.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import androidx.core.content.ContextCompat

/**
 * Helper for managing RECORD_AUDIO and POST_NOTIFICATIONS permissions for ambient noise sampling.
 *
 * Android 13+ requires POST_NOTIFICATIONS to show the foreground notification needed for microphone access.
 */
object MicrophonePermissionHelper {

    /**
     * Check if RECORD_AUDIO permission is granted.
     */
    fun hasPermission(context: Context): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Check if POST_NOTIFICATIONS permission is granted (Android 13+).
     * Required to show foreground notification for microphone access.
     */
    fun hasNotificationPermission(context: Context): Boolean {
        // Only required on Android 13+
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
            return true
        }

        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.POST_NOTIFICATIONS
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Check if BOTH microphone AND notification permissions are granted.
     * Both are required for ambient noise sampling to work in background.
     */
    fun hasAllPermissions(context: Context): Boolean {
        return hasPermission(context) && hasNotificationPermission(context)
    }

    /**
     * Get the list of permissions that need to be requested.
     */
    fun getRequiredPermissions(): List<String> {
        return buildList {
            add(Manifest.permission.RECORD_AUDIO)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                add(Manifest.permission.POST_NOTIFICATIONS)
            }
        }
    }
}

title: MigraineHubScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.Fill
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

/* -- Custom hand-drawn icons for the hub -- */

private fun DrawScope.drawMigraineIcon(color: Color) {
    val w = size.width; val h = size.height
    val stroke = Stroke(w * 0.035f, cap = StrokeCap.Round, join = StrokeJoin.Round)
    // Center pain point
    drawCircle(color.copy(alpha = 0.6f), radius = w * 0.08f, center = Offset(w * 0.5f, h * 0.5f), style = Fill)
    drawCircle(color, radius = w * 0.15f, center = Offset(w * 0.5f, h * 0.5f), style = Stroke(w * 0.03f, cap = StrokeCap.Round))
    // Radiating pain spikes - cardinal
    drawLine(color, Offset(w * 0.50f, h * 0.30f), Offset(w * 0.50f, h * 0.08f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.50f, h * 0.70f), Offset(w * 0.50f, h * 0.92f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.30f, h * 0.50f), Offset(w * 0.08f, h * 0.50f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.70f, h * 0.50f), Offset(w * 0.92f, h * 0.50f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    // Radiating pain spikes - diagonal
    drawLine(color, Offset(w * 0.36f, h * 0.36f), Offset(w * 0.20f, h * 0.20f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.64f, h * 0.36f), Offset(w * 0.80f, h * 0.20f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.36f, h * 0.64f), Offset(w * 0.20f, h * 0.80f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.64f, h * 0.64f), Offset(w * 0.80f, h * 0.80f), strokeWidth = w * 0.03f, cap = StrokeCap.Round)
    // Pulsing ring
    drawCircle(color, radius = w * 0.24f, center = Offset(w * 0.5f, h * 0.5f), style = stroke)
}

private fun DrawScope.drawTriggerIcon(color: Color) {
    val w = size.width; val h = size.height
    // Lightning bolt
    val bolt = Path().apply {
        moveTo(w * 0.55f, h * 0.05f)
        lineTo(w * 0.30f, h * 0.45f)
        lineTo(w * 0.50f, h * 0.45f)
        lineTo(w * 0.28f, h * 0.95f)
        lineTo(w * 0.70f, h * 0.40f)
        lineTo(w * 0.50f, h * 0.40f)
        lineTo(w * 0.70f, h * 0.05f)
        close()
    }
    drawPath(bolt, color, style = Fill)
}

private fun DrawScope.drawMedicineIcon(color: Color) {
    val w = size.width; val h = size.height
    val stroke = Stroke(w * 0.07f, cap = StrokeCap.Round, join = StrokeJoin.Round)
    // Pill capsule
    val r = w * 0.18f
    drawRoundRect(color, topLeft = Offset(w * 0.18f, h * 0.15f),
        size = androidx.compose.ui.geometry.Size(w * 0.64f, h * 0.70f),
        cornerRadius = androidx.compose.ui.geometry.CornerRadius(r, r), style = stroke)
    // Divider line in middle
    drawLine(color, Offset(w * 0.18f, h * 0.50f), Offset(w * 0.82f, h * 0.50f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
    // Plus sign on top half
    drawLine(color, Offset(w * 0.50f, h * 0.25f), Offset(w * 0.50f, h * 0.40f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.42f, h * 0.325f), Offset(w * 0.58f, h * 0.325f), strokeWidth = w * 0.06f, cap = StrokeCap.Round)
}

private fun DrawScope.drawReliefIcon(color: Color) {
    val w = size.width; val h = size.height
    val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
    // Leaf shape
    val leaf = Path().apply {
        moveTo(w * 0.50f, h * 0.08f)
        cubicTo(w * 0.85f, h * 0.15f, w * 0.90f, h * 0.55f, w * 0.50f, h * 0.75f)
        cubicTo(w * 0.10f, h * 0.55f, w * 0.15f, h * 0.15f, w * 0.50f, h * 0.08f)
        close()
    }
    drawPath(leaf, color, style = stroke)
    // Leaf vein - center
    drawLine(color, Offset(w * 0.50f, h * 0.18f), Offset(w * 0.50f, h * 0.68f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
    // Leaf veins - side
    drawLine(color, Offset(w * 0.50f, h * 0.35f), Offset(w * 0.34f, h * 0.26f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.50f, h * 0.35f), Offset(w * 0.66f, h * 0.26f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.50f, h * 0.50f), Offset(w * 0.30f, h * 0.42f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.50f, h * 0.50f), Offset(w * 0.70f, h * 0.42f), strokeWidth = w * 0.035f, cap = StrokeCap.Round)
    // Water droplet below
    val drop = Path().apply {
        moveTo(w * 0.50f, h * 0.78f)
        cubicTo(w * 0.44f, h * 0.85f, w * 0.38f, h * 0.92f, w * 0.50f, h * 0.98f)
        cubicTo(w * 0.62f, h * 0.92f, w * 0.56f, h * 0.85f, w * 0.50f, h * 0.78f)
        close()
    }
    drawPath(drop, color, style = Fill)
}

private fun DrawScope.drawProdromeIcon(color: Color) {
    val w = size.width; val h = size.height
    val stroke = Stroke(w * 0.06f, cap = StrokeCap.Round, join = StrokeJoin.Round)
    // Eye shape
    val top = Path().apply {
        moveTo(w * 0.05f, h * 0.50f)
        cubicTo(w * 0.25f, h * 0.15f, w * 0.75f, h * 0.15f, w * 0.95f, h * 0.50f)
    }
    val bottom = Path().apply {
        moveTo(w * 0.05f, h * 0.50f)
        cubicTo(w * 0.25f, h * 0.85f, w * 0.75f, h * 0.85f, w * 0.95f, h * 0.50f)
    }
    drawPath(top, color, style = stroke)
    drawPath(bottom, color, style = stroke)
    // Iris
    drawCircle(color, radius = w * 0.14f, center = Offset(w * 0.50f, h * 0.50f), style = stroke)
    // Pupil
    drawCircle(color, radius = w * 0.06f, center = Offset(w * 0.50f, h * 0.50f), style = Fill)
    // Sparkle lines (aura disturbance)
    drawLine(color, Offset(w * 0.80f, h * 0.15f), Offset(w * 0.88f, h * 0.08f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.90f, h * 0.22f), Offset(w * 0.97f, h * 0.18f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
    drawLine(color, Offset(w * 0.85f, h * 0.08f), Offset(w * 0.92f, h * 0.12f), strokeWidth = w * 0.04f, cap = StrokeCap.Round)
}

/* -- Screen -- */

@Composable
fun MigraineHubScreen(navController: NavController) {
    val scrollState = rememberScrollState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Hero Card - Log Full Migraine
            HeroCard(
                modifier = Modifier.clickable { navController.navigate(Routes.LOG_MIGRAINE) }
            ) {
                Box(
                    modifier = Modifier
                        .size(56.dp)
                        .drawBehind { drawMigraineIcon(Color(0xFFE091C8)) }
                )

                Spacer(Modifier.height(8.dp))

                Text(
                    "Log Migraine",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold)
                )

                Text(
                    "Full migraine with triggers, medicines & reliefs",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )

                Spacer(Modifier.height(12.dp))

                Text(
                    "Tap to start →",
                    color = AppTheme.AccentPurple,
                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
                )
            }

            // Quick Log Section Title
            BaseCard {
                Text(
                    "Quick Log",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Text(
                    "Log items without a migraine",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            // Quick Log Cards Row 1
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                QuickLogCard(
                    modifier = Modifier.weight(1f),
                    title = "Trigger",
                    subtitle = "Log a trigger",
                    iconColor = Color(0xFFFFB74D),
                    drawIcon = { drawTriggerIcon(it) },
                    onClick = { navController.navigate(Routes.QUICK_LOG_TRIGGER) }
                )

                QuickLogCard(
                    modifier = Modifier.weight(1f),
                    title = "Medicine",
                    subtitle = "Log a medicine",
                    iconColor = Color(0xFF4FC3F7),
                    drawIcon = { drawMedicineIcon(it) },
                    onClick = { navController.navigate(Routes.QUICK_LOG_MEDICINE) }
                )
            }

            // Quick Log Cards Row 2
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                QuickLogCard(
                    modifier = Modifier.weight(1f),
                    title = "Relief",
                    subtitle = "Log a relief",
                    iconColor = Color(0xFF81C784),
                    drawIcon = { drawReliefIcon(it) },
                    onClick = { navController.navigate(Routes.QUICK_LOG_RELIEF) }
                )

                QuickLogCard(
                    modifier = Modifier.weight(1f),
                    title = "Activity",
                    subtitle = "Log activity",
                    iconColor = Color(0xFFFF8A65),
                    drawIcon = { HubIcons.run { drawActivityPulse(it) } },
                    onClick = { navController.navigate(Routes.QUICK_LOG_ACTIVITY) }
                )
            }

            // Quick Log Cards Row 3
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                QuickLogCard(
                    modifier = Modifier.weight(1f),
                    title = "Prodrome",
                    subtitle = "Log symptoms",
                    iconColor = AppTheme.AccentPurple,
                    drawIcon = { drawProdromeIcon(it) },
                    onClick = { navController.navigate(Routes.QUICK_LOG_PRODROME) }
                )

                QuickLogCard(
                    modifier = Modifier.weight(1f),
                    title = "Migraine",
                    subtitle = "Quick log",
                    iconColor = AppTheme.AccentPink,
                    drawIcon = { HubIcons.run { drawMigraineStarburst(it) } },
                    onClick = { navController.navigate(Routes.QUICK_LOG_MIGRAINE) }
                )
            }
        }
    }
}

@Composable
private fun QuickLogCard(
    modifier: Modifier = Modifier,
    title: String,
    subtitle: String,
    iconColor: Color,
    enabled: Boolean = true,
    drawIcon: DrawScope.(Color) -> Unit,
    onClick: () -> Unit
) {
    val actualColor = if (enabled) iconColor else AppTheme.SubtleTextColor.copy(alpha = 0.5f)

    BaseCard(
        modifier = modifier
            .then(
                if (enabled) Modifier.clickable(onClick = onClick)
                else Modifier
            )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Round icon circle
            Box(
                modifier = Modifier
                    .size(52.dp)
                    .clip(CircleShape)
                    .background(actualColor.copy(alpha = 0.15f))
                    .border(1.5.dp, actualColor.copy(alpha = 0.3f), CircleShape),
                contentAlignment = Alignment.Center
            ) {
                Box(
                    modifier = Modifier
                        .size(28.dp)
                        .drawBehind { drawIcon(actualColor) }
                )
            }

            Spacer(Modifier.height(10.dp))

            Text(
                title,
                color = if (enabled) AppTheme.BodyTextColor else AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )

            Text(
                subtitle,
                color = if (enabled) AppTheme.SubtleTextColor else AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                style = MaterialTheme.typography.bodySmall,
                textAlign = TextAlign.Center
            )
        }
    }
}


title: MigraineLinkerDialog.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/**
 * Direction for migraine lookup relative to the logged item's date.
 *
 * FORWARD: triggers/prodromes/activities — the migraine comes *after* the item
 *   → show migraines from itemDate to itemDate+2
 * BACKWARD: reliefs/medicines/locations/missed — the migraine came *before* the item
 *   → show migraines from itemDate-2 to itemDate
 */
enum class LinkDirection { FORWARD, BACKWARD }

/**
 * Dialog shown in quick-log mode to let the user link their logged item(s) to a nearby migraine.
 * Shows auto-suggested migraines from the relevant date range, plus an expandable dropdown
 * to browse all migraines from the last 30 days.
 */
@Composable
fun MigraineLinkerDialog(
    direction: LinkDirection,
    itemStartAtIso: String?,
    authVm: AuthViewModel,
    onLink: (migraineId: String?) -> Unit,
    onDismiss: () -> Unit
) {
    val db = remember { SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY) }
    val authState by authVm.state.collectAsState()

    // Suggested migraines (from date range)
    var suggested by remember { mutableStateOf<List<SupabaseDbService.MigraneSummaryRow>>(emptyList()) }
    var loading by remember { mutableStateOf(true) }

    // All recent migraines (last 30 days) for dropdown
    var allRecent by remember { mutableStateOf<List<SupabaseDbService.MigraneSummaryRow>>(emptyList()) }
    var allLoading by remember { mutableStateOf(false) }
    var showAll by remember { mutableStateOf(false) }

    var selectedId by remember { mutableStateOf<String?>(null) }

    val today = remember { LocalDate.now() }

    // Determine the item date
    val itemDate = remember(itemStartAtIso) {
        try {
            if (itemStartAtIso != null) LocalDate.parse(itemStartAtIso.substring(0, 10))
            else LocalDate.now()
        } catch (_: Exception) { LocalDate.now() }
    }

    // Compute suggested date range
    val (fromDate, toDate) = remember(itemDate, direction) {
        when (direction) {
            LinkDirection.FORWARD -> itemDate to itemDate.plusDays(2)
            LinkDirection.BACKWARD -> itemDate.minusDays(2) to itemDate
        }
    }

    // Fetch suggested migraines
    LaunchedEffect(authState.accessToken, fromDate, toDate) {
        val token = authState.accessToken ?: return@LaunchedEffect
        loading = true
        suggested = try {
            db.getNearbyMigraines(token, fromDate.toString(), toDate.toString())
        } catch (_: Exception) { emptyList() }
        loading = false
    }

    // Fetch all recent when dropdown opened
    LaunchedEffect(showAll, authState.accessToken) {
        if (showAll && allRecent.isEmpty()) {
            val token = authState.accessToken ?: return@LaunchedEffect
            allLoading = true
            allRecent = try {
                val from = today.minusDays(30).toString()
                val to = today.toString()
                db.getNearbyMigraines(token, from, to)
            } catch (_: Exception) { emptyList() }
            allLoading = false
        }
    }

    // IDs already in suggested list
    val suggestedIds = remember(suggested) { suggested.map { it.id }.toSet() }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text("Link to migraine?") },
        text = {
            Column(
                modifier = Modifier.verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                val hint = when (direction) {
                    LinkDirection.FORWARD -> "Which migraine did this lead to?"
                    LinkDirection.BACKWARD -> "Which migraine was this for?"
                }
                Text(hint, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)

                // ── Suggested migraines ──
                if (loading) {
                    Box(Modifier.fillMaxWidth().padding(16.dp), contentAlignment = Alignment.Center) {
                        CircularProgressIndicator(color = AppTheme.AccentPurple, modifier = Modifier.size(24.dp), strokeWidth = 2.dp)
                    }
                } else if (suggested.isEmpty()) {
                    Text(
                        "No migraines found nearby",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp)
                    )
                } else {
                    Text("Suggested", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
                    suggested.forEach { m ->
                        MigraineRow(m, selectedId == m.id, today) { selectedId = if (selectedId == m.id) null else m.id }
                    }
                }

                // ── Browse all dropdown ──
                HorizontalDivider(color = Color.White.copy(alpha = 0.08f))

                Row(
                    modifier = Modifier.fillMaxWidth().clickable { showAll = !showAll }.padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text(
                        "Browse all migraines",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Icon(
                        if (showAll) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                        contentDescription = null,
                        tint = AppTheme.AccentPurple,
                        modifier = Modifier.size(20.dp)
                    )
                }

                if (showAll) {
                    if (allLoading) {
                        Box(Modifier.fillMaxWidth().padding(8.dp), contentAlignment = Alignment.Center) {
                            CircularProgressIndicator(color = AppTheme.AccentPurple, modifier = Modifier.size(20.dp), strokeWidth = 2.dp)
                        }
                    } else {
                        // Show migraines not already in suggested list
                        val extra = allRecent.filter { it.id !in suggestedIds }
                        if (extra.isEmpty()) {
                            Text(
                                "No other migraines in the last 30 days",
                                color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.bodySmall,
                                modifier = Modifier.padding(vertical = 4.dp)
                            )
                        } else {
                            extra.forEach { m ->
                                MigraineRow(m, selectedId == m.id, today) { selectedId = if (selectedId == m.id) null else m.id }
                            }
                        }
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = { onLink(selectedId) }) {
                Text(if (selectedId != null) "Link & Save" else "Save without linking", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = AppTheme.SubtleTextColor)
            }
        }
    )
}

@Composable
private fun MigraineRow(
    m: SupabaseDbService.MigraneSummaryRow,
    isSelected: Boolean,
    today: LocalDate,
    onClick: () -> Unit
) {
    val migraineDate = try {
        Instant.parse(m.startAt).atZone(ZoneId.systemDefault()).toLocalDateTime()
    } catch (_: Exception) { null }

    val dayLabel = migraineDate?.let {
        val d = it.toLocalDate()
        when {
            d == today -> "Today"
            d == today.minusDays(1) -> "Yesterday"
            d == today.plusDays(1) -> "Tomorrow"
            d == today.minusDays(2) -> "2 days ago"
            else -> d.format(DateTimeFormatter.ofPattern("EEE dd MMM"))
        }
    } ?: "Unknown"

    val timeLabel = migraineDate?.format(DateTimeFormatter.ofPattern("HH:mm")) ?: ""
    val severityLabel = m.severity?.let { "Severity $it/10" } ?: ""
    val typeLabel = m.type?.replaceFirstChar { it.uppercase() } ?: ""

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(10.dp))
            .background(if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.25f) else Color.White.copy(alpha = 0.06f))
            .clickable(onClick = onClick)
            .padding(12.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Column(Modifier.weight(1f)) {
            Text(
                "$dayLabel $timeLabel",
                color = if (isSelected) Color.White else AppTheme.BodyTextColor,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
            )
            if (typeLabel.isNotEmpty() || severityLabel.isNotEmpty()) {
                Text(
                    listOfNotNull(typeLabel.ifEmpty { null }, severityLabel.ifEmpty { null }).joinToString(" · "),
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall
                )
            }
        }
        if (isSelected) {
            Text("✓", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
        }
    }
}

title: MigraineMeFirebaseService.kt
text:
package com.migraineme

import android.util.Log
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import okhttp3.MediaType.Companion.toMediaTypeOrNull

/**
 * Firebase Cloud Messaging Service
 *
 * Handles incoming FCM messages to trigger background syncs.
 *
 * Supported message types:
 * - sync_location: Triggers location sync
 * - sync_screen_time: Triggers screen time sync
 * - sync_hourly: Triggers location, screen time, phone sleep, phone behavior, and Health Connect
 * - sync_health_connect: Triggers Health Connect data sync
 * - evening_checkin: Shows notification prompting the user to do their evening check-in
 */
class MigraineMeFirebaseService : FirebaseMessagingService() {

    override fun onNewToken(token: String) {
        super.onNewToken(token)
        Log.d(TAG, "New FCM token: ${token.take(20)}...")

        // Save to Supabase
        CoroutineScope(Dispatchers.IO).launch {
            saveFcmTokenToSupabase(token)
        }
    }

    override fun onMessageReceived(message: RemoteMessage) {
        super.onMessageReceived(message)
        Log.d(TAG, "FCM message received: ${message.data}")

        val type = message.data["type"] ?: return

        when (type) {
            "sync_location" -> {
                Log.d(TAG, "Triggering location sync from FCM")
                LocationDailySyncWorker.runOnceNow(applicationContext)
            }
            "sync_screen_time" -> {
                Log.d(TAG, "Triggering screen time sync from FCM")
                ScreenTimeSyncWorker.runOnce(applicationContext)
            }
            "sync_hourly" -> {
                // Hourly sync - triggers location, screen time, phone sleep, phone behavior, AND Health Connect
                Log.d(TAG, "Triggering hourly sync from FCM")
                LocationDailySyncWorker.runOnceNow(applicationContext)
                ScreenTimeSyncWorker.runOnce(applicationContext)
                PhoneSleepSyncWorker.runOnce(applicationContext)
                PhoneBehaviorSyncWorker.runOnce(applicationContext)
                triggerHealthConnectSync()
            }
            "sync_health_connect" -> {
                // Health Connect sync - triggers both changes worker and push worker
                Log.d(TAG, "Triggering Health Connect sync from FCM")
                triggerHealthConnectSync()
            }
            "evening_checkin" -> {
                Log.d(TAG, "Showing evening check-in notification")
                showEveningCheckinNotification()
            }
            else -> {
                Log.w(TAG, "Unknown FCM message type: $type")
            }
        }
    }

    /**
     * Triggers Health Connect data sync:
     * 1. HealthConnectChangesWorker - reads changes from Health Connect → local outbox
     * 2. HealthConnectPushWorker - pushes from outbox → Supabase
     *
     * Uses OneTimeWorkRequest - no periodic scheduling needed since FCM controls timing.
     */
    private fun triggerHealthConnectSync() {
        try {
            val workManager = androidx.work.WorkManager.getInstance(applicationContext)

            // Run changes worker (reads from Health Connect)
            workManager.enqueue(
                androidx.work.OneTimeWorkRequestBuilder<HealthConnectChangesWorker>()
                    .build()
            )

            // Run push worker (pushes to Supabase)
            workManager.enqueue(
                androidx.work.OneTimeWorkRequestBuilder<HealthConnectPushWorker>()
                    .build()
            )

            Log.d(TAG, "Health Connect sync workers triggered")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to trigger Health Connect sync", e)
        }
    }

    private fun showEveningCheckinNotification() {
        val channelId = "evening_checkin"
        val nm = getSystemService(android.content.Context.NOTIFICATION_SERVICE) as android.app.NotificationManager

        // Create channel (no-op if already exists)
        val channel = android.app.NotificationChannel(
            channelId, "Evening Check-in",
            android.app.NotificationManager.IMPORTANCE_DEFAULT
        ).apply { description = "Daily evening check-in reminder" }
        nm.createNotificationChannel(channel)

        // Tap opens the check-in screen
        val intent = android.content.Intent(this, MainActivity::class.java).apply {
            flags = android.content.Intent.FLAG_ACTIVITY_NEW_TASK or android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP
            putExtra("navigate_to", Routes.EVENING_CHECKIN)
        }
        val pi = android.app.PendingIntent.getActivity(
            this, 0, intent,
            android.app.PendingIntent.FLAG_UPDATE_CURRENT or android.app.PendingIntent.FLAG_IMMUTABLE
        )

        val notification = androidx.core.app.NotificationCompat.Builder(this, channelId)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentTitle("How was today?")
            .setContentText("Take 15 seconds to log your day")
            .setContentIntent(pi)
            .setAutoCancel(true)
            .build()

        nm.notify(8020, notification)
    }

    private suspend fun saveFcmTokenToSupabase(fcmToken: String) {
        try {
            val accessToken = SessionStore.getValidAccessToken(applicationContext)
            if (accessToken == null) {
                Log.w(TAG, "No access token - will save FCM token on next login")
                // Store locally for later
                SessionStore.saveFcmToken(applicationContext, fcmToken)
                return
            }

            val userId = SessionStore.readUserId(applicationContext)
            if (userId == null) {
                Log.w(TAG, "No user ID - will save FCM token on next login")
                SessionStore.saveFcmToken(applicationContext, fcmToken)
                return
            }

            // Save to Supabase profiles
            val client = okhttp3.OkHttpClient()
            val json = org.json.JSONObject().apply {
                put("fcm_token", fcmToken)
            }

            val request = okhttp3.Request.Builder()
                .url("${BuildConfig.SUPABASE_URL}/rest/v1/profiles?user_id=eq.$userId")
                .patch(okhttp3.RequestBody.create(
                    "application/json".toMediaTypeOrNull(),
                    json.toString()
                ))
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $accessToken")
                .addHeader("Content-Type", "application/json")
                .addHeader("Prefer", "return=minimal")
                .build()

            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                Log.d(TAG, "FCM token saved to Supabase")
                SessionStore.saveFcmToken(applicationContext, fcmToken)
            } else {
                Log.e(TAG, "Failed to save FCM token: ${response.code}")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error saving FCM token", e)
        }
    }

    companion object {
        private const val TAG = "FCMService"
    }
}

title: MigraineOverlayHelper.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.DrawScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.ZonedDateTime

/**
 * Shared helper for drawing migraine overlay bands on history graphs.
 *
 * Fetches migraine dates from Supabase and provides a draw function
 * that renders semi-transparent red vertical bands on Canvas graphs.
 */
object MigraineOverlayHelper {

    /**
     * Fetch the set of dates (as "yyyy-MM-dd" strings) that had a migraine
     * within the given date range.
     */
    suspend fun fetchMigraineDates(
        context: Context,
        days: Int,
        endDate: LocalDate = LocalDate.now()
    ): Set<String> = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.getValidAccessToken(context) ?: return@withContext emptySet()
            val dbService = SupabaseDbService(
                supabaseUrl = BuildConfig.SUPABASE_URL,
                supabaseKey = BuildConfig.SUPABASE_ANON_KEY
            )
            val allMigraines = dbService.getMigraines(token)

            val zone = ZoneId.systemDefault()
            val today = endDate
            val cutoff = today.minusDays(days.toLong())

            val dates = mutableSetOf<String>()

            for (m in allMigraines) {
                try {
                    val startDate = parseToLocalDate(m.startAt, zone) ?: continue
                    val endDate = if (m.endAt != null) {
                        parseToLocalDate(m.endAt, zone) ?: startDate
                    } else {
                        startDate
                    }

                    Log.d("MigraineOverlay", "Migraine: startAt=${m.startAt} -> $startDate, endAt=${m.endAt} -> $endDate, cutoff=$cutoff, today=$today")

                    // Add all dates in the migraine span
                    var d = startDate
                    while (!d.isAfter(endDate) && !d.isAfter(today)) {
                        if (!d.isBefore(cutoff)) {
                            dates.add(d.toString())
                        }
                        d = d.plusDays(1)
                    }
                } catch (e: Exception) {
                    Log.e("MigraineOverlay", "Failed to parse migraine: ${m.startAt} / ${m.endAt}", e)
                }
            }

            Log.d("MigraineOverlay", "Final migraine dates for overlay: $dates")

            dates
        } catch (_: Exception) {
            emptySet()
        }
    }

    /**
     * Draw red vertical bands on a Canvas for each migraine date.
     *
     * @param dateList The ordered list of date strings ("yyyy-MM-dd") shown on the graph x-axis
     * @param migraineDates Set of dates that had migraines
     * @param padding Canvas padding in px
     * @param graphWidth Total drawable width in px
     * @param graphHeight Total drawable height in px
     */
    fun DrawScope.drawMigraineBands(
        dateList: List<String>,
        migraineDates: Set<String>,
        padding: Float,
        graphWidth: Float,
        graphHeight: Float
    ) {
        if (migraineDates.isEmpty() || dateList.isEmpty()) return

        val totalDays = dateList.size
        val maxIndex = (totalDays - 1).coerceAtLeast(1)
        val bandColor = Color(0xFFE57373).copy(alpha = 0.15f)
        val borderColor = Color(0xFFE57373).copy(alpha = 0.35f)
        val slotWidth = graphWidth / maxIndex.toFloat()

        // Merge consecutive migraine days into runs, draw one band per run
        var runStart = -1

        for (i in 0..totalDays) {
            val isMigraine = i < totalDays && dateList[i] in migraineDates

            if (isMigraine && runStart == -1) {
                runStart = i
            } else if (!isMigraine && runStart != -1) {
                val runEnd = i - 1
                // Band spans from half-slot before runStart to half-slot after runEnd
                val left = (padding + (runStart.toFloat() / maxIndex) * graphWidth - slotWidth / 2).coerceAtLeast(padding)
                val right = (padding + (runEnd.toFloat() / maxIndex) * graphWidth + slotWidth / 2).coerceAtMost(padding + graphWidth)

                drawRect(
                    color = bandColor,
                    topLeft = Offset(left, padding),
                    size = Size(right - left, graphHeight)
                )
                // Left edge
                drawLine(borderColor, Offset(left, padding), Offset(left, padding + graphHeight), 1.5f)
                // Right edge
                drawLine(borderColor, Offset(right, padding), Offset(right, padding + graphHeight), 1.5f)

                runStart = -1
            }
        }
    }

    /**
     * Parse a timestamp string from Supabase into a LocalDate in the given timezone.
     *
     * Handles all common formats:
     * - "2026-02-05T23:30:00+00:00" (OffsetDateTime — Supabase timestamptz)
     * - "2026-02-05T23:30:00Z" (Instant)
     * - "2026-02-05T23:30:00" (LocalDateTime, assumed UTC)
     * - "2026-02-05" (already a date)
     */
    private fun parseToLocalDate(timestamp: String, zone: ZoneId): LocalDate? {
        // Try OffsetDateTime first (most common from Supabase timestamptz)
        try {
            return OffsetDateTime.parse(timestamp).atZoneSameInstant(zone).toLocalDate()
        } catch (_: Exception) {}

        // Try ZonedDateTime
        try {
            return ZonedDateTime.parse(timestamp).withZoneSameInstant(zone).toLocalDate()
        } catch (_: Exception) {}

        // Try Instant (ends with Z)
        try {
            return Instant.parse(timestamp).atZone(zone).toLocalDate()
        } catch (_: Exception) {}

        // Try LocalDateTime (no timezone info — assume UTC)
        try {
            val ldt = LocalDateTime.parse(timestamp.removeSuffix("Z"))
            return ldt.atZone(ZoneId.of("UTC")).withZoneSameInstant(zone).toLocalDate()
        } catch (_: Exception) {}

        // Try just a date string
        try {
            return LocalDate.parse(timestamp.take(10))
        } catch (_: Exception) {}

        return null
    }
}

title: MigrainePickerCard.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.filled.KeyboardArrowUp
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/**
 * Inline migraine picker card for quick log screens.
 * Shows migraines within ±3 days of the item date,
 * with an expandable "Browse all" section for last 30 days.
 *
 * @param itemStartAtIso The start_at of the logged item (determines center date). Defaults to today.
 * @param authVm For access token.
 * @param selectedMigraineId Currently selected migraine ID (state hoisted to parent).
 * @param onSelect Called when user selects/deselects a migraine.
 */
@Composable
fun MigrainePickerCard(
    itemStartAtIso: String? = null,
    authVm: AuthViewModel,
    selectedMigraineId: String?,
    onSelect: (String?) -> Unit
) {
    val db = remember { SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY) }
    val authState by authVm.state.collectAsState()

    var suggested by remember { mutableStateOf<List<SupabaseDbService.MigraneSummaryRow>>(emptyList()) }
    var loading by remember { mutableStateOf(true) }
    var allRecent by remember { mutableStateOf<List<SupabaseDbService.MigraneSummaryRow>>(emptyList()) }
    var allLoading by remember { mutableStateOf(false) }
    var expanded by remember { mutableStateOf(false) }

    val today = remember { LocalDate.now() }

    val itemDate = remember(itemStartAtIso) {
        try {
            if (itemStartAtIso != null) LocalDate.parse(itemStartAtIso.substring(0, 10))
            else LocalDate.now()
        } catch (_: Exception) { LocalDate.now() }
    }

    val (fromDate, toDate) = remember(itemDate) {
        itemDate.minusDays(3) to itemDate.plusDays(3)
    }

    // Fetch suggested
    LaunchedEffect(authState.accessToken, fromDate, toDate) {
        val token = authState.accessToken ?: return@LaunchedEffect
        loading = true
        suggested = try {
            db.getNearbyMigraines(token, fromDate.toString(), toDate.toString())
        } catch (_: Exception) { emptyList() }
        loading = false
    }

    // Fetch all when expanded
    LaunchedEffect(expanded, authState.accessToken) {
        if (expanded && allRecent.isEmpty()) {
            val token = authState.accessToken ?: return@LaunchedEffect
            allLoading = true
            allRecent = try {
                db.getNearbyMigraines(token, today.minusDays(30).toString(), today.toString())
            } catch (_: Exception) { emptyList() }
            allLoading = false
        }
    }

    val suggestedIds = remember(suggested) { suggested.map { it.id }.toSet() }

    BaseCard {
        Text("Link to migraine", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))

        if (loading) {
            Box(Modifier.fillMaxWidth().padding(8.dp), contentAlignment = Alignment.Center) {
                CircularProgressIndicator(color = AppTheme.AccentPurple, modifier = Modifier.size(20.dp), strokeWidth = 2.dp)
            }
        } else if (suggested.isEmpty() && !expanded) {
            Text("No nearby migraines found", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
        } else {
            suggested.forEach { m ->
                PickerMigraineRow(m, selectedMigraineId == m.id, today) {
                    onSelect(if (selectedMigraineId == m.id) null else m.id)
                }
            }
        }

        // Browse all
        HorizontalDivider(color = Color.White.copy(alpha = 0.08f), modifier = Modifier.padding(vertical = 4.dp))
        Row(
            modifier = Modifier.fillMaxWidth().clickable { expanded = !expanded }.padding(vertical = 2.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text("Browse all", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold))
            Icon(
                if (expanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,
                contentDescription = null, tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp)
            )
        }

        if (expanded) {
            if (allLoading) {
                Box(Modifier.fillMaxWidth().padding(8.dp), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator(color = AppTheme.AccentPurple, modifier = Modifier.size(20.dp), strokeWidth = 2.dp)
                }
            } else {
                val extra = allRecent.filter { it.id !in suggestedIds }
                if (extra.isEmpty()) {
                    Text("No other migraines in the last 30 days", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                } else {
                    extra.forEach { m ->
                        PickerMigraineRow(m, selectedMigraineId == m.id, today) {
                            onSelect(if (selectedMigraineId == m.id) null else m.id)
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun PickerMigraineRow(
    m: SupabaseDbService.MigraneSummaryRow,
    isSelected: Boolean,
    today: LocalDate,
    onClick: () -> Unit
) {
    val migraineDate = try {
        Instant.parse(m.startAt).atZone(ZoneId.systemDefault()).toLocalDateTime()
    } catch (_: Exception) { null }

    val dayLabel = migraineDate?.let {
        val d = it.toLocalDate()
        when {
            d == today -> "Today"
            d == today.minusDays(1) -> "Yesterday"
            d == today.plusDays(1) -> "Tomorrow"
            d == today.minusDays(2) -> "2 days ago"
            else -> d.format(DateTimeFormatter.ofPattern("EEE dd MMM"))
        }
    } ?: "Unknown"

    val timeLabel = migraineDate?.format(DateTimeFormatter.ofPattern("HH:mm")) ?: ""
    val severityLabel = m.severity?.let { "$it/10" } ?: ""
    val typeLabel = m.type?.replaceFirstChar { it.uppercase() } ?: ""

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 2.dp)
            .clip(RoundedCornerShape(8.dp))
            .background(if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.25f) else Color.White.copy(alpha = 0.06f))
            .clickable(onClick = onClick)
            .padding(horizontal = 12.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Column(Modifier.weight(1f)) {
            Text(
                "$dayLabel $timeLabel",
                color = if (isSelected) Color.White else AppTheme.BodyTextColor,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
            )
            if (typeLabel.isNotEmpty() || severityLabel.isNotEmpty()) {
                Text(
                    listOfNotNull(typeLabel.ifEmpty { null }, severityLabel.ifEmpty { null }).joinToString(" · "),
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.labelSmall
                )
            }
        }
        if (isSelected) {
            Text("✓", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
        }
    }
}

title: MigraineViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MigraineViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserMigrainePoolRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserMigrainePoolRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.MigrainePrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.MigrainePrefRow>> = _frequent

    private val _hidden = MutableStateFlow<List<SupabaseDbService.MigrainePrefRow>>(emptyList())
    val hidden: StateFlow<List<SupabaseDbService.MigrainePrefRow>> = _hidden

    private fun safeSortPrefs(prefs: List<SupabaseDbService.MigrainePrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllMigrainePool(accessToken)
                val prefs = db.getMigrainePrefs(accessToken)
                _pool.value = p
                _frequent.value = safeSortPrefs(prefs.filter { it.status == "frequent" })
                _hidden.value = prefs.filter { it.status == "hidden" }
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
                _hidden.value = emptyList()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String) {
        viewModelScope.launch {
            try {
                db.upsertMigraineToPool(accessToken, label.trim())
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, migraineId: String) {
        viewModelScope.launch {
            try {
                db.deleteMigraineFromPool(accessToken, migraineId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, migraineId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertMigrainePref(accessToken, migraineId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteMigrainePref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


title: MissedActivitiesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun MissedActivitiesScreen(
    navController: NavController,
    vm: MissedActivityViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {}
) {
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken) { authState.accessToken?.let { vm.loadAll(it) } }

    fun rebuildDraftWithMissed(missed: List<MissedActivityDraft>) {
        val d = draft
        logVm.clearDraft()
        d.migraine?.let { logVm.setMigraineDraft(it.type, it.severity, it.beganAtIso, it.endedAtIso, it.note, symptoms = it.symptoms) }
        if (d.painLocations.isNotEmpty()) logVm.setPainLocationsDraft(d.painLocations)
        d.prodromes.forEach { logVm.addProdromeDraft(it.type, it.startAtIso, it.note) }
        d.triggers.forEach { logVm.addTriggerDraft(it.type, it.startAtIso, it.note) }
        d.meds.forEach { m -> logVm.addMedicineDraft(m.name ?: "", m.amount, m.notes, m.startAtIso, m.reliefScale) }
        d.rels.forEach { logVm.addReliefDraft(it.type, it.notes, it.startAtIso, it.endAtIso, it.reliefScale) }
        d.locations.forEach { logVm.addLocationDraft(it.type, it.startAtIso, it.note) }
        d.activities.forEach { logVm.addActivityDraft(it.type, it.startAtIso, it.note) }
        missed.forEach { logVm.addMissedActivityDraft(it.type, it.startAtIso, it.note) }
    }

    fun onTap(label: String) {
        val idx = draft.missedActivities.indexOfFirst { it.type == label }
        if (idx >= 0) {
            rebuildDraftWithMissed(draft.missedActivities.toMutableList().apply { removeAt(idx) })
        } else {
            rebuildDraftWithMissed(draft.missedActivities + MissedActivityDraft(type = label))
        }
    }

    val frequentLabels = remember(frequent) { frequent.mapNotNull { it.missedActivity?.label }.toSet() }
    val selectedLabels = remember(draft.missedActivities) { draft.missedActivities.map { it.type }.toSet() }
    val grouped = remember(pool) { pool.groupBy { it.category ?: "Other" }.toSortedMap() }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Activity", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Missed", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) { Icon(Icons.Outlined.Close, "Close", tint = Color.White, modifier = Modifier.size(28.dp)) }
            }

            HeroCard {
                Box(Modifier.size(40.dp).drawBehind {
                    HubIcons.run { drawMissedActivity(Color(0xFFEF9A9A)) }
                })
                Text("What did you miss?", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.missedActivities.isEmpty()) "Activities you couldn't do" else "${draft.missedActivities.size} missed activit${if (draft.missedActivities.size > 1) "ies" else "y"}",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center
                )
                if (draft.missedActivities.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.missedActivities.forEachIndexed { index, ma ->
                        Row(
                            Modifier.fillMaxWidth().padding(vertical = 3.dp).clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f)).padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Text(ma.type, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium), modifier = Modifier.weight(1f))
                            Icon(Icons.Outlined.Close, "Remove", tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                modifier = Modifier.size(18.dp).clickable {
                                    rebuildDraftWithMissed(draft.missedActivities.toMutableList().apply { removeAt(index) })
                                })
                        }
                    }
                }
            }

            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Missed Activities", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_MISSED_ACTIVITIES) })
                }
            }

            BaseCard {
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { ma ->
                            MissedCircleButton(ma.label, ma.label in selectedLabels, ma.iconKey) { onTap(ma.label) }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }
                val entries = grouped.entries.toList()
                entries.forEachIndexed { ci, (cat, items) ->
                    val nonFreq = items.filter { it.label !in frequentLabels }
                    if (nonFreq.isNotEmpty()) {
                        Text(cat, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreq.forEach { ma -> MissedCircleButton(ma.label, ma.label in selectedLabels, ma.iconKey) { onTap(ma.label) } }
                        }
                        if (entries.drop(ci + 1).any { (_, its) -> its.any { it.label !in frequentLabels } })
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                    }
                }
                if (pool.isEmpty()) Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
            }

            Row(Modifier.fillMaxWidth().padding(vertical = 8.dp), horizontalArrangement = Arrangement.SpaceBetween) {
                OutlinedButton(onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }
                Button(onClick = { navController.navigate(Routes.NOTES) },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text("Next") }
            }
            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun MissedCircleButton(label: String, isSelected: Boolean, iconKey: String? = null, onClick: () -> Unit) {
    val accent = Color(0xFFEF9A9A)
    val icon = MissedActivityIcons.forKey(iconKey)
    val bg = if (isSelected) accent.copy(alpha = 0.40f) else Color.White.copy(alpha = 0.08f)
    val border = if (isSelected) accent.copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.width(72.dp).clickable(remember { MutableInteractionSource() }, null, onClick = onClick)
    ) {
        Box(Modifier.size(52.dp).clip(CircleShape).background(bg).border(1.5.dp, border, CircleShape), contentAlignment = Alignment.Center) {
            if (icon != null) {
                Icon(imageVector = icon, contentDescription = label, tint = if (isSelected) Color.White else AppTheme.SubtleTextColor, modifier = Modifier.size(24.dp))
            } else {
                Text(label.take(2).uppercase(), color = if (isSelected) Color.White else AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold))
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(label, color = if (isSelected) Color.White else AppTheme.BodyTextColor,
            style = MaterialTheme.typography.labelSmall, textAlign = TextAlign.Center, maxLines = 2, modifier = Modifier.fillMaxWidth())
    }
}

@Composable
private fun MissedTimeDialog(title: String, initialIso: String? = null, onDismiss: () -> Unit, onSkip: (() -> Unit)?, onConfirm: (iso: String?) -> Unit) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E), titleContentColor = Color.White, textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Time: ${formatMissedTime(pickedIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select time", onDateTimeSelected = { pickedIso = it })
            }
        },
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text(if (onSkip != null) "Add" else "Save", color = AppTheme.AccentPurple) } },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) { Text("Cancel", color = AppTheme.SubtleTextColor) }
                if (onSkip != null) TextButton(onClick = onSkip) { Text("Skip", color = Color(0xFFEF9A9A)) }
            }
        }
    )
}

private fun formatMissedTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull() ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) { "Not set" }
}


title: MissedActivityIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

object MissedActivityIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    // ─── CARE ───────────────────────────────────────────────

    /** childcare — adult + small figure */
    val Childcare: ImageVector by lazy {
        ImageVector.Builder("MissedChildcare", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 5f); arcTo(2f, 2f, 0f, true, true, 15f, 5f); arcTo(2f, 2f, 0f, true, true, 19f, 5f)
                moveTo(17f, 7f); lineTo(17f, 13f)
                moveTo(17f, 10f); lineTo(21f, 12f); moveTo(17f, 10f); lineTo(13f, 8f)
                moveTo(17f, 13f); lineTo(15f, 20f); moveTo(17f, 13f); lineTo(19f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(9f, 8f); arcTo(2f, 2f, 0f, true, true, 5f, 8f); arcTo(2f, 2f, 0f, true, true, 9f, 8f)
                moveTo(7f, 10f); lineTo(7f, 14f)
                moveTo(7f, 14f); lineTo(5f, 19f); moveTo(7f, 14f); lineTo(9f, 19f)
            }
        }.build()
    }

    /** pet_care — paw print */
    val PetCare: ImageVector by lazy {
        ImageVector.Builder("PetCare", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Main pad
                moveTo(12f, 16f); curveTo(10f, 14f, 7f, 14f, 7f, 17f); curveTo(7f, 20f, 12f, 22f, 12f, 22f)
                curveTo(12f, 22f, 17f, 20f, 17f, 17f); curveTo(17f, 14f, 14f, 14f, 12f, 16f)
            }
            // Toe pads
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 10f); arcTo(1.5f, 2f, 0f, true, true, 7f, 10.01f)
                moveTo(10.5f, 7f); arcTo(1.5f, 2f, 0f, true, true, 10.5f, 7.01f)
                moveTo(13.5f, 7f); arcTo(1.5f, 2f, 0f, true, true, 13.5f, 7.01f)
                moveTo(17f, 10f); arcTo(1.5f, 2f, 0f, true, true, 17f, 10.01f)
            }
        }.build()
    }

    /** self_care — heart in hand */
    val SelfCare: ImageVector by lazy {
        ImageVector.Builder("SelfCare", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Heart
                moveTo(12f, 10f); curveTo(12f, 7f, 9f, 5f, 7.5f, 7f); curveTo(6f, 9f, 8f, 12f, 12f, 15f)
                curveTo(16f, 12f, 18f, 9f, 16.5f, 7f); curveTo(15f, 5f, 12f, 7f, 12f, 10f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cupped hand
                moveTo(5f, 18f); curveTo(5f, 16f, 8f, 15f, 12f, 15f); curveTo(16f, 15f, 19f, 16f, 19f, 18f)
                lineTo(19f, 20f); lineTo(5f, 20f); close()
            }
        }.build()
    }

    // ─── EXERCISE ───────────────────────────────────────────

    /** exercise — jumping figure */
    val Exercise: ImageVector by lazy {
        ImageVector.Builder("MissedExercise", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 13f)
                moveTo(12f, 9f); lineTo(6f, 6f); moveTo(12f, 9f); lineTo(18f, 6f)
                moveTo(12f, 13f); lineTo(7f, 20f); moveTo(12f, 13f); lineTo(17f, 20f)
            }
        }.build()
    }

    /** gym — dumbbell */
    val Gym: ImageVector by lazy {
        ImageVector.Builder("MissedGym", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 12f); lineTo(18f, 12f)
                moveTo(3f, 9f); lineTo(3f, 15f); moveTo(6f, 8f); lineTo(6f, 16f)
                moveTo(21f, 9f); lineTo(21f, 15f); moveTo(18f, 8f); lineTo(18f, 16f)
            }
        }.build()
    }

    /** sport — trophy */
    val Sport: ImageVector by lazy {
        ImageVector.Builder("Sport", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 4f); lineTo(17f, 4f); lineTo(17f, 10f); curveTo(17f, 13f, 15f, 15f, 12f, 15f)
                curveTo(9f, 15f, 7f, 13f, 7f, 10f); close()
                moveTo(12f, 15f); lineTo(12f, 18f)
                moveTo(8f, 20f); lineTo(16f, 20f)
                moveTo(12f, 18f); lineTo(12f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 6f); curveTo(5f, 6f, 3f, 7f, 3f, 9f); curveTo(3f, 11f, 5f, 12f, 7f, 12f)
                moveTo(17f, 6f); curveTo(19f, 6f, 21f, 7f, 21f, 9f); curveTo(21f, 11f, 19f, 12f, 17f, 12f)
            }
        }.build()
    }

    /** walk — person walking */
    val Walk: ImageVector by lazy {
        ImageVector.Builder("MissedWalk", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 14f)
                moveTo(12f, 9f); lineTo(8f, 12f); moveTo(12f, 9f); lineTo(16f, 11f)
                moveTo(12f, 14f); lineTo(9f, 22f); moveTo(12f, 14f); lineTo(15f, 22f)
            }
        }.build()
    }

    // ─── LEISURE ────────────────────────────────────────────

    /** hobbies — palette */
    val Hobbies: ImageVector by lazy {
        ImageVector.Builder("MissedHobbies", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); curveTo(17f, 2f, 22f, 6f, 22f, 12f); curveTo(22f, 14f, 20f, 15f, 18f, 15f)
                lineTo(16f, 15f); curveTo(15f, 15f, 14f, 16f, 14f, 17f); curveTo(14f, 18f, 14f, 19f, 13f, 20f)
                curveTo(12f, 21f, 10f, 22f, 8f, 22f); curveTo(4f, 22f, 2f, 18f, 2f, 12f); curveTo(2f, 6f, 6f, 2f, 12f, 2f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 12f); lineTo(7.1f, 12f)
                moveTo(12f, 7f); lineTo(12.1f, 7f)
                moveTo(17f, 10f); lineTo(17.1f, 10f)
            }
        }.build()
    }

    // ─── OTHER ──────────────────────────────────────────────

    /** chores — broom */
    val Chores: ImageVector by lazy {
        ImageVector.Builder("Chores", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 12f)
                moveTo(8f, 12f); lineTo(16f, 12f); lineTo(18f, 22f); lineTo(6f, 22f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(19f, 3f); lineTo(19f, 5f); moveTo(18f, 4f); lineTo(20f, 4f)
                moveTo(5f, 6f); lineTo(5f, 8f); moveTo(4f, 7f); lineTo(6f, 7f)
            }
        }.build()
    }

    /** cooking — pot with steam */
    val Cooking: ImageVector by lazy {
        ImageVector.Builder("MissedCooking", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 12f); lineTo(20f, 12f); lineTo(20f, 18f); curveTo(20f, 20f, 18f, 21f, 16f, 21f)
                lineTo(8f, 21f); curveTo(6f, 21f, 4f, 20f, 4f, 18f); close()
                moveTo(2f, 12f); lineTo(22f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(9f, 9f); curveTo(9f, 7f, 10f, 6f, 9f, 5f)
                moveTo(12f, 9f); curveTo(12f, 7f, 13f, 6f, 12f, 5f)
                moveTo(15f, 9f); curveTo(15f, 7f, 16f, 6f, 15f, 5f)
            }
        }.build()
    }

    /** shopping — bag */
    val Shopping: ImageVector by lazy {
        ImageVector.Builder("MissedShopping", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 8f); lineTo(5f, 20f); lineTo(19f, 20f); lineTo(19f, 8f); close()
                moveTo(8f, 8f); lineTo(8f, 6f); curveTo(8f, 4f, 10f, 2f, 12f, 2f); curveTo(14f, 2f, 16f, 4f, 16f, 6f); lineTo(16f, 8f)
            }
        }.build()
    }

    // ─── SOCIAL ─────────────────────────────────────────────

    /** date — heart */
    val Date: ImageVector by lazy {
        ImageVector.Builder("Date", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 8f); curveTo(12f, 5f, 9f, 3f, 7f, 5f); curveTo(5f, 7f, 5f, 10f, 12f, 19f)
                curveTo(19f, 10f, 19f, 7f, 17f, 5f); curveTo(15f, 3f, 12f, 5f, 12f, 8f)
            }
        }.build()
    }

    /** family_event — people with star */
    val FamilyEvent: ImageVector by lazy {
        ImageVector.Builder("FamilyEvent", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(11f, 8f); arcTo(3f, 3f, 0f, true, true, 5f, 8f); arcTo(3f, 3f, 0f, true, true, 11f, 8f)
                moveTo(1f, 20f); curveTo(1f, 16f, 4f, 14f, 8f, 14f); curveTo(10f, 14f, 12f, 15f, 13f, 16f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 4f); lineTo(19.7f, 6f); lineTo(22f, 6.3f); lineTo(20.3f, 8f); lineTo(20.7f, 10.3f)
                lineTo(19f, 9.2f); lineTo(17.3f, 10.3f); lineTo(17.7f, 8f); lineTo(16f, 6.3f); lineTo(18.3f, 6f); close()
            }
        }.build()
    }

    /** night_out — moon + glass */
    val NightOut: ImageVector by lazy {
        ImageVector.Builder("NightOut", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cocktail glass
                moveTo(7f, 3f); lineTo(17f, 3f); lineTo(12f, 12f); close()
                moveTo(12f, 12f); lineTo(12f, 19f)
                moveTo(8f, 19f); lineTo(16f, 19f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(19f, 5f); lineTo(19f, 7f); moveTo(18f, 6f); lineTo(20f, 6f)
            }
        }.build()
    }

    /** social_plans — two people */
    val SocialPlans: ImageVector by lazy {
        ImageVector.Builder("SocialPlans", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(11f, 6f); arcTo(3f, 3f, 0f, true, true, 5f, 6f); arcTo(3f, 3f, 0f, true, true, 11f, 6f)
                moveTo(1f, 20f); curveTo(1f, 16f, 4f, 13f, 8f, 13f); curveTo(12f, 13f, 15f, 16f, 15f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 6f); arcTo(2.5f, 2.5f, 0f, true, true, 14f, 6f); arcTo(2.5f, 2.5f, 0f, true, true, 19f, 6f)
                moveTo(23f, 20f); curveTo(23f, 17f, 21f, 14f, 17f, 14f)
            }
        }.build()
    }

    // ─── TRAVEL ─────────────────────────────────────────────

    /** driving — car */
    val Driving: ImageVector by lazy {
        ImageVector.Builder("MissedDriving", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 11f); lineTo(7f, 5f); lineTo(17f, 5f); lineTo(19f, 11f)
                moveTo(3f, 11f); lineTo(21f, 11f); lineTo(21f, 17f); lineTo(3f, 17f); close()
                moveTo(5f, 17f); lineTo(5f, 19f); moveTo(19f, 17f); lineTo(19f, 19f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(7f, 14f); lineTo(7.1f, 14f); moveTo(17f, 14f); lineTo(17.1f, 14f)
            }
        }.build()
    }

    /** travel — suitcase */
    val Travel: ImageVector by lazy {
        ImageVector.Builder("Travel", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 8f); lineTo(21f, 8f); lineTo(21f, 20f); lineTo(3f, 20f); close()
                moveTo(8f, 8f); lineTo(8f, 5f); curveTo(8f, 4f, 9f, 3f, 10f, 3f); lineTo(14f, 3f)
                curveTo(15f, 3f, 16f, 4f, 16f, 5f); lineTo(16f, 8f)
                moveTo(12f, 12f); lineTo(12f, 16f)
            }
        }.build()
    }

    // ─── WORK ───────────────────────────────────────────────

    /** meeting — people at table */
    val Meeting: ImageVector by lazy {
        ImageVector.Builder("MissedMeeting", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 14f); lineTo(20f, 14f)
                moveTo(7f, 10f); arcTo(2f, 2f, 0f, true, true, 3f, 10f); arcTo(2f, 2f, 0f, true, true, 7f, 10f)
                moveTo(14f, 10f); arcTo(2f, 2f, 0f, true, true, 10f, 10f); arcTo(2f, 2f, 0f, true, true, 14f, 10f)
                moveTo(21f, 10f); arcTo(2f, 2f, 0f, true, true, 17f, 10f); arcTo(2f, 2f, 0f, true, true, 21f, 10f)
                moveTo(8f, 14f); lineTo(8f, 20f); moveTo(16f, 14f); lineTo(16f, 20f)
            }
        }.build()
    }

    /** school — graduation cap */
    val School: ImageVector by lazy {
        ImageVector.Builder("MissedSchool", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 10f); lineTo(12f, 5f); lineTo(22f, 10f); lineTo(12f, 15f); close()
                moveTo(6f, 12f); lineTo(6f, 17f); curveTo(6f, 17f, 9f, 20f, 12f, 20f); curveTo(15f, 20f, 18f, 17f, 18f, 17f); lineTo(18f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(22f, 10f); lineTo(22f, 16f)
            }
        }.build()
    }

    /** study — open book */
    val Study: ImageVector by lazy {
        ImageVector.Builder("MissedStudy", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 4f); lineTo(2f, 18f); curveTo(2f, 18f, 5f, 16f, 12f, 16f)
                moveTo(22f, 4f); lineTo(22f, 18f); curveTo(22f, 18f, 19f, 16f, 12f, 16f)
                moveTo(12f, 16f); lineTo(12f, 4f)
                moveTo(2f, 4f); curveTo(2f, 4f, 5f, 2f, 12f, 4f)
                moveTo(22f, 4f); curveTo(22f, 4f, 19f, 2f, 12f, 4f)
            }
        }.build()
    }

    /** work — briefcase */
    val Work: ImageVector by lazy {
        ImageVector.Builder("MissedWork", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 8f); lineTo(21f, 8f); lineTo(21f, 20f); lineTo(3f, 20f); close()
                moveTo(8f, 8f); lineTo(8f, 5f); curveTo(8f, 4f, 9f, 3f, 10f, 3f); lineTo(14f, 3f)
                curveTo(15f, 3f, 16f, 4f, 16f, 5f); lineTo(16f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 13f); lineTo(21f, 13f)
            }
        }.build()
    }

    /** other — circle X */
    val Other: ImageVector by lazy {
        ImageVector.Builder("MissedOther", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); arcTo(10f, 10f, 0f, true, true, 12f, 22f); arcTo(10f, 10f, 0f, true, true, 12f, 2f)
                moveTo(9f, 9f); lineTo(15f, 15f); moveTo(15f, 9f); lineTo(9f, 15f)
            }
        }.build()
    }

    // ─── LOOKUP ────────────────────────────────────────────────

    data class MissedActivityPickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<MissedActivityPickerIcon> by lazy { listOf(
        MissedActivityPickerIcon("childcare", "Childcare", Childcare),
        MissedActivityPickerIcon("pet_care", "Pet care", PetCare),
        MissedActivityPickerIcon("self_care", "Self-care", SelfCare),
        MissedActivityPickerIcon("exercise", "Exercise", Exercise),
        MissedActivityPickerIcon("gym", "Gym", Gym),
        MissedActivityPickerIcon("sport", "Sport", Sport),
        MissedActivityPickerIcon("walk", "Walk", Walk),
        MissedActivityPickerIcon("hobbies", "Hobbies", Hobbies),
        MissedActivityPickerIcon("chores", "Chores", Chores),
        MissedActivityPickerIcon("cooking", "Cooking", Cooking),
        MissedActivityPickerIcon("shopping", "Shopping", Shopping),
        MissedActivityPickerIcon("date", "Date", Date),
        MissedActivityPickerIcon("family_event", "Family event", FamilyEvent),
        MissedActivityPickerIcon("night_out", "Night out", NightOut),
        MissedActivityPickerIcon("social_plans", "Social plans", SocialPlans),
        MissedActivityPickerIcon("driving", "Driving", Driving),
        MissedActivityPickerIcon("travel", "Travel", Travel),
        MissedActivityPickerIcon("meeting", "Meeting", Meeting),
        MissedActivityPickerIcon("school", "School", School),
        MissedActivityPickerIcon("study", "Study", Study),
        MissedActivityPickerIcon("work", "Work", Work),
        MissedActivityPickerIcon("other", "Other", Other),
    ) }

    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: MissedActivityViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MissedActivityViewModel : ViewModel() {

    private val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserMissedActivityRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserMissedActivityRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.MissedActivityPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.MissedActivityPrefRow>> = _frequent

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            runCatching {
                _pool.value = db.getAllMissedActivityPool(accessToken)
                _frequent.value = db.getMissedActivityPrefs(accessToken).sortedBy { it.position }
            }.onFailure { it.printStackTrace() }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null) {
        viewModelScope.launch {
            runCatching { db.upsertMissedActivityToPool(accessToken, label, category); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun removeFromPool(accessToken: String, id: String) {
        viewModelScope.launch {
            runCatching { db.deleteMissedActivityFromPool(accessToken, id); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun addToFrequent(accessToken: String, id: String) {
        viewModelScope.launch {
            runCatching {
                val pos = (_frequent.value.maxOfOrNull { it.position } ?: -1) + 1
                db.insertMissedActivityPref(accessToken, id, pos, "frequent"); loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            runCatching { db.deleteMissedActivityPref(accessToken, prefId); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun setCategory(accessToken: String, id: String, category: String?) {
        viewModelScope.launch {
            runCatching { db.setMissedActivityCategory(accessToken, id, category); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }

    fun setAutomation(accessToken: String, id: String, enabled: Boolean) {
        viewModelScope.launch {
            runCatching { db.setMissedActivityAutomation(accessToken, id, enabled); loadAll(accessToken) }
                .onFailure { it.printStackTrace() }
        }
    }
}


title: MonitorCardConfig.kt
text:
package com.migraineme

import android.content.Context
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

/**
 * Configuration for Monitor screen cards - visibility and order
 */
@Serializable
data class MonitorCardConfig(
    val cardOrder: List<String> = DEFAULT_ORDER,
    val hiddenCards: Set<String> = emptySet(),
    val nutritionDisplayMetrics: List<String> = DEFAULT_NUTRITION_METRICS
) {
    companion object {
        // Card identifiers
        const val CARD_NUTRITION = "nutrition"
        const val CARD_PHYSICAL = "physical"
        const val CARD_SLEEP = "sleep"
        const val CARD_MENTAL = "mental"
        const val CARD_ENVIRONMENT = "environment"
        const val CARD_MENSTRUATION = "menstruation"
        
        val DEFAULT_ORDER = listOf(
            CARD_NUTRITION,
            CARD_ENVIRONMENT,
            CARD_PHYSICAL,
            CARD_SLEEP,
            CARD_MENTAL,
            CARD_MENSTRUATION
        )
        
        val CARD_LABELS = mapOf(
            CARD_NUTRITION to "Nutrition",
            CARD_PHYSICAL to "Physical Health",
            CARD_SLEEP to "Sleep",
            CARD_MENTAL to "Mental Health",
            CARD_ENVIRONMENT to "Environment",
            CARD_MENSTRUATION to "Menstruation"
        )
        
        // Nutrition metric identifiers
        const val METRIC_CALORIES = "calories"
        const val METRIC_PROTEIN = "protein"
        const val METRIC_CARBS = "carbs"
        const val METRIC_FAT = "fat"
        const val METRIC_FIBER = "fiber"
        const val METRIC_SUGAR = "sugar"
        const val METRIC_SODIUM = "sodium"
        const val METRIC_CAFFEINE = "caffeine"
        const val METRIC_CHOLESTEROL = "cholesterol"
        const val METRIC_SATURATED_FAT = "saturated_fat"
        const val METRIC_UNSATURATED_FAT = "unsaturated_fat"
        const val METRIC_TRANS_FAT = "trans_fat"
        const val METRIC_POTASSIUM = "potassium"
        const val METRIC_CALCIUM = "calcium"
        const val METRIC_IRON = "iron"
        const val METRIC_MAGNESIUM = "magnesium"
        const val METRIC_ZINC = "zinc"
        const val METRIC_SELENIUM = "selenium"
        const val METRIC_PHOSPHORUS = "phosphorus"
        const val METRIC_COPPER = "copper"
        const val METRIC_MANGANESE = "manganese"
        const val METRIC_VITAMIN_A = "vitamin_a"
        const val METRIC_VITAMIN_C = "vitamin_c"
        const val METRIC_VITAMIN_D = "vitamin_d"
        const val METRIC_VITAMIN_E = "vitamin_e"
        const val METRIC_VITAMIN_K = "vitamin_k"
        const val METRIC_VITAMIN_B6 = "vitamin_b6"
        const val METRIC_VITAMIN_B12 = "vitamin_b12"
        const val METRIC_THIAMIN = "thiamin"
        const val METRIC_RIBOFLAVIN = "riboflavin"
        const val METRIC_NIACIN = "niacin"
        const val METRIC_FOLATE = "folate"
        const val METRIC_BIOTIN = "biotin"
        const val METRIC_PANTOTHENIC_ACID = "pantothenic_acid"
        const val METRIC_TYRAMINE_EXPOSURE = "tyramine_exposure"
        const val METRIC_ALCOHOL_EXPOSURE = "alcohol_exposure"
        const val METRIC_GLUTEN_EXPOSURE = "gluten_exposure"
        
        val DEFAULT_NUTRITION_METRICS = listOf(
            METRIC_CALORIES,
            METRIC_PROTEIN,
            METRIC_CAFFEINE
        )
        
        val ALL_NUTRITION_METRICS = listOf(
            METRIC_BIOTIN,
            METRIC_CAFFEINE,
            METRIC_CALCIUM,
            METRIC_CALORIES,
            METRIC_CARBS,
            METRIC_CHOLESTEROL,
            METRIC_COPPER,
            METRIC_FAT,
            METRIC_FIBER,
            METRIC_FOLATE,
            METRIC_IRON,
            METRIC_MAGNESIUM,
            METRIC_MANGANESE,
            METRIC_NIACIN,
            METRIC_PANTOTHENIC_ACID,
            METRIC_PHOSPHORUS,
            METRIC_POTASSIUM,
            METRIC_PROTEIN,
            METRIC_RIBOFLAVIN,
            METRIC_SATURATED_FAT,
            METRIC_SELENIUM,
            METRIC_SODIUM,
            METRIC_SUGAR,
            METRIC_THIAMIN,
            METRIC_TRANS_FAT,
            METRIC_UNSATURATED_FAT,
            METRIC_VITAMIN_A,
            METRIC_VITAMIN_B6,
            METRIC_VITAMIN_B12,
            METRIC_VITAMIN_C,
            METRIC_VITAMIN_D,
            METRIC_VITAMIN_E,
            METRIC_VITAMIN_K,
            METRIC_ZINC,
            METRIC_TYRAMINE_EXPOSURE,
            METRIC_ALCOHOL_EXPOSURE,
            METRIC_GLUTEN_EXPOSURE
        )
        
        val NUTRITION_METRIC_LABELS = mapOf(
            METRIC_CALORIES to "Calories",
            METRIC_PROTEIN to "Protein",
            METRIC_CARBS to "Carbs",
            METRIC_FAT to "Fat",
            METRIC_FIBER to "Fiber",
            METRIC_SUGAR to "Sugar",
            METRIC_SODIUM to "Sodium",
            METRIC_CAFFEINE to "Caffeine",
            METRIC_CHOLESTEROL to "Cholesterol",
            METRIC_SATURATED_FAT to "Sat. Fat",
            METRIC_UNSATURATED_FAT to "Unsat. Fat",
            METRIC_TRANS_FAT to "Trans Fat",
            METRIC_POTASSIUM to "Potassium",
            METRIC_CALCIUM to "Calcium",
            METRIC_IRON to "Iron",
            METRIC_MAGNESIUM to "Magnesium",
            METRIC_ZINC to "Zinc",
            METRIC_SELENIUM to "Selenium",
            METRIC_PHOSPHORUS to "Phosphorus",
            METRIC_COPPER to "Copper",
            METRIC_MANGANESE to "Manganese",
            METRIC_VITAMIN_A to "Vitamin A",
            METRIC_VITAMIN_C to "Vitamin C",
            METRIC_VITAMIN_D to "Vitamin D",
            METRIC_VITAMIN_E to "Vitamin E",
            METRIC_VITAMIN_K to "Vitamin K",
            METRIC_VITAMIN_B6 to "Vitamin B6",
            METRIC_VITAMIN_B12 to "Vitamin B12",
            METRIC_THIAMIN to "Thiamin (B1)",
            METRIC_RIBOFLAVIN to "Riboflavin (B2)",
            METRIC_NIACIN to "Niacin (B3)",
            METRIC_FOLATE to "Folate (B9)",
            METRIC_BIOTIN to "Biotin (B7)",
            METRIC_PANTOTHENIC_ACID to "Pantothenic (B5)",
            METRIC_TYRAMINE_EXPOSURE to "Tyramine",
            METRIC_ALCOHOL_EXPOSURE to "Alcohol",
            METRIC_GLUTEN_EXPOSURE to "Gluten"
        )
        
        val NUTRITION_METRIC_UNITS = mapOf(
            METRIC_CALORIES to "",
            METRIC_PROTEIN to "g",
            METRIC_CARBS to "g",
            METRIC_FAT to "g",
            METRIC_FIBER to "g",
            METRIC_SUGAR to "g",
            METRIC_SODIUM to "mg",
            METRIC_CAFFEINE to "mg",
            METRIC_CHOLESTEROL to "mg",
            METRIC_SATURATED_FAT to "g",
            METRIC_UNSATURATED_FAT to "g",
            METRIC_TRANS_FAT to "g",
            METRIC_POTASSIUM to "mg",
            METRIC_CALCIUM to "mg",
            METRIC_IRON to "mg",
            METRIC_MAGNESIUM to "mg",
            METRIC_ZINC to "mg",
            METRIC_SELENIUM to "mcg",
            METRIC_PHOSPHORUS to "mg",
            METRIC_COPPER to "mg",
            METRIC_MANGANESE to "mg",
            METRIC_VITAMIN_A to "mcg",
            METRIC_VITAMIN_C to "mg",
            METRIC_VITAMIN_D to "mcg",
            METRIC_VITAMIN_E to "mg",
            METRIC_VITAMIN_K to "mcg",
            METRIC_VITAMIN_B6 to "mg",
            METRIC_VITAMIN_B12 to "mcg",
            METRIC_THIAMIN to "mg",
            METRIC_RIBOFLAVIN to "mg",
            METRIC_NIACIN to "mg",
            METRIC_FOLATE to "mcg",
            METRIC_BIOTIN to "mcg",
            METRIC_PANTOTHENIC_ACID to "mg",
            METRIC_TYRAMINE_EXPOSURE to "",
            METRIC_ALCOHOL_EXPOSURE to "",
            METRIC_GLUTEN_EXPOSURE to ""
        )

        /** Set of categorical risk metrics (use MAX not SUM, display as labels) */
        val RISK_METRICS = setOf(METRIC_TYRAMINE_EXPOSURE, METRIC_ALCOHOL_EXPOSURE, METRIC_GLUTEN_EXPOSURE)

        fun isRiskMetric(metric: String) = metric in RISK_METRICS
    }
    
    fun isVisible(cardId: String): Boolean = cardId !in hiddenCards
    
    fun getOrderedVisibleCards(): List<String> {
        return cardOrder.filter { it !in hiddenCards }
    }
    
    fun toggleVisibility(cardId: String): MonitorCardConfig {
        val newHidden = if (cardId in hiddenCards) {
            hiddenCards - cardId
        } else {
            hiddenCards + cardId
        }
        return copy(hiddenCards = newHidden)
    }
    
    fun moveCard(fromIndex: Int, toIndex: Int): MonitorCardConfig {
        if (fromIndex == toIndex) return this
        if (fromIndex < 0 || fromIndex >= cardOrder.size) return this
        if (toIndex < 0 || toIndex >= cardOrder.size) return this
        
        val mutableList = cardOrder.toMutableList()
        val item = mutableList.removeAt(fromIndex)
        mutableList.add(toIndex, item)
        return copy(cardOrder = mutableList)
    }
    
    fun toggleNutritionMetric(metric: String): MonitorCardConfig {
        val current = nutritionDisplayMetrics.toMutableList()
        if (metric in current) {
            current.remove(metric)
        } else if (current.size < 3) {
            current.add(metric)
        }
        return copy(nutritionDisplayMetrics = current)
    }
}

/**
 * Store for Monitor card configuration
 */
object MonitorCardConfigStore {
    private const val PREFS_NAME = "monitor_card_config"
    private const val KEY_CONFIG = "config_json"
    
    private val json = Json { 
        ignoreUnknownKeys = true 
        encodeDefaults = true
    }
    
    fun load(context: Context): MonitorCardConfig {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val jsonStr = prefs.getString(KEY_CONFIG, null)
        
        return if (jsonStr != null) {
            try {
                json.decodeFromString<MonitorCardConfig>(jsonStr)
            } catch (e: Exception) {
                MonitorCardConfig()
            }
        } else {
            MonitorCardConfig()
        }
    }
    
    fun save(context: Context, config: MonitorCardConfig) {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val jsonStr = json.encodeToString(config)
        prefs.edit().putString(KEY_CONFIG, jsonStr).apply()
    }
}



title: MonitorConfigScreen.kt
text:
package com.migraineme

import androidx.compose.animation.core.animateDpAsState
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.DragHandle
import androidx.compose.material.icons.outlined.Bedtime
import androidx.compose.material.icons.outlined.BubbleChart
import androidx.compose.material.icons.outlined.Cloud
import androidx.compose.material.icons.outlined.FavoriteBorder
import androidx.compose.material.icons.outlined.FitnessCenter
import androidx.compose.material.icons.outlined.Restaurant
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Switch
import androidx.compose.material3.SwitchDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import org.burnoutcrew.reorderable.ReorderableItem
import org.burnoutcrew.reorderable.detectReorderAfterLongPress
import org.burnoutcrew.reorderable.rememberReorderableLazyListState
import org.burnoutcrew.reorderable.reorderable

@Composable
fun MonitorConfigScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    var config by remember { mutableStateOf(MonitorCardConfigStore.load(context)) }

    fun updateConfig(newConfig: MonitorCardConfig) {
        config = newConfig
        MonitorCardConfigStore.save(context, newConfig)
    }

    val reorderState = rememberReorderableLazyListState(
        onMove = { from, to ->
            // Adjust for header items (spacer + back button + header = 3 items)
            val fromIndex = from.index - 3
            val toIndex = to.index - 3
            if (fromIndex >= 0 && toIndex >= 0) {
                updateConfig(config.moveCard(fromIndex, toIndex))
            }
        }
    )

    LazyColumn(
        state = reorderState.listState,
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 16.dp)
            .reorderable(reorderState),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Top spacer for logo reveal area
        item {
            Spacer(Modifier.height(AppTheme.LogoRevealHeight))
        }

        // Back button
        item {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = onBack) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                }
            }
        }

        // Header in HeroCard
        item {
            HeroCard {
                Text(
                    "Customize your Monitor",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    "Long-press and drag to reorder cards",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }

        // Card items
        itemsIndexed(
            items = config.cardOrder,
            key = { _, cardId -> cardId }
        ) { _, cardId ->
            ReorderableItem(reorderState, key = cardId) { isDragging ->
                val elevation by animateDpAsState(if (isDragging) 8.dp else 0.dp, label = "elevation")

                CardConfigItem(
                    cardId = cardId,
                    isVisible = config.isVisible(cardId),
                    isDragging = isDragging,
                    elevation = elevation,
                    onToggleVisibility = {
                        updateConfig(config.toggleVisibility(cardId))
                    },
                    modifier = Modifier.detectReorderAfterLongPress(reorderState)
                )
            }
        }

        // Bottom spacer
        item {
            Spacer(Modifier.height(16.dp))
        }
    }
}

@Composable
private fun CardConfigItem(
    cardId: String,
    isVisible: Boolean,
    isDragging: Boolean,
    elevation: androidx.compose.ui.unit.Dp,
    onToggleVisibility: () -> Unit,
    modifier: Modifier = Modifier
) {
    val icon = getCardIcon(cardId)
    val iconTint = getCardIconTint(cardId)
    val label = MonitorCardConfig.CARD_LABELS[cardId] ?: cardId

    BaseCard(
        modifier = modifier
            .shadow(elevation, shape = AppTheme.BaseCardShape)
            .alpha(if (isVisible) 1f else 0.6f)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Drag handle
            Icon(
                imageVector = Icons.Default.DragHandle,
                contentDescription = "Drag to reorder",
                tint = AppTheme.SubtleTextColor,
                modifier = Modifier.size(24.dp)
            )

            Spacer(Modifier.width(12.dp))

            // Card icon
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = if (isVisible) iconTint else iconTint.copy(alpha = 0.4f),
                modifier = Modifier.size(24.dp)
            )

            Spacer(Modifier.width(12.dp))

            // Card name
            Text(
                text = label,
                color = if (isVisible) AppTheme.TitleColor else AppTheme.TitleColor.copy(alpha = 0.5f),
                style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.Medium),
                modifier = Modifier.weight(1f)
            )

            // Visibility toggle
            Switch(
                checked = isVisible,
                onCheckedChange = { onToggleVisibility() },
                colors = SwitchDefaults.colors(
                    checkedThumbColor = AppTheme.AccentPurple,
                    checkedTrackColor = AppTheme.AccentPurple.copy(alpha = 0.5f),
                    uncheckedThumbColor = AppTheme.SubtleTextColor,
                    uncheckedTrackColor = AppTheme.TrackColor
                )
            )
        }
    }
}

private fun getCardIcon(cardId: String): ImageVector {
    return when (cardId) {
        MonitorCardConfig.CARD_NUTRITION -> Icons.Outlined.Restaurant
        MonitorCardConfig.CARD_PHYSICAL -> Icons.Outlined.FitnessCenter
        MonitorCardConfig.CARD_SLEEP -> Icons.Outlined.Bedtime
        MonitorCardConfig.CARD_MENTAL -> Icons.Outlined.BubbleChart
        MonitorCardConfig.CARD_ENVIRONMENT -> Icons.Outlined.Cloud
        MonitorCardConfig.CARD_MENSTRUATION -> Icons.Outlined.FavoriteBorder
        else -> Icons.Outlined.Cloud
    }
}

private fun getCardIconTint(cardId: String): Color {
    return when (cardId) {
        MonitorCardConfig.CARD_NUTRITION -> Color(0xFFFFB74D)
        MonitorCardConfig.CARD_PHYSICAL -> Color(0xFF81C784)
        MonitorCardConfig.CARD_SLEEP -> Color(0xFF7986CB)
        MonitorCardConfig.CARD_MENTAL -> Color(0xFFBA68C8)
        MonitorCardConfig.CARD_ENVIRONMENT -> Color(0xFF4FC3F7)
        MonitorCardConfig.CARD_MENSTRUATION -> Color(0xFFE57373)
        else -> Color(0xFF4FC3F7)
    }
}



title: MonitorEnvironmentScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.time.format.DateTimeFormatter

@Composable
fun MonitorEnvironmentScreen(
    navController: NavController,
    authVm: AuthViewModel
) {
    val context = LocalContext.current
    val scrollState = rememberScrollState()
    val scope = rememberCoroutineScope()

    val weatherService = remember { WeatherHistoryService(context) }

    // Today's weather
    var todayWeather by remember { mutableStateOf<WeatherDayData?>(null) }
    var isLoadingToday by remember { mutableStateOf(true) }
    val weatherConfig = remember { WeatherCardConfigStore.load(context) }

    // Forecast data (next 6 days)
    var forecastDays by remember { mutableStateOf<List<WeatherDayData>>(emptyList()) }

    // Load today's weather + forecast
    LaunchedEffect(Unit) {
        scope.launch {
            todayWeather = weatherService.getTodayWeather()
            // Fetch 7 days ending 6 days from now to get forecast
            val today = LocalDate.now()
            val result = weatherService.getWeatherHistory(7, today.plusDays(6))
            forecastDays = result.days.filter { it.date > today.toString() }
            isLoadingToday = false
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Back navigation
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }


            // Customize card - controls what shows on MONITOR screen's weather card
            HeroCard(
                modifier = Modifier.clickable { navController.navigate(Routes.WEATHER_CONFIG) }
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        Icons.Outlined.Tune,
                        contentDescription = "Configure",
                        tint = AppTheme.AccentPurple,
                        modifier = Modifier.size(24.dp)
                    )
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            "Customize Monitor Card",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                        )
                        Text(
                            "Choose 3 metrics for the Weather card on Monitor",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                    Text(
                        "→",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            }
            BaseCard {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Spacer(Modifier.width(12.dp))
                    Column {
                        Text("Barometric pressure changes, humidity, and temperature fluctuations are common migraine triggers. We track these automatically based on your location.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyLarge)
                    }
                }
            }
            // Today's weather card - show ALL metrics
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth().clickable { navController.navigate(Routes.ENV_DATA_HISTORY) },
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        "Today's Weather",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Text("History →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                }
                Spacer(Modifier.height(8.dp))

                if (isLoadingToday) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(24.dp),
                            color = AppTheme.AccentPurple,
                            strokeWidth = 2.dp
                        )
                    }
                } else if (todayWeather == null) {
                    Text(
                        "No weather data for today",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                } else {
                    // Weather condition
                    val condition = weatherCodeToCondition(todayWeather!!.weatherCode)
                    Text(
                        condition,
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )

                    if (todayWeather!!.isThunderstormDay) {
                        Text(
                            "⚡ Thunderstorm detected",
                            color = Color(0xFFFFB74D),
                            style = MaterialTheme.typography.bodySmall
                        )
                    }

                    Spacer(Modifier.height(8.dp))

                    // Top 3 selected metrics
                    val selectedMetrics = weatherConfig.weatherDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val value = weatherMetricValue(todayWeather!!, metric) ?: "—"
                            val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(value, color = slotColors.getOrElse(index) { slotColors.last() }, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
                                Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    }

                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text("All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    // All remaining metrics
                    WeatherCardConfig.ALL_WEATHER_METRICS.forEach { metric ->
                        if (metric !in selectedMetrics) {
                            val value = weatherMetricValue(todayWeather!!, metric) ?: "—"
                            val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                            Row(
                                modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                                Text(value, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
                            }
                        }
                    }
                }
            }

            // 7-Day Forecast
            if (forecastDays.isNotEmpty()) {
                BaseCard {
                    Text(
                        "7-Day Forecast",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Spacer(Modifier.height(8.dp))

                    val dayFormatter = DateTimeFormatter.ofPattern("EEE")
                    val dateFormatter = DateTimeFormatter.ofPattern("d MMM")
                    val selectedMetrics = weatherConfig.weatherDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                    forecastDays.forEach { day ->
                        val date = LocalDate.parse(day.date)
                        val dayLabel = if (date == LocalDate.now().plusDays(1)) "Tomorrow" else date.format(dayFormatter)
                        val condition = weatherCodeToCondition(day.weatherCode)

                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { navController.navigate(Routes.ENV_DATA_HISTORY) }
                                .padding(vertical = 6.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column(modifier = Modifier.weight(0.8f)) {
                                Text(
                                    dayLabel,
                                    color = Color(0xFF4FC3F7),
                                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
                                )
                                Text(
                                    date.format(dateFormatter),
                                    color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.bodySmall
                                )
                            }
                            Text(
                                condition,
                                color = AppTheme.BodyTextColor,
                                style = MaterialTheme.typography.bodySmall,
                                modifier = Modifier.weight(1f)
                            )
                            Column(horizontalAlignment = Alignment.End) {
                                selectedMetrics.forEachIndexed { index, metric ->
                                    val value = weatherMetricValue(day, metric) ?: "—"
                                    val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                                    Text(
                                        "$value",
                                        color = slotColors.getOrElse(index) { slotColors.last() },
                                        style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium)
                                    )
                                }
                            }
                        }
                        if (day != forecastDays.last()) {
                            HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.1f))
                        }
                    }
                }
            }

            // History + Forecast Graph
            WeatherHistoryGraph(
                days = 21,
                endDate = LocalDate.now().plusDays(6),
                forecastStartDate = LocalDate.now().plusDays(1).toString(),
                onClick = { navController.navigate(Routes.FULL_GRAPH_WEATHER) }
            )


        }
    }
}

private fun weatherMetricValue(weather: WeatherDayData, metric: String): String? {
    val v = when (metric) {
        WeatherCardConfig.METRIC_TEMPERATURE -> weather.tempMean
        WeatherCardConfig.METRIC_PRESSURE -> weather.pressureMean
        WeatherCardConfig.METRIC_HUMIDITY -> weather.humidityMean
        WeatherCardConfig.METRIC_WIND_SPEED -> weather.windSpeedMean
        WeatherCardConfig.METRIC_UV_INDEX -> weather.uvIndexMax
        WeatherCardConfig.METRIC_ALTITUDE -> weather.altitudeMaxM
        WeatherCardConfig.METRIC_ALTITUDE_CHANGE -> weather.altitudeChangeM
        else -> null
    } ?: return null
    if (v == 0.0 && metric != WeatherCardConfig.METRIC_UV_INDEX && metric != WeatherCardConfig.METRIC_ALTITUDE) return null
    val unit = WeatherCardConfig.WEATHER_METRIC_UNITS[metric] ?: ""
    return when (metric) {
        WeatherCardConfig.METRIC_PRESSURE -> String.format("%.0f%s", v, unit)
        WeatherCardConfig.METRIC_ALTITUDE -> String.format("%.0f%s", v, unit)
        WeatherCardConfig.METRIC_ALTITUDE_CHANGE -> String.format("%.0f%s", v, unit)
        else -> String.format("%.1f%s", v, unit)
    }
}

private fun weatherMetricColor(metric: String): Color = when (metric) {
    WeatherCardConfig.METRIC_TEMPERATURE -> Color(0xFFFF8A65)
    WeatherCardConfig.METRIC_PRESSURE -> Color(0xFF7986CB)
    WeatherCardConfig.METRIC_HUMIDITY -> Color(0xFF4FC3F7)
    WeatherCardConfig.METRIC_WIND_SPEED -> Color(0xFF81C784)
    WeatherCardConfig.METRIC_UV_INDEX -> Color(0xFFFFB74D)
    WeatherCardConfig.METRIC_ALTITUDE -> Color(0xFFCE93D8)
    WeatherCardConfig.METRIC_ALTITUDE_CHANGE -> Color(0xFFBA68C8)
    else -> Color(0xFF4FC3F7)
}

private fun weatherCodeToCondition(code: Int): String {
    return when (code) {
        0 -> "Clear sky"
        1 -> "Mainly clear"
        2 -> "Partly cloudy"
        3 -> "Overcast"
        45, 48 -> "Foggy"
        51, 53, 55 -> "Drizzle"
        56, 57 -> "Freezing drizzle"
        61, 63, 65 -> "Rain"
        66, 67 -> "Freezing rain"
        71, 73, 75 -> "Snow"
        77 -> "Snow grains"
        80, 81, 82 -> "Rain showers"
        85, 86 -> "Snow showers"
        95 -> "Thunderstorm"
        96, 99 -> "Thunderstorm with hail"
        else -> "Unknown"
    }
}



title: MonitorMentalScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId

@Composable
fun MonitorMentalScreen(
    navController: NavController,
    authVm: AuthViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()
    val today = remember { LocalDate.now(ZoneId.systemDefault()).toString() }

    var mentalDetail by remember { mutableStateOf<MentalDetailData?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    val mentalConfig = remember { MentalCardConfigStore.load(ctx) }

    LaunchedEffect(authState.accessToken, today) {
        val token = authState.accessToken
        if (token.isNullOrBlank()) {
            isLoading = false
            return@LaunchedEffect
        }
        withContext(Dispatchers.IO) {
            mentalDetail = try { loadMentalDetailData(ctx, token, today) } catch (e: Exception) { Log.e("MentalDetail", "Load failed", e); null }
            isLoading = false
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Back
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                }
            }

            // Customize HeroCard
            HeroCard(modifier = Modifier.clickable { navController.navigate(Routes.MENTAL_CONFIG) }) {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.Tune, contentDescription = "Configure", tint = AppTheme.AccentPurple, modifier = Modifier.size(24.dp))
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(text = "Customize Monitor Card", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                        Text(text = "Choose 3 metrics for the Mental Health card on Monitor", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    }
                    Text(text = "→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
                }
            }

            // Explainer
            BaseCard {
                Text(
                    text = "Screen time, phone usage patterns, and environmental noise are linked to stress and migraine triggers. Tracking these passively helps identify behavioral patterns.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyLarge
                )
            }

            // Today's Mental Health — shows ALL metrics
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth().clickable { navController.navigate(Routes.MENTAL_DATA_HISTORY) },
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(text = "Today's Data", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("History →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                }
                Spacer(Modifier.height(8.dp))

                if (isLoading) {
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                    }
                } else if (mentalDetail == null) {
                    Text(text = "No mental health data for today", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    Spacer(Modifier.height(4.dp))
                    Text(text = "Enable metrics in Data Settings to start tracking", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                } else {
                    val detail = mentalDetail!!

                    // Top 3 selected metrics
                    val selectedMetrics = mentalConfig.mentalDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val value = detail.displayValue(metric) ?: "—"
                            val label = MentalCardConfig.labelFor(metric)
                            MentalMetricLargeItem(label, value, slotColors.getOrElse(index) { slotColors.last() })
                        }
                    }

                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text(text = "All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    // All metrics (show "—" for missing data)
                    MentalCardConfig.ALL_MENTAL_METRICS.forEach { metric ->
                        if (metric !in selectedMetrics) {
                            val value = detail.displayValue(metric) ?: "—"
                            val label = MentalCardConfig.labelFor(metric)
                            MentalMetricRowItem(label, value, AppTheme.SubtleTextColor)
                        }
                    }
                }
            }

            // History Graph
            MentalHistoryGraph(
                days = 14,
                onClick = { navController.navigate(Routes.FULL_GRAPH_MENTAL) }
            )
        }
    }
}

@Composable
private fun MentalMetricLargeItem(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(text = value, color = color, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
        Text(text = label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}

@Composable
private fun MentalMetricRowItem(label: String, value: String, color: Color) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
        Text(text = value, color = color, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
    }
}

// ─── Data class ──────────────────────────────────────────────────────────────

private data class MentalDetailData(
    val stress: Double?,
    val screenTimeHours: Double?,
    val lateScreenTimeHours: Double?,
    val noiseIndex: Double?,
    val brightness: Double?,
    val volumePct: Double?,
    val darkModeHours: Double?,
    val unlockCount: Int?
) {
    fun displayValue(metric: String): String? = when (metric) {
        MentalCardConfig.METRIC_STRESS -> stress?.let { String.format("%.0f", it) }
        MentalCardConfig.METRIC_SCREEN_TIME -> screenTimeHours?.let { String.format("%.1fh", it) }
        MentalCardConfig.METRIC_LATE_SCREEN_TIME -> lateScreenTimeHours?.let { String.format("%.1fh", it) }
        MentalCardConfig.METRIC_NOISE -> noiseIndex?.let { String.format("%.0f dB", it) }
        MentalCardConfig.METRIC_BRIGHTNESS -> brightness?.let { String.format("%.0f", it) }
        MentalCardConfig.METRIC_VOLUME -> volumePct?.let { "${it.toInt()}%" }
        MentalCardConfig.METRIC_DARK_MODE -> darkModeHours?.let { String.format("%.1fh", it) }
        MentalCardConfig.METRIC_UNLOCKS -> unlockCount?.let { "$it" }
        else -> null
    }

    fun numericValue(metric: String): Double? = when (metric) {
        MentalCardConfig.METRIC_STRESS -> stress
        MentalCardConfig.METRIC_SCREEN_TIME -> screenTimeHours
        MentalCardConfig.METRIC_LATE_SCREEN_TIME -> lateScreenTimeHours
        MentalCardConfig.METRIC_NOISE -> noiseIndex
        MentalCardConfig.METRIC_BRIGHTNESS -> brightness
        MentalCardConfig.METRIC_VOLUME -> volumePct
        MentalCardConfig.METRIC_DARK_MODE -> darkModeHours
        MentalCardConfig.METRIC_UNLOCKS -> unlockCount?.toDouble()
        else -> null
    }
}

// ─── Data loading ────────────────────────────────────────────────────────────

private suspend fun loadMentalDetailData(
    ctx: android.content.Context,
    token: String,
    date: String
): MentalDetailData? = withContext(Dispatchers.IO) {
    val userId = SessionStore.readUserId(ctx) ?: return@withContext null
    val client = okhttp3.OkHttpClient()
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val key = BuildConfig.SUPABASE_ANON_KEY

    fun fetchDouble(table: String, column: String): Double? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) arr.getJSONObject(0).optDouble(column).takeIf { !it.isNaN() } else null
            } else null
        } catch (_: Exception) { null }
    }

    fun fetchInt(table: String, column: String): Int? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val v = arr.getJSONObject(0).optInt(column, Int.MIN_VALUE)
                    if (v != Int.MIN_VALUE) v else null
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    fun fetchSamplesAvg(table: String, column: String, tsColumn: String = "sampled_at"): Double? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${date}T00:00:00&${tsColumn}=lt.${date}T23:59:59&select=$column"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val values = (0 until arr.length()).mapNotNull {
                        arr.getJSONObject(it).optDouble(column).takeIf { v -> !v.isNaN() }
                    }
                    if (values.isNotEmpty()) values.average() else null
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    fun fetchSamplesMax(table: String, column: String, tsColumn: String = "sampled_at"): Int? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${date}T00:00:00&${tsColumn}=lt.${date}T23:59:59&select=$column"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val values = (0 until arr.length()).mapNotNull {
                        val v = arr.getJSONObject(it).optInt(column, Int.MIN_VALUE)
                        if (v != Int.MIN_VALUE) v else null
                    }
                    values.maxOrNull()
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    fun fetchDarkModeSamplesHours(): Double? {
        return try {
            val url = "$base/rest/v1/phone_dark_mode_samples?user_id=eq.$userId&sampled_at=gte.${date}T00:00:00&sampled_at=lt.${date}T23:59:59&select=is_dark"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                val total = arr.length()
                if (total > 0) {
                    val darkCount = (0 until total).count { arr.getJSONObject(it).optBoolean("is_dark", false) }
                    (darkCount.toDouble() / total) * 24.0
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    val stress = fetchDouble("stress_index_daily", "value")
    val screenTime = fetchDouble("screen_time_daily", "total_hours")
        ?: fetchDouble("screen_time_live", "value_hours")
    val lateScreenTime = fetchDouble("screen_time_late_night", "value_hours")
    val noise = fetchDouble("ambient_noise_index_daily", "day_mean_lmean")
        ?: fetchSamplesAvg("ambient_noise_samples", "l_mean", "start_ts")

    // Phone behavior: try daily table first, fall back to live samples
    val brightness = fetchDouble("phone_brightness_daily", "value_mean")
        ?: fetchSamplesAvg("phone_brightness_samples", "value")
    val volume = fetchDouble("phone_volume_daily", "value_mean_pct")
        ?: fetchSamplesAvg("phone_volume_samples", "value_pct")
    val darkMode = fetchDouble("phone_dark_mode_daily", "value_hours")
        ?: fetchDarkModeSamplesHours()
    val unlocks = fetchInt("phone_unlock_daily", "value_count")
        ?: fetchSamplesMax("phone_unlock_samples", "value_count")

    Log.d("MentalDetail", "stress=$stress screenTime=$screenTime lateScreen=$lateScreenTime noise=$noise brightness=$brightness volume=$volume darkMode=$darkMode unlocks=$unlocks")

    if (stress == null && screenTime == null && lateScreenTime == null && noise == null &&
        brightness == null && volume == null && darkMode == null && unlocks == null) {
        Log.d("MentalDetail", "All null — returning null")
        return@withContext null
    }

    MentalDetailData(
        stress = stress,
        screenTimeHours = screenTime,
        lateScreenTimeHours = lateScreenTime,
        noiseIndex = noise,
        brightness = brightness,
        volumePct = volume,
        darkModeHours = darkMode,
        unlockCount = unlocks
    )
}

title: MonitorNutritionScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.outlined.Restaurant
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch

@Composable
fun MonitorNutritionScreen(
    navController: NavController,
    authVm: AuthViewModel
) {
    val context = LocalContext.current
    val scrollState = rememberScrollState()
    val scope = rememberCoroutineScope()
    val focusManager = LocalFocusManager.current
    val authState by authVm.state.collectAsState()
    
    val searchService = remember { USDAFoodSearchService(context) }
    val config = remember { MonitorCardConfigStore.load(context) }
    
    // Today's logged items
    var todayItems by remember { mutableStateOf<List<NutritionLogItem>>(emptyList()) }
    var isLoadingToday by remember { mutableStateOf(true) }
    
    // Search state
    var searchQuery by remember { mutableStateOf("") }
    var searchResults by remember { mutableStateOf<List<USDAFoodSearchResult>>(emptyList()) }
    var foodRisks by remember { mutableStateOf<Map<Int, FoodRiskResult>>(emptyMap()) }
    var isClassifyingSearchRisks by remember { mutableStateOf(false) }
    var isSearching by remember { mutableStateOf(false) }
    var searchError by remember { mutableStateOf<String?>(null) }
    
    // Add food dialog state
    var selectedFood by remember { mutableStateOf<USDAFoodSearchResult?>(null) }
    var selectedFoodDetails by remember { mutableStateOf<USDAFoodDetailsFull?>(null) }
    var isLoadingDetails by remember { mutableStateOf(false) }
    var selectedMealType by remember { mutableStateOf("lunch") }
    var selectedServings by remember { mutableStateOf(1.0) }
    var isAdding by remember { mutableStateOf(false) }
    var addSuccess by remember { mutableStateOf<String?>(null) }
    var addError by remember { mutableStateOf<String?>(null) }
    var selectedFoodRisks by remember { mutableStateOf<FoodRiskResult?>(null) }
    var isClassifyingRisks by remember { mutableStateOf(false) }
    
    // Edit dialog state
    var editingItem by remember { mutableStateOf<NutritionLogItem?>(null) }
    var editMealType by remember { mutableStateOf("lunch") }
    
    // Load today's items
    LaunchedEffect(Unit) {
        scope.launch {
            todayItems = searchService.getTodayNutritionItems()
            isLoadingToday = false
        }
    }
    
    fun reloadTodayItems() {
        scope.launch { todayItems = searchService.getTodayNutritionItems() }
    }
    
    fun performSearch() {
        if (searchQuery.isBlank()) return
        focusManager.clearFocus()
        scope.launch {
            isSearching = true
            searchError = null
            foodRisks = emptyMap()
            searchResults = searchService.searchFoods(searchQuery)
            if (searchResults.isEmpty()) searchError = "No foods found for \"$searchQuery\""
            isSearching = false

            // Classify food risks in background on IO thread
            if (searchResults.isNotEmpty()) {
                isClassifyingSearchRisks = true
                val classifier = FoodRiskClassifierService()
                val token = authState.accessToken ?: run { isClassifyingSearchRisks = false; return@launch }
                val risks = mutableMapOf<Int, FoodRiskResult>()
                searchResults.forEach { food ->
                    try {
                        val result = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                            classifier.classify(token, food.description)
                        }
                        risks[food.fdcId] = result
                        foodRisks = risks.toMap()
                    } catch (e: Exception) {
                        android.util.Log.e("NutritionScreen", "Risk classify failed: ${e.message}", e)
                    }
                }
                isClassifyingSearchRisks = false
            }
        }
    }
    
    fun selectFood(food: USDAFoodSearchResult) {
        selectedFood = food
        selectedFoodDetails = null
        selectedServings = 1.0
        isLoadingDetails = true
        selectedFoodRisks = null
        isClassifyingRisks = true
        scope.launch {
            selectedFoodDetails = searchService.getFoodDetails(food.fdcId)
            isLoadingDetails = false
        }
        // Check if we already have risks from search results
        val cached = foodRisks[food.fdcId]
        if (cached != null) {
            selectedFoodRisks = cached
            isClassifyingRisks = false
        } else {
            scope.launch {
                try {
                    val token = authState.accessToken ?: return@launch
                    val result = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
                        FoodRiskClassifierService().classify(token, food.description)
                    }
                    selectedFoodRisks = result
                } catch (e: Exception) {
                    selectedFoodRisks = FoodRiskResult()
                    android.util.Log.e("NutritionScreen", "Risk classify failed: ${e.message}")
                } finally {
                    isClassifyingRisks = false
                }
            }
        }
    }
    
    // Dialogs
    if (selectedFood != null) {
        AddFoodDialog(
            food = selectedFood!!,
            foodDetails = selectedFoodDetails,
            isLoadingDetails = isLoadingDetails,
            mealType = selectedMealType,
            onMealTypeChange = { selectedMealType = it },
            servings = selectedServings,
            onServingsChange = { selectedServings = it },
            isAdding = isAdding,
            monitorMetrics = config.nutritionDisplayMetrics,
            tyramineRisk = selectedFoodRisks?.tyramine,
            alcoholRisk = selectedFoodRisks?.alcohol,
            glutenRisk = selectedFoodRisks?.gluten,
            isClassifyingRisks = isClassifyingRisks,
            onDismiss = { selectedFood = null; selectedFoodDetails = null },
            onConfirm = {
                scope.launch {
                    isAdding = true
                    addError = null
                    val (success, errorMsg) = if (selectedFoodDetails != null) {
                        searchService.addFoodFromDetails(
                            foodDetails = selectedFoodDetails!!,
                            foodName = selectedFood!!.description,
                            mealType = selectedMealType,
                            servings = selectedServings
                        )
                    } else Pair(false, "No food details loaded")
                    isAdding = false
                    if (success) {
                        addSuccess = selectedFood!!.description
                        selectedFood = null
                        selectedFoodDetails = null
                        searchResults = emptyList()
                        searchQuery = ""
                        reloadTodayItems()
                    } else {
                        addError = errorMsg ?: "Failed to add food"
                    }
                }
            }
        )
    }
    
    if (addSuccess != null) {
        AlertDialog(
            onDismissRequest = { addSuccess = null },
            title = { Text("Food Added!", color = AppTheme.TitleColor) },
            text = { Text("$addSuccess has been added to your nutrition log.", color = AppTheme.BodyTextColor) },
            confirmButton = { TextButton(onClick = { addSuccess = null }) { Text("OK", color = AppTheme.AccentPurple) } },
            containerColor = Color(0xFF1E0A2E)
        )
    }
    
    if (addError != null) {
        AlertDialog(
            onDismissRequest = { addError = null },
            title = { Text("Error", color = Color(0xFFE57373)) },
            text = { Text(addError!!, color = AppTheme.BodyTextColor) },
            confirmButton = { TextButton(onClick = { addError = null }) { Text("OK", color = AppTheme.AccentPurple) } },
            containerColor = Color(0xFF1E0A2E)
        )
    }
    
    if (editingItem != null) {
        EditFoodDialog(
            item = editingItem!!,
            mealType = editMealType,
            onMealTypeChange = { editMealType = it },
            onDismiss = { editingItem = null },
            onSave = { multiplier ->
                scope.launch {
                    val success = searchService.updateNutritionItem(
                        id = editingItem!!.id,
                        mealType = editMealType,
                        servingsMultiplier = if (multiplier != 1.0) multiplier else null
                    )
                    if (success) { editingItem = null; reloadTodayItems() }
                }
            },
            onDelete = {
                scope.launch {
                    searchService.deleteNutritionItem(editingItem!!.id)
                    editingItem = null
                    reloadTodayItems()
                }
            }
        )
    }

    // UI
    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Back
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = Color.White)
                }
            }
            


            HeroCard(modifier = Modifier.clickable { navController.navigate(Routes.NUTRITION_CONFIG) }) {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.Tune, "Configure", tint = AppTheme.AccentPurple, modifier = Modifier.size(24.dp))
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Customize Display", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                        Text("Choose metrics to show on Monitor", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    }
                    Text("→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
                }
            }
            BaseCard {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Spacer(Modifier.width(12.dp))
                    Column {
                        Text("Certain foods and nutrients can trigger migraines. Tracking caffeine, sugar, tyramine, and sodium helps identify patterns.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyLarge)
                    }
                }
            }
            
            // Search
            BaseCard {
                Text("Add Food", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Spacer(Modifier.height(4.dp))
                Text("Search USDA database to log food", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Spacer(Modifier.height(12.dp))
                
                OutlinedTextField(
                    value = searchQuery,
                    onValueChange = { searchQuery = it; if (it.isBlank()) { searchResults = emptyList(); searchError = null } },
                    placeholder = { Text("Search foods") },
                    leadingIcon = { Icon(Icons.Default.Search, null, tint = AppTheme.SubtleTextColor) },
                    trailingIcon = { if (isSearching) CircularProgressIndicator(Modifier.size(20.dp), AppTheme.AccentPurple, strokeWidth = 2.dp) },
                    singleLine = true,
                    keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),
                    keyboardActions = KeyboardActions(onSearch = { performSearch() }),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = AppTheme.AccentPurple,
                        unfocusedBorderColor = AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        focusedTextColor = AppTheme.TitleColor,
                        unfocusedTextColor = AppTheme.TitleColor,
                        cursorColor = AppTheme.AccentPurple,
                        focusedPlaceholderColor = AppTheme.SubtleTextColor,
                        unfocusedPlaceholderColor = AppTheme.SubtleTextColor
                    ),
                    modifier = Modifier.fillMaxWidth()
                )
                
                searchError?.let {
                    Spacer(Modifier.height(8.dp))
                    Text(it, color = Color(0xFFE57373), style = MaterialTheme.typography.bodySmall)
                }
            }
            
            // Results
            if (searchResults.isNotEmpty()) {
                BaseCard {
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                        Text("Search Results", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                        Text("✕", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.titleMedium, modifier = Modifier.clickable { searchResults = emptyList() })
                    }
                    Spacer(Modifier.height(8.dp))
                    searchResults.forEach { food ->
                        FoodSearchResultItem(
                            food = food,
                            foodRisks = foodRisks[food.fdcId],
                            isClassifyingRisks = isClassifyingSearchRisks && foodRisks[food.fdcId] == null,
                            onClick = { selectFood(food) }
                        )
                    }
                }
            }
            
            // Today's Log
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth().clickable { navController.navigate(Routes.NUTRITION_HISTORY) },
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text("Today's Log", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("History →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                }
                Spacer(Modifier.height(8.dp))
                
                when {
                    isLoadingToday -> Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(Modifier.size(20.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
                    }
                    todayItems.isEmpty() -> Text("No food logged today", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    else -> {
                        val selectedMetrics = config.nutritionDisplayMetrics.take(3)
                        val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                        // Top 3 selected metrics
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceEvenly
                        ) {
                            selectedMetrics.forEachIndexed { index, metric ->
                                val total = todayItems.sumOf { it.metricValue(metric) ?: 0.0 }
                                val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                                val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                                val formatted = if (total >= 10) "${total.toInt()}$unit" else String.format("%.1f$unit", total)
                                NutritionSummaryValue(formatted, label, slotColors.getOrElse(index) { slotColors.last() })
                            }
                        }

                        Spacer(Modifier.height(4.dp))
                        HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                        Spacer(Modifier.height(4.dp))

                        // Individual food items
                        todayItems.forEach { item ->
                            TodayLogItem(
                                item = item,
                                onEdit = if (item.source == "manual_usda") {{ editingItem = item; editMealType = item.mealType }} else null,
                                onDelete = if (item.source == "manual_usda") {{ scope.launch { searchService.deleteNutritionItem(item.id); reloadTodayItems() } }} else null
                            )
                        }

                        // All metrics breakdown
                        Spacer(Modifier.height(4.dp))
                        HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                        Spacer(Modifier.height(8.dp))
                        Text("All Nutrients", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        Spacer(Modifier.height(4.dp))

                        MonitorCardConfig.ALL_NUTRITION_METRICS.forEach { metric ->
                            val isRisk = MonitorCardConfig.isRiskMetric(metric)
                            val total = if (isRisk) {
                                todayItems.maxOfOrNull { it.metricValue(metric) ?: 0.0 } ?: 0.0
                            } else {
                                todayItems.sumOf { it.metricValue(metric) ?: 0.0 }
                            }
                            val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                            val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                            if (isRisk) {
                                val (levelText, valueColor) = RiskColors.formatRiskLevel(metric, total.toInt())
                                val level = when (total.toInt()) { 3 -> "high"; 2 -> "medium"; 1 -> "low"; else -> "none" }
                                Row(
                                    modifier = Modifier.fillMaxWidth().padding(vertical = 3.dp),
                                    horizontalArrangement = Arrangement.SpaceBetween,
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                        when (metric) {
                                            MonitorCardConfig.METRIC_TYRAMINE_EXPOSURE -> CheeseIcon(valueColor, 12.dp)
                                            MonitorCardConfig.METRIC_ALCOHOL_EXPOSURE -> WineGlassIcon(valueColor, 12.dp)
                                            MonitorCardConfig.METRIC_GLUTEN_EXPOSURE -> WheatIcon(valueColor, 12.dp)
                                        }
                                        Spacer(Modifier.width(5.dp))
                                        Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                                    }
                                    Row(verticalAlignment = Alignment.Bottom) {
                                        Text(levelText, color = valueColor, style = MaterialTheme.typography.bodySmall)
                                        if (level != "none") {
                                            Spacer(Modifier.width(4.dp))
                                            RiskBar(valueColor, level, maxHeight = 12.dp)
                                        }
                                    }
                                }
                            } else {
                                val formatted = if (total > 0) {
                                    if (total >= 10) "${total.toInt()} $unit" else "${String.format("%.1f", total)} $unit"
                                } else "—"
                                Row(
                                    modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
                                    horizontalArrangement = Arrangement.SpaceBetween
                                ) {
                                    Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                                    Text(formatted, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                                }
                            }
                        }
                    }
                }
            }
            
            // History Graph
            NutritionHistoryGraph(
                days = 14,
                onClick = { navController.navigate(Routes.FULL_GRAPH_NUTRITION) }
            )
        }
    }
}

@Composable
private fun NutritionSummaryValue(value: String, label: String, color: Color = AppTheme.TitleColor) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(value, color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}

// Risk metric color scheme
// Defined in RiskColors.kt


title: MonitorPhysicalScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId

@Composable
fun MonitorPhysicalScreen(
    navController: NavController,
    authVm: AuthViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()
    val today = remember { LocalDate.now(ZoneId.systemDefault()).toString() }

    var physicalDetail by remember { mutableStateOf<PhysicalDetailData?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    val physicalConfig = remember { PhysicalCardConfigStore.load(ctx) }

    LaunchedEffect(authState.accessToken, today) {
        val token = authState.accessToken
        if (token.isNullOrBlank()) {
            isLoading = false
            return@LaunchedEffect
        }
        withContext(Dispatchers.IO) {
            physicalDetail = try { loadPhysicalDetailData(ctx, token, today) } catch (_: Exception) { null }
            isLoading = false
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Back
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                }
            }

            // Customize HeroCard
            HeroCard(modifier = Modifier.clickable { navController.navigate(Routes.PHYSICAL_CONFIG) }) {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.Tune, contentDescription = "Configure", tint = AppTheme.AccentPurple, modifier = Modifier.size(24.dp))
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(text = "Customize Monitor Card", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                        Text(text = "Choose 3 metrics for the Physical Health card on Monitor", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    }
                    Text(text = "→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
                }
            }

            // Explainer
            BaseCard {
                Text(
                    text = "Poor recovery, low HRV, and elevated resting heart rate are strongly correlated with migraine onset. Tracking these metrics helps identify patterns and predict migraine risk.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyLarge
                )
            }

            // Today's Physical Health — shows ALL metrics
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth().clickable { navController.navigate(Routes.PHYSICAL_DATA_HISTORY) },
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(text = "Today's Data", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("History →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                }
                Spacer(Modifier.height(8.dp))

                if (isLoading) {
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                    }
                } else if (physicalDetail == null) {
                    Text(text = "No physical health data for today", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    Spacer(Modifier.height(4.dp))
                    Text(text = "Connect a wearable or enable Health Connect in Data Settings", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                } else {
                    val detail = physicalDetail!!

                    // Top 3 selected metrics
                    val selectedMetrics = physicalConfig.physicalDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val value = detail.displayValue(metric) ?: "—"
                            val label = PhysicalCardConfig.labelFor(metric)
                            PhysicalMetricLargeItem(label, value, slotColors.getOrElse(index) { slotColors.last() })
                        }
                    }

                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text(text = "All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    // All metrics (show "—" for missing data)
                    PhysicalCardConfig.ALL_PHYSICAL_METRICS.forEach { metric ->
                        if (metric !in selectedMetrics) {
                            val value = detail.displayValue(metric) ?: "—"
                            val label = PhysicalCardConfig.labelFor(metric)
                            PhysicalMetricRowItem(label, value, AppTheme.SubtleTextColor)
                        }
                    }
                }
            }

            // History Graph
            PhysicalHistoryGraph(
                days = 14,
                onClick = { navController.navigate(Routes.FULL_GRAPH_PHYSICAL) }
            )
        }
    }
}

// ─── Composable helpers ──────────────────────────────────────────────────────

@Composable
private fun PhysicalMetricLargeItem(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(text = value, color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        Text(text = label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}

@Composable
private fun PhysicalMetricRowItem(label: String, value: String?, color: Color) {
    if (value == null) return
    Row(
        modifier = Modifier.fillMaxWidth().height(24.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = label, color = AppTheme.TitleColor, style = MaterialTheme.typography.bodySmall)
        Text(text = value, color = color, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
    }
}

// ─── Data class ──────────────────────────────────────────────────────────────

private data class PhysicalDetailData(
    val recovery: Double?,
    val hrv: Double?,
    val restingHr: Double?,
    val spo2: Double?,
    val skinTemp: Double?,
    val respiratoryRate: Double?,
    val stress: Double?,
    val highHrZonesMinutes: Double?,
    val steps: Int?,
    val weight: Double?,
    val bodyFat: Double?,
    val bloodPressureSystolic: Double?,
    val bloodPressureDiastolic: Double?,
    val bloodGlucose: Double?
) {
    fun displayValue(metric: String): String? = when (metric) {
        PhysicalCardConfig.METRIC_RECOVERY -> recovery?.let { "${it.toInt()}%" }
        PhysicalCardConfig.METRIC_HRV -> hrv?.let { "${it.toInt()} ms" }
        PhysicalCardConfig.METRIC_RESTING_HR -> restingHr?.let { "${it.toInt()} bpm" }
        PhysicalCardConfig.METRIC_SPO2 -> spo2?.let { "${it.toInt()}%" }
        PhysicalCardConfig.METRIC_SKIN_TEMP -> skinTemp?.let { String.format("%.1f°C", it) }
        PhysicalCardConfig.METRIC_RESPIRATORY_RATE -> respiratoryRate?.let { String.format("%.1f bpm", it) }
        PhysicalCardConfig.METRIC_STRESS -> stress?.let { String.format("%.0f", it) }
        PhysicalCardConfig.METRIC_HIGH_HR_ZONES -> highHrZonesMinutes?.let { "${it.toInt()} min" }
        PhysicalCardConfig.METRIC_STEPS -> steps?.let { "%,d".format(it) }
        PhysicalCardConfig.METRIC_WEIGHT -> weight?.let { String.format("%.1f kg", it) }
        PhysicalCardConfig.METRIC_BODY_FAT -> bodyFat?.let { String.format("%.1f%%", it) }
        PhysicalCardConfig.METRIC_BLOOD_PRESSURE -> {
            if (bloodPressureSystolic != null && bloodPressureDiastolic != null)
                "${bloodPressureSystolic.toInt()}/${bloodPressureDiastolic.toInt()}"
            else null
        }
        PhysicalCardConfig.METRIC_BLOOD_GLUCOSE -> bloodGlucose?.let { String.format("%.0f mg/dL", it) }
        else -> null
    }

    /** Numeric value for a metric (for graph usage) */
    fun numericValue(metric: String): Double? = when (metric) {
        PhysicalCardConfig.METRIC_RECOVERY -> recovery
        PhysicalCardConfig.METRIC_HRV -> hrv
        PhysicalCardConfig.METRIC_RESTING_HR -> restingHr
        PhysicalCardConfig.METRIC_SPO2 -> spo2
        PhysicalCardConfig.METRIC_SKIN_TEMP -> skinTemp
        PhysicalCardConfig.METRIC_RESPIRATORY_RATE -> respiratoryRate
        PhysicalCardConfig.METRIC_STRESS -> stress
        PhysicalCardConfig.METRIC_HIGH_HR_ZONES -> highHrZonesMinutes
        PhysicalCardConfig.METRIC_STEPS -> steps?.toDouble()
        PhysicalCardConfig.METRIC_WEIGHT -> weight
        PhysicalCardConfig.METRIC_BODY_FAT -> bodyFat
        PhysicalCardConfig.METRIC_BLOOD_PRESSURE -> bloodPressureSystolic
        PhysicalCardConfig.METRIC_BLOOD_GLUCOSE -> bloodGlucose
        else -> null
    }
}

// ─── Data loading ────────────────────────────────────────────────────────────

private suspend fun loadPhysicalDetailData(
    ctx: android.content.Context,
    token: String,
    date: String
): PhysicalDetailData? = withContext(Dispatchers.IO) {
    val physService = SupabasePhysicalHealthService(ctx)

    val recovery = try { physService.fetchRecoveryScoreDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val hrv = try { physService.fetchHrvDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val rhr = try { physService.fetchRestingHrDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val spo2 = try { physService.fetchSpo2Daily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val skinTemp = try { physService.fetchSkinTempDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val stress = try { physService.fetchStressIndexDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val highHr = try { physService.fetchHighHrDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }

    // Fetch metrics from tables that don't have dedicated fetch methods yet — use direct REST
    val userId = SessionStore.readUserId(ctx)
    val client = okhttp3.OkHttpClient()

    val steps = if (userId != null) fetchSingleDouble(client, token, "steps_daily", userId, date, "value_count")?.toInt() else null
    val weight = if (userId != null) fetchSingleDouble(client, token, "weight_daily", userId, date, "value_kg") else null
    val bodyFat = if (userId != null) fetchSingleDouble(client, token, "body_fat_daily", userId, date, "value_pct") else null
    val respiratoryRate = if (userId != null) fetchSingleDouble(client, token, "respiratory_rate_daily", userId, date, "value_bpm") else null
    val bloodGlucose = if (userId != null) fetchSingleDouble(client, token, "blood_glucose_daily", userId, date, "value_mgdl") else null

    var bpSystolic: Double? = null
    var bpDiastolic: Double? = null
    if (userId != null) {
        try {
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/blood_pressure_daily?user_id=eq.$userId&date=eq.$date&select=value_systolic,value_diastolic&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val obj = arr.getJSONObject(0)
                    bpSystolic = obj.optDouble("value_systolic").takeIf { !it.isNaN() }
                    bpDiastolic = obj.optDouble("value_diastolic").takeIf { !it.isNaN() }
                }
            }
        } catch (_: Exception) {}
    }

    // Return null only if we have absolutely no data
    if (recovery == null && hrv == null && rhr == null && spo2 == null && skinTemp == null &&
        stress == null && highHr == null && steps == null && weight == null && bodyFat == null &&
        respiratoryRate == null && bloodGlucose == null && bpSystolic == null) {
        return@withContext null
    }

    PhysicalDetailData(
        recovery = recovery?.value_pct,
        hrv = hrv?.value_rmssd_ms,
        restingHr = rhr?.value_bpm,
        spo2 = spo2?.value_pct,
        skinTemp = skinTemp?.value_celsius,
        respiratoryRate = respiratoryRate,
        stress = stress?.value,
        highHrZonesMinutes = highHr?.value_minutes,
        steps = steps,
        weight = weight,
        bodyFat = bodyFat,
        bloodPressureSystolic = bpSystolic,
        bloodPressureDiastolic = bpDiastolic,
        bloodGlucose = bloodGlucose
    )
}

/** Generic helper to fetch a single double value from a daily table */
private fun fetchSingleDouble(
    client: okhttp3.OkHttpClient,
    token: String,
    table: String,
    userId: String,
    date: String,
    column: String
): Double? {
    return try {
        val url = "${BuildConfig.SUPABASE_URL}/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
        val request = okhttp3.Request.Builder().url(url).get()
            .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
            .addHeader("Authorization", "Bearer $token").build()
        val response = client.newCall(request).execute()
        val body = response.body?.string()
        if (response.isSuccessful && !body.isNullOrBlank()) {
            val arr = org.json.JSONArray(body)
            if (arr.length() > 0) {
                arr.getJSONObject(0).optDouble(column).takeIf { !it.isNaN() }
            } else null
        } else null
    } catch (_: Exception) { null }
}

title: MonitorScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Bedtime
import androidx.compose.material.icons.outlined.BubbleChart
import androidx.compose.material.icons.outlined.Cloud
import androidx.compose.material.icons.outlined.FavoriteBorder
import androidx.compose.material.icons.outlined.FitnessCenter
import androidx.compose.material.icons.outlined.Restaurant
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.Icon
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit

@Composable
fun MonitorScreen(
    navController: NavController,
    authVm: AuthViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()
    
    val today = remember { LocalDate.now(ZoneId.systemDefault()).toString() }
    
    // Card configuration
    var cardConfig by remember { mutableStateOf(MonitorCardConfigStore.load(ctx)) }
    var weatherConfig by remember { mutableStateOf(WeatherCardConfigStore.load(ctx)) }
    var sleepConfig by remember { mutableStateOf(SleepCardConfigStore.load(ctx)) }
    var physicalConfig by remember { mutableStateOf(PhysicalCardConfigStore.load(ctx)) }
    var mentalConfig by remember { mutableStateOf(MentalCardConfigStore.load(ctx)) }
    
    // Refresh config when returning to screen
    LaunchedEffect(Unit) {
        cardConfig = MonitorCardConfigStore.load(ctx)
        weatherConfig = WeatherCardConfigStore.load(ctx)
        sleepConfig = SleepCardConfigStore.load(ctx)
        physicalConfig = PhysicalCardConfigStore.load(ctx)
        mentalConfig = MentalCardConfigStore.load(ctx)
    }
    
    // Nutrition data — use same service as MonitorNutritionScreen for full metric coverage
    var nutritionItems by remember { mutableStateOf<List<NutritionLogItem>>(emptyList()) }
    var nutritionLoading by remember { mutableStateOf(true) }
    
    // Weather data
    var weatherSummary by remember { mutableStateOf<WeatherSummary?>(null) }
    var weatherLoading by remember { mutableStateOf(true) }
    
    // Physical health data
    var physicalSummary by remember { mutableStateOf<PhysicalSummary?>(null) }
    var physicalLoading by remember { mutableStateOf(true) }
    
    // Mental health data
    var mentalSummary by remember { mutableStateOf<MentalSummary?>(null) }
    var mentalLoading by remember { mutableStateOf(true) }
    
    // Sleep data
    var sleepSummary by remember { mutableStateOf<SleepSummary?>(null) }
    var sleepLoading by remember { mutableStateOf(true) }
    
    // Menstruation data
    var menstruationSettings by remember { mutableStateOf<MenstruationSettings?>(null) }
    var menstruationEnabled by remember { mutableStateOf(false) }
    var menstruationLoading by remember { mutableStateOf(true) }
    
    LaunchedEffect(authState.accessToken, today) {
        val token = authState.accessToken
        if (token.isNullOrBlank()) {
            nutritionLoading = false
            weatherLoading = false
            physicalLoading = false
            sleepLoading = false
            mentalLoading = false
            menstruationLoading = false
            return@LaunchedEffect
        }
        
        // Load nutrition items (same as MonitorNutritionScreen — supports all 34 nutrients)
        withContext(Dispatchers.IO) {
            nutritionItems = try {
                USDAFoodSearchService(ctx).getTodayNutritionItems()
            } catch (_: Exception) {
                emptyList()
            }
            nutritionLoading = false
        }
        
        // Load weather summary
        withContext(Dispatchers.IO) {
            weatherSummary = try {
                loadWeatherSummary(ctx, token, today)
            } catch (_: Exception) {
                null
            }
            weatherLoading = false
        }
        
        // Load physical health summary
        withContext(Dispatchers.IO) {
            physicalSummary = try {
                loadPhysicalSummary(ctx, token, today)
            } catch (_: Exception) {
                null
            }
            physicalLoading = false
        }
        
        // Load mental health summary
        withContext(Dispatchers.IO) {
            mentalSummary = try {
                loadMentalSummary(ctx, token, today)
            } catch (_: Exception) {
                null
            }
            mentalLoading = false
        }
        
        // Load sleep summary
        withContext(Dispatchers.IO) {
            sleepSummary = try {
                loadSleepSummary(ctx, token, today)
            } catch (_: Exception) {
                null
            }
            sleepLoading = false
        }
        
        // Load menstruation settings AND check if enabled
        withContext(Dispatchers.IO) {
            try {
                // Check if menstruation metric is enabled
                val edge = EdgeFunctionsService()
                val metricSettings = edge.getMetricSettings(ctx)
                menstruationEnabled = metricSettings.any { 
                    it.metric == "menstruation" && it.enabled 
                }
                
                // Only load settings if enabled
                if (menstruationEnabled) {
                    menstruationSettings = SupabaseMenstruationService(ctx).getSettings(token)
                }
            } catch (_: Exception) {
                menstruationEnabled = false
                menstruationSettings = null
            }
            menstruationLoading = false
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Configure Data Collection Card (HeroCard style like HomeScreen)
            HeroCard(
                modifier = Modifier.clickable { navController.navigate(Routes.MONITOR_CONFIG) }
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Outlined.Tune,
                        contentDescription = "Configure",
                        tint = AppTheme.AccentPurple,
                        modifier = Modifier.size(28.dp)
                    )
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            "Configure Monitor",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        Text(
                            "Show, hide, and reorder cards",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                    Text(
                        "→",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            }

            // Render cards in configured order
            cardConfig.cardOrder.forEach { cardId ->
                if (cardConfig.isVisible(cardId)) {
                    when (cardId) {
                        MonitorCardConfig.CARD_NUTRITION -> {
                            NutritionCard(
                                nutritionLoading = nutritionLoading,
                                nutritionItems = nutritionItems,
                                displayMetrics = cardConfig.nutritionDisplayMetrics,
                                onClick = { navController.navigate(Routes.MONITOR_NUTRITION) }
                            )
                        }
                        MonitorCardConfig.CARD_ENVIRONMENT -> {
                            EnvironmentCard(
                                weatherLoading = weatherLoading,
                                weatherSummary = weatherSummary,
                                displayMetrics = weatherConfig.weatherDisplayMetrics.take(3),
                                onClick = { navController.navigate(Routes.MONITOR_ENVIRONMENT) }
                            )
                        }
                        MonitorCardConfig.CARD_PHYSICAL -> {
                            PhysicalHealthCard(
                                physicalLoading = physicalLoading,
                                physicalSummary = physicalSummary,
                                displayMetrics = physicalConfig.physicalDisplayMetrics.take(3),
                                onClick = { navController.navigate(Routes.MONITOR_PHYSICAL) }
                            )
                        }
                        MonitorCardConfig.CARD_SLEEP -> {
                            SleepCard(
                                sleepLoading = sleepLoading,
                                sleepSummary = sleepSummary,
                                displayMetrics = sleepConfig.sleepDisplayMetrics.take(3),
                                onClick = { navController.navigate(Routes.MONITOR_SLEEP) }
                            )
                        }
                        MonitorCardConfig.CARD_MENTAL -> {
                            MentalHealthCard(
                                mentalLoading = mentalLoading,
                                mentalSummary = mentalSummary,
                                displayMetrics = mentalConfig.mentalDisplayMetrics.take(3),
                                onClick = { navController.navigate(Routes.MONITOR_MENTAL) }
                            )
                        }

                        MonitorCardConfig.CARD_MENSTRUATION -> {
                            if (menstruationEnabled || menstruationLoading) {
                                MenstruationCard(
                                    menstruationLoading = menstruationLoading,
                                    menstruationSettings = menstruationSettings,
                                    onClick = { navController.navigate(Routes.MENSTRUATION_SETTINGS) }
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

// Individual card composables
@Composable
private fun NutritionCard(
    nutritionLoading: Boolean,
    nutritionItems: List<NutritionLogItem>,
    displayMetrics: List<String>,
    onClick: () -> Unit
) {
    MonitorCategoryCard(
        icon = Icons.Outlined.Restaurant,
        title = "Nutrition",
        iconTint = Color(0xFFFFB74D),
        onClick = onClick
    ) {
        if (nutritionLoading) {
            Text("Loading...", color = AppTheme.SubtleTextColor)
        } else {
            val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                displayMetrics.forEachIndexed { index, metric ->
                    val total = nutritionItems.sumOf { it.metricValue(metric) ?: 0.0 }
                    val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                    val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                    val formatted = if (total >= 10) "${total.toInt()}$unit" else String.format("%.1f$unit", total)
                    val color = slotColors.getOrElse(index) { slotColors.last() }
                    
                    NutritionMetric(
                        label = label,
                        value = formatted,
                        color = color
                    )
                }
            }
            
            Spacer(Modifier.height(6.dp))
            
            val mealTypes = nutritionItems.mapNotNull { it.mealType?.takeIf { m -> m.isNotBlank() && m != "unknown" } }.toSet()
            Text(
                "${mealTypes.size} meals • ${nutritionItems.size} items today",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
        }
    }
}

@Composable
private fun EnvironmentCard(
    weatherLoading: Boolean,
    weatherSummary: WeatherSummary?,
    displayMetrics: List<String>,
    onClick: () -> Unit
) {
    MonitorCategoryCard(
        icon = Icons.Outlined.Cloud,
        title = "Environment",
        iconTint = Color(0xFF4FC3F7),
        onClick = onClick
    ) {
        if (weatherLoading) {
            Text("Loading...", color = AppTheme.SubtleTextColor)
        } else if (weatherSummary == null) {
            Text("No weather data", color = AppTheme.SubtleTextColor)
        } else {
            val weather = weatherSummary
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        "${weather.temperature}°C",
                        color = Color.White,
                        style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold)
                    )
                    Text(weather.condition, color = AppTheme.SubtleTextColor)
                }
                Column(horizontalAlignment = Alignment.End) {
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                    displayMetrics.take(3).forEachIndexed { index, metric ->
                        val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                        val value = getWeatherMetricValue(weather, metric)
                        val unit = WeatherCardConfig.WEATHER_METRIC_UNITS[metric] ?: ""
                        Text(
                            "$label: $value$unit",
                            color = slotColors.getOrElse(index) { slotColors.last() },
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }
        }
    }
}

private fun getWeatherMetricValue(weather: WeatherSummary, metric: String): String {
    return when (metric) {
        WeatherCardConfig.METRIC_TEMPERATURE -> weather.temperature.toString()
        WeatherCardConfig.METRIC_PRESSURE -> weather.pressure.toString()
        WeatherCardConfig.METRIC_HUMIDITY -> weather.humidity.toString()
        WeatherCardConfig.METRIC_WIND_SPEED -> String.format("%.1f", weather.windSpeed)
        WeatherCardConfig.METRIC_UV_INDEX -> weather.uvIndex.toString()
        WeatherCardConfig.METRIC_ALTITUDE -> weather.altitudeMaxM?.let { String.format("%.0f", it) } ?: "—"
        WeatherCardConfig.METRIC_ALTITUDE_CHANGE -> weather.altitudeChangeM?.let { String.format("%.0f", it) } ?: "—"
        else -> "—"
    }
}

@Composable
private fun PhysicalHealthCard(
    physicalLoading: Boolean,
    physicalSummary: PhysicalSummary?,
    displayMetrics: List<String>,
    onClick: () -> Unit
) {
    MonitorCategoryCard(
        icon = Icons.Outlined.FitnessCenter,
        title = "Physical Health",
        iconTint = Color(0xFF81C784),
        onClick = onClick
    ) {
        if (physicalLoading) {
            Text("Loading...", color = AppTheme.SubtleTextColor)
        } else if (physicalSummary == null) {
            Text("No physical health data", color = AppTheme.SubtleTextColor)
            Text("Connect a wearable to see data", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
        } else {
            val physical = physicalSummary
            val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                displayMetrics.forEachIndexed { index, metric ->
                    val label = PhysicalCardConfig.labelFor(metric)
                    val color = slotColors.getOrElse(index) { slotColors.last() }
                    val value = when (metric) {
                        PhysicalCardConfig.METRIC_RECOVERY -> physical.recoveryScore?.let { "${it.toInt()}%" } ?: "—"
                        PhysicalCardConfig.METRIC_HRV -> physical.hrv?.let { "${it.toInt()} ms" } ?: "—"
                        PhysicalCardConfig.METRIC_RESTING_HR -> physical.restingHr?.let { "${it.toInt()} bpm" } ?: "—"
                        PhysicalCardConfig.METRIC_SPO2 -> physical.spo2?.let { "${it.toInt()}%" } ?: "—"
                        PhysicalCardConfig.METRIC_SKIN_TEMP -> physical.skinTemp?.let { String.format("%.1f°C", it) } ?: "—"
                        PhysicalCardConfig.METRIC_RESPIRATORY_RATE -> physical.respiratoryRate?.let { String.format("%.1f", it) } ?: "—"
                        PhysicalCardConfig.METRIC_STRESS -> physical.stress?.let { String.format("%.0f", it) } ?: "—"
                        PhysicalCardConfig.METRIC_HIGH_HR_ZONES -> physical.highHrZones?.let { "${it.toInt()} min" } ?: "—"
                        PhysicalCardConfig.METRIC_STEPS -> physical.steps?.let { "%,d".format(it) } ?: "—"
                        PhysicalCardConfig.METRIC_WEIGHT -> physical.weight?.let { String.format("%.1f kg", it) } ?: "—"
                        PhysicalCardConfig.METRIC_BODY_FAT -> physical.bodyFat?.let { String.format("%.1f%%", it) } ?: "—"
                        PhysicalCardConfig.METRIC_BLOOD_PRESSURE -> if (physical.bpSystolic != null) "${physical.bpSystolic}/${physical.bpDiastolic}" else "—"
                        PhysicalCardConfig.METRIC_BLOOD_GLUCOSE -> physical.bloodGlucose?.let { String.format("%.0f", it) } ?: "—"
                        else -> "—"
                    }
                    PhysicalMetric(label, value, color)
                }
            }
        }
    }
}

@Composable
private fun SleepCard(
    sleepLoading: Boolean,
    sleepSummary: SleepSummary?,
    displayMetrics: List<String>,
    onClick: () -> Unit
) {
    MonitorCategoryCard(
        icon = Icons.Outlined.Bedtime,
        title = "Sleep",
        iconTint = Color(0xFF7986CB),
        onClick = onClick
    ) {
        if (sleepLoading) {
            Text("Loading...", color = AppTheme.SubtleTextColor)
        } else if (sleepSummary == null) {
            Text("No sleep data", color = AppTheme.SubtleTextColor)
            Text("Enable phone sleep or connect a wearable", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
        } else {
            val sleep = sleepSummary
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                displayMetrics.forEachIndexed { index, metric ->
                    val label = SleepCardConfig.labelFor(metric)
                    val color = slotColors.getOrElse(index) { slotColors.last() }
                    val value = getSleepSummaryMetricValue(sleep, metric)
                    SleepMetric(label, value, color)
                }
            }
        }
    }
}

@Composable
private fun MentalHealthCard(
    mentalLoading: Boolean,
    mentalSummary: MentalSummary?,
    displayMetrics: List<String>,
    onClick: () -> Unit
) {
    MonitorCategoryCard(
        icon = Icons.Outlined.BubbleChart,
        title = "Mental Health",
        iconTint = Color(0xFFBA68C8),
        onClick = onClick
    ) {
        if (mentalLoading) {
            Text("Loading...", color = AppTheme.SubtleTextColor)
        } else if (mentalSummary == null) {
            Text("No mental health data", color = AppTheme.SubtleTextColor)
            Text("Enable metrics in Data Settings", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
        } else {
            val mental = mentalSummary
            val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                displayMetrics.forEachIndexed { index, metric ->
                    val label = MentalCardConfig.labelFor(metric)
                    val color = slotColors.getOrElse(index) { slotColors.last() }
                    val value = mental.displayValue(metric)
                    MentalMetric(label, value, color)
                }
            }
        }
    }
}

@Composable
private fun MentalMetric(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(value, color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}



@Composable
private fun MenstruationCard(
    menstruationLoading: Boolean,
    menstruationSettings: MenstruationSettings?,
    onClick: () -> Unit
) {
    MonitorCategoryCard(
        icon = Icons.Outlined.FavoriteBorder,
        title = "Menstruation",
        iconTint = Color(0xFFE57373),
        onClick = onClick
    ) {
        if (menstruationLoading) {
            Text("Loading...", color = AppTheme.SubtleTextColor)
        } else if (menstruationSettings == null || menstruationSettings.lastMenstruationDate == null) {
            Text("Not configured", color = AppTheme.SubtleTextColor)
            Text("Tap to set up cycle tracking", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
        } else {
            val settings = menstruationSettings
            val lastDate = settings.lastMenstruationDate!!
            val nextExpected = lastDate.plusDays(settings.avgCycleLength.toLong())
            val todayDate = LocalDate.now()
            val daysUntil = ChronoUnit.DAYS.between(todayDate, nextExpected)
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column {
                    Text(
                        "Next: $nextExpected",
                        color = Color.White,
                        style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Text(
                        when {
                            daysUntil < 0 -> "${-daysUntil} days ago"
                            daysUntil == 0L -> "Today"
                            daysUntil == 1L -> "Tomorrow"
                            else -> "In $daysUntil days"
                        },
                        color = when {
                            daysUntil in -2..2 -> Color(0xFFE57373)
                            daysUntil in 3..7 -> Color(0xFFFFB74D)
                            else -> AppTheme.SubtleTextColor
                        },
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                Column(horizontalAlignment = Alignment.End) {
                    Text(
                        "Cycle: ${settings.avgCycleLength} days",
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    Text(
                        "Last: $lastDate",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
        }
    }
}

@Composable
private fun NutritionMetric(
    label: String,
    value: String,
    color: Color
) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            value,
            color = color,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold)
        )
        Text(
            label,
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.bodySmall
        )
    }
}

@Composable
private fun MonitorCategoryCard(
    icon: ImageVector,
    title: String,
    iconTint: Color,
    enabled: Boolean = true,
    onClick: () -> Unit,
    content: @Composable () -> Unit
) {
    BaseCard(
        modifier = if (enabled) Modifier.clickable(onClick = onClick) else Modifier
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                tint = if (enabled) iconTint else iconTint.copy(alpha = 0.4f),
                modifier = Modifier.size(24.dp)
            )
            Spacer(Modifier.width(10.dp))
            Text(
                title,
                color = if (enabled) AppTheme.TitleColor else AppTheme.TitleColor.copy(alpha = 0.5f),
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.weight(1f))
            if (enabled) {
                Text(
                    "→",
                    color = AppTheme.AccentPurple,
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
        
        Spacer(Modifier.height(8.dp))
        
        content()
    }
}

@Composable
private fun PhysicalMetric(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            value,
            color = color,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold)
        )
        Text(
            label,
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.bodySmall
        )
    }
}

@Composable
private fun SleepMetric(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(
            value,
            color = color,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold)
        )
        Text(
            label,
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.bodySmall
        )
    }
}

private fun getSleepSummaryMetricValue(sleep: SleepSummary, metric: String): String {
    return when (metric) {
        SleepCardConfig.METRIC_DURATION -> String.format("%.1fh", sleep.durationHours)
        SleepCardConfig.METRIC_FELL_ASLEEP -> sleep.fellAsleepDisplay ?: "—"
        SleepCardConfig.METRIC_WOKE_UP -> sleep.wokeUpDisplay ?: "—"
        SleepCardConfig.METRIC_SCORE -> if (sleep.sleepScore > 0) "${sleep.sleepScore}%" else "—"
        SleepCardConfig.METRIC_EFFICIENCY -> if (sleep.efficiency > 0) "${sleep.efficiency}%" else "—"
        SleepCardConfig.METRIC_DISTURBANCES -> sleep.disturbances?.toString() ?: "—"
        SleepCardConfig.METRIC_STAGES_DEEP -> sleep.stagesDeep?.let { formatSleepHM(it) } ?: "—"
        SleepCardConfig.METRIC_STAGES_REM -> sleep.stagesRem?.let { formatSleepHM(it) } ?: "—"
        SleepCardConfig.METRIC_STAGES_LIGHT -> sleep.stagesLight?.let { formatSleepHM(it) } ?: "—"
        else -> "—"
    }
}

private fun formatSleepHM(hm: Double): String {
    val totalMinutes = (hm * 60).toInt()
    val hours = totalMinutes / 60
    val minutes = totalMinutes % 60
    return if (hours > 0) "${hours}h${minutes}m" else "${minutes}m"
}

// Data classes for summaries

data class WeatherSummary(
    val temperature: Int,
    val condition: String,
    val humidity: Int,
    val pressure: Int,
    val uvIndex: Int,
    val windSpeed: Double = 0.0,
    val altitudeMaxM: Double? = null,
    val altitudeChangeM: Double? = null
)

data class PhysicalSummary(
    val recoveryScore: Double? = null,
    val hrv: Double? = null,
    val restingHr: Double? = null,
    val spo2: Double? = null,
    val skinTemp: Double? = null,
    val respiratoryRate: Double? = null,
    val stress: Double? = null,
    val highHrZones: Double? = null,
    val steps: Int? = null,
    val weight: Double? = null,
    val bodyFat: Double? = null,
    val bpSystolic: Int? = null,
    val bpDiastolic: Int? = null,
    val bloodGlucose: Double? = null
)

data class SleepSummary(
    val durationHours: Double,
    val sleepScore: Int,
    val efficiency: Int,
    val fellAsleepDisplay: String? = null,
    val wokeUpDisplay: String? = null,
    val sourceLabel: String = "",
    val disturbances: Int? = null,
    val stagesDeep: Double? = null,
    val stagesRem: Double? = null,
    val stagesLight: Double? = null
)

// Data loading functions

private suspend fun loadWeatherSummary(ctx: android.content.Context, token: String, date: String): WeatherSummary? {
    return withContext(Dispatchers.IO) {
        try {
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/user_weather_daily?user_id=eq.${SessionStore.readUserId(ctx)}&date=eq.$date&select=*"
            
            val client = OkHttpClient()
            val request = Request.Builder()
                .url(url)
                .get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: return@withContext null
            
            if (!response.isSuccessful) return@withContext null
            
            val arr = org.json.JSONArray(body)
            if (arr.length() == 0) return@withContext null
            
            val obj = arr.getJSONObject(0)
            
            val weatherCode = obj.optInt("weather_code", 0)
            val condition = weatherCodeToCondition(weatherCode)

            // Fetch altitude from user_location_daily
            var altitudeMaxM: Double? = null
            var altitudeChangeM: Double? = null
            try {
                val locUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/user_location_daily?user_id=eq.${SessionStore.readUserId(ctx)}&date=eq.$date&select=altitude_max_m,altitude_change_m&limit=1"
                val locReq = Request.Builder().url(locUrl).get()
                    .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    .addHeader("Authorization", "Bearer $token").build()
                val locResp = client.newCall(locReq).execute()
                val locBody = locResp.body?.string()
                if (locResp.isSuccessful && !locBody.isNullOrBlank()) {
                    val locArr = org.json.JSONArray(locBody)
                    if (locArr.length() > 0) {
                        val locObj = locArr.getJSONObject(0)
                        altitudeMaxM = locObj.optDouble("altitude_max_m").takeIf { !it.isNaN() }
                        altitudeChangeM = locObj.optDouble("altitude_change_m").takeIf { !it.isNaN() }
                    }
                }
            } catch (_: Exception) { }
            
            WeatherSummary(
                temperature = obj.optDouble("temp_c_mean", 0.0).toInt(),
                condition = condition,
                humidity = obj.optInt("humidity_pct_mean", 0),
                pressure = obj.optDouble("pressure_hpa_mean", 0.0).toInt(),
                uvIndex = obj.optDouble("uv_index_max", 0.0).toInt(),
                windSpeed = obj.optDouble("wind_speed_mps_mean", 0.0),
                altitudeMaxM = altitudeMaxM,
                altitudeChangeM = altitudeChangeM
            )
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }
}

private fun weatherCodeToCondition(code: Int): String {
    return when (code) {
        0 -> "Clear sky"
        1 -> "Mainly clear"
        2 -> "Partly cloudy"
        3 -> "Overcast"
        45, 48 -> "Foggy"
        51, 53, 55 -> "Drizzle"
        56, 57 -> "Freezing drizzle"
        61, 63, 65 -> "Rain"
        66, 67 -> "Freezing rain"
        71, 73, 75 -> "Snow"
        77 -> "Snow grains"
        80, 81, 82 -> "Rain showers"
        85, 86 -> "Snow showers"
        95 -> "Thunderstorm"
        96, 99 -> "Thunderstorm with hail"
        else -> "Unknown"
    }
}

private suspend fun loadPhysicalSummary(ctx: android.content.Context, token: String, date: String): PhysicalSummary? {
    val userId = SessionStore.readUserId(ctx) ?: return null
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val key = BuildConfig.SUPABASE_ANON_KEY
    val client = OkHttpClient()

    fun fetchDouble(table: String, column: String): Double? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val v = arr.getJSONObject(0).optDouble(column)
                    if (!v.isNaN()) v else null
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    fun fetchInt(table: String, column: String): Int? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val v = arr.getJSONObject(0).optInt(column, Int.MIN_VALUE)
                    if (v != Int.MIN_VALUE) v else null
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    val recovery = fetchDouble("recovery_score_daily", "value_pct")
    val hrv = fetchDouble("hrv_daily", "value_rmssd_ms")
    val rhr = fetchDouble("resting_hr_daily", "value_bpm")
    val spo2 = fetchDouble("spo2_daily", "value_pct")
    val skinTemp = fetchDouble("skin_temp_daily", "value_celsius")
    val respiratoryRate = fetchDouble("respiratory_rate_daily", "value_bpm")
    val stress = fetchDouble("stress_index_daily", "value")
    val highHrZones = fetchDouble("time_in_high_hr_zones_daily", "value_minutes")
    val steps = fetchInt("steps_daily", "value_count")
    val weight = fetchDouble("weight_daily", "value_kg")
    val bodyFat = fetchDouble("body_fat_daily", "value_pct")
    val bloodGlucose = fetchDouble("blood_glucose_daily", "value_mgdl")

    // Blood pressure needs two columns
    var bpSys: Int? = null
    var bpDia: Int? = null
    try {
        val url = "$base/rest/v1/blood_pressure_daily?user_id=eq.$userId&date=eq.$date&select=value_systolic,value_diastolic&limit=1"
        val req = Request.Builder().url(url).get()
            .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
        val resp = client.newCall(req).execute()
        val body = resp.body?.string()
        if (resp.isSuccessful && !body.isNullOrBlank()) {
            val arr = org.json.JSONArray(body)
            if (arr.length() > 0) {
                val obj = arr.getJSONObject(0)
                val s = obj.optDouble("value_systolic")
                val d = obj.optDouble("value_diastolic")
                if (!s.isNaN()) bpSys = s.toInt()
                if (!d.isNaN()) bpDia = d.toInt()
            }
        }
    } catch (_: Exception) {}

    // If nothing at all, return null
    if (recovery == null && hrv == null && rhr == null && spo2 == null && skinTemp == null &&
        respiratoryRate == null && stress == null && highHrZones == null && steps == null &&
        weight == null && bodyFat == null && bpSys == null && bloodGlucose == null) {
        return null
    }

    return PhysicalSummary(
        recoveryScore = recovery,
        hrv = hrv,
        restingHr = rhr,
        spo2 = spo2,
        skinTemp = skinTemp,
        respiratoryRate = respiratoryRate,
        stress = stress,
        highHrZones = highHrZones,
        steps = steps,
        weight = weight,
        bodyFat = bodyFat,
        bpSystolic = bpSys,
        bpDiastolic = bpDia,
        bloodGlucose = bloodGlucose
    )
}

private suspend fun loadSleepSummary(ctx: android.content.Context, token: String, date: String): SleepSummary? {
    val db = SupabaseMetricsService(ctx)
    
    // Fetch sleep metrics for today
    val durationList = try {
        db.fetchSleepDurationDaily(token, 1)
    } catch (_: Exception) {
        emptyList()
    }
    
    val scoreList = try {
        db.fetchSleepScoreDaily(token, 1)
    } catch (_: Exception) {
        emptyList()
    }
    
    val efficiencyList = try {
        db.fetchSleepEfficiencyDaily(token, 1)
    } catch (_: Exception) {
        emptyList()
    }
    
    // Check if we have data for today
    val todayDuration = durationList.find { it.date == date }
    val todayScore = scoreList.find { it.date == date }
    val todayEfficiency = efficiencyList.find { it.date == date }
    
    if (todayDuration == null && todayScore == null && todayEfficiency == null) {
        return null
    }
    
    // Fetch fell asleep / woke up / source via raw query
    val userId = SessionStore.readUserId(ctx)
    var fellAsleepDisplay: String? = null
    var wokeUpDisplay: String? = null
    var sourceLabel = ""
    
    if (userId != null) {
        val client = okhttp3.OkHttpClient()
        
        // Fell asleep
        try {
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/fell_asleep_time_daily?" +
                    "user_id=eq.$userId&date=eq.$date&select=value_at&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val valueAt = arr.getJSONObject(0).optString("value_at", "")
                    if (valueAt.isNotBlank()) {
                        fellAsleepDisplay = try {
                            val zdt = java.time.ZonedDateTime.parse(valueAt)
                            val local = zdt.withZoneSameInstant(java.time.ZoneId.systemDefault())
                            local.format(java.time.format.DateTimeFormatter.ofPattern("h:mm a"))
                        } catch (_: Exception) { valueAt.take(5) }
                    }
                }
            }
        } catch (_: Exception) {}
        
        // Woke up
        try {
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/woke_up_time_daily?" +
                    "user_id=eq.$userId&date=eq.$date&select=value_at&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val valueAt = arr.getJSONObject(0).optString("value_at", "")
                    if (valueAt.isNotBlank()) {
                        wokeUpDisplay = try {
                            val zdt = java.time.ZonedDateTime.parse(valueAt)
                            val local = zdt.withZoneSameInstant(java.time.ZoneId.systemDefault())
                            local.format(java.time.format.DateTimeFormatter.ofPattern("h:mm a"))
                        } catch (_: Exception) { valueAt.take(5) }
                    }
                }
            }
        } catch (_: Exception) {}
        
        // Source
        try {
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/sleep_duration_daily?" +
                    "user_id=eq.$userId&date=eq.$date&select=source&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val src = arr.getJSONObject(0).optString("source", "")
                    sourceLabel = when (src) {
                        "phone" -> "Phone"
                        "whoop" -> "WHOOP"
                        "health_connect" -> "Health Connect"
                        else -> ""
                    }
                }
            }
        } catch (_: Exception) {}
    }
    
    // Fetch disturbances and stages (wearable-only, may be null)
    val todayDisturbances = try {
        db.fetchSleepDisturbancesDaily(token, 1).find { it.date == date }
    } catch (_: Exception) { null }
    
    val todayStages = try {
        db.fetchSleepStagesDaily(token, 1).find { it.date == date }
    } catch (_: Exception) { null }
    
    return SleepSummary(
        durationHours = todayDuration?.value_hours ?: 0.0,
        sleepScore = todayScore?.value_pct?.toInt() ?: 0,
        efficiency = todayEfficiency?.value_pct?.toInt() ?: 0,
        fellAsleepDisplay = fellAsleepDisplay,
        wokeUpDisplay = wokeUpDisplay,
        sourceLabel = sourceLabel,
        disturbances = todayDisturbances?.value_count,
        stagesDeep = todayStages?.value_sws_hm,
        stagesRem = todayStages?.value_rem_hm,
        stagesLight = todayStages?.value_light_hm
    )
}

// ─── Mental Health Summary ──────────────────────────────────────────────────

data class MentalSummary(
    val stress: Double?,
    val screenTimeHours: Double?,
    val lateScreenTimeHours: Double?,
    val noiseIndex: Double?,
    val brightness: Double?,
    val volumePct: Double?,
    val darkModeHours: Double?,
    val unlockCount: Int?
) {
    fun displayValue(metric: String): String = when (metric) {
        MentalCardConfig.METRIC_STRESS -> stress?.let { String.format("%.0f", it) } ?: "—"
        MentalCardConfig.METRIC_SCREEN_TIME -> screenTimeHours?.let { String.format("%.1fh", it) } ?: "—"
        MentalCardConfig.METRIC_LATE_SCREEN_TIME -> lateScreenTimeHours?.let { String.format("%.1fh", it) } ?: "—"
        MentalCardConfig.METRIC_NOISE -> noiseIndex?.let { String.format("%.0f dB", it) } ?: "—"
        MentalCardConfig.METRIC_BRIGHTNESS -> brightness?.let { String.format("%.0f", it) } ?: "—"
        MentalCardConfig.METRIC_VOLUME -> volumePct?.let { "${it.toInt()}%" } ?: "—"
        MentalCardConfig.METRIC_DARK_MODE -> darkModeHours?.let { String.format("%.1fh", it) } ?: "—"
        MentalCardConfig.METRIC_UNLOCKS -> unlockCount?.let { "$it" } ?: "—"
        else -> "—"
    }
}

private suspend fun loadMentalSummary(ctx: android.content.Context, token: String, date: String): MentalSummary? {
    val userId = SessionStore.readUserId(ctx) ?: return null
    val client = OkHttpClient()
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val key = BuildConfig.SUPABASE_ANON_KEY

    fun fetchDouble(table: String, column: String): Double? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) arr.getJSONObject(0).optDouble(column).takeIf { !it.isNaN() } else null
            } else null
        } catch (_: Exception) { null }
    }

    fun fetchInt(table: String, column: String): Int? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=$column&limit=1"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val v = arr.getJSONObject(0).optInt(column, Int.MIN_VALUE)
                    if (v != Int.MIN_VALUE) v else null
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    /** Fetch today's samples from a _samples table, compute AVG of a numeric column */
    fun fetchSamplesAvg(table: String, column: String, tsColumn: String = "sampled_at"): Double? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${date}T00:00:00&${tsColumn}=lt.${date}T23:59:59&select=$column"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val values = (0 until arr.length()).mapNotNull {
                        arr.getJSONObject(it).optDouble(column).takeIf { v -> !v.isNaN() }
                    }
                    if (values.isNotEmpty()) values.average() else null
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    /** Fetch today's samples and return MAX of integer column */
    fun fetchSamplesMax(table: String, column: String, tsColumn: String = "sampled_at"): Int? {
        return try {
            val url = "$base/rest/v1/$table?user_id=eq.$userId&${tsColumn}=gte.${date}T00:00:00&${tsColumn}=lt.${date}T23:59:59&select=$column"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                if (arr.length() > 0) {
                    val values = (0 until arr.length()).mapNotNull {
                        val v = arr.getJSONObject(it).optInt(column, Int.MIN_VALUE)
                        if (v != Int.MIN_VALUE) v else null
                    }
                    values.maxOrNull()
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    /** Fetch dark mode samples, estimate hours as (dark_count / total) * 24 */
    fun fetchDarkModeSamplesHours(): Double? {
        return try {
            val url = "$base/rest/v1/phone_dark_mode_samples?user_id=eq.$userId&sampled_at=gte.${date}T00:00:00&sampled_at=lt.${date}T23:59:59&select=is_dark"
            val req = Request.Builder().url(url).get()
                .addHeader("apikey", key).addHeader("Authorization", "Bearer $token").build()
            val resp = client.newCall(req).execute()
            val body = resp.body?.string()
            if (resp.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                val total = arr.length()
                if (total > 0) {
                    val darkCount = (0 until total).count { arr.getJSONObject(it).optBoolean("is_dark", false) }
                    (darkCount.toDouble() / total) * 24.0
                } else null
            } else null
        } catch (_: Exception) { null }
    }

    val stress = fetchDouble("stress_index_daily", "value")
    val screenTime = fetchDouble("screen_time_daily", "total_hours")
        ?: fetchDouble("screen_time_live", "value_hours")
    val lateScreen = fetchDouble("screen_time_late_night", "value_hours")
    val noise = fetchDouble("ambient_noise_index_daily", "day_mean_lmean")
        ?: fetchSamplesAvg("ambient_noise_samples", "l_mean", "start_ts")

    // Phone behavior: try daily table first, fall back to live samples
    val brightness = fetchDouble("phone_brightness_daily", "value_mean")
        ?: fetchSamplesAvg("phone_brightness_samples", "value")
    val volume = fetchDouble("phone_volume_daily", "value_mean_pct")
        ?: fetchSamplesAvg("phone_volume_samples", "value_pct")
    val darkMode = fetchDouble("phone_dark_mode_daily", "value_hours")
        ?: fetchDarkModeSamplesHours()
    val unlocks = fetchInt("phone_unlock_daily", "value_count")
        ?: fetchSamplesMax("phone_unlock_samples", "value_count")

    if (stress == null && screenTime == null && lateScreen == null && noise == null &&
        brightness == null && volume == null && darkMode == null && unlocks == null) {
        return null
    }

    return MentalSummary(stress, screenTime, lateScreen, noise, brightness, volume, darkMode, unlocks)
}

title: MonitorSleepScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

@Composable
fun MonitorSleepScreen(
    navController: NavController,
    authVm: AuthViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()
    val today = remember { LocalDate.now(ZoneId.systemDefault()).toString() }

    var sleepDetail by remember { mutableStateOf<SleepDetailData?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    val sleepConfig = remember { SleepCardConfigStore.load(ctx) }

    LaunchedEffect(authState.accessToken, today) {
        val token = authState.accessToken
        if (token.isNullOrBlank()) {
            isLoading = false
            return@LaunchedEffect
        }
        withContext(Dispatchers.IO) {
            sleepDetail = try { loadSleepDetailData(ctx, token, today) } catch (_: Exception) { null }
            isLoading = false
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Back
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                IconButton(onClick = { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                }
            }

            // Customize HeroCard
            HeroCard(modifier = Modifier.clickable { navController.navigate(Routes.SLEEP_CONFIG) }) {
                Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.Tune, contentDescription = "Configure", tint = AppTheme.AccentPurple, modifier = Modifier.size(24.dp))
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(text = "Customize Monitor Card", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                        Text(text = "Choose 3 metrics for the Sleep card on Monitor", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    }
                    Text(text = "→", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium)
                }
            }

            // Explainer
            BaseCard {
                Text(
                    text = "Poor sleep quality and irregular sleep patterns are among the most common migraine triggers. Tracking your sleep helps identify patterns and predict migraine risk.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyLarge
                )
            }

            // Today's Sleep — shows ALL metrics
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth().clickable { navController.navigate(Routes.SLEEP_DATA_HISTORY) },
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(text = "Last Night's Sleep", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("History →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                }
                Spacer(Modifier.height(8.dp))

                if (isLoading) {
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                    }
                } else if (sleepDetail == null) {
                    Text(text = "No sleep data for last night", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    Spacer(Modifier.height(4.dp))
                    Text(text = "Enable phone sleep tracking or connect a wearable in Data Settings", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                } else {
                    val detail = sleepDetail!!

                    // Top 3 selected metrics
                    val selectedMetrics = sleepConfig.sleepDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val value = detail.displayValue(metric) ?: "—"
                            val label = SleepCardConfig.labelFor(metric)
                            SleepMetricLargeItem(label, value, slotColors.getOrElse(index) { slotColors.last() })
                        }
                    }

                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text(text = "All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    // All metrics that have data
                    SleepCardConfig.ALL_SLEEP_METRICS.forEach { metric ->
                        if (metric !in selectedMetrics) {
                            val value = detail.displayValue(metric)
                            if (value != null) {
                                val label = SleepCardConfig.labelFor(metric)
                                SleepMetricRowItem(label, value, AppTheme.SubtleTextColor)
                            }
                        }
                    }
                }
            }

            // History Graph
            SleepHistoryGraph(
                days = 14,
                onClick = { navController.navigate(Routes.FULL_GRAPH_SLEEP) }
            )


        }
    }
}

// ─── Composable helpers ──────────────────────────────────────────────────────

@Composable
private fun SleepMetricLargeItem(label: String, value: String, color: Color) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(text = value, color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        Text(text = label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}

@Composable
private fun SleepMetricRowItem(label: String, value: String?, color: Color) {
    if (value == null) return
    Row(
        modifier = Modifier.fillMaxWidth().height(24.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = label, color = AppTheme.TitleColor, style = MaterialTheme.typography.bodySmall)
        Text(text = value, color = color, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
    }
}

// ─── Helpers ─────────────────────────────────────────────────────────────────

private fun sleepHoursMinutes(hm: Double): String {
    val totalMinutes = (hm * 60).toInt()
    val hours = totalMinutes / 60
    val minutes = totalMinutes % 60
    return if (hours > 0) "${hours}h ${minutes}m" else "${minutes}m"
}

private fun sleepTimeFromIso(isoString: String): String? {
    return try {
        val zdt = ZonedDateTime.parse(isoString)
        val local = zdt.withZoneSameInstant(ZoneId.systemDefault())
        local.format(DateTimeFormatter.ofPattern("h:mm a"))
    } catch (_: Exception) {
        try { isoString.take(5) } catch (_: Exception) { null }
    }
}

// ─── Data class ──────────────────────────────────────────────────────────────

private data class SleepDetailData(
    val durationHours: Double,
    val fellAsleepDisplay: String?,
    val wokeUpDisplay: String?,
    val sleepScore: Double?,
    val efficiency: Double?,
    val disturbances: Int?,
    val stagesDeep: Double?,
    val stagesRem: Double?,
    val stagesLight: Double?,
    val sourceLabel: String,
    val hasWearableData: Boolean
) {
    fun displayValue(metric: String): String? = when (metric) {
        SleepCardConfig.METRIC_DURATION -> String.format("%.1fh", durationHours)
        SleepCardConfig.METRIC_FELL_ASLEEP -> fellAsleepDisplay
        SleepCardConfig.METRIC_WOKE_UP -> wokeUpDisplay
        SleepCardConfig.METRIC_SCORE -> sleepScore?.let { "${it.toInt()}%" }
        SleepCardConfig.METRIC_EFFICIENCY -> efficiency?.let { "${it.toInt()}%" }
        SleepCardConfig.METRIC_DISTURBANCES -> disturbances?.toString()
        SleepCardConfig.METRIC_STAGES_DEEP -> stagesDeep?.let { sleepHoursMinutes(it) }
        SleepCardConfig.METRIC_STAGES_REM -> stagesRem?.let { sleepHoursMinutes(it) }
        SleepCardConfig.METRIC_STAGES_LIGHT -> stagesLight?.let { sleepHoursMinutes(it) }
        else -> null
    }
}

// ─── Data loading ────────────────────────────────────────────────────────────

private suspend fun loadSleepDetailData(
    ctx: android.content.Context,
    token: String,
    date: String
): SleepDetailData? = withContext(Dispatchers.IO) {
    val metrics = SupabaseMetricsService(ctx)

    val duration = try { metrics.fetchSleepDurationDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    if (duration == null) return@withContext null

    val sourceInfo = try { sleepFetchSource(ctx, token, date) } catch (_: Exception) { null }
    val sourceLabel = when (sourceInfo) {
        "phone" -> "Phone"
        "whoop" -> "WHOOP"
        "health_connect" -> "Health Connect"
        else -> "Unknown"
    }

    val fellAsleep = try { sleepFetchTime(ctx, token, date, "fell_asleep_time_daily") } catch (_: Exception) { null }
    val wokeUp = try { sleepFetchTime(ctx, token, date, "woke_up_time_daily") } catch (_: Exception) { null }

    val score = try { metrics.fetchSleepScoreDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val efficiency = try { metrics.fetchSleepEfficiencyDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val disturbances = try { metrics.fetchSleepDisturbancesDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }
    val stages = try { metrics.fetchSleepStagesDaily(token, 1).find { it.date == date } } catch (_: Exception) { null }

    val hasWearable = score != null || efficiency != null || disturbances != null || stages != null

    SleepDetailData(
        durationHours = duration.value_hours,
        fellAsleepDisplay = fellAsleep?.let { sleepTimeFromIso(it) },
        wokeUpDisplay = wokeUp?.let { sleepTimeFromIso(it) },
        sleepScore = score?.value_pct,
        efficiency = efficiency?.value_pct,
        disturbances = disturbances?.value_count,
        stagesDeep = stages?.value_sws_hm,
        stagesRem = stages?.value_rem_hm,
        stagesLight = stages?.value_light_hm,
        sourceLabel = sourceLabel,
        hasWearableData = hasWearable
    )
}

private suspend fun sleepFetchSource(ctx: android.content.Context, token: String, date: String): String? {
    return withContext(Dispatchers.IO) {
        try {
            val client = okhttp3.OkHttpClient()
            val userId = SessionStore.readUserId(ctx) ?: return@withContext null
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/sleep_duration_daily?user_id=eq.$userId&date=eq.$date&select=source&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: return@withContext null
            if (!response.isSuccessful) return@withContext null
            val arr = org.json.JSONArray(body)
            if (arr.length() > 0) arr.getJSONObject(0).optString("source", null) else null
        } catch (_: Exception) { null }
    }
}

private suspend fun sleepFetchTime(ctx: android.content.Context, token: String, date: String, table: String): String? {
    return withContext(Dispatchers.IO) {
        try {
            val client = okhttp3.OkHttpClient()
            val userId = SessionStore.readUserId(ctx) ?: return@withContext null
            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/$table?user_id=eq.$userId&date=eq.$date&select=value_at&limit=1"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token").build()
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: return@withContext null
            if (!response.isSuccessful) return@withContext null
            val arr = org.json.JSONArray(body)
            if (arr.length() > 0) arr.getJSONObject(0).optString("value_at", null) else null
        } catch (_: Exception) { null }
    }
}

title: NotesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.ui.draw.drawBehind
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.foundation.BorderStroke
import androidx.navigation.NavController

@Composable
fun NotesScreen(
    navController: NavController,
    vm: LogViewModel,
    onClose: () -> Unit = {}
) {
    val draft by vm.draft.collectAsState()
    val scrollState = rememberScrollState()

    var notes by rememberSaveable { mutableStateOf("") }

    // Sync from existing draft once
    LaunchedEffect(draft.migraine) {
        draft.migraine?.let { m ->
            notes = m.note ?: ""
        }
    }

    fun syncDraft() {
        vm.setMigraineDraft(note = notes.ifBlank { null })
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { syncDraft(); navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Reliefs", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Notes", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawNotesIcon(AppTheme.AccentPink) } }
                )
                Text("Notes", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    "Add any additional notes about this migraine",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // Notes input
            BaseCard {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Box(
                        modifier = Modifier
                            .size(20.dp)
                            .drawBehind { HubIcons.run { drawNotesIcon(AppTheme.AccentPurple) } }
                    )
                    Spacer(Modifier.width(8.dp))
                    Text("Your notes", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                }
                Spacer(Modifier.height(8.dp))
                OutlinedTextField(
                    value = notes,
                    onValueChange = { v -> notes = v; syncDraft() },
                    placeholder = { Text("What were you doing? How did it feel? Any patterns you noticed…", color = AppTheme.SubtleTextColor) },
                    modifier = Modifier.fillMaxWidth(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedTextColor = Color.White, unfocusedTextColor = AppTheme.BodyTextColor,
                        cursorColor = AppTheme.AccentPurple, focusedBorderColor = AppTheme.AccentPurple,
                        unfocusedBorderColor = Color.White.copy(alpha = 0.15f)
                    ),
                    minLines = 5
                )
            }

            // Navigation
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                OutlinedButton(
                    onClick = { syncDraft(); navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }
                Button(
                    onClick = { syncDraft(); navController.navigate(Routes.REVIEW) },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text("Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

title: NutritionBackfillUtility.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * NUTRITION BACKFILL UTILITY
 *
 * Helper functions to diagnose and fix nutrition backfill issues.
 *
 * USAGE:
 * Add a debug button in your ThirdPartyConnectionsScreen:
 *
 * ```kotlin
 * Button(onClick = {
 *     scope.launch {
 *         NutritionBackfillUtility.forceReBackfill(context)
 *     }
 * }) {
 *     Text("Force Re-Backfill (Debug)")
 * }
 * ```
 */
object NutritionBackfillUtility {

    private const val TAG = "NutritionBackfillUtil"

    /**
     * Force a complete re-backfill by:
     * 1. Clearing the sync token (so the worker thinks it's the first run)
     * 2. Clearing the outbox (to avoid duplicates)
     * 3. Triggering an immediate worker run
     *
     * This is useful when:
     * - The initial backfill failed or was incomplete
     * - You granted permission but data wasn't captured
     * - You want to test the backfill process
     */
    suspend fun forceReBackfill(context: Context) = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "Starting force re-backfill...")

            val db = NutritionSyncDatabase.get(context)
            val dao = db.dao()

            // Get current state for logging
            val beforeState = dao.getSyncState()
            val beforeOutbox = dao.getOutboxBatch(1000).size

            Log.d(TAG, "Before: token=${beforeState?.nutritionChangesToken?.take(10)}..., outbox=$beforeOutbox")

            // Clear the sync token so backfill will trigger
            dao.upsertSyncState(
                SyncStateEntity(
                    id = 1,
                    nutritionChangesToken = null,  // This is the key - null means "never synced"
                    lastHourlyRunAtEpochMs = null,
                    lastPushRunAtEpochMs = beforeState?.lastPushRunAtEpochMs
                )
            )

            // Optionally clear outbox to avoid duplicates
            // (Comment this out if you want to keep existing outbox items)
            val outboxIds = dao.getOutboxBatch(1000).map { it.healthConnectId }
            if (outboxIds.isNotEmpty()) {
                dao.deleteOutboxByIds(outboxIds)
                Log.d(TAG, "Cleared ${outboxIds.size} items from outbox")
            }

            Log.d(TAG, "Sync token cleared. Triggering immediate worker run...")

            // Trigger immediate worker run
            val work = OneTimeWorkRequestBuilder<HealthConnectNutritionChangesWorker>()
                .addTag("force_backfill")
                .build()

            WorkManager.getInstance(context).enqueue(work)

            Log.d(TAG, "Force re-backfill initiated. Worker will run shortly and capture last 7 days of data.")

        } catch (e: Exception) {
            Log.e(TAG, "Failed to force re-backfill", e)
            throw e
        }
    }

    /**
     * Get detailed status of the nutrition sync system.
     * Useful for debugging in logs.
     */
    suspend fun getDetailedStatus(context: Context): NutritionSyncStatus = withContext(Dispatchers.IO) {
        val db = NutritionSyncDatabase.get(context)
        val dao = db.dao()

        val state = dao.getSyncState()
        val outbox = dao.getOutboxBatch(1000)

        NutritionSyncStatus(
            hasToken = !state?.nutritionChangesToken.isNullOrBlank(),
            tokenPreview = state?.nutritionChangesToken?.take(20),
            lastHourlyRun = state?.lastHourlyRunAtEpochMs,
            lastPushRun = state?.lastPushRunAtEpochMs,
            outboxCount = outbox.size,
            outboxUpserts = outbox.count { it.operation == "UPSERT" },
            outboxDeletes = outbox.count { it.operation == "DELETE" }
        )
    }

    /**
     * Log current sync status to logcat for debugging
     */
    suspend fun logCurrentStatus(context: Context) {
        try {
            val status = getDetailedStatus(context)

            Log.d(TAG, "═══════════════════════════════════════")
            Log.d(TAG, "NUTRITION SYNC STATUS")
            Log.d(TAG, "═══════════════════════════════════════")
            Log.d(TAG, "Has Token: ${status.hasToken}")
            Log.d(TAG, "Token Preview: ${status.tokenPreview ?: "null"}")
            Log.d(TAG, "Last Hourly Run: ${status.lastHourlyRun?.let { java.util.Date(it) } ?: "never"}")
            Log.d(TAG, "Last Push Run: ${status.lastPushRun?.let { java.util.Date(it) } ?: "never"}")
            Log.d(TAG, "Outbox Total: ${status.outboxCount}")
            Log.d(TAG, "  - UPSERTs: ${status.outboxUpserts}")
            Log.d(TAG, "  - DELETEs: ${status.outboxDeletes}")
            Log.d(TAG, "═══════════════════════════════════════")

            if (status.hasToken && status.outboxCount == 0) {
                Log.w(TAG, "⚠️ WARNING: Token exists but outbox is empty!")
                Log.w(TAG, "This suggests:")
                Log.w(TAG, "  1. Backfill ran but found no data in Health Connect, OR")
                Log.w(TAG, "  2. Data was already pushed to Supabase, OR")
                Log.w(TAG, "  3. There's an issue with the backfill logic")
            }

            if (!status.hasToken && status.outboxCount > 0) {
                Log.w(TAG, "⚠️ WARNING: Outbox has data but no token!")
                Log.w(TAG, "This is unusual - token should be created after backfill")
            }

        } catch (e: Exception) {
            Log.e(TAG, "Failed to get status", e)
        }
    }

    data class NutritionSyncStatus(
        val hasToken: Boolean,
        val tokenPreview: String?,
        val lastHourlyRun: Long?,
        val lastPushRun: Long?,
        val outboxCount: Int,
        val outboxUpserts: Int,
        val outboxDeletes: Int
    )
}

title: NutritionComponents.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun FoodSearchResultItem(
    food: USDAFoodSearchResult,
    foodRisks: FoodRiskResult? = null,
    isClassifyingRisks: Boolean = false,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                food.description,
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium),
                maxLines = 2
            )
            if (food.brandName != null) {
                Text(
                    food.brandName,
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
            Row(verticalAlignment = Alignment.CenterVertically) {
                food.calories?.let {
                    Text(
                        "${it.toInt()} cal",
                        color = Color(0xFFFFB74D),
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                if (food.servingSize != null && food.servingSizeUnit != null) {
                    Text(
                        " • ${food.servingSize.toInt()} ${food.servingSizeUnit}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                // Risk badges — geometric icon + vertical bar
                if (foodRisks != null) {
                    val tColor = when (foodRisks.tyramine) {
                        "high" -> RiskColors.TyramineHigh; "medium" -> RiskColors.TyramineMedium; "low" -> RiskColors.TyramineLow; else -> null
                    }
                    val aColor = when (foodRisks.alcohol) {
                        "high" -> RiskColors.AlcoholHigh; "medium" -> RiskColors.AlcoholMedium; "low" -> RiskColors.AlcoholLow; else -> null
                    }
                    val gColor = when (foodRisks.gluten) {
                        "high" -> RiskColors.GlutenHigh; "medium" -> RiskColors.GlutenMedium; "low" -> RiskColors.GlutenLow; else -> null
                    }
                    tColor?.let { TyramineRiskBadge(it, foodRisks.tyramine) }
                    aColor?.let { AlcoholRiskBadge(it, foodRisks.alcohol) }
                    gColor?.let { GlutenRiskBadge(it, foodRisks.gluten) }
                } else if (isClassifyingRisks) {
                    Spacer(Modifier.width(6.dp))
                    CircularProgressIndicator(
                        modifier = Modifier.size(10.dp),
                        color = AppTheme.AccentPurple,
                        strokeWidth = 1.5.dp
                    )
                }
            }
        }
        
        Icon(
            Icons.Default.Add,
            contentDescription = "Add",
            tint = AppTheme.AccentPurple,
            modifier = Modifier.size(24.dp)
        )
    }
}

@Composable
private fun RiskBadge(
    letter: String,
    level: String,
    highColor: Color,
    mediumColor: Color,
    lowColor: Color
) {
    if (level == "none") return
    val color = when (level) {
        "high" -> highColor; "medium" -> mediumColor; "low" -> lowColor
        else -> return
    }
    Spacer(Modifier.width(4.dp))
    Text(
        letter,
        color = color,
        style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
    )
}

@Composable
fun TodayLogItem(
    item: NutritionLogItem,
    onEdit: (() -> Unit)?,
    onDelete: (() -> Unit)?
) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(item.foodName, color = AppTheme.TitleColor, style = MaterialTheme.typography.bodyMedium, maxLines = 1)
            Row {
                Text(item.mealType.replaceFirstChar { it.uppercase() }, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                item.calories?.let {
                    Text(" • ${it.toInt()} cal", color = Color(0xFFFFB74D), style = MaterialTheme.typography.bodySmall)
                }
                if (item.source == "manual_usda") {
                    Text(" • Manual", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
                }
            }
        }
        
        if (onEdit != null) {
            Text("✎", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.clickable { onEdit() }.padding(8.dp))
        }
        
        if (onDelete != null) {
            Text("✕", color = Color(0xFFE57373), style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.clickable { onDelete() }.padding(8.dp))
        }
    }
}

@Composable
fun NutrientRow(label: String, value: Double?, unit: String) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(label, color = AppTheme.TitleColor, style = MaterialTheme.typography.bodySmall)
        Text(
            if (value != null && value > 0) {
                if (value < 1) String.format("%.2f%s", value, unit) else String.format("%.1f%s", value, unit)
            } else "—",
            color = AppTheme.AccentPurple,
            style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium)
        )
    }
}


title: NutritionConfigScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.PhoneAndroid
import androidx.compose.material.icons.filled.Watch
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

private fun sourceTypeForNutrition(preferredSource: String?): String? = when (preferredSource) {
    "phone" -> "phone"
    "health_connect" -> "external"
    null -> null
    else -> "phone"
}

@OptIn(ExperimentalLayoutApi::class, ExperimentalMaterial3Api::class)
@Composable
fun NutritionConfigScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    var config by remember { mutableStateOf(MonitorCardConfigStore.load(context)) }

    var metricSettings by remember {
        mutableStateOf<Map<String, EdgeFunctionsService.MetricSettingResponse>>(emptyMap())
    }
    var settingsLoaded by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        scope.launch {
            try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(context)
                metricSettings = settings.associateBy { it.metric }
            } catch (_: Exception) { }
            settingsLoaded = true
        }
    }

    // Nutrition is a single metric in metric_settings
    val nutritionSetting = metricSettings["nutrition"]
    val nutritionSource = sourceTypeForNutrition(nutritionSetting?.preferredSource)
    // Only hide all metrics if nutrition is explicitly disabled
    val hideNutrition = settingsLoaded && nutritionSetting != null && !nutritionSetting.enabled

    fun updateConfig(newConfig: MonitorCardConfig) {
        config = newConfig
        MonitorCardConfigStore.save(context, newConfig)
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = onBack) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }

            HeroCard {
                Text(
                    text = "Customize Nutrition Display",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Choose which 3 metrics appear on the Monitor screen",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            if (hideNutrition) {
                BaseCard {
                    Text(
                        text = "No nutrition source enabled",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    Spacer(Modifier.height(4.dp))
                    Text(
                        text = "Enable nutrition tracking in Data Settings to customize metrics.",
                        color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            } else {
                BaseCard {
                    Text(
                        text = "Select 3 Metrics",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                    )

                    Spacer(Modifier.height(12.dp))

                    FlowRow(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                        for (metric in MonitorCardConfig.ALL_NUTRITION_METRICS) {
                            val isSelected = metric in config.nutritionDisplayMetrics
                            val canSelect = isSelected || config.nutritionDisplayMetrics.size < 3
                            val slotIndex = if (isSelected) config.nutritionDisplayMetrics.indexOf(metric) else -1
                            val slotColor = if (slotIndex in slotColors.indices) slotColors[slotIndex] else AppTheme.AccentPurple

                            FilterChip(
                                selected = isSelected,
                                onClick = {
                                    if (canSelect || isSelected) {
                                        updateConfig(config.toggleNutritionMetric(metric))
                                    }
                                },
                                label = {
                                    Text(
                                        text = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric,
                                        style = MaterialTheme.typography.bodySmall
                                    )
                                },
                                leadingIcon = if (isSelected) {
                                    {
                                        Icon(
                                            Icons.Default.Check,
                                            contentDescription = null,
                                            modifier = Modifier.size(16.dp)
                                        )
                                    }
                                } else null,
                                trailingIcon = when (nutritionSource) {
                                    "external" -> {
                                        {
                                            Icon(
                                                Icons.Default.Watch,
                                                contentDescription = "External",
                                                modifier = Modifier.size(14.dp),
                                                tint = if (isSelected) slotColor else AppTheme.SubtleTextColor
                                            )
                                        }
                                    }
                                    else -> {
                                        {
                                            Icon(
                                                Icons.Default.PhoneAndroid,
                                                contentDescription = "Phone",
                                                modifier = Modifier.size(14.dp),
                                                tint = if (isSelected) slotColor else AppTheme.SubtleTextColor
                                            )
                                        }
                                    }
                                },
                                colors = FilterChipDefaults.filterChipColors(
                                    selectedContainerColor = slotColor.copy(alpha = 0.3f),
                                    selectedLabelColor = AppTheme.TitleColor,
                                    selectedLeadingIconColor = slotColor,
                                    containerColor = Color.Transparent,
                                    labelColor = AppTheme.BodyTextColor
                                ),
                                border = FilterChipDefaults.filterChipBorder(
                                    borderColor = AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                                    selectedBorderColor = slotColor,
                                    enabled = true,
                                    selected = isSelected
                                ),
                                enabled = true
                            )
                        }
                    }

                    Spacer(Modifier.height(12.dp))

                    Text(
                        text = "${config.nutritionDisplayMetrics.size}/3 selected",
                        color = if (config.nutritionDisplayMetrics.size == 3)
                            AppTheme.AccentPurple
                        else
                            AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall
                    )

                    Spacer(Modifier.height(8.dp))
                    Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                        Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                            Icon(Icons.Default.Watch, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                            Text(text = "External", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        }
                        Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                            Icon(Icons.Default.PhoneAndroid, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                            Text(text = "Phone", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        }
                    }
                }
            }
        }
    }
}

title: NutritionDiagnosticActivity.kt
text:
package com.migraineme

import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.NutritionRecord
import androidx.health.connect.client.request.ReadRecordsRequest
import androidx.health.connect.client.time.TimeRangeFilter
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit

/**
 * DIAGNOSTIC ACTIVITY FOR NUTRITION BACKFILL DEBUGGING
 *
 * This activity helps identify why the 7-day backfill isn't working by:
 * 1. Checking Health Connect permissions
 * 2. Reading nutrition data directly from Health Connect for the last 7 days
 * 3. Checking the local nutrition_outbox database
 * 4. Comparing what's in Health Connect vs what's in the outbox
 *
 * To use:
 * 1. Add this activity to AndroidManifest.xml
 * 2. Add a button in ThirdPartyConnectionsScreen to launch it
 * 3. Run diagnostics to see exactly what data exists where
 */
@OptIn(ExperimentalMaterial3Api::class)
class NutritionDiagnosticActivity : ComponentActivity() {

    @OptIn(ExperimentalMaterial3Api::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            MaterialTheme {
                DiagnosticScreen()
            }
        }
    }

    @Composable
    fun DiagnosticScreen() {
        val scope = rememberCoroutineScope()
        var diagnosticResults by remember { mutableStateOf<DiagnosticResults?>(null) }
        var isRunning by remember { mutableStateOf(false) }
        var error by remember { mutableStateOf<String?>(null) }

        Scaffold(
            topBar = {
                TopAppBar(title = { Text("Nutrition Backfill Diagnostic") })
            }
        ) { padding ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(padding)
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                Button(
                    onClick = {
                        scope.launch {
                            isRunning = true
                            error = null
                            try {
                                diagnosticResults = runDiagnostics()
                            } catch (e: Exception) {
                                error = "Error: ${e.message}"
                                Log.e(TAG, "Diagnostic failed", e)
                            } finally {
                                isRunning = false
                            }
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    enabled = !isRunning
                ) {
                    Text(if (isRunning) "Running..." else "Run Diagnostics")
                }

                error?.let { err ->
                    Card(
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
                    ) {
                        Text(
                            text = err,
                            modifier = Modifier.padding(16.dp),
                            color = MaterialTheme.colorScheme.onErrorContainer
                        )
                    }
                }

                diagnosticResults?.let { results ->
                    DiagnosticResultsDisplay(results)
                }
            }
        }
    }

    @Composable
    fun DiagnosticResultsDisplay(results: DiagnosticResults) {
        LazyColumn(
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Summary Card
            item {
                Card {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text("SUMMARY", style = MaterialTheme.typography.titleLarge)
                        Spacer(Modifier.height(8.dp))

                        ResultRow("Permission Granted", results.hasPermission.toString())
                        ResultRow("Health Connect Available", results.healthConnectAvailable.toString())
                        ResultRow("Sync Token Exists", results.syncTokenExists.toString())
                        ResultRow("Last Sync Token Update", results.lastTokenUpdate ?: "Never")
                        ResultRow("Last Outbox Push", results.lastPushRun ?: "Never")

                        Spacer(Modifier.height(8.dp))
                        Divider()
                        Spacer(Modifier.height(8.dp))

                        ResultRow(
                            "Health Connect Records (7d)",
                            "${results.healthConnectRecords.size}",
                            if (results.healthConnectRecords.isEmpty()) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                        )
                        ResultRow(
                            "Outbox Records",
                            "${results.outboxRecords.size}",
                            if (results.outboxRecords.isEmpty()) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                        )

                        val missing = results.healthConnectRecords.filterNot { hcId ->
                            results.outboxRecords.any { it.healthConnectId == hcId }
                        }
                        ResultRow(
                            "Missing in Outbox",
                            "${missing.size}",
                            if (missing.isNotEmpty()) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                        )
                    }
                }
            }

            // Health Connect Records
            item {
                Card {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text("HEALTH CONNECT RECORDS (Last 7 Days)", style = MaterialTheme.typography.titleMedium)
                        Spacer(Modifier.height(8.dp))

                        if (results.healthConnectRecords.isEmpty()) {
                            Text("❌ No records found!", color = MaterialTheme.colorScheme.error)
                            Text(
                                "This means Cronometer (or other nutrition apps) haven't synced data to Health Connect, " +
                                        "OR the permission isn't granted properly.",
                                style = MaterialTheme.typography.bodySmall,
                                modifier = Modifier.padding(top = 8.dp)
                            )
                        }
                    }
                }
            }

            items(results.healthConnectRecordDetails) { detail ->
                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = if (detail.inOutbox)
                            MaterialTheme.colorScheme.surfaceVariant
                        else
                            MaterialTheme.colorScheme.errorContainer
                    )
                ) {
                    Column(modifier = Modifier.padding(12.dp)) {
                        Text(
                            detail.name ?: "Unknown Food",
                            style = MaterialTheme.typography.titleSmall
                        )
                        Text(detail.time, style = MaterialTheme.typography.bodySmall)
                        Text(
                            "Calories: ${detail.calories ?: "N/A"} | ID: ${detail.id.take(8)}...",
                            style = MaterialTheme.typography.bodySmall
                        )
                        Text(
                            if (detail.inOutbox) "✓ In outbox" else "❌ MISSING FROM OUTBOX",
                            color = if (detail.inOutbox)
                                MaterialTheme.colorScheme.primary
                            else
                                MaterialTheme.colorScheme.error,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }

            // Database State
            item {
                Card {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text("DATABASE STATE", style = MaterialTheme.typography.titleMedium)
                        Spacer(Modifier.height(8.dp))

                        if (results.syncTokenExists) {
                            Text("✓ Sync token exists")
                            Text("This means backfill already ran. Only NEW changes will be detected.",
                                style = MaterialTheme.typography.bodySmall)
                        } else {
                            Text("❌ No sync token - backfill should trigger on next worker run")
                        }
                    }
                }
            }

            // Recommendations
            item {
                Card(
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text("🔍 WHAT TO CHECK", style = MaterialTheme.typography.titleMedium)
                        Spacer(Modifier.height(8.dp))

                        if (!results.hasPermission) {
                            Text("❌ ISSUE: Permission not granted!")
                            Text("→ Grant Health Connect permission first", style = MaterialTheme.typography.bodySmall)
                        } else if (results.healthConnectRecords.isEmpty()) {
                            Text("❌ ISSUE: No data in Health Connect!")
                            Text("→ Check if Cronometer is syncing to Health Connect", style = MaterialTheme.typography.bodySmall)
                            Text("→ Open Cronometer, go to Settings → Health Connect", style = MaterialTheme.typography.bodySmall)
                            Text("→ Ensure 'Sync to Health Connect' is enabled", style = MaterialTheme.typography.bodySmall)
                        } else if (results.outboxRecords.isEmpty() && !results.syncTokenExists) {
                            Text("⚠️ ISSUE: HC has data but outbox is empty and no sync token")
                            Text("→ The HealthConnectNutritionChangesWorker hasn't run yet", style = MaterialTheme.typography.bodySmall)
                            Text("→ It should trigger automatically within 1 hour", style = MaterialTheme.typography.bodySmall)
                            Text("→ Or you can trigger it manually (see code)", style = MaterialTheme.typography.bodySmall)
                        } else if (results.healthConnectRecordDetails.any { !it.inOutbox }) {
                            Text("⚠️ ISSUE: Some HC records missing from outbox")
                            Text("→ This indicates the backfill didn't capture everything", style = MaterialTheme.typography.bodySmall)
                            Text("→ You may need to force a re-backfill (see recommendations below)", style = MaterialTheme.typography.bodySmall)
                        } else {
                            Text("✓ Data looks good!")
                            Text("→ If data still isn't in Supabase, check NutritionOutboxPushWorker logs", style = MaterialTheme.typography.bodySmall)
                        }
                    }
                }
            }
        }
    }

    @Composable
    fun ResultRow(label: String, value: String, color: androidx.compose.ui.graphics.Color = MaterialTheme.colorScheme.onSurface) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(label, style = MaterialTheme.typography.bodyMedium)
            Text(value, style = MaterialTheme.typography.bodyMedium, color = color)
        }
    }

    private suspend fun runDiagnostics(): DiagnosticResults = withContext(Dispatchers.IO) {
        val results = DiagnosticResults()

        // 1. Check Health Connect availability and permissions
        try {
            val hc = HealthConnectClient.getOrCreate(applicationContext)
            results.healthConnectAvailable = true

            val granted = hc.permissionController.getGrantedPermissions()
            results.hasPermission = HealthPermission.getReadPermission(NutritionRecord::class) in granted

            Log.d(TAG, "Health Connect available: ${results.healthConnectAvailable}")
            Log.d(TAG, "Permission granted: ${results.hasPermission}")

            // 2. Read nutrition records from Health Connect for last 7 days
            if (results.hasPermission) {
                val end = Instant.now()
                val start = end.minus(7, ChronoUnit.DAYS)

                val request = ReadRecordsRequest(
                    recordType = NutritionRecord::class,
                    timeRangeFilter = TimeRangeFilter.between(start, end)
                )

                val response = hc.readRecords(request)
                results.healthConnectRecords = response.records.map { it.metadata.id }

                Log.d(TAG, "Found ${results.healthConnectRecords.size} HC records in last 7 days")

                // Get details for display
                results.healthConnectRecordDetails = response.records.map { record ->
                    val date = record.startTime.atZone(ZoneOffset.UTC).toLocalDate()
                    val time = record.startTime.atZone(ZoneOffset.systemDefault())
                        .format(DateTimeFormatter.ofPattern("MMM dd, HH:mm"))

                    NutritionRecordDetail(
                        id = record.metadata.id,
                        name = record.name,
                        time = time,
                        calories = record.energy?.inKilocalories?.toInt()?.toString(),
                        inOutbox = false // Will be updated later
                    )
                }
            }

            // 3. Check database state
            val db = NutritionSyncDatabase.get(applicationContext)
            val dao = db.dao()

            val syncState = dao.getSyncState()
            results.syncTokenExists = !syncState?.nutritionChangesToken.isNullOrBlank()
            results.lastTokenUpdate = syncState?.lastHourlyRunAtEpochMs?.let { ms ->
                Instant.ofEpochMilli(ms).atZone(ZoneOffset.systemDefault())
                    .format(DateTimeFormatter.ofPattern("MMM dd HH:mm:ss"))
            }
            results.lastPushRun = syncState?.lastPushRunAtEpochMs?.let { ms ->
                Instant.ofEpochMilli(ms).atZone(ZoneOffset.systemDefault())
                    .format(DateTimeFormatter.ofPattern("MMM dd HH:mm:ss"))
            }

            // 4. Check outbox
            val outboxItems = dao.getOutboxBatch(limit = 1000)
            results.outboxRecords = outboxItems

            Log.d(TAG, "Outbox contains ${outboxItems.size} items")

            // 5. Mark which HC records are in the outbox
            val outboxIds = outboxItems.map { it.healthConnectId }.toSet()
            results.healthConnectRecordDetails = results.healthConnectRecordDetails.map { detail ->
                detail.copy(inOutbox = detail.id in outboxIds)
            }

            Log.d(TAG, "Diagnostic complete")

        } catch (e: Exception) {
            Log.e(TAG, "Diagnostic error", e)
            throw e
        }

        results
    }

    data class DiagnosticResults(
        var healthConnectAvailable: Boolean = false,
        var hasPermission: Boolean = false,
        var healthConnectRecords: List<String> = emptyList(),
        var healthConnectRecordDetails: List<NutritionRecordDetail> = emptyList(),
        var outboxRecords: List<NutritionOutboxEntity> = emptyList(),
        var syncTokenExists: Boolean = false,
        var lastTokenUpdate: String? = null,
        var lastPushRun: String? = null
    )

    data class NutritionRecordDetail(
        val id: String,
        val name: String?,
        val time: String,
        val calories: String?,
        val inOutbox: Boolean
    )

    companion object {
        private const val TAG = "NutritionDiagnostic"
    }
}

title: NutritionDialogs.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddFoodDialog(
    food: USDAFoodSearchResult,
    foodDetails: USDAFoodDetailsFull?,
    isLoadingDetails: Boolean,
    mealType: String,
    onMealTypeChange: (String) -> Unit,
    servings: Double,
    onServingsChange: (Double) -> Unit,
    isAdding: Boolean,
    monitorMetrics: List<String>,
    tyramineRisk: String? = null,
    alcoholRisk: String? = null,
    glutenRisk: String? = null,
    isClassifyingRisks: Boolean = false,
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val mealTypes = listOf("breakfast", "lunch", "dinner", "snack")
    val scrollState = rememberScrollState()
    
    AlertDialog(
        onDismissRequest = { if (!isAdding && !isLoadingDetails) onDismiss() },
        title = { Text("Add Food", color = AppTheme.TitleColor) },
        text = {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .heightIn(max = 400.dp)
                    .verticalScroll(scrollState)
            ) {
                Text(
                    food.description,
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
                )
                
                food.brandName?.let {
                    Text(it, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
                
                Spacer(Modifier.height(12.dp))
                
                // Servings selector
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text("Servings", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium)
                    if (food.servingSize != null && food.servingSizeUnit != null) {
                        Text(
                            "1 serving = ${food.servingSize.toInt()} ${food.servingSizeUnit}",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
                
                Spacer(Modifier.height(8.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        "−",
                        color = if (servings > 0.5) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        style = MaterialTheme.typography.headlineMedium,
                        modifier = Modifier
                            .clickable(enabled = servings > 0.5) { onServingsChange((servings - 0.5).coerceAtLeast(0.5)) }
                            .padding(horizontal = 12.dp)
                    )
                    
                    Column(
                        modifier = Modifier.weight(1f),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            if (servings == servings.toLong().toDouble()) "${servings.toLong()}" else String.format("%.1f", servings),
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                            textAlign = androidx.compose.ui.text.style.TextAlign.Center
                        )
                        if (food.servingSize != null && food.servingSizeUnit != null) {
                            Text(
                                "= ${(food.servingSize * servings).toInt()} ${food.servingSizeUnit}",
                                color = AppTheme.AccentPurple,
                                style = MaterialTheme.typography.bodySmall
                            )
                        }
                    }
                    
                    Text(
                        "+",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.headlineMedium,
                        modifier = Modifier
                            .clickable { onServingsChange(servings + 0.5) }
                            .padding(horizontal = 12.dp)
                    )
                }
                
                Spacer(Modifier.height(12.dp))
                
                if (isLoadingDetails) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
                        Spacer(Modifier.width(8.dp))
                        Text("Loading nutrients...", color = AppTheme.SubtleTextColor)
                    }
                } else if (foodDetails != null) {
                    val nutrients = foodDetails.foodNutrients.associate { it.nutrient.id to (it.amount ?: 0.0) }
                    
                    val nutrientIdMap = mapOf(
                        MonitorCardConfig.METRIC_CALORIES to 1008,
                        MonitorCardConfig.METRIC_PROTEIN to 1003,
                        MonitorCardConfig.METRIC_CARBS to 1005,
                        MonitorCardConfig.METRIC_FAT to 1004,
                        MonitorCardConfig.METRIC_FIBER to 1079,
                        MonitorCardConfig.METRIC_SUGAR to 2000,
                        MonitorCardConfig.METRIC_SODIUM to 1093,
                        MonitorCardConfig.METRIC_CAFFEINE to 1057,
                        MonitorCardConfig.METRIC_SATURATED_FAT to 1258,
                        MonitorCardConfig.METRIC_UNSATURATED_FAT to 1292,
                        MonitorCardConfig.METRIC_TRANS_FAT to 1257,
                        MonitorCardConfig.METRIC_CHOLESTEROL to 1253,
                        MonitorCardConfig.METRIC_POTASSIUM to 1092,
                        MonitorCardConfig.METRIC_CALCIUM to 1087,
                        MonitorCardConfig.METRIC_IRON to 1089,
                        MonitorCardConfig.METRIC_MAGNESIUM to 1090,
                        MonitorCardConfig.METRIC_ZINC to 1095,
                        MonitorCardConfig.METRIC_SELENIUM to 1103,
                        MonitorCardConfig.METRIC_PHOSPHORUS to 1091,
                        MonitorCardConfig.METRIC_COPPER to 1098,
                        MonitorCardConfig.METRIC_MANGANESE to 1101,
                        MonitorCardConfig.METRIC_VITAMIN_A to 1106,
                        MonitorCardConfig.METRIC_VITAMIN_C to 1162,
                        MonitorCardConfig.METRIC_VITAMIN_D to 1114,
                        MonitorCardConfig.METRIC_VITAMIN_E to 1109,
                        MonitorCardConfig.METRIC_VITAMIN_K to 1185,
                        MonitorCardConfig.METRIC_VITAMIN_B6 to 1175,
                        MonitorCardConfig.METRIC_VITAMIN_B12 to 1178,
                        MonitorCardConfig.METRIC_THIAMIN to 1165,
                        MonitorCardConfig.METRIC_RIBOFLAVIN to 1166,
                        MonitorCardConfig.METRIC_NIACIN to 1167,
                        MonitorCardConfig.METRIC_FOLATE to 1177,
                        MonitorCardConfig.METRIC_BIOTIN to 1176,
                        MonitorCardConfig.METRIC_PANTOTHENIC_ACID to 1170
                    )
                    
                    fun getValue(metric: String): Double? {
                        return nutrientIdMap[metric]?.let { nutrients[it] }?.times(servings)
                    }
                    
                    // Favorite metrics
                    Text(
                        "Nutrition (per serving × $servings)",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Spacer(Modifier.height(4.dp))
                    
                    monitorMetrics.forEach { metric ->
                        if (metric != MonitorCardConfig.METRIC_TYRAMINE_EXPOSURE) {
                            val value = getValue(metric)
                            val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                            val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                            NutrientRow(label, value, unit)
                        }
                    }

                    // Food risk rows (tyramine, alcohol, gluten)
                    Spacer(Modifier.height(4.dp))
                    if (isClassifyingRisks) {
                        Row(
                            modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text("Food Risks", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                CircularProgressIndicator(Modifier.size(12.dp), AppTheme.AccentPurple, strokeWidth = 1.5.dp)
                                Spacer(Modifier.width(4.dp))
                                Text("Classifying…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    } else {
                        DialogRiskRowWithIcon("Tyramine", tyramineRisk, RiskColors.TyramineHigh, RiskColors.TyramineMedium, RiskColors.TyramineLow) { c, s -> CheeseIcon(c, s) }
                        DialogRiskRowWithIcon("Alcohol", alcoholRisk, RiskColors.AlcoholHigh, RiskColors.AlcoholMedium, RiskColors.AlcoholLow) { c, s -> WineGlassIcon(c, s) }
                        DialogRiskRowWithIcon("Gluten", glutenRisk, RiskColors.GlutenHigh, RiskColors.GlutenMedium, RiskColors.GlutenLow) { c, s -> WheatIcon(c, s) }
                    }

                    // All Nutrients divider
                    Spacer(Modifier.height(8.dp))
                    androidx.compose.material3.HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(6.dp))
                    Text("All Nutrients", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    val shownMetrics = monitorMetrics.toSet()
                    MonitorCardConfig.ALL_NUTRITION_METRICS.forEach { metric ->
                        if (!MonitorCardConfig.isRiskMetric(metric) && metric !in shownMetrics) {
                            val value = getValue(metric)
                            val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                            val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                            NutrientRow(label, value, unit)
                        }
                    }
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text("Meal Type", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium)
                Spacer(Modifier.height(8.dp))
                
                ExposedDropdownMenuBox(expanded = expanded, onExpandedChange = { expanded = !expanded }) {
                    OutlinedTextField(
                        value = mealType.replaceFirstChar { it.uppercase() },
                        onValueChange = {},
                        readOnly = true,
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                            focusedTextColor = AppTheme.TitleColor,
                            unfocusedTextColor = AppTheme.TitleColor
                        ),
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    
                    ExposedDropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
                        mealTypes.forEach { type ->
                            DropdownMenuItem(
                                text = { Text(type.replaceFirstChar { it.uppercase() }) },
                                onClick = {
                                    onMealTypeChange(type)
                                    expanded = false
                                }
                            )
                        }
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onConfirm, enabled = !isAdding && !isLoadingDetails && foodDetails != null) {
                if (isAdding) {
                    CircularProgressIndicator(Modifier.size(16.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
                } else {
                    Text("Add", color = AppTheme.AccentPurple)
                }
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss, enabled = !isAdding) {
                Text("Cancel", color = AppTheme.SubtleTextColor)
            }
        },
        containerColor = Color(0xFF1E0A2E)
    )
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditFoodDialog(
    item: NutritionLogItem,
    mealType: String,
    onMealTypeChange: (String) -> Unit,
    onDismiss: () -> Unit,
    onSave: (Double) -> Unit,
    onDelete: () -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val mealTypes = listOf("breakfast", "lunch", "dinner", "snack")
    var servingsMultiplier by remember { mutableStateOf(1.0) }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Food", color = AppTheme.TitleColor) },
        text = {
            Column {
                Text(item.foodName, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium))
                
                item.calories?.let {
                    val adjustedCalories = (it * servingsMultiplier).toInt()
                    Text(
                        "$adjustedCalories calories${if (servingsMultiplier != 1.0) " (was ${it.toInt()})" else ""}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text("Adjust Servings", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium)
                Spacer(Modifier.height(8.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        "−",
                        color = if (servingsMultiplier > 0.5) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        style = MaterialTheme.typography.headlineMedium,
                        modifier = Modifier
                            .clickable(enabled = servingsMultiplier > 0.5) { servingsMultiplier = (servingsMultiplier - 0.5).coerceAtLeast(0.5) }
                            .padding(horizontal = 12.dp)
                    )
                    
                    Text(
                        "${if (servingsMultiplier == servingsMultiplier.toLong().toDouble()) servingsMultiplier.toLong() else String.format("%.1f", servingsMultiplier)}x",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                        modifier = Modifier.weight(1f),
                        textAlign = androidx.compose.ui.text.style.TextAlign.Center
                    )
                    
                    Text(
                        "+",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.headlineMedium,
                        modifier = Modifier.clickable { servingsMultiplier += 0.5 }.padding(horizontal = 12.dp)
                    )
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text("Meal Type", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium)
                Spacer(Modifier.height(8.dp))
                
                ExposedDropdownMenuBox(expanded = expanded, onExpandedChange = { expanded = !expanded }) {
                    OutlinedTextField(
                        value = mealType.replaceFirstChar { it.uppercase() },
                        onValueChange = {},
                        readOnly = true,
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                            focusedTextColor = AppTheme.TitleColor,
                            unfocusedTextColor = AppTheme.TitleColor
                        ),
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    
                    ExposedDropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
                        mealTypes.forEach { type ->
                            DropdownMenuItem(
                                text = { Text(type.replaceFirstChar { it.uppercase() }) },
                                onClick = {
                                    onMealTypeChange(type)
                                    expanded = false
                                }
                            )
                        }
                    }
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text(
                    "Delete this entry",
                    color = Color(0xFFE57373),
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.clickable { onDelete() }.padding(vertical = 8.dp)
                )
            }
        },
        confirmButton = {
            TextButton(onClick = { onSave(servingsMultiplier) }) {
                Text("Save", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = AppTheme.SubtleTextColor)
            }
        },
        containerColor = Color(0xFF1E0A2E)
    )
}

@Composable
private fun DialogRiskRowWithIcon(
    label: String,
    risk: String?,
    highColor: Color,
    mediumColor: Color,
    lowColor: Color,
    icon: @Composable (Color, Dp) -> Unit
) {
    val level = risk ?: "none"
    val display = when (level) { "high" -> "High"; "medium" -> "Medium"; "low" -> "Low"; else -> "None" }
    val color = when (level) {
        "high" -> highColor; "medium" -> mediumColor; "low" -> lowColor
        else -> AppTheme.SubtleTextColor
    }
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 3.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Row(verticalAlignment = Alignment.CenterVertically) {
            icon(color, 14.dp)
            Spacer(Modifier.width(6.dp))
            Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
        }
        Row(verticalAlignment = Alignment.Bottom) {
            Text(display, color = color, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold))
            if (level != "none") {
                Spacer(Modifier.width(4.dp))
                RiskBar(color, level, maxHeight = 14.dp)
            }
        }
    }
}

title: NutritionGraph.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// Metric colors
private val metricColors = mapOf(
    MonitorCardConfig.METRIC_CALORIES to Color(0xFFFFB74D),
    MonitorCardConfig.METRIC_PROTEIN to Color(0xFF81C784),
    MonitorCardConfig.METRIC_CARBS to Color(0xFF64B5F6),
    MonitorCardConfig.METRIC_FAT to Color(0xFFE57373),
    MonitorCardConfig.METRIC_FIBER to Color(0xFFBA68C8),
    MonitorCardConfig.METRIC_SUGAR to Color(0xFFFF8A65),
    MonitorCardConfig.METRIC_SODIUM to Color(0xFF4DD0E1),
    MonitorCardConfig.METRIC_CAFFEINE to Color(0xFFAED581),
    MonitorCardConfig.METRIC_CHOLESTEROL to Color(0xFFFFD54F),
    MonitorCardConfig.METRIC_SATURATED_FAT to Color(0xFFEF5350),
    MonitorCardConfig.METRIC_UNSATURATED_FAT to Color(0xFF66BB6A),
    MonitorCardConfig.METRIC_TRANS_FAT to Color(0xFFEC407A),
    MonitorCardConfig.METRIC_POTASSIUM to Color(0xFF26C6DA),
    MonitorCardConfig.METRIC_CALCIUM to Color(0xFFAB47BC),
    MonitorCardConfig.METRIC_IRON to Color(0xFF8D6E63),
    MonitorCardConfig.METRIC_MAGNESIUM to Color(0xFF5C6BC0),
    MonitorCardConfig.METRIC_ZINC to Color(0xFF78909C),
    MonitorCardConfig.METRIC_VITAMIN_A to Color(0xFFFFA726),
    MonitorCardConfig.METRIC_VITAMIN_C to Color(0xFFFFEE58),
    MonitorCardConfig.METRIC_VITAMIN_D to Color(0xFFFFCA28),
    MonitorCardConfig.METRIC_VITAMIN_E to Color(0xFF9CCC65),
    MonitorCardConfig.METRIC_VITAMIN_K to Color(0xFF26A69A),
    MonitorCardConfig.METRIC_VITAMIN_B6 to Color(0xFF7E57C2),
    MonitorCardConfig.METRIC_VITAMIN_B12 to Color(0xFFEC407A),
    MonitorCardConfig.METRIC_THIAMIN to Color(0xFF42A5F5),
    MonitorCardConfig.METRIC_RIBOFLAVIN to Color(0xFF66BB6A),
    MonitorCardConfig.METRIC_NIACIN to Color(0xFFFFCA28),
    MonitorCardConfig.METRIC_FOLATE to Color(0xFF26C6DA),
    MonitorCardConfig.METRIC_BIOTIN to Color(0xFFAB47BC),
    MonitorCardConfig.METRIC_PANTOTHENIC_ACID to Color(0xFF8D6E63),
    MonitorCardConfig.METRIC_PHOSPHORUS to Color(0xFF5C6BC0),
    MonitorCardConfig.METRIC_SELENIUM to Color(0xFF78909C),
    MonitorCardConfig.METRIC_COPPER to Color(0xFFD4E157),
    MonitorCardConfig.METRIC_MANGANESE to Color(0xFF29B6F6)
)

// Get metric value from day data
private fun getDayValue(day: NutritionDayData, metric: String): Float {
    return when (metric) {
        MonitorCardConfig.METRIC_CALORIES -> day.calories.toFloat()
        MonitorCardConfig.METRIC_PROTEIN -> day.protein.toFloat()
        MonitorCardConfig.METRIC_CARBS -> day.carbs.toFloat()
        MonitorCardConfig.METRIC_FAT -> day.fat.toFloat()
        MonitorCardConfig.METRIC_FIBER -> day.fiber.toFloat()
        MonitorCardConfig.METRIC_SUGAR -> day.sugar.toFloat()
        MonitorCardConfig.METRIC_SODIUM -> day.sodium.toFloat()
        MonitorCardConfig.METRIC_CAFFEINE -> day.caffeine.toFloat()
        else -> 0f
    }
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun NutritionHistoryGraph(
    days: Int = 14,
    endDate: java.time.LocalDate = java.time.LocalDate.now(),
    onClick: (() -> Unit)? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val searchService = remember { USDAFoodSearchService(context) }
    
    var historyData by remember { mutableStateOf<List<NutritionDayData>>(emptyList()) }
    var allTimeMin by remember { mutableStateOf<Map<String, Float>>(emptyMap()) }
    var allTimeMax by remember { mutableStateOf<Map<String, Float>>(emptyMap()) }
    var isLoading by remember { mutableStateOf(true) }
    var selectedMetrics by remember { mutableStateOf(setOf(MonitorCardConfig.METRIC_CALORIES)) }
    var migraineDates by remember { mutableStateOf<Set<String>>(emptySet()) }
    
    // Load history data
    LaunchedEffect(days, endDate) {
        scope.launch {
            val result = searchService.getNutritionHistory(days, endDate)
            historyData = result.days
            allTimeMin = result.allTimeMin
            allTimeMax = result.allTimeMax
            migraineDates = MigraineOverlayHelper.fetchMigraineDates(context, days, endDate)
            isLoading = false
        }
    }
    
    val isNormalized = selectedMetrics.size >= 2
    val daysWithLogs = historyData.filter { it.calories > 0 }
    
    // Helper to get metric key for allTime lookups
    fun metricKey(m: String) = when (m) {
        MonitorCardConfig.METRIC_CALORIES -> "calories"
        MonitorCardConfig.METRIC_PROTEIN -> "protein"
        MonitorCardConfig.METRIC_CARBS -> "carbs"
        MonitorCardConfig.METRIC_FAT -> "fat"
        MonitorCardConfig.METRIC_FIBER -> "fiber"
        MonitorCardConfig.METRIC_SUGAR -> "sugar"
        MonitorCardConfig.METRIC_SODIUM -> "sodium"
        MonitorCardConfig.METRIC_CAFFEINE -> "caffeine"
        else -> "calories"
    }
    
    BaseCard(modifier = if (onClick != null) Modifier.clickable { onClick() } else Modifier) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                "$days-Day History",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            if (onClick != null) {
                Text("View Full →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
            }
        }
        
        Spacer(Modifier.height(8.dp))
        
        if (isLoading) {
            Row(
                modifier = Modifier.fillMaxWidth().height(150.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
            }
        } else if (historyData.isEmpty()) {
            Text(
                "No data available",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else if (selectedMetrics.isEmpty()) {
            Text(
                "Select a metric below",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else {
            // Legend
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                selectedMetrics.forEach { metric ->
                    val color = metricColors[metric] ?: AppTheme.AccentPurple
                    val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                    val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                    val values = daysWithLogs.map { getDayValue(it, metric) }
                    
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Canvas(Modifier.size(8.dp)) { drawCircle(color) }
                        Spacer(Modifier.width(4.dp))
                        if (isNormalized) {
                            val key = metricKey(metric)
                            val minVal = allTimeMin[key] ?: 0f
                            val maxVal = allTimeMax[key] ?: 1f
                            Text("$label [${minVal.toInt()}-${maxVal.toInt()}$unit]", color = color, style = MaterialTheme.typography.labelSmall)
                        } else {
                            val avg = values.average().toInt()
                            Text("$label (avg: $avg$unit)", color = color, style = MaterialTheme.typography.labelSmall)
                        }
                    }
                }
            }
            
            if (isNormalized) {
                Spacer(Modifier.height(4.dp))
                Text("⚠️ Normalized 0-1 scale • Dotted = last $days days avg", color = Color(0xFFFFB74D), style = MaterialTheme.typography.labelSmall)
            } else if (daysWithLogs.isNotEmpty()) {
                Spacer(Modifier.height(4.dp))
                Text("Dotted line = last $days days average", color = AppTheme.SubtleTextColor.copy(alpha = 0.7f), style = MaterialTheme.typography.labelSmall)
            }

            if (migraineDates.isNotEmpty()) {
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Canvas(Modifier.size(8.dp)) { drawRect(Color(0xFFE57373).copy(alpha = 0.35f)) }
                    Spacer(Modifier.width(4.dp))
                    Text("Red bands = migraine days", color = Color(0xFFE57373), style = MaterialTheme.typography.labelSmall)
                }
            }
            
            Spacer(Modifier.height(8.dp))
            
            if (daysWithLogs.isEmpty()) {
                Text(
                    "No logged days in this period",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(vertical = 16.dp)
                )
            } else {
                val yAxisWidth = 50.dp
                
                // Y-axis values depend on normalization
                val yTop: String
                val yMid: String
                val yBot: String
                
                if (isNormalized) {
                    yTop = "1.0"
                    yMid = "0.5"
                    yBot = "0.0"
                } else {
                    val metric = selectedMetrics.first()
                    val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                    val values = daysWithLogs.map { getDayValue(it, metric) }
                    val max = values.maxOrNull() ?: 1f
                    val min = values.minOrNull() ?: 0f
                    yTop = "${max.toInt()}$unit"
                    yMid = "${((max + min) / 2).toInt()}$unit"
                    yBot = "${min.toInt()}$unit"
                }
                
                Row(modifier = Modifier.fillMaxWidth().height(150.dp)) {
                    // Y-axis labels
                    Column(
                        modifier = Modifier.width(yAxisWidth).fillMaxHeight(),
                        verticalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(yTop, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(yMid, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(yBot, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                    
                    // Graph canvas
                    Canvas(modifier = Modifier.weight(1f).fillMaxHeight()) {
                        val padding = 8.dp.toPx()
                        val graphWidth = size.width - padding * 2
                        val graphHeight = size.height - padding * 2
                        val dashWidth = 6.dp.toPx()
                        val gapWidth = 4.dp.toPx()

                        // Draw migraine bands (behind everything)
                        with(MigraineOverlayHelper) {
                            drawMigraineBands(
                                dateList = historyData.map { it.date },
                                migraineDates = migraineDates,
                                padding = padding,
                                graphWidth = graphWidth,
                                graphHeight = graphHeight
                            )
                        }
                        
                        selectedMetrics.forEach { metric ->
                            val color = metricColors[metric] ?: Color.White
                            
                            // Get indexed values for X positioning
                            val indexedValues = historyData.mapIndexedNotNull { i, day ->
                                if (day.calories > 0) i to getDayValue(day, metric) else null
                            }
                            
                            if (indexedValues.isEmpty()) return@forEach
                            
                            val values = indexedValues.map { it.second }
                            
                            // For single metric: use window min/max (actual values)
                            // For multi metric: use all-time min/max (normalized)
                            val minVal: Float
                            val maxVal: Float
                            if (isNormalized) {
                                val key = metricKey(metric)
                                minVal = allTimeMin[key] ?: 0f
                                maxVal = (allTimeMax[key] ?: 1f).coerceAtLeast(minVal + 1f)
                            } else {
                                minVal = values.minOrNull() ?: 0f
                                maxVal = (values.maxOrNull() ?: 1f).coerceAtLeast(minVal + 1f)
                            }
                            val range = maxVal - minVal
                            
                            // Normalize values to 0-1 scale for plotting
                            val plotPoints = indexedValues.map { (idx, value) ->
                                idx to ((value - minVal) / range).coerceIn(0f, 1f)
                            }
                            
                            // Draw dotted average line (always show)
                            if (plotPoints.isNotEmpty()) {
                                val avgNormalized = plotPoints.map { it.second }.average().toFloat()
                                val avgY = padding + graphHeight - (avgNormalized * graphHeight)
                                
                                var x = padding
                                while (x < size.width - padding) {
                                    drawLine(
                                        color.copy(alpha = 0.5f),
                                        Offset(x, avgY),
                                        Offset((x + dashWidth).coerceAtMost(size.width - padding), avgY),
                                        strokeWidth = 1.5.dp.toPx()
                                    )
                                    x += dashWidth + gapWidth
                                }
                            }
                            
                            // Draw line
                            if (plotPoints.size > 1) {
                                val path = Path()
                                plotPoints.forEachIndexed { i, (dayIdx, normalizedValue) ->
                                    val x = padding + (dayIdx.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                    val y = padding + graphHeight - (normalizedValue * graphHeight)
                                    if (i == 0) path.moveTo(x, y) else path.lineTo(x, y)
                                }
                                drawPath(path, color, style = Stroke(2.dp.toPx(), cap = StrokeCap.Round, join = StrokeJoin.Round))
                            }
                            
                            // Draw dots
                            plotPoints.forEach { (dayIdx, normalizedValue) ->
                                val x = padding + (dayIdx.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                val y = padding + graphHeight - (normalizedValue * graphHeight)
                                drawCircle(color, 4.dp.toPx(), Offset(x, y))
                            }
                        }
                    }
                }
                
                // Date labels
                Spacer(Modifier.height(4.dp))
                Row(
                    modifier = Modifier.fillMaxWidth().padding(start = yAxisWidth),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    val fmt = DateTimeFormatter.ofPattern("MMM d")
                    Text(LocalDate.parse(historyData.first().date).format(fmt), color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    Text(LocalDate.parse(historyData.last().date).format(fmt), color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
        }
        
        Spacer(Modifier.height(12.dp))
        
        // Metric selector - multi-select
        Text(
            "Select Metrics${if (selectedMetrics.size > 1) " (${selectedMetrics.size} selected)" else ""}",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )
        Spacer(Modifier.height(8.dp))
        
        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(6.dp),
            verticalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            MonitorCardConfig.ALL_NUTRITION_METRICS.forEach { metric ->
                val isSelected = metric in selectedMetrics
                val chipColor = metricColors[metric] ?: AppTheme.AccentPurple
                val chipLabel = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                
                FilterChip(
                    selected = isSelected,
                    onClick = {
                        selectedMetrics = if (isSelected) {
                            selectedMetrics - metric
                        } else {
                            selectedMetrics + metric
                        }
                    },
                    label = { Text(chipLabel, style = MaterialTheme.typography.labelSmall) },
                    colors = FilterChipDefaults.filterChipColors(
                        selectedContainerColor = chipColor.copy(alpha = 0.3f),
                        selectedLabelColor = chipColor,
                        containerColor = AppTheme.BaseCardContainer,
                        labelColor = AppTheme.SubtleTextColor
                    ),
                    border = FilterChipDefaults.filterChipBorder(
                        borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        selectedBorderColor = chipColor,
                        enabled = true,
                        selected = isSelected
                    )
                )
            }
        }
    }
}

title: NutritionHistoryScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.ChevronLeft
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.time.format.DateTimeFormatter

@Composable
fun NutritionHistoryScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scrollState = rememberSaveable(saver = ScrollState.Saver) { ScrollState(0) }
    val scope = rememberCoroutineScope()
    
    // Use rememberSaveable for date to survive config changes
    var selectedDateStr by rememberSaveable { mutableStateOf(LocalDate.now().toString()) }
    val selectedDate = LocalDate.parse(selectedDateStr)
    
    var items by remember { mutableStateOf<List<NutritionLogItem>>(emptyList()) }
    var isLoading by remember { mutableStateOf(true) }
    
    // Edit dialog state
    var editingItem by remember { mutableStateOf<NutritionLogItem?>(null) }
    var editMealType by remember { mutableStateOf("lunch") }
    
    val searchService = remember { USDAFoodSearchService(context) }
    val nutritionConfig = remember { MonitorCardConfigStore.load(context) }
    
    val dateFormatter = DateTimeFormatter.ofPattern("EEEE, MMM d")
    val today = LocalDate.now()
    
    fun loadItems() {
        scope.launch {
            isLoading = true
            items = searchService.getNutritionItemsForDate(selectedDate.toString())
            isLoading = false
        }
    }
    
    // Load items when date changes - but don't reset scroll
    LaunchedEffect(selectedDateStr) {
        loadItems()
    }
    
    // Edit dialog
    if (editingItem != null) {
        HistoryEditFoodDialog(
            item = editingItem!!,
            mealType = editMealType,
            onMealTypeChange = { editMealType = it },
            onDismiss = { editingItem = null },
            onSave = { servingsMultiplier ->
                scope.launch {
                    val success = searchService.updateNutritionItem(
                        id = editingItem!!.id,
                        mealType = editMealType,
                        servingsMultiplier = if (servingsMultiplier != 1.0) servingsMultiplier else null
                    )
                    if (success) {
                        editingItem = null
                        loadItems()
                    }
                }
            },
            onDelete = {
                scope.launch {
                    searchService.deleteNutritionItem(editingItem!!.id)
                    editingItem = null
                    loadItems()
                }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
            // Back navigation
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = onBack) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }
            
            // Header
            HeroCard {
                Text(
                    "Nutrition History",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    "View and manage your food log",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
            
            // Date navigation
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(
                        onClick = { selectedDateStr = selectedDate.minusDays(1).toString() }
                    ) {
                        Icon(
                            Icons.Default.ChevronLeft,
                            contentDescription = "Previous day",
                            tint = AppTheme.AccentPurple
                        )
                    }
                    
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            when {
                                selectedDate == today -> "Today"
                                selectedDate == today.minusDays(1) -> "Yesterday"
                                else -> selectedDate.format(dateFormatter)
                            },
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        if (selectedDate != today && selectedDate != today.minusDays(1)) {
                            Text(
                                selectedDate.format(DateTimeFormatter.ofPattern("yyyy")),
                                color = AppTheme.SubtleTextColor,
                                style = MaterialTheme.typography.bodySmall
                            )
                        }
                    }
                    
                    IconButton(
                        onClick = { selectedDateStr = selectedDate.plusDays(1).toString() },
                        enabled = selectedDate < today
                    ) {
                        Icon(
                            Icons.Default.ChevronRight,
                            contentDescription = "Next day",
                            tint = if (selectedDate < today) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f)
                        )
                    }
                }
            }
            
            // Items for selected date
            BaseCard {
                if (isLoading) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 16.dp),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(24.dp),
                            color = AppTheme.AccentPurple,
                            strokeWidth = 2.dp
                        )
                    }
                } else if (items.isEmpty()) {
                    Text(
                        "No food logged for this day",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 16.dp)
                    )
                } else {
                    val grouped = items.groupBy { it.mealType }
                    val mealOrder = listOf("breakfast", "lunch", "dinner", "snack", "unknown")
                    val selectedMetrics = nutritionConfig.nutritionDisplayMetrics.take(3)

                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                    // Top 3 selected metrics
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceEvenly
                    ) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val total = items.sumOf { it.metricValue(metric) ?: 0.0 }
                            val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                            val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                            val formatted = if (total >= 10) "${total.toInt()}$unit" else String.format("%.1f$unit", total)
                            HistorySummaryValue(formatted, label, slotColors.getOrElse(index) { slotColors.last() })
                        }
                    }
                    
                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(4.dp))
                    
                    // Food items grouped by meal
                    mealOrder.forEach { mealType ->
                        val mealItems = grouped[mealType] ?: return@forEach
                        
                        Text(
                            mealType.replaceFirstChar { it.uppercase() },
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        
                        Spacer(Modifier.height(4.dp))
                        
                        mealItems.forEach { item ->
                            HistoryLogItem(
                                item = item,
                                onEdit = if (item.source == "manual_usda") {
                                    {
                                        editingItem = item
                                        editMealType = item.mealType
                                    }
                                } else null,
                                onDelete = if (item.source == "manual_usda") {
                                    {
                                        scope.launch {
                                            searchService.deleteNutritionItem(item.id)
                                            loadItems()
                                        }
                                    }
                                } else null
                            )
                        }
                        
                        Spacer(Modifier.height(12.dp))
                    }

                    // All metrics breakdown
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text("All Nutrients", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    MonitorCardConfig.ALL_NUTRITION_METRICS.forEach { metric ->
                        val isRisk = MonitorCardConfig.isRiskMetric(metric)
                        val total = if (isRisk) {
                            items.maxOfOrNull { it.metricValue(metric) ?: 0.0 } ?: 0.0
                        } else {
                            items.sumOf { it.metricValue(metric) ?: 0.0 }
                        }
                        val label = MonitorCardConfig.NUTRITION_METRIC_LABELS[metric] ?: metric
                        val unit = MonitorCardConfig.NUTRITION_METRIC_UNITS[metric] ?: ""
                        if (isRisk) {
                            val (levelText, valueColor) = RiskColors.formatRiskLevel(metric, total.toInt())
                            val level = when (total.toInt()) { 3 -> "high"; 2 -> "medium"; 1 -> "low"; else -> "none" }
                            Row(
                                modifier = Modifier.fillMaxWidth().padding(vertical = 3.dp),
                                horizontalArrangement = Arrangement.SpaceBetween,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    when (metric) {
                                        MonitorCardConfig.METRIC_TYRAMINE_EXPOSURE -> CheeseIcon(valueColor, 12.dp)
                                        MonitorCardConfig.METRIC_ALCOHOL_EXPOSURE -> WineGlassIcon(valueColor, 12.dp)
                                        MonitorCardConfig.METRIC_GLUTEN_EXPOSURE -> WheatIcon(valueColor, 12.dp)
                                    }
                                    Spacer(Modifier.width(5.dp))
                                    Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                                }
                                Row(verticalAlignment = Alignment.Bottom) {
                                    Text(levelText, color = valueColor, style = MaterialTheme.typography.bodySmall)
                                    if (level != "none") {
                                        Spacer(Modifier.width(4.dp))
                                        RiskBar(valueColor, level, maxHeight = 12.dp)
                                    }
                                }
                            }
                        } else {
                            val formatted = if (total > 0) {
                                if (total >= 10) "${total.toInt()} $unit" else "${String.format("%.1f", total)} $unit"
                            } else "—"
                            Row(
                                modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                                Text(formatted, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    }
                }
            }
        }
    }

@Composable
private fun HistoryLogItem(
    item: NutritionLogItem,
    onEdit: (() -> Unit)?,
    onDelete: (() -> Unit)?
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(
                item.foodName,
                color = AppTheme.BodyTextColor,
                style = MaterialTheme.typography.bodyMedium,
                maxLines = 2
            )
            Row {
                item.calories?.let {
                    Text(
                        "${it.toInt()} cal",
                        color = Color(0xFFFFB74D),
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                if (item.source == "manual_usda") {
                    Text(
                        " • Manual",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.bodySmall
                    )
                } else if (item.source.isNotBlank()) {
                    Text(
                        " • ${item.source}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
        }
        
        if (onEdit != null) {
            Text(
                "✎",
                color = AppTheme.AccentPurple,
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .clickable { onEdit() }
                    .padding(8.dp)
            )
        }
        
        if (onDelete != null) {
            Text(
                "✕",
                color = Color(0xFFE57373),
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .clickable { onDelete() }
                    .padding(8.dp)
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun HistoryEditFoodDialog(
    item: NutritionLogItem,
    mealType: String,
    onMealTypeChange: (String) -> Unit,
    onDismiss: () -> Unit,
    onSave: (Double) -> Unit,
    onDelete: () -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val mealTypes = listOf("breakfast", "lunch", "dinner", "snack")
    var servingsMultiplier by remember { mutableStateOf(1.0) }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Edit Food", color = AppTheme.TitleColor) },
        text = {
            Column {
                Text(
                    item.foodName,
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
                )
                
                item.calories?.let {
                    val adjustedCalories = (it * servingsMultiplier).toInt()
                    Text(
                        "$adjustedCalories calories${if (servingsMultiplier != 1.0) " (was ${it.toInt()})" else ""}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text("Adjust Servings", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium)
                Spacer(Modifier.height(8.dp))
                
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        "−",
                        color = if (servingsMultiplier > 0.5) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        style = MaterialTheme.typography.headlineMedium,
                        modifier = Modifier
                            .clickable(enabled = servingsMultiplier > 0.5) { servingsMultiplier = (servingsMultiplier - 0.5).coerceAtLeast(0.5) }
                            .padding(horizontal = 12.dp)
                    )
                    
                    Text(
                        "${if (servingsMultiplier == servingsMultiplier.toLong().toDouble()) servingsMultiplier.toLong() else String.format("%.1f", servingsMultiplier)}x",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                        modifier = Modifier.weight(1f),
                        textAlign = TextAlign.Center
                    )
                    
                    Text(
                        "+",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.headlineMedium,
                        modifier = Modifier
                            .clickable { servingsMultiplier += 0.5 }
                            .padding(horizontal = 12.dp)
                    )
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text("Meal Type", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium)
                Spacer(Modifier.height(8.dp))
                
                ExposedDropdownMenuBox(expanded = expanded, onExpandedChange = { expanded = !expanded }) {
                    OutlinedTextField(
                        value = mealType.replaceFirstChar { it.uppercase() },
                        onValueChange = {},
                        readOnly = true,
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                            focusedTextColor = AppTheme.TitleColor,
                            unfocusedTextColor = AppTheme.TitleColor
                        ),
                        modifier = Modifier.fillMaxWidth().menuAnchor()
                    )
                    
                    ExposedDropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
                        mealTypes.forEach { type ->
                            DropdownMenuItem(
                                text = { Text(type.replaceFirstChar { it.uppercase() }) },
                                onClick = { onMealTypeChange(type); expanded = false }
                            )
                        }
                    }
                }
                
                Spacer(Modifier.height(16.dp))
                
                Text(
                    "Delete this entry",
                    color = Color(0xFFE57373),
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.clickable { onDelete() }.padding(vertical = 8.dp)
                )
            }
        },
        confirmButton = {
            TextButton(onClick = { onSave(servingsMultiplier) }) {
                Text("Save", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = AppTheme.SubtleTextColor)
            }
        },
        containerColor = Color(0xFF1E0A2E)
    )
}

@Composable
private fun HistorySummaryValue(value: String, label: String, color: Color = AppTheme.TitleColor) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        Text(value, color = color, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
        Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
    }
}




title: NutritionOutboxEntity.kt
text:
package com.migraineme

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "nutrition_outbox")
data class NutritionOutboxEntity(
    @PrimaryKey val healthConnectId: String,
    val operation: String, // "UPSERT" or "DELETE"
    val createdAtEpochMs: Long,
    val retryCount: Int = 0
)

title: NutritionOutboxPushWorker.kt
text:
package com.migraineme

import android.content.Context
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.NutritionRecord
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneOffset

/**
 * Worker that pushes nutrition data from local outbox to Supabase
 *
 * NOW WITH USDA ENRICHMENT:
 * - Checks if nutrition data is incomplete (missing micronutrients)
 * - Enriches from USDA FoodData Central API before uploading
 * - Marks records as enriched=true
 */
class NutritionOutboxPushWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    companion object {
        private val REQUIRED_PERMISSIONS = setOf(
            HealthPermission.getReadPermission(NutritionRecord::class)
        )
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            val accessToken = SessionStore.getValidAccessToken(applicationContext)
                ?: return@withContext Result.retry()

            val hc = HealthConnectClient.getOrCreate(applicationContext)
            val granted = hc.permissionController.getGrantedPermissions()
            if (!REQUIRED_PERMISSIONS.all { it in granted }) {
                return@withContext Result.failure()
            }

            val db = NutritionSyncDatabase.get(applicationContext)
            val dao = db.dao()

            val batch = dao.getOutboxBatch(limit = 200)
            if (batch.isEmpty()) {
                dao.markPushRun(System.currentTimeMillis())
                return@withContext Result.success()
            }

            val service = SupabaseNutritionService(applicationContext)
            val enrichmentService = USDAEnrichmentService() // USDA enrichment
            val riskClassifier = FoodRiskClassifierService() // Food risk classification

            val upserts = batch.filter { it.operation == "UPSERT" }
            val deletes = batch.filter { it.operation == "DELETE" }

            val succeededIds = mutableListOf<String>()
            val failedIds = mutableListOf<String>()

            // 1) Push UPSERTs with USDA enrichment + tyramine classification
            for (item in upserts) {
                try {
                    val record = hc.readRecord(NutritionRecord::class, item.healthConnectId).record
                    val date: LocalDate = record.startTime.atZone(ZoneOffset.UTC).toLocalDate()
                    val nutrition = mapToNutritionData(record, date)

                    // Step 1: Enrich nutrition data if needed
                    val enriched = if (enrichmentService.needsEnrichment(nutrition)) {
                        android.util.Log.d("NutritionOutboxPush", "Enriching: ${nutrition.foodName}")
                        enrichmentService.enrichNutrition(nutrition)
                    } else {
                        android.util.Log.d("NutritionOutboxPush", "No enrichment needed: ${nutrition.foodName}")
                        nutrition.copy(enriched = true)
                    }

                    // Step 2: Classify food risks (tyramine, alcohol, gluten)
                    val risks = if (!enriched.foodName.isNullOrBlank()) {
                        riskClassifier.classify(accessToken, enriched.foodName)
                    } else FoodRiskResult()
                    val finalNutrition = enriched.copy(
                        tyramineExposure = risks.tyramine,
                        alcoholExposure = risks.alcohol,
                        glutenExposure = risks.gluten
                    )

                    service.uploadNutritionRecord(accessToken, finalNutrition, item.healthConnectId)
                    succeededIds.add(item.healthConnectId)
                } catch (e: Exception) {
                    failedIds.add(item.healthConnectId)
                    android.util.Log.e("NutritionOutboxPush", "Failed UPSERT id=${item.healthConnectId}: ${e.message}", e)
                }
            }

            // 2) Push DELETEs (batch)
            if (deletes.isNotEmpty()) {
                val idsToDelete = deletes.map { it.healthConnectId }
                try {
                    service.deleteNutritionRecordsByHealthConnectIds(accessToken, idsToDelete)
                    succeededIds.addAll(idsToDelete)
                } catch (e: Exception) {
                    failedIds.addAll(idsToDelete)
                    android.util.Log.e("NutritionOutboxPush", "Failed DELETE batch: ${e.message}", e)
                }
            }

            if (succeededIds.isNotEmpty()) {
                dao.deleteOutboxByIds(succeededIds.distinct())
            }
            if (failedIds.isNotEmpty()) {
                dao.incrementRetry(failedIds.distinct())
            }

            dao.markPushRun(System.currentTimeMillis())

            if (succeededIds.isEmpty() && failedIds.isNotEmpty()) {
                return@withContext Result.retry()
            }

            Result.success()
        } catch (e: Exception) {
            android.util.Log.e("NutritionOutboxPush", "Push worker failed: ${e.message}", e)
            Result.retry()
        }
    }

    private fun mapToNutritionData(record: NutritionRecord, date: LocalDate): NutritionData {
        return NutritionData(
            date = date,
            timestamp = record.startTime,
            endTimestamp = record.endTime,

            foodName = record.name,
            mealType = mapMealType(record.mealType),

            calories = record.energy?.inKilocalories,

            protein = record.protein?.inGrams,
            totalCarbohydrate = record.totalCarbohydrate?.inGrams,
            sugar = record.sugar?.inGrams,
            dietaryFiber = record.dietaryFiber?.inGrams,
            totalFat = record.totalFat?.inGrams,
            saturatedFat = record.saturatedFat?.inGrams,
            unsaturatedFat = record.unsaturatedFat?.inGrams,
            monounsaturatedFat = record.monounsaturatedFat?.inGrams,
            polyunsaturatedFat = record.polyunsaturatedFat?.inGrams,
            transFat = record.transFat?.inGrams,
            cholesterol = record.cholesterol?.inGrams?.times(1000),

            calcium = record.calcium?.inGrams?.times(1000),
            chloride = record.chloride?.inGrams?.times(1000),
            chromium = record.chromium?.inGrams?.times(1_000_000),
            copper = record.copper?.inGrams?.times(1000),
            iodine = record.iodine?.inGrams?.times(1_000_000),
            iron = record.iron?.inGrams?.times(1000),
            magnesium = record.magnesium?.inGrams?.times(1000),
            manganese = record.manganese?.inGrams?.times(1000),
            molybdenum = record.molybdenum?.inGrams?.times(1_000_000),
            phosphorus = record.phosphorus?.inGrams?.times(1000),
            potassium = record.potassium?.inGrams?.times(1000),
            selenium = record.selenium?.inGrams?.times(1_000_000),
            sodium = record.sodium?.inGrams?.times(1000),
            zinc = record.zinc?.inGrams?.times(1000),

            vitaminA = record.vitaminA?.inGrams?.times(1_000_000),
            vitaminB6 = record.vitaminB6?.inGrams?.times(1000),
            vitaminB12 = record.vitaminB12?.inGrams?.times(1_000_000),
            vitaminC = record.vitaminC?.inGrams?.times(1000),
            vitaminD = record.vitaminD?.inGrams?.times(1_000_000),
            vitaminE = record.vitaminE?.inGrams?.times(1000),
            vitaminK = record.vitaminK?.inGrams?.times(1_000_000),
            biotin = record.biotin?.inGrams?.times(1_000_000),
            folate = record.folate?.inGrams?.times(1_000_000),
            folicAcid = record.folicAcid?.inGrams?.times(1_000_000),
            niacin = record.niacin?.inGrams?.times(1000),
            pantothenicAcid = record.pantothenicAcid?.inGrams?.times(1000),
            riboflavin = record.riboflavin?.inGrams?.times(1000),
            thiamin = record.thiamin?.inGrams?.times(1000),

            caffeine = record.caffeine?.inGrams?.times(1000),

            tyramineExposure = null, // Set by FoodRiskClassifierService after enrichment
            alcoholExposure = null,
            glutenExposure = null,

            source = "health_connect",
            enriched = false // Will be set to true after enrichment
        )
    }

    private fun mapMealType(type: Int?): String {
        return when (type) {
            1 -> "breakfast"
            2 -> "lunch"
            3 -> "dinner"
            4 -> "snack"
            else -> "unknown"
        }
    }
}


title: NutritionPushHelper.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

/**
 * Helper to check and manually trigger the nutrition push worker
 */
object NutritionPushHelper {
    
    private const val TAG = "NutritionPushHelper"
    
    /**
     * Manually trigger the push worker to upload outbox to Supabase
     */
    suspend fun triggerPushNow(context: Context) = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "Manually triggering nutrition push worker...")
            
            // Check what's in outbox first
            val db = NutritionSyncDatabase.get(context)
            val dao = db.dao()
            val outbox = dao.getOutboxBatch(1000)
            
            Log.d(TAG, "Outbox has ${outbox.size} items before push")
            outbox.take(5).forEach { item ->
                Log.d(TAG, "  - ${item.operation}: ${item.healthConnectId.take(8)}...")
            }
            
            // Trigger immediate push
            val work = OneTimeWorkRequestBuilder<NutritionOutboxPushWorker>()
                .addTag("manual_nutrition_push")
                .build()
            
            WorkManager.getInstance(context).enqueue(work)
            
            Log.d(TAG, "Push worker enqueued. Check logs for 'NutritionOutboxPush' tag")
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to trigger push", e)
            throw e
        }
    }
    
    /**
     * Check if there's a valid Supabase access token
     */
    suspend fun checkSupabaseToken(context: Context): Boolean = withContext(Dispatchers.IO) {
        val token = SessionStore.getValidAccessToken(context)
        val hasToken = !token.isNullOrBlank()
        
        Log.d(TAG, "Supabase token present: $hasToken")
        if (hasToken) {
            Log.d(TAG, "Token preview: ${token?.take(20)}...")
        } else {
            Log.e(TAG, "NO SUPABASE TOKEN! User may not be logged in.")
        }
        
        hasToken
    }
    
    /**
     * Get detailed push worker status
     */
    suspend fun getDetailedPushStatus(context: Context): PushStatus = withContext(Dispatchers.IO) {
        val db = NutritionSyncDatabase.get(context)
        val dao = db.dao()
        
        val state = dao.getSyncState()
        val outbox = dao.getOutboxBatch(1000)
        val hasToken = checkSupabaseToken(context)
        
        PushStatus(
            outboxCount = outbox.size,
            lastPushRun = state?.lastPushRunAtEpochMs,
            hasSupabaseToken = hasToken,
            outboxSample = outbox.take(3).map { 
                "${it.operation}: ${it.healthConnectId.take(12)}... (retry: ${it.retryCount})" 
            }
        )
    }
    
    /**
     * Log detailed push status
     */
    suspend fun logPushStatus(context: Context) {
        try {
            val status = getDetailedPushStatus(context)
            
            Log.d(TAG, "═══════════════════════════════════════")
            Log.d(TAG, "NUTRITION PUSH STATUS")
            Log.d(TAG, "═══════════════════════════════════════")
            Log.d(TAG, "Outbox Count: ${status.outboxCount}")
            Log.d(TAG, "Last Push Run: ${status.lastPushRun?.let { java.util.Date(it) } ?: "never"}")
            Log.d(TAG, "Has Supabase Token: ${status.hasSupabaseToken}")
            
            if (status.outboxSample.isNotEmpty()) {
                Log.d(TAG, "Sample items:")
                status.outboxSample.forEach { Log.d(TAG, "  $it") }
            }
            
            Log.d(TAG, "═══════════════════════════════════════")
            
            // Warnings
            if (status.outboxCount > 0 && !status.hasSupabaseToken) {
                Log.e(TAG, "⚠️ WARNING: Outbox has items but NO Supabase token!")
                Log.e(TAG, "→ User needs to log in to Supabase first")
            }
            
            if (status.outboxCount > 100) {
                Log.w(TAG, "⚠️ WARNING: Large outbox (${status.outboxCount} items)")
                Log.w(TAG, "→ This may take several push cycles to clear")
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get push status", e)
        }
    }
    
    data class PushStatus(
        val outboxCount: Int,
        val lastPushRun: Long?,
        val hasSupabaseToken: Boolean,
        val outboxSample: List<String>
    )
}

title: NutritionSyncDao.kt
text:
package com.migraineme

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Transaction

@Dao
interface NutritionSyncDao {

    @Query("SELECT * FROM sync_state WHERE id = 1")
    suspend fun getSyncState(): SyncStateEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertSyncState(state: SyncStateEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertOutbox(item: NutritionOutboxEntity)

    @Query("SELECT * FROM nutrition_outbox ORDER BY createdAtEpochMs ASC LIMIT :limit")
    suspend fun getOutboxBatch(limit: Int): List<NutritionOutboxEntity>

    @Query("DELETE FROM nutrition_outbox WHERE healthConnectId IN (:ids)")
    suspend fun deleteOutboxByIds(ids: List<String>)

    @Query("UPDATE nutrition_outbox SET retryCount = retryCount + 1 WHERE healthConnectId IN (:ids)")
    suspend fun incrementRetry(ids: List<String>)

    @Transaction
    suspend fun markHourlyRun(token: String?, nowMs: Long) {
        val current = getSyncState() ?: SyncStateEntity()
        upsertSyncState(
            current.copy(
                nutritionChangesToken = token,
                lastHourlyRunAtEpochMs = nowMs
            )
        )
    }

    @Transaction
    suspend fun markPushRun(nowMs: Long) {
        val current = getSyncState() ?: SyncStateEntity()
        upsertSyncState(
            current.copy(lastPushRunAtEpochMs = nowMs)
        )
    }
}

title: NutritionSyncDatabase.kt
text:
package com.migraineme

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase

@Database(
    entities = [SyncStateEntity::class, NutritionOutboxEntity::class],
    version = 1,
    exportSchema = false
)
abstract class NutritionSyncDatabase : RoomDatabase() {
    abstract fun dao(): NutritionSyncDao

    companion object {
        @Volatile private var INSTANCE: NutritionSyncDatabase? = null

        fun get(context: Context): NutritionSyncDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    NutritionSyncDatabase::class.java,
                    "nutrition_sync.db"
                ).build().also { INSTANCE = it }
            }
        }
    }
}

title: NutritionSyncScheduler.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.Constraints
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.util.concurrent.TimeUnit

/**
 * Schedules nutrition sync workers
 *
 * - Changes worker: Runs every 15 minutes (detects new/updated/deleted nutrition records)
 * - Push worker: Runs every 15 minutes (uploads to Supabase)
 *
 * Total max delay: ~30 minutes (15 min to detect + 15 min to upload)
 * Typical delay: ~15 minutes (if workers sync in same cycle)
 */
object NutritionSyncScheduler {

    private const val TAG = "NutritionSyncScheduler"
    private const val HOURLY_WORK_NAME = "hc_nutrition_changes_hourly"
    private const val PUSH_WORK_NAME = "nutrition_outbox_push_15m"
    private const val IMMEDIATE_CHANGES_WORK_NAME = "hc_nutrition_changes_immediate"
    private const val IMMEDIATE_PUSH_WORK_NAME = "nutrition_outbox_push_immediate"

    /**
     * Schedule both nutrition workers AND trigger immediate run
     *
     * SMART SCHEDULING:
     * - If workers already exist and are healthy (ENQUEUED/RUNNING) → Do nothing
     * - If workers don't exist or are in bad state (CANCELLED/FAILED) → Create fresh workers
     * - Always triggers immediate sync for instant data sync
     *
     * This ensures:
     * - Safe to call multiple times (idempotent)
     * - Opening screen doesn't reset timers
     * - App restart doesn't break workers
     */
    fun schedule(context: Context) {
        Log.d(TAG, "========== schedule() called ==========")

        val wm = WorkManager.getInstance(context)

        // Check if workers already exist and are healthy
        val workersHealthy = areWorkersHealthy(wm)

        if (workersHealthy) {
            Log.d(TAG, "Workers already running and healthy - skipping schedule")
            // Still trigger immediate sync for fresh data
            triggerImmediateSync(context)
            Log.d(TAG, "========== schedule() complete (no changes) ==========")
            return
        }

        Log.d(TAG, "Workers need scheduling - creating fresh workers")
        logCurrentWorkerStates(context, "BEFORE schedule()")

        val hourlyConstraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.NOT_REQUIRED)
            .build()

        val pushConstraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val hourly = PeriodicWorkRequestBuilder<HealthConnectNutritionChangesWorker>(
            15, TimeUnit.MINUTES
        )
            .setConstraints(hourlyConstraints)
            .addTag("nutrition")
            .addTag("health_connect")
            .build()

        val push = PeriodicWorkRequestBuilder<NutritionOutboxPushWorker>(
            15, TimeUnit.MINUTES
        )
            .setConstraints(pushConstraints)
            .addTag("nutrition")
            .addTag("supabase")
            .build()

        Log.d(TAG, "Enqueueing HOURLY_WORK with REPLACE policy")
        // Use REPLACE to ensure clean state when rescheduling
        wm.enqueueUniquePeriodicWork(
            HOURLY_WORK_NAME,
            ExistingPeriodicWorkPolicy.REPLACE,
            hourly
        )

        Log.d(TAG, "Enqueueing PUSH_WORK with REPLACE policy")
        wm.enqueueUniquePeriodicWork(
            PUSH_WORK_NAME,
            ExistingPeriodicWorkPolicy.REPLACE,
            push
        )

        logCurrentWorkerStates(context, "AFTER schedule()")

        Log.d(TAG, "Triggering immediate sync")
        triggerImmediateSync(context)

        Log.d(TAG, "========== schedule() complete ==========")
    }

    /**
     * Check if workers are already running and healthy
     * Returns true if both workers exist and are in good state (ENQUEUED or RUNNING)
     */
    private fun areWorkersHealthy(wm: WorkManager): Boolean {
        return try {
            val hourlyInfo = wm.getWorkInfosForUniqueWork(HOURLY_WORK_NAME).get()
            val pushInfo = wm.getWorkInfosForUniqueWork(PUSH_WORK_NAME).get()

            if (hourlyInfo.isEmpty() || pushInfo.isEmpty()) {
                Log.d(TAG, "Workers don't exist")
                return false
            }

            val hourlyState = hourlyInfo.firstOrNull()?.state
            val pushState = pushInfo.firstOrNull()?.state

            val healthyStates = setOf(WorkInfo.State.ENQUEUED, WorkInfo.State.RUNNING)

            val hourlyHealthy = hourlyState in healthyStates
            val pushHealthy = pushState in healthyStates

            Log.d(TAG, "Worker health check - hourly: $hourlyState ($hourlyHealthy), push: $pushState ($pushHealthy)")

            hourlyHealthy && pushHealthy
        } catch (e: Exception) {
            Log.e(TAG, "Error checking worker health: ${e.message}", e)
            false
        }
    }

    /**
     * Trigger immediate one-time sync (used on connect and for manual push)
     * Runs both workers in sequence: changes detection → upload to Supabase
     */
    fun triggerImmediateSync(context: Context) {
        Log.d(TAG, "========== triggerImmediateSync() called ==========")

        val wm = WorkManager.getInstance(context)

        val changesConstraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.NOT_REQUIRED)
            .build()

        val pushConstraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val immediateChanges = OneTimeWorkRequestBuilder<HealthConnectNutritionChangesWorker>()
            .setConstraints(changesConstraints)
            .addTag("nutrition")
            .addTag("health_connect")
            .addTag("immediate")
            .build()

        val immediatePush = OneTimeWorkRequestBuilder<NutritionOutboxPushWorker>()
            .setConstraints(pushConstraints)
            .addTag("nutrition")
            .addTag("supabase")
            .addTag("immediate")
            .build()

        Log.d(TAG, "Enqueueing immediate changes worker with REPLACE policy")
        wm.enqueueUniqueWork(
            IMMEDIATE_CHANGES_WORK_NAME,
            ExistingWorkPolicy.REPLACE,
            immediateChanges
        )

        Log.d(TAG, "Enqueueing immediate push worker with REPLACE policy")
        wm.enqueueUniqueWork(
            IMMEDIATE_PUSH_WORK_NAME,
            ExistingWorkPolicy.REPLACE,
            immediatePush
        )

        logCurrentWorkerStates(context, "AFTER triggerImmediateSync()")
        Log.d(TAG, "========== triggerImmediateSync() complete ==========")
    }

    /**
     * Cancel both nutrition workers
     */
    fun cancel(context: Context) {
        Log.d(TAG, "========== cancel() called ==========")
        logCurrentWorkerStates(context, "BEFORE cancel()")

        val wm = WorkManager.getInstance(context)

        Log.d(TAG, "Cancelling all nutrition workers")
        wm.cancelUniqueWork(HOURLY_WORK_NAME)
        wm.cancelUniqueWork(PUSH_WORK_NAME)
        wm.cancelUniqueWork(IMMEDIATE_CHANGES_WORK_NAME)
        wm.cancelUniqueWork(IMMEDIATE_PUSH_WORK_NAME)

        logCurrentWorkerStates(context, "AFTER cancel()")
        Log.d(TAG, "========== cancel() complete ==========")
    }

    /**
     * Log current state of all nutrition workers
     */
    private fun logCurrentWorkerStates(context: Context, label: String) {
        Log.d(TAG, "---------- Worker States: $label ----------")

        val wm = WorkManager.getInstance(context)

        CoroutineScope(Dispatchers.IO).launch {
            try {
                val hourlyInfo = wm.getWorkInfosForUniqueWork(HOURLY_WORK_NAME).get()
                val pushInfo = wm.getWorkInfosForUniqueWork(PUSH_WORK_NAME).get()
                val immediateChangesInfo = wm.getWorkInfosForUniqueWork(IMMEDIATE_CHANGES_WORK_NAME).get()
                val immediatePushInfo = wm.getWorkInfosForUniqueWork(IMMEDIATE_PUSH_WORK_NAME).get()

                Log.d(TAG, "HOURLY_WORK (${HOURLY_WORK_NAME}):")
                logWorkInfoList(hourlyInfo)

                Log.d(TAG, "PUSH_WORK (${PUSH_WORK_NAME}):")
                logWorkInfoList(pushInfo)

                Log.d(TAG, "IMMEDIATE_CHANGES (${IMMEDIATE_CHANGES_WORK_NAME}):")
                logWorkInfoList(immediateChangesInfo)

                Log.d(TAG, "IMMEDIATE_PUSH (${IMMEDIATE_PUSH_WORK_NAME}):")
                logWorkInfoList(immediatePushInfo)

            } catch (e: Exception) {
                Log.e(TAG, "Error getting worker states: ${e.message}", e)
            }
        }

        Log.d(TAG, "---------- End Worker States ----------")
    }

    /**
     * Log details about a list of WorkInfo objects
     */
    private fun logWorkInfoList(workInfoList: List<WorkInfo>) {
        if (workInfoList.isEmpty()) {
            Log.d(TAG, "  → NO WORKERS FOUND")
            return
        }

        workInfoList.forEachIndexed { index, workInfo ->
            Log.d(TAG, "  Worker #$index:")
            Log.d(TAG, "    ID: ${workInfo.id}")
            Log.d(TAG, "    State: ${workInfo.state}")
            Log.d(TAG, "    Run Attempt: ${workInfo.runAttemptCount}")
            Log.d(TAG, "    Tags: ${workInfo.tags}")

            if (workInfo.state == WorkInfo.State.ENQUEUED) {
                Log.d(TAG, "    Next run: scheduled by WorkManager")
            }

            if (workInfo.outputData.keyValueMap.isNotEmpty()) {
                Log.d(TAG, "    Output: ${workInfo.outputData.keyValueMap}")
            }
        }
    }

    /**
     * Utility function to check worker status (can be called from UI/testing)
     */
    fun logAllNutritionWorkerStatus(context: Context) {
        Log.d(TAG, "========== MANUAL STATUS CHECK ==========")
        logCurrentWorkerStates(context, "MANUAL CHECK")
        Log.d(TAG, "========== END MANUAL STATUS CHECK ==========")
    }
}

title: OnboardingCoach.kt
text:
package com.migraineme

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.CornerRadius
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Rect
import androidx.compose.ui.geometry.RoundRect
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.clipPath
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.boundsInRoot
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

object SetupScrollState {
    var scrollPosition by mutableStateOf(0)
}

data class TourStep(
    val route: String,
    val icon: ImageVector,
    val title: String,
    val body: String,
    val highlight: String,
    val interactive: Boolean = false,
    val spotlightKey: String? = null,
)

val tourSteps = listOf(
    TourStep(Routes.HOME, Icons.Outlined.Home, "Home — Your Risk Gauge",
        "This gauge shows your real-time migraine risk based on active triggers. The 7-day forecast lets you tap any day to preview future risk. Active Triggers shows exactly what's driving your score and how much each contributes.",
        "Your daily command centre — always start here."),
    TourStep(Routes.MONITOR, Icons.Outlined.Timeline, "Monitor — Live Data",
        "All your data streams in one place: sleep, recovery, heart rate, weather, screen time, nutrition. Each card shows today's value and a trend graph. Tap any card for detailed history and configuration.",
        "Keep an eye on your body and environment."),
    TourStep(Routes.INSIGHTS, Icons.Outlined.BarChart, "Insights — Migraine Analysis",
        "Explore each migraine in detail: see what was happening in your body and environment before, during, and after. Toggle metrics to spot patterns. Drill into breakdowns by trigger, medicine, relief, and more.",
        "Understand what's really going on."),
    TourStep(Routes.MIGRAINE, Icons.Outlined.Psychology, "Migraine — Log Attacks",
        "When a migraine hits, log everything here: pain location, severity, and symptoms. Quick-log buttons at the top let you rapidly log a trigger, medicine, relief, or activity without the full wizard.",
        "Your go-to when a migraine hits."),
    TourStep(Routes.JOURNAL, Icons.Outlined.History, "Journal — Your Timeline",
        "Every migraine, trigger, medicine, relief, activity, and location — all in chronological order. Tap any entry to edit. The badge shows items that need your attention.",
        "Your complete migraine diary."),
    TourStep(Routes.MANAGE_ITEMS, Icons.Outlined.Tune, "Settings — Manage Items",
        "Add, remove, or customise your triggers, medicines, reliefs, prodromes, and activities. Set severity levels for triggers and prodromes. Reorder your favourites for quick logging.",
        "Make the app truly yours."),
    TourStep(Routes.RISK_WEIGHTS, Icons.Outlined.Speed, "Settings — Risk Model",
        "Customise how your risk score is calculated. Decay weights control how fast triggers lose influence over days. Thresholds set where the gauge transitions between None, Low, Mild, and High zones.",
        "Advanced control over your predictions."),
    TourStep(Routes.PROFILE, Icons.Outlined.Person, "Settings — Profile",
        "Your account details and app preferences. Change your password, manage your data, and configure notification settings.",
        "Your account, your rules."),
)

val setupSteps = listOf(
    TourStep(Routes.THIRD_PARTY_CONNECTIONS, Icons.Outlined.Watch, "Connect WHOOP",
        "If you have a WHOOP band, tap the Connect button below to link it. This will automatically import your sleep, recovery, HRV, and more.",
        "Tap Connect on the WHOOP card below",
        interactive = true, spotlightKey = "whoop_card"),
    TourStep(Routes.THIRD_PARTY_CONNECTIONS, Icons.Outlined.FavoriteBorder, "Connect Health Connect",
        "Health Connect links your phone's health data — sleep, steps, heart rate, nutrition, and more from any compatible app.",
        "Tap Connect on the Health Connect card below",
        interactive = true, spotlightKey = "health_connect_card"),
    TourStep(Routes.DATA, Icons.Outlined.Storage, "Configure Data Collection",
        "Control exactly which metrics MigraineMe collects. Scroll through and toggle on the data you want to track. You can always change these later in Settings.",
        "Toggle on the metrics that matter to you ↓",
        interactive = true),
)

object SpotlightState {
    private val _rects = mutableStateMapOf<String, Rect>()
    var overlayRootOffset by mutableStateOf(Offset.Zero)

    fun register(key: String, rootBounds: Rect) { _rects[key] = rootBounds }
    fun clear() { _rects.clear(); overlayRootOffset = Offset.Zero }

    @Composable
    fun getLocalRect(key: String): Rect? {
        val rootRect = _rects[key] ?: return null
        val off = overlayRootOffset
        return Rect(
            left = rootRect.left - off.x,
            top = rootRect.top - off.y,
            right = rootRect.right - off.x,
            bottom = rootRect.bottom - off.y
        )
    }
}

fun Modifier.spotlightTarget(key: String): Modifier = this.onGloballyPositioned { coords ->
    if (TourManager.isActive() && TourManager.currentPhase() == CoachPhase.SETUP) {
        SpotlightState.register(key, coords.boundsInRoot())
    }
}

enum class CoachPhase { TOUR, SETUP }

data class TourState(
    val active: Boolean = false,
    val phase: CoachPhase = CoachPhase.TOUR,
    val stepIndex: Int = 0,
)

object TourManager {
    private val _state = MutableStateFlow(TourState())
    val state: StateFlow<TourState> = _state

    private fun currentSteps(): List<TourStep> = when (_state.value.phase) {
        CoachPhase.TOUR -> tourSteps
        CoachPhase.SETUP -> setupSteps
    }

    fun startTour() {
        _state.update { TourState(active = true, phase = CoachPhase.TOUR, stepIndex = 0) }
    }

    fun startSetup() {
        SpotlightState.clear()
        _state.update { TourState(active = true, phase = CoachPhase.SETUP, stepIndex = 0) }
    }

    fun nextStep(): String? {
        val steps = currentSteps()
        val nextIdx = _state.value.stepIndex + 1
        if (nextIdx < steps.size) {
            _state.update { it.copy(stepIndex = nextIdx) }
            return steps[nextIdx].route
        } else {
            endPhase()
            return null
        }
    }

    fun prevStep(): String? {
        val steps = currentSteps()
        val prevIdx = _state.value.stepIndex - 1
        if (prevIdx >= 0) {
            _state.update { it.copy(stepIndex = prevIdx) }
            return steps[prevIdx].route
        }
        return null
    }

    fun endPhase() {
        SpotlightState.clear()
        _state.update { TourState() }
    }

    fun isActive(): Boolean = _state.value.active
    fun currentPhase(): CoachPhase = _state.value.phase
}

@Composable
fun CoachOverlay(
    navigateTo: (String) -> Unit,
    onTourFinished: () -> Unit = {},
    onSetupFinished: () -> Unit = {},
) {
    val tourState by TourManager.state.collectAsState()
    val steps = when (tourState.phase) {
        CoachPhase.TOUR -> tourSteps
        CoachPhase.SETUP -> setupSteps
    }
    val step = if (tourState.active) steps.getOrNull(tourState.stepIndex) else null
    val ctx = LocalContext.current
    val density = LocalDensity.current

    fun finishAndClean() {
        val wasTour = tourState.phase == CoachPhase.TOUR
        TourManager.endPhase()
        if (wasTour) {
            CoroutineScope(Dispatchers.IO).launch {
                DemoDataSeeder.clearDemoData(ctx)
                kotlinx.coroutines.withContext(Dispatchers.Main) { onTourFinished() }
            }
        } else {
            onSetupFinished()
        }
    }

    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val pulseAlpha by infiniteTransition.animateFloat(
        initialValue = 0.3f, targetValue = 0.8f,
        animationSpec = infiniteRepeatable(tween(1000, easing = FastOutSlowInEasing), RepeatMode.Reverse),
        label = "pulseAlpha"
    )
    val arrowOffset by infiniteTransition.animateFloat(
        initialValue = 0f, targetValue = 8f,
        animationSpec = infiniteRepeatable(tween(600, easing = FastOutSlowInEasing), RepeatMode.Reverse),
        label = "arrowBounce"
    )

    Box(
        Modifier
            .fillMaxSize()
            .onGloballyPositioned { coords ->
                SpotlightState.overlayRootOffset = Offset(
                    coords.boundsInRoot().left,
                    coords.boundsInRoot().top
                )
            }
    )

    val spotlightRect = step?.spotlightKey?.let { SpotlightState.getLocalRect(it) }
    val hasSpotlight = spotlightRect != null && spotlightRect.width > 0f && spotlightRect.height > 0f

    AnimatedVisibility(
        visible = step != null,
        enter = fadeIn(tween(300)), exit = fadeOut(tween(300))
    ) {
        if (step != null) {
            if (hasSpotlight && spotlightRect != null) {
                val paddingPx = with(density) { 8.dp.toPx() }
                val cornerPx = with(density) { 18.dp.toPx() }
                val strokePx = with(density) { 3.dp.toPx() }

                Canvas(
                    Modifier
                        .fillMaxSize()
                        .graphicsLayer { compositingStrategy = CompositingStrategy.Offscreen }
                ) {
                    drawRect(Color.Black.copy(alpha = 0.5f))
                    val cutout = RoundRect(
                        left = spotlightRect.left - paddingPx,
                        top = spotlightRect.top - paddingPx,
                        right = spotlightRect.right + paddingPx,
                        bottom = spotlightRect.bottom + paddingPx,
                        cornerRadius = CornerRadius(cornerPx)
                    )
                    val cutoutPath = Path().apply { addRoundRect(cutout) }
                    clipPath(cutoutPath, ClipOp.Intersect) {
                        drawRect(Color.Transparent, blendMode = BlendMode.Clear)
                    }
                    drawRoundRect(
                        color = Color(0xFFFF7BB0).copy(alpha = pulseAlpha),
                        topLeft = Offset(cutout.left, cutout.top),
                        size = Size(cutout.right - cutout.left, cutout.bottom - cutout.top),
                        cornerRadius = CornerRadius(cornerPx),
                        style = Stroke(width = strokePx)
                    )
                }
            } else if (!step.interactive) {
                Box(Modifier.fillMaxSize().background(Color.Black.copy(alpha = 0.4f)))
            }
        }
    }

    var isCollapsed by remember { mutableStateOf(false) }
    LaunchedEffect(tourState.stepIndex) {
        isCollapsed = false
        val currentStep = steps.getOrNull(tourState.stepIndex)
        if (currentStep?.interactive == true) {
            // TOUR: don't collapse page 1 (Home, idx 0)
            // SETUP: don't collapse page 1 (WHOOP, idx 0) or page 2 (HC, idx 1)
            val shouldCollapse = when (tourState.phase) {
                CoachPhase.TOUR -> tourState.stepIndex > 0
                CoachPhase.SETUP -> tourState.stepIndex >= 2
            }
            if (shouldCollapse) {
                kotlinx.coroutines.delay(3000)
                isCollapsed = true
            }
        }
    }
    LaunchedEffect(SetupScrollState.scrollPosition) {
        if (SetupScrollState.scrollPosition == 0 && isCollapsed) {
            isCollapsed = false
        }
        // Expand when scrolled to bottom (position == -1 sentinel)
        if (SetupScrollState.scrollPosition == -1 && isCollapsed) {
            isCollapsed = false
        }
    }

    AnimatedVisibility(visible = step != null, enter = slideInVertically { -it } + fadeIn(tween(300)), exit = slideOutVertically { -it } + fadeOut(tween(200))) {
        if (step != null) {
            val topPad = if (step.route == Routes.PROFILE) 80.dp else 12.dp
            val isInteractive = step.interactive

            Box(Modifier.fillMaxWidth().padding(horizontal = 16.dp).padding(top = topPad, bottom = 12.dp)) {
                AnimatedContent(
                    targetState = isCollapsed,
                    transitionSpec = {
                        fadeIn(tween(200)) + scaleIn(initialScale = 0.8f, animationSpec = tween(200)) togetherWith
                        fadeOut(tween(150)) + scaleOut(targetScale = 0.8f, animationSpec = tween(150))
                    },
                    label = "collapse"
                ) { collapsed ->
                    if (collapsed) {
                        Card(
                            onClick = { isCollapsed = false },
                            colors = CardDefaults.cardColors(containerColor = Color(0xFF1E0A2E)),
                            shape = RoundedCornerShape(28.dp),
                            elevation = CardDefaults.cardElevation(defaultElevation = 16.dp),
                            modifier = Modifier
                                .border(1.dp, Color(0xFFFF7BB0).copy(alpha = 0.5f), RoundedCornerShape(28.dp))
                        ) {
                            Row(
                                Modifier.padding(horizontal = 16.dp, vertical = 10.dp),
                                verticalAlignment = Alignment.CenterVertically,
                                horizontalArrangement = Arrangement.spacedBy(8.dp)
                            ) {
                                Box(
                                    Modifier.size(28.dp).background(
                                        Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), AppTheme.AccentPink.copy(alpha = 0.2f))),
                                        CircleShape
                                    ), contentAlignment = Alignment.Center
                                ) {
                                    Icon(step.icon, null, tint = Color.White, modifier = Modifier.size(14.dp))
                                }
                                Text(
                                    "${tourState.stepIndex + 1}/${steps.size} — Tap to expand",
                                    color = AppTheme.SubtleTextColor,
                                    style = MaterialTheme.typography.labelMedium
                                )
                            }
                        }
                    } else {
                        Card(
                            colors = CardDefaults.cardColors(containerColor = Color(0xFF1E0A2E)),
                            shape = RoundedCornerShape(18.dp),
                            elevation = CardDefaults.cardElevation(defaultElevation = 16.dp),
                            modifier = Modifier.fillMaxWidth()
                                .animateContentSize(spring(dampingRatio = 0.8f))
                                .then(
                                    if (isInteractive) Modifier.border(
                                        2.dp,
                                        Color(0xFFFF7BB0).copy(alpha = pulseAlpha),
                                        RoundedCornerShape(18.dp)
                                    ) else Modifier
                                )
                        ) {
                            Box(Modifier.fillMaxWidth().height(3.dp).background(
                                Brush.horizontalGradient(listOf(
                                    if (isInteractive) AppTheme.AccentPink else AppTheme.AccentPurple,
                                    if (isInteractive) AppTheme.AccentPurple else AppTheme.AccentPink
                                ))
                            ))

                            Column(Modifier.padding(16.dp)) {
                                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(10.dp)) {
                                    Box(Modifier.size(38.dp).background(
                                        Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), AppTheme.AccentPink.copy(alpha = 0.2f))),
                                        CircleShape), contentAlignment = Alignment.Center) {
                                        Icon(step.icon, null, tint = Color.White, modifier = Modifier.size(20.dp))
                                    }
                                    Column(Modifier.weight(1f)) {
                                        Text(step.title, color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold))
                                        Text("${tourState.stepIndex + 1} of ${steps.size}", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                                    }
                                    if (isInteractive) {
                                        // Hide minimize on SETUP pages 1+2 (WHOOP, HC) — always expanded
                                        val allowMinimize = !(tourState.phase == CoachPhase.SETUP && tourState.stepIndex < 2)
                                        if (allowMinimize) {
                                            IconButton(onClick = { isCollapsed = true }, modifier = Modifier.size(28.dp)) {
                                                Icon(Icons.Outlined.UnfoldLess, "Minimize", tint = AppTheme.SubtleTextColor, modifier = Modifier.size(18.dp))
                                            }
                                        }
                                    }
                                    // ★ Never show X during onboarding (TOUR or SETUP)
                                    // User must complete the flow to ensure cleanup
                                }

                                Spacer(Modifier.height(10.dp))
                                Text(step.body, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall, lineHeight = MaterialTheme.typography.bodySmall.lineHeight)
                                Spacer(Modifier.height(6.dp))
                                Text(step.highlight, color = if (isInteractive) AppTheme.AccentPink else AppTheme.AccentPurple, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))

                                if (isInteractive && step.spotlightKey == null && !(tourState.phase == CoachPhase.TOUR && tourState.stepIndex == 2)) {
                                    Spacer(Modifier.height(4.dp))
                                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) {
                                        Icon(Icons.Filled.KeyboardArrowDown, "Scroll down",
                                            tint = AppTheme.AccentPink.copy(alpha = pulseAlpha),
                                            modifier = Modifier.size(28.dp).offset(y = arrowOffset.dp))
                                    }
                                }

                                Spacer(Modifier.height(if (isInteractive) 6.dp else 14.dp))

                                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                                    if (tourState.stepIndex > 0) {
                                        TextButton(onClick = { val route = TourManager.prevStep(); if (route != null) navigateTo(route) }) {
                                            Text("Back", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium)
                                        }
                                    } else {
                                        Spacer(Modifier.width(1.dp))
                                    }

                                    Row(horizontalArrangement = Arrangement.spacedBy(3.dp), verticalAlignment = Alignment.CenterVertically) {
                                        steps.indices.forEach { i ->
                                            Box(Modifier.size(if (i == tourState.stepIndex) 8.dp else 5.dp).clip(CircleShape).background(
                                                when {
                                                    i == tourState.stepIndex -> if (isInteractive) AppTheme.AccentPink else AppTheme.AccentPurple
                                                    i < tourState.stepIndex -> (if (isInteractive) AppTheme.AccentPink else AppTheme.AccentPurple).copy(alpha = 0.4f)
                                                    else -> AppTheme.TrackColor
                                                }
                                            ))
                                        }
                                    }

                                    if (tourState.stepIndex < steps.size - 1) {
                                        Button(onClick = { val route = TourManager.nextStep(); if (route != null) navigateTo(route) },
                                            colors = ButtonDefaults.buttonColors(containerColor = if (isInteractive) AppTheme.AccentPink else AppTheme.AccentPurple),
                                            shape = RoundedCornerShape(10.dp), contentPadding = PaddingValues(horizontal = 16.dp, vertical = 6.dp)) {
                                            Text("Next", style = MaterialTheme.typography.labelMedium); Spacer(Modifier.width(4.dp))
                                            Icon(Icons.AutoMirrored.Filled.ArrowForward, null, modifier = Modifier.size(14.dp))
                                        }
                                    } else {
                                        Button(onClick = { finishAndClean() },
                                            colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                                            shape = RoundedCornerShape(10.dp), contentPadding = PaddingValues(horizontal = 16.dp, vertical = 6.dp)) {
                                            Icon(Icons.Filled.Check, null, modifier = Modifier.size(14.dp)); Spacer(Modifier.width(4.dp))
                                            Text("Done!", style = MaterialTheme.typography.labelMedium)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

title: OnboardingPages.kt
text:
package com.migraineme

import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.delay

@Composable
fun OnboardingCenteredPage(content: @Composable ColumnScope.() -> Unit) {
    Column(Modifier.fillMaxSize().padding(horizontal = 24.dp).verticalScroll(rememberScrollState()),
        verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally, content = content)
}

@Composable
fun OnboardingScrollPage(content: @Composable ColumnScope.() -> Unit) {
    Column(Modifier.fillMaxSize().padding(horizontal = 24.dp).verticalScroll(rememberScrollState()),
        verticalArrangement = Arrangement.spacedBy(8.dp), content = content)
}

@Composable
fun WelcomePage() {
    OnboardingCenteredPage {
        val anim = rememberInfiniteTransition(label = "pulse")
        val scale by anim.animateFloat(0.95f, 1.05f, infiniteRepeatable(tween(2000), RepeatMode.Reverse), label = "s")
        Box(Modifier.size((100 * scale).dp), contentAlignment = Alignment.Center) {
            Canvas(Modifier.size(80.dp)) {
                drawArc(brush = Brush.sweepGradient(listOf(Color(0xFFB97BFF), Color(0xFFFF7BB0), Color(0xFFB97BFF))),
                    startAngle = 180f, sweepAngle = 180f, useCenter = false, style = Stroke(width = 8.dp.toPx(), cap = StrokeCap.Round))
            }
        }
        Spacer(Modifier.height(24.dp))
        Text("Welcome to MigraineMe", color = Color.White, style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
        Spacer(Modifier.height(12.dp))
        Text("Your personal migraine prediction companion.\n\nLet's get you set up in a few minutes.",
            color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyLarge, textAlign = TextAlign.Center, modifier = Modifier.padding(horizontal = 16.dp))
    }
}

@Composable
fun HowItWorksPage() {
    val steps = listOf(
        Triple(Icons.Outlined.Sensors, "Connect", "Data flows in from your wearable, Health Connect and phone"),
        Triple(Icons.Outlined.Bolt, "Detect", "Unusual patterns get flagged automatically"),
        Triple(Icons.Outlined.Speed, "Score", "Everything adds up to your daily risk"),
        Triple(Icons.Outlined.CalendarMonth, "Predict", "See what's coming 7 days ahead"),
        Triple(Icons.Outlined.AutoAwesome, "Learn", "Gets smarter the more you use it"),
    )
    var activeStep by remember { mutableIntStateOf(-1) }
    var allRevealed by remember { mutableStateOf(false) }
    LaunchedEffect(Unit) { delay(600); for (i in steps.indices) { activeStep = i; delay(1200) }; delay(500); allRevealed = true }
    val lineProgress by animateFloatAsState(if (activeStep >= 0) ((activeStep + 1).toFloat() / steps.size) else 0f, tween(900, easing = FastOutSlowInEasing), label = "line")

    Column(Modifier.fillMaxSize().padding(horizontal = 32.dp), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally) {
        Text("How it works", color = Color.White, style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(32.dp))
        Box(Modifier.fillMaxWidth()) {
            Canvas(Modifier.width(2.dp).height((steps.size * 72).dp).align(Alignment.TopStart).offset(x = 23.dp)) {
                drawLine(Color.White.copy(alpha = 0.08f), Offset(0f, 0f), Offset(0f, size.height), 2.dp.toPx(), cap = StrokeCap.Round)
                drawLine(Brush.verticalGradient(listOf(Color(0xFFB97BFF), Color(0xFFFF7BB0))), Offset(0f, 0f), Offset(0f, size.height * lineProgress), 2.dp.toPx(), cap = StrokeCap.Round)
            }
            Column(verticalArrangement = Arrangement.spacedBy(24.dp)) {
                steps.forEachIndexed { index, (icon, title, subtitle) ->
                    val isActive = index <= activeStep
                    val alpha by animateFloatAsState(if (isActive) 1f else 0.15f, tween(500), label = "a$index")
                    val scale by animateFloatAsState(if (index == activeStep && !allRevealed) 1.06f else 1f, spring(dampingRatio = 0.6f, stiffness = 200f), label = "s$index")
                    val offsetX by animateDpAsState(if (isActive) 0.dp else 50.dp, tween(500, easing = FastOutSlowInEasing), label = "x$index")
                    Row(Modifier.fillMaxWidth().offset(x = offsetX).graphicsLayer { scaleX = scale; scaleY = scale; this.alpha = alpha },
                        horizontalArrangement = Arrangement.spacedBy(16.dp), verticalAlignment = Alignment.CenterVertically) {
                        Box(Modifier.size(48.dp)
                            .background(if (isActive) Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), AppTheme.AccentPink.copy(alpha = 0.2f))) else Brush.linearGradient(listOf(Color.White.copy(alpha = 0.05f), Color.White.copy(alpha = 0.05f))), CircleShape)
                            .then(if (isActive) Modifier.border(1.5.dp, Brush.linearGradient(listOf(AppTheme.AccentPurple, AppTheme.AccentPink)), CircleShape) else Modifier),
                            contentAlignment = Alignment.Center) {
                            Icon(icon, null, tint = if (isActive) Color.White else Color.White.copy(alpha = 0.3f), modifier = Modifier.size(24.dp))
                        }
                        Column {
                            Text(title, color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
                            Text(subtitle, color = if (isActive) AppTheme.BodyTextColor else AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun ConnectionsPage(onNavigateToConnections: () -> Unit, wearableConnected: String?, onWearableChanged: (String) -> Unit) {
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.Link, "Connect your data")
        Text("The more data MigraineMe has, the better it predicts.", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(4.dp))
        listOf("WHOOP" to "Sleep, recovery, HRV, HR, SpO₂, skin temp", "Health Connect" to "Steps, sleep, heart rate, nutrition, and more", "Both" to "Get the best of both sources", "None" to "I'll log everything manually").forEach { (label, desc) ->
            OnboardingChoiceCard(label, desc, wearableConnected == label) { onWearableChanged(label) }
        }
        if (wearableConnected != null && wearableConnected != "None") {
            Spacer(Modifier.height(8.dp))
            OutlinedButton(onClick = onNavigateToConnections, modifier = Modifier.fillMaxWidth(), shape = RoundedCornerShape(12.dp),
                border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPurple)) {
                Icon(Icons.Outlined.Settings, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(18.dp)); Spacer(Modifier.width(8.dp))
                Text("Set up connections now", color = AppTheme.AccentPurple)
            }
            Text("You can also do this later from the menu.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun DataCollectionPage(wearable: String?, enabledMetrics: MutableMap<String, Boolean>) {
    val hasWearable = wearable == "WHOOP" || wearable == "Both"
    val hasLocation = enabledMetrics["user_location_daily"] == true
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.Storage, "What do you want to track?")
        Text("Turn on the data you want MigraineMe to collect. You can change these later in Settings → Data.",
            color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(4.dp))
        dataCollectionGroups.forEach { group ->
            Text(group.title, color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold), modifier = Modifier.padding(top = 4.dp))
            group.items.forEach { item ->
                val available = when {
                    item.requiresWearable && !hasWearable -> false
                    item.requiresLocation && !hasLocation -> false
                    else -> true
                }
                val enabled = enabledMetrics[item.metric] ?: (available && item.source != "reference")
                DataToggleRow(item, enabled, available) { on -> enabledMetrics[item.metric] = on }
            }
        }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun PersonalQuestionsPage1(frequency: String?, onFrequency: (String) -> Unit, duration: String?, onDuration: (String) -> Unit, severity: String?, onSeverity: (String) -> Unit) {
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.Person, "About your migraines")
        OnboardingQuestionSection("How often do you get migraines?") {
            listOf("Daily", "2-3x per week", "Weekly", "2-3x per month", "Monthly", "Rarely").forEach { OnboardingChoiceChip(it, frequency == it) { onFrequency(it) } }
        }
        OnboardingQuestionSection("How long do they usually last?") {
            listOf("A few hours", "Half a day", "A full day", "2-3 days", "More than 3 days").forEach { OnboardingChoiceChip(it, duration == it) { onDuration(it) } }
        }
        OnboardingQuestionSection("How severe are they typically?") {
            listOf("Mild — can push through", "Moderate — slows me down", "Severe — can't function", "Debilitating — bed rest required").forEach { OnboardingChoiceChip(it, severity == it) { onSeverity(it) } }
        }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun PersonalQuestionsPage2(timing: String?, onTiming: (String) -> Unit, warningSign: String?, onWarningSign: (String) -> Unit, medication: String?, onMedication: (String) -> Unit) {
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.Schedule, "Timing & patterns")
        OnboardingQuestionSection("When do they usually hit?") {
            listOf("Morning (wake up with it)", "Afternoon", "Evening", "Night", "No pattern / varies").forEach { OnboardingChoiceChip(it, timing == it) { onTiming(it) } }
        }
        OnboardingQuestionSection("Do you get warning signs before an attack?") {
            listOf("Yes, clearly — I can feel one coming", "Sometimes — occasional hints", "Rarely — they catch me off guard", "No — they come without warning").forEach { OnboardingChoiceChip(it, warningSign == it) { onWarningSign(it) } }
        }
        OnboardingQuestionSection("Do you take preventive or acute medication?") {
            listOf("Yes, preventive daily medication", "Yes, acute medication when needed", "Both preventive and acute", "No medication currently").forEach { OnboardingChoiceChip(it, medication == it) { onMedication(it) } }
        }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun PersonalQuestionsPage3(knownTriggerAreas: Set<String>, onTriggerAreas: (Set<String>) -> Unit, familyHistory: String?, onFamilyHistory: (String) -> Unit, trackCycle: String?, onTrackCycle: (String) -> Unit) {
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.Lightbulb, "What you already know")
        OnboardingQuestionSection("Which of these seem to affect your migraines? (select all that apply)") {
            listOf("Sleep", "Stress", "Weather", "Screen time", "Diet", "Hormones", "Exercise", "Not sure yet").forEach { area ->
                val selected = area in knownTriggerAreas
                OnboardingChoiceChip(area, selected) {
                    if (area == "Not sure yet") onTriggerAreas(setOf("Not sure yet"))
                    else { val new = knownTriggerAreas.toMutableSet(); new.remove("Not sure yet"); if (selected) new.remove(area) else new.add(area); onTriggerAreas(new) }
                }
            }
        }
        OnboardingQuestionSection("Does anyone in your family get migraines?") {
            listOf("Yes", "No", "Not sure").forEach { OnboardingChoiceChip(it, familyHistory == it) { onFamilyHistory(it) } }
        }
        OnboardingQuestionSection("Do you want to track your menstrual cycle?") {
            listOf("Yes", "No", "Not applicable").forEach { OnboardingChoiceChip(it, trackCycle == it) { onTrackCycle(it) } }
        }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun TriggerGroupPage(title: String, icon: ImageVector, questions: List<SeverityQuestion>, answers: MutableMap<String, SeverityChoice>) {
    OnboardingScrollPage {
        OnboardingIconHeader(icon, title)
        Text("How much does each of these affect your migraines?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(4.dp))
        questions.forEach { q -> SeverityQuestionCard(q, answers[q.label] ?: SeverityChoice.NONE) { answers[q.label] = it } }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun SuggestionsPage(suggestions: MutableMap<String, SeverityChoice>) {
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.AutoAwesome, "Your personalised model")
        Text("Based on your answers, here's what we suggest. Tap to adjust.", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(4.dp))
        if (suggestions.isEmpty()) {
            Text("Complete the previous sections to get personalised suggestions.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth().padding(vertical = 24.dp))
        } else {
            val grouped = suggestions.entries.sortedByDescending { it.value.ordinal }.groupBy { it.value }
            grouped.forEach { (severity, items) ->
                if (severity == SeverityChoice.NONE) return@forEach
                Text("${severity.label} influence", color = severity.color, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold), modifier = Modifier.padding(top = 8.dp))
                items.forEach { (label, sev) -> SuggestionRow(label, sev) { suggestions[label] = it } }
            }
            val noneCount = suggestions.count { it.value == SeverityChoice.NONE }
            if (noneCount > 0) Text("$noneCount triggers left at None (no influence)", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall, modifier = Modifier.padding(top = 8.dp))
        }
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
fun RiskModelPage() {
    OnboardingScrollPage {
        OnboardingIconHeader(Icons.Outlined.Speed, "Your Risk Gauge")
        Text("Each trigger has a severity — you decide how much it matters:", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(8.dp))
        SeverityExplainRow(SeverityChoice.HIGH, "Reliably triggers your migraines")
        SeverityExplainRow(SeverityChoice.MILD, "Contributes but not always the cause")
        SeverityExplainRow(SeverityChoice.LOW, "Might play a role occasionally")
        SeverityExplainRow(SeverityChoice.NONE, "No influence — doesn't count")
        Spacer(Modifier.height(12.dp))
        Text("Recent triggers weigh more than older ones. The score decays over 7 days.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Text("Adjust everything anytime in Settings → Risk Model.", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
        Spacer(Modifier.height(0.dp))
    }
}

@Composable
private fun SeverityExplainRow(severity: SeverityChoice, description: String) {
    Row(Modifier.fillMaxWidth().padding(vertical = 4.dp), horizontalArrangement = Arrangement.spacedBy(10.dp), verticalAlignment = Alignment.CenterVertically) {
        Box(Modifier.size(10.dp).background(severity.color, CircleShape))
        Text("${severity.label}:", color = severity.color, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold), modifier = Modifier.width(42.dp))
        Text(description, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall, modifier = Modifier.weight(1f))
    }
}

@Composable
fun CompletePage(saving: Boolean) {
    OnboardingCenteredPage {
        Box(Modifier.size(80.dp).background(Brush.linearGradient(listOf(AppTheme.AccentPurple, AppTheme.AccentPink)), CircleShape), contentAlignment = Alignment.Center) {
            Icon(Icons.Filled.Check, null, tint = Color.White, modifier = Modifier.size(40.dp))
        }
        Spacer(Modifier.height(24.dp))
        Text("Almost there!", color = Color.White, style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
        Spacer(Modifier.height(12.dp))
        Text("Your risk model is personalised.\n\nWe're loading some sample data so you can see the app in action. Next up: a quick tour of every screen.",
            color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.padding(horizontal = 16.dp))
    }
}

title: OnboardingQuestions.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

enum class SeverityChoice(val label: String, val color: Color) {
    HIGH("High", Color(0xFFE57373)),
    MILD("Mild", Color(0xFFFFB74D)),
    LOW("Low", Color(0xFF81C784)),
    NONE("None", Color.White.copy(alpha = 0.4f))
}

data class SeverityQuestion(val label: String, val displayName: String, val description: String, val type: String)

data class DataCollectionItem(val metric: String, val displayName: String, val description: String, val source: String, val requiresWearable: Boolean = false, val requiresLocation: Boolean = false)
data class DataCollectionGroup(val title: String, val items: List<DataCollectionItem>)

val dataCollectionGroups = listOf(
    DataCollectionGroup("Sleep", listOf(
        DataCollectionItem("sleep_duration_daily", "Sleep duration", "Hours of sleep per night", "both"),
        DataCollectionItem("sleep_score_daily", "Sleep score", "Overall sleep quality score", "wearable", requiresWearable = true),
        DataCollectionItem("sleep_efficiency_daily", "Sleep efficiency", "Time asleep vs time in bed", "wearable", requiresWearable = true),
        DataCollectionItem("sleep_stages_daily", "Sleep stages", "Deep, REM, light sleep breakdown", "wearable", requiresWearable = true),
        DataCollectionItem("sleep_disturbances_daily", "Sleep disturbances", "Wake-ups and restlessness", "wearable", requiresWearable = true),
        DataCollectionItem("fell_asleep_time_daily", "Bedtime", "When you fell asleep", "both"),
        DataCollectionItem("woke_up_time_daily", "Wake time", "When you woke up", "both"),
    )),
    DataCollectionGroup("Physical Health", listOf(
        DataCollectionItem("recovery_score_daily", "Recovery", "Daily recovery percentage", "wearable", requiresWearable = true),
        DataCollectionItem("resting_hr_daily", "Resting heart rate", "Your resting BPM", "wearable", requiresWearable = true),
        DataCollectionItem("hrv_daily", "HRV", "Heart rate variability", "wearable", requiresWearable = true),
        DataCollectionItem("skin_temp_daily", "Skin temperature", "Wrist skin temp deviation", "wearable", requiresWearable = true),
        DataCollectionItem("spo2_daily", "Blood oxygen (SpO₂)", "Oxygen saturation", "wearable", requiresWearable = true),
        DataCollectionItem("steps_daily", "Steps", "Daily step count", "wearable", requiresWearable = true),
        DataCollectionItem("time_in_high_hr_zones_daily", "High HR zones", "Minutes in elevated heart rate", "wearable", requiresWearable = true),
    )),
    DataCollectionGroup("Mental Health & Screen", listOf(
        DataCollectionItem("stress_index_daily", "Stress index", "Computed from HRV and activity", "computed"),
        DataCollectionItem("screen_time_daily", "Screen time", "Total phone screen time", "phone"),
        DataCollectionItem("screen_time_late_night", "Late night screen time", "Screen use after 10pm", "phone"),
        DataCollectionItem("ambient_noise_samples", "Noise sampling", "Ambient noise levels", "phone"),
        DataCollectionItem("phone_brightness_daily", "Phone brightness", "Average screen brightness", "phone"),
        DataCollectionItem("phone_volume_daily", "Phone volume", "Average media volume", "phone"),
        DataCollectionItem("phone_dark_mode_daily", "Dark mode", "Hours in dark mode", "phone"),
        DataCollectionItem("phone_unlock_daily", "Phone unlocks", "How often you check your phone", "phone"),
    )),
    DataCollectionGroup("Environment", listOf(
        DataCollectionItem("user_location_daily", "Location", "Your location for weather data", "phone"),
        DataCollectionItem("temperature_daily", "Temperature", "Local temperature", "reference", requiresLocation = true),
        DataCollectionItem("pressure_daily", "Barometric pressure", "Atmospheric pressure", "reference", requiresLocation = true),
        DataCollectionItem("humidity_daily", "Humidity", "Local humidity levels", "reference", requiresLocation = true),
        DataCollectionItem("wind_daily", "Wind", "Wind speed", "reference", requiresLocation = true),
        DataCollectionItem("uv_daily", "UV index", "UV radiation level", "reference", requiresLocation = true),
    )),
    DataCollectionGroup("Diet", listOf(
        DataCollectionItem("nutrition", "Nutrition tracking", "Log meals and track nutrients, caffeine, alcohol", "phone"),
    )),
    DataCollectionGroup("Menstruation", listOf(
        DataCollectionItem("menstruation", "Menstrual cycle", "Track your cycle and predict periods", "phone"),
    )),
)

val sleepTriggerQuestions = listOf(
    SeverityQuestion("Sleep duration low", "Short sleep", "Not sleeping long enough (< 6-7 hours)", "trigger"),
    SeverityQuestion("Sleep disturbances high", "Restless sleep", "Frequent wake-ups or tossing and turning", "trigger"),
    SeverityQuestion("Bedtime late", "Late bedtime", "Going to bed much later than usual", "trigger"),
    SeverityQuestion("Deep sleep low", "Poor deep sleep", "Not enough restorative deep sleep", "trigger"),
    SeverityQuestion("REM sleep low", "Low REM sleep", "Below your normal REM percentage", "trigger"),
    SeverityQuestion("Sleep efficiency low", "Poor sleep efficiency", "Lots of time in bed but not sleeping", "trigger"),
    SeverityQuestion("Sleep score low", "Low sleep score", "Overall poor sleep quality score", "trigger"),
)

val bodyTriggerQuestions = listOf(
    SeverityQuestion("Recovery low", "Low recovery", "Poor recovery score from your wearable", "trigger"),
    SeverityQuestion("Stress high", "High physiological stress", "Elevated stress index", "trigger"),
    SeverityQuestion("Steps low", "Sedentary day", "Very low step count / no movement", "trigger"),
    SeverityQuestion("High HR zones low", "No exercise", "No time in elevated heart rate zones", "trigger"),
    SeverityQuestion("High HR zones high", "Over-exercise", "Too much intense exercise", "trigger"),
    SeverityQuestion("Recovery high", "Unusual high recovery", "Unexpectedly high recovery (can signal change)", "trigger"),
)

val environmentTriggerQuestions = listOf(
    SeverityQuestion("Pressure low", "Low pressure", "Falling barometric pressure / storm fronts", "trigger"),
    SeverityQuestion("Pressure high", "High pressure", "Rising barometric pressure", "trigger"),
    SeverityQuestion("Humidity high", "High humidity", "Muggy, heavy air", "trigger"),
    SeverityQuestion("Temperature low", "Cold weather", "Sharp drops in temperature", "trigger"),
    SeverityQuestion("Temperature high", "Hot weather", "Heat waves, high temperatures", "trigger"),
    SeverityQuestion("Wind speed high", "Strong wind", "Windy or gusty conditions", "trigger"),
    SeverityQuestion("UV high", "High UV", "High ultraviolet radiation", "trigger"),
)

val cognitiveTriggerQuestions = listOf(
    SeverityQuestion("Screen time high", "Excess screen time", "Too many hours on phone/computer", "trigger"),
    SeverityQuestion("Late screen time high", "Late night screens", "Screen use close to bedtime", "trigger"),
    SeverityQuestion("Noise high", "Noisy environment", "Loud or sustained noise exposure", "trigger"),
    SeverityQuestion("Stress", "Emotional stress", "Work pressure, anxiety, conflict", "trigger"),
    SeverityQuestion("Anger", "Anger", "Episodes of anger or frustration", "trigger"),
    SeverityQuestion("Anxiety", "Anxiety", "Feeling anxious or worried", "trigger"),
    SeverityQuestion("Let-down", "Let-down effect", "Migraine after stress ends (weekends, holidays)", "trigger"),
)

val dietTriggerQuestions = listOf(
    SeverityQuestion("Alcohol exposure high", "Alcohol", "Wine, beer, spirits", "trigger"),
    SeverityQuestion("Caffeine high", "Too much caffeine", "Excess coffee, tea, energy drinks", "trigger"),
    SeverityQuestion("Caffeine low", "Caffeine withdrawal", "Missing your usual caffeine intake", "trigger"),
    SeverityQuestion("Calories low", "Skipped meals", "Undereating, fasting, missed meals", "trigger"),
    SeverityQuestion("Dehydration", "Dehydration", "Not drinking enough water", "trigger"),
    SeverityQuestion("Gluten exposure high", "Gluten", "Foods containing gluten", "trigger"),
    SeverityQuestion("Calories high", "Overeating", "Eating significantly more than usual", "trigger"),
)

val hormonalTriggerQuestions = listOf(
    SeverityQuestion("menstruation_predicted", "Menstrual cycle", "Period-related migraines (before, during, or after)", "trigger"),
)

val physicalProdromeQuestions = listOf(
    SeverityQuestion("HRV low", "Low HRV", "Heart rate variability drops before attacks", "prodrome"),
    SeverityQuestion("Resting HR high", "Elevated resting HR", "Resting heart rate higher than usual", "prodrome"),
    SeverityQuestion("SpO2 low", "Low blood oxygen", "SpO₂ dips before migraines", "prodrome"),
    SeverityQuestion("Skin temp low", "Skin temp drop", "Skin temperature decreases", "prodrome"),
    SeverityQuestion("Skin temp high", "Skin temp rise", "Skin temperature increases", "prodrome"),
    SeverityQuestion("Resp rate high", "Fast breathing", "Respiratory rate increases", "prodrome"),
    SeverityQuestion("Muscle tension", "Neck/shoulder tension", "Stiffness in neck or shoulders", "prodrome"),
    SeverityQuestion("Frequent urination", "Frequent urination", "Needing to urinate more often", "prodrome"),
)

val sensoryProdromeQuestions = listOf(
    SeverityQuestion("Sensitivity to light", "Light sensitivity", "Bright lights feel painful or overwhelming", "prodrome"),
    SeverityQuestion("Sensitivity to sound", "Sound sensitivity", "Normal sounds feel too loud", "prodrome"),
    SeverityQuestion("Sensitivity to smell", "Smell sensitivity", "Strong odours become unbearable", "prodrome"),
    SeverityQuestion("Numbness", "Numbness", "Tingling or numbness in face or hands", "prodrome"),
    SeverityQuestion("Tingling", "Tingling", "Pins and needles sensations", "prodrome"),
)

val moodProdromeQuestions = listOf(
    SeverityQuestion("Mood change", "Mood changes", "Unusual irritability, sadness, or euphoria", "prodrome"),
    SeverityQuestion("Irritability", "Irritability", "Being unusually short-tempered", "prodrome"),
    SeverityQuestion("Depression", "Low mood", "Feeling down or depressed", "prodrome"),
    SeverityQuestion("Euphoria", "Euphoria", "Unusual feelings of elation", "prodrome"),
    SeverityQuestion("Difficulty focusing", "Brain fog", "Trouble concentrating or reading", "prodrome"),
    SeverityQuestion("Word-finding trouble", "Word-finding trouble", "Struggling to find the right words", "prodrome"),
)

val autonomicProdromeQuestions = listOf(
    SeverityQuestion("Yawning", "Excessive yawning", "Yawning frequently without being tired", "prodrome"),
    SeverityQuestion("Food cravings", "Food cravings", "Unusual cravings for sweets or specific foods", "prodrome"),
    SeverityQuestion("Loss of appetite", "Loss of appetite", "Not feeling hungry at all", "prodrome"),
    SeverityQuestion("Nasal congestion", "Nasal congestion", "Stuffy nose without a cold", "prodrome"),
    SeverityQuestion("Tearing", "Tearing", "Watery eyes without cause", "prodrome"),
)

fun generateSuggestions(
    frequency: String?, duration: String?, severity: String?, timing: String?, warningSign: String?,
    triggerAreas: Set<String>, wearable: String?, medication: String?, familyHistory: String?, trackCycle: String?,
): Map<String, SeverityChoice> {
    val map = mutableMapOf<String, SeverityChoice>()
    val base = when (frequency) { "Daily", "2-3x per week" -> SeverityChoice.HIGH; "Weekly" -> SeverityChoice.MILD; else -> SeverityChoice.LOW }
    val lower = when (base) { SeverityChoice.HIGH -> SeverityChoice.MILD; SeverityChoice.MILD -> SeverityChoice.LOW; else -> SeverityChoice.LOW }

    if ("Sleep" in triggerAreas) {
        map["Sleep duration low"] = base; map["Sleep disturbances high"] = lower; map["Bedtime late"] = SeverityChoice.LOW
        if (wearable != "None" && wearable != null) { map["Sleep score low"] = lower; map["Sleep efficiency low"] = SeverityChoice.LOW }
    }
    if ("Stress" in triggerAreas) {
        map["Stress"] = base; map["Anxiety"] = lower; map["Let-down"] = SeverityChoice.LOW
        if (wearable != "None" && wearable != null) { map["Stress high"] = lower; map["Recovery low"] = lower }
    }
    if ("Weather" in triggerAreas) { map["Pressure low"] = base; map["Temperature high"] = lower; map["Temperature low"] = lower; map["Humidity high"] = SeverityChoice.LOW; map["Wind speed high"] = SeverityChoice.LOW }
    if ("Screen time" in triggerAreas) { map["Screen time high"] = base; map["Late screen time high"] = lower; map["Noise high"] = SeverityChoice.LOW }
    if ("Diet" in triggerAreas) { map["Alcohol exposure high"] = base; map["Caffeine high"] = lower; map["Caffeine low"] = lower; map["Calories low"] = lower; map["Dehydration"] = lower; map["Gluten exposure high"] = SeverityChoice.LOW }
    if ("Hormones" in triggerAreas || trackCycle == "Yes") { map["menstruation_predicted"] = base }
    if ("Exercise" in triggerAreas) { map["High HR zones low"] = lower; map["High HR zones high"] = SeverityChoice.LOW; map["Steps low"] = SeverityChoice.LOW }

    if (warningSign == "Yes, clearly") {
        map["Sensitivity to light"] = SeverityChoice.HIGH; map["Sensitivity to sound"] = SeverityChoice.MILD; map["Sensitivity to smell"] = SeverityChoice.MILD
        map["Mood change"] = SeverityChoice.MILD; map["Muscle tension"] = SeverityChoice.MILD; map["Difficulty focusing"] = SeverityChoice.MILD
        map["Yawning"] = SeverityChoice.LOW; map["Food cravings"] = SeverityChoice.LOW; map["Numbness"] = SeverityChoice.LOW
    } else if (warningSign == "Sometimes") {
        map["Sensitivity to light"] = SeverityChoice.MILD; map["Sensitivity to sound"] = SeverityChoice.LOW
        map["Mood change"] = SeverityChoice.LOW; map["Muscle tension"] = SeverityChoice.LOW; map["Yawning"] = SeverityChoice.LOW
    }

    if (wearable == "WHOOP" || wearable == "Both") {
        map["HRV low"] = lower; map["Resting HR high"] = SeverityChoice.LOW; map["SpO2 low"] = SeverityChoice.LOW; map["Skin temp low"] = SeverityChoice.LOW
    }

    if (severity == "Severe" || severity == "Debilitating") {
        for (key in map.keys.toList()) { if (map[key] == SeverityChoice.LOW) map[key] = SeverityChoice.MILD }
    }
    if (timing == "Morning") {
        if ("Sleep duration low" !in map) map["Sleep duration low"] = SeverityChoice.MILD
        if ("Sleep disturbances high" !in map) map["Sleep disturbances high"] = SeverityChoice.LOW
    }
    return map
}

// ─── Shared UI components ────────────────────────────────────

@Composable
fun OnboardingIconHeader(icon: ImageVector, title: String) {
    Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {
        Box(Modifier.size(52.dp).background(AppTheme.AccentPurple.copy(alpha = 0.15f), CircleShape), contentAlignment = Alignment.Center) {
            Icon(icon, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(26.dp))
        }
        Spacer(Modifier.height(12.dp))
        Text(title, color = Color.White, style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
        Spacer(Modifier.height(4.dp))
    }
}

@Composable
fun OnboardingChoiceCard(label: String, description: String, isSelected: Boolean, onClick: () -> Unit) {
    Card(modifier = Modifier.fillMaxWidth().clickable { onClick() }
        .then(if (isSelected) Modifier.border(1.5.dp, AppTheme.AccentPurple, RoundedCornerShape(12.dp)) else Modifier),
        colors = CardDefaults.cardColors(containerColor = if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.1f) else Color.White.copy(alpha = 0.04f)),
        shape = RoundedCornerShape(12.dp)) {
        Row(Modifier.padding(14.dp), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            if (isSelected) Box(Modifier.size(20.dp).background(AppTheme.AccentPurple, CircleShape), contentAlignment = Alignment.Center) {
                Icon(Icons.Filled.Check, null, tint = Color.White, modifier = Modifier.size(14.dp))
            } else Box(Modifier.size(20.dp).border(1.dp, Color.White.copy(alpha = 0.2f), CircleShape))
            Column {
                Text(label, color = Color.White, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold))
                Text(description, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
            }
        }
    }
}

@Composable
fun OnboardingChoiceChip(label: String, isSelected: Boolean, onClick: () -> Unit) {
    Box(Modifier.fillMaxWidth().clip(RoundedCornerShape(10.dp))
        .background(if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.15f) else Color.White.copy(alpha = 0.04f))
        .then(if (isSelected) Modifier.border(1.dp, AppTheme.AccentPurple, RoundedCornerShape(10.dp)) else Modifier)
        .clickable { onClick() }.padding(horizontal = 14.dp, vertical = 10.dp)) {
        Text(label, color = if (isSelected) AppTheme.AccentPurple else AppTheme.BodyTextColor,
            style = MaterialTheme.typography.bodyMedium.copy(fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal))
    }
}

@Composable
fun OnboardingQuestionSection(question: String, content: @Composable ColumnScope.() -> Unit) {
    Column(Modifier.fillMaxWidth()) {
        Text(question, color = Color.White, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium))
        Spacer(Modifier.height(6.dp))
        Column(verticalArrangement = Arrangement.spacedBy(4.dp), content = content)
    }
}

@Composable
fun SeverityQuestionCard(question: SeverityQuestion, selected: SeverityChoice, onSelect: (SeverityChoice) -> Unit) {
    Card(colors = CardDefaults.cardColors(containerColor = Color.White.copy(alpha = 0.04f)), shape = RoundedCornerShape(12.dp), modifier = Modifier.fillMaxWidth()) {
        Column(Modifier.padding(12.dp)) {
            Text(question.displayName, color = Color.White, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium))
            Text(question.description, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
            Spacer(Modifier.height(8.dp))
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                SeverityChoice.entries.reversed().forEach { choice ->
                    val isSelected = choice == selected
                    Box(Modifier.weight(1f).height(36.dp).clip(RoundedCornerShape(8.dp))
                        .background(if (isSelected) choice.color.copy(alpha = 0.2f) else Color.White.copy(alpha = 0.04f))
                        .then(if (isSelected) Modifier.border(1.5.dp, choice.color, RoundedCornerShape(8.dp)) else Modifier.border(1.dp, Color.White.copy(alpha = 0.06f), RoundedCornerShape(8.dp)))
                        .clickable { onSelect(choice) }, contentAlignment = Alignment.Center) {
                        Text(choice.label, color = if (isSelected) choice.color else AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.labelMedium.copy(fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal))
                    }
                }
            }
        }
    }
}

@Composable
fun SuggestionRow(label: String, severity: SeverityChoice, onChange: (SeverityChoice) -> Unit) {
    Row(Modifier.fillMaxWidth().background(Color.White.copy(alpha = 0.04f), RoundedCornerShape(10.dp)).padding(horizontal = 12.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
        Text(label, color = Color.White, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium), modifier = Modifier.weight(1f))
        Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
            SeverityChoice.entries.reversed().forEach { choice ->
                val isSelected = choice == severity
                Box(Modifier.size(28.dp).clip(RoundedCornerShape(6.dp))
                    .background(if (isSelected) choice.color.copy(alpha = 0.25f) else Color.Transparent)
                    .then(if (isSelected) Modifier.border(1.dp, choice.color, RoundedCornerShape(6.dp)) else Modifier)
                    .clickable { onChange(choice) }, contentAlignment = Alignment.Center) {
                    Text(choice.label.first().toString(), color = if (isSelected) choice.color else Color.White.copy(alpha = 0.25f),
                        style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold))
                }
            }
        }
    }
}

@Composable
fun DataToggleRow(item: DataCollectionItem, enabled: Boolean, available: Boolean, onToggle: (Boolean) -> Unit) {
    Row(Modifier.fillMaxWidth().background(Color.White.copy(alpha = 0.04f), RoundedCornerShape(10.dp)).padding(horizontal = 12.dp, vertical = 10.dp),
        horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
        Column(Modifier.weight(1f)) {
            Text(item.displayName, color = if (available) Color.White else AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium))
            Text(if (!available) "Requires ${if (item.requiresWearable) "wearable" else "location"}" else item.description,
                color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
        }
        Switch(checked = enabled && available, onCheckedChange = { if (available) onToggle(it) }, enabled = available,
            colors = SwitchDefaults.colors(checkedThumbColor = Color.White, checkedTrackColor = AppTheme.AccentPurple,
                uncheckedThumbColor = Color.White.copy(alpha = 0.5f), uncheckedTrackColor = AppTheme.TrackColor))
    }
}

title: OnboardingScreen.kt
text:
package com.migraineme

import android.content.Context
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowForward
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import androidx.compose.runtime.rememberCoroutineScope

object OnboardingPrefs {
    private const val PREFS_NAME = "onboarding"
    private const val KEY_COMPLETED = "completed"
    fun isCompleted(context: Context): Boolean = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE).getBoolean(KEY_COMPLETED, false)
    fun setCompleted(context: Context) { context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE).edit().putBoolean(KEY_COMPLETED, true).apply() }
    fun reset(context: Context) { context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE).edit().putBoolean(KEY_COMPLETED, false).apply() }
}

private enum class PageId { WELCOME, HOW_IT_WORKS, LOADING_DATA, SETUP_LANDING }

@Composable
fun OnboardingScreen(
    startAtSetup: Boolean = false,
    onComplete: () -> Unit,
    onStartTour: () -> Unit = {},
    onStartSetup: () -> Unit = {},
    onTourSkipped: () -> Unit = {},
) {
    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext

    val pages = PageId.entries
    var currentIdx by remember { mutableStateOf(if (startAtSetup) pages.indexOf(PageId.SETUP_LANDING) else 0) }
    val currentPage = pages[currentIdx]

    // ── Observe seeder progress directly ──
    val seedProgress by DemoDataSeeder.progress.collectAsState()
    val dataReady by DemoDataSeeder.dataReady.collectAsState()
    var seedingStarted by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    // Helper: clean up demo data then go to setup landing (connections)
    fun skipAndClean() {
        OnboardingPrefs.setCompleted(appCtx)
        scope.launch(Dispatchers.IO) {
            DemoDataSeeder.clearDemoData(appCtx)
            kotlinx.coroutines.withContext(Dispatchers.Main) { onTourSkipped() }
        }
    }

    // ── Kick off seeding when we hit the LOADING_DATA page ──
    LaunchedEffect(currentPage) {
        if (currentPage == PageId.LOADING_DATA && !seedingStarted && !startAtSetup) {
            seedingStarted = true
            // Ensure userId is set before seeding
            withContext(Dispatchers.IO) {
                val token = SessionStore.getValidAccessToken(appCtx)
                if (token != null) {
                    var userId = SessionStore.readUserId(appCtx)
                    if (userId.isNullOrBlank()) {
                        userId = JwtUtils.extractUserIdFromAccessToken(token)
                        if (!userId.isNullOrBlank()) {
                            SessionStore.saveUserId(appCtx, userId)
                        }
                    }
                }
            }
            // Seed everything (including risk_score_live directly)
            launch(Dispatchers.IO) {
                DemoDataSeeder.seedDemoData(appCtx)
            }
        }
    }

    // ── Auto-advance to tour when data is ready ──
    LaunchedEffect(dataReady) {
        if (dataReady && currentPage == PageId.LOADING_DATA) {
            kotlinx.coroutines.delay(600L)
            onStartTour()
        }
    }

    val bgBrush = remember { Brush.verticalGradient(listOf(Color(0xFF1A0029), Color(0xFF2A003D), Color(0xFF1A0029))) }

    Box(Modifier.fillMaxSize().background(bgBrush)) {
        Column(Modifier.fillMaxSize()) {
            Spacer(Modifier.height(20.dp))

            Box(Modifier.weight(1f).fillMaxWidth()) {
                AnimatedContent(
                    targetState = currentIdx,
                    transitionSpec = {
                        if (targetState > initialState) slideInHorizontally { it } + fadeIn() togetherWith slideOutHorizontally { -it } + fadeOut()
                        else slideInHorizontally { -it } + fadeIn() togetherWith slideOutHorizontally { it } + fadeOut()
                    }, label = "page"
                ) { idx ->
                    when (pages[idx]) {
                        PageId.WELCOME -> WelcomePage()
                        PageId.HOW_IT_WORKS -> HowItWorksPage()
                        PageId.LOADING_DATA -> LoadingDataPage(
                            progress = seedProgress.fraction,
                            statusText = seedProgress.phase,
                            isComplete = dataReady
                        )
                        PageId.SETUP_LANDING -> SetupLandingPage()
                    }
                }
            }

            // ── Bottom buttons ──
            Row(
                Modifier.fillMaxWidth().padding(horizontal = 24.dp, vertical = 16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Left
                when (currentPage) {
                    PageId.WELCOME -> {
                        TextButton(onClick = { skipAndClean() }) {
                            Text("Skip", color = AppTheme.SubtleTextColor)
                        }
                    }
                    PageId.HOW_IT_WORKS -> {
                        TextButton(onClick = { currentIdx-- }) {
                            Text("Back", color = AppTheme.SubtleTextColor)
                        }
                    }
                    PageId.LOADING_DATA -> {
                        TextButton(onClick = { skipAndClean() }) {
                            Text("Skip", color = AppTheme.SubtleTextColor)
                        }
                    }
                    PageId.SETUP_LANDING -> {
                        TextButton(onClick = { OnboardingPrefs.setCompleted(appCtx); onComplete() }) {
                            Text("Skip", color = AppTheme.SubtleTextColor)
                        }
                    }
                }

                // Right
                when (currentPage) {
                    PageId.WELCOME -> {
                        Button(
                            onClick = { currentIdx++ },
                            colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            Text("Next"); Spacer(Modifier.width(4.dp))
                            Icon(Icons.AutoMirrored.Filled.ArrowForward, null, modifier = Modifier.size(18.dp))
                        }
                    }
                    PageId.HOW_IT_WORKS -> {
                        Button(
                            onClick = { currentIdx = pages.indexOf(PageId.LOADING_DATA) },
                            colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            Text("Take the Tour"); Spacer(Modifier.width(4.dp))
                            Icon(Icons.AutoMirrored.Filled.ArrowForward, null, modifier = Modifier.size(18.dp))
                        }
                    }
                    PageId.LOADING_DATA -> {
                        Button(
                            onClick = { onStartTour() },
                            enabled = dataReady,
                            colors = ButtonDefaults.buttonColors(
                                containerColor = AppTheme.AccentPink,
                                disabledContainerColor = AppTheme.AccentPink.copy(alpha = 0.3f)
                            ),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            if (dataReady) {
                                Text("Start Tour"); Spacer(Modifier.width(4.dp))
                                Icon(Icons.AutoMirrored.Filled.ArrowForward, null, modifier = Modifier.size(18.dp))
                            } else {
                                CircularProgressIndicator(Modifier.size(18.dp), color = Color.White, strokeWidth = 2.dp)
                                Spacer(Modifier.width(8.dp)); Text("Loading…")
                            }
                        }
                    }
                    PageId.SETUP_LANDING -> {
                        Button(
                            onClick = { OnboardingPrefs.setCompleted(appCtx); onStartSetup() },
                            colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            Text("Let's go"); Spacer(Modifier.width(4.dp))
                            Icon(Icons.AutoMirrored.Filled.ArrowForward, null, modifier = Modifier.size(18.dp))
                        }
                    }
                }
            }
        }
    }
}

// ═════════════════════════════════════════════════════════════════════════════
// Loading Data Page
// ═════════════════════════════════════════════════════════════════════════════

@Composable
private fun LoadingDataPage(progress: Float, statusText: String, isComplete: Boolean) {
    val animatedProgress by animateFloatAsState(
        targetValue = progress,
        animationSpec = tween(600, easing = FastOutSlowInEasing),
        label = "progress"
    )

    val pulse = rememberInfiniteTransition(label = "pulse")
    val pulseScale by pulse.animateFloat(0.95f, 1.08f, infiniteRepeatable(tween(1200), RepeatMode.Reverse), label = "s")
    val pulseAlpha by pulse.animateFloat(0.4f, 0.8f, infiniteRepeatable(tween(1200), RepeatMode.Reverse), label = "a")

    data class LoadStep(val label: String, val threshold: Float, val icon: androidx.compose.ui.graphics.vector.ImageVector)
    val steps = listOf(
        LoadStep("Account", 0.05f, Icons.Outlined.Person),
        LoadStep("Sleep & health data", 0.25f, Icons.Outlined.FavoriteBorder),
        LoadStep("Weather & nutrition", 0.50f, Icons.Outlined.Cloud),
        LoadStep("Migraine history", 0.70f, Icons.Outlined.Psychology),
        LoadStep("Risk gauge", 0.85f, Icons.Outlined.Speed),
        LoadStep("Ready!", 1.0f, Icons.Outlined.CheckCircle),
    )

    Column(
        Modifier.fillMaxSize().padding(horizontal = 32.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Animated icon
        Box(
            Modifier
                .size((80 * if (!isComplete) pulseScale else 1f).dp)
                .background(
                    Brush.linearGradient(listOf(
                        AppTheme.AccentPurple.copy(alpha = if (!isComplete) pulseAlpha else 0.8f),
                        AppTheme.AccentPink.copy(alpha = if (!isComplete) pulseAlpha * 0.7f else 0.6f)
                    )),
                    CircleShape
                ),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                if (isComplete) Icons.Outlined.CheckCircle else Icons.Outlined.CloudSync,
                null, tint = Color.White, modifier = Modifier.size(40.dp)
            )
        }

        Spacer(Modifier.height(28.dp))

        Text(
            if (isComplete) "All set!" else "Preparing your onboarding",
            color = Color.White,
            style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold),
            textAlign = TextAlign.Center
        )

        Spacer(Modifier.height(8.dp))

        Text(
            if (isComplete) "Your dashboard is ready for the tour."
            else "We're getting everything ready so you\ncan see the app in action.",
            color = AppTheme.BodyTextColor,
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center
        )

        Spacer(Modifier.height(32.dp))

        // Progress bar
        Box(
            Modifier.fillMaxWidth().height(6.dp)
                .clip(RoundedCornerShape(3.dp))
                .background(AppTheme.TrackColor)
        ) {
            Box(
                Modifier.fillMaxWidth(animatedProgress).height(6.dp)
                    .clip(RoundedCornerShape(3.dp))
                    .background(Brush.horizontalGradient(listOf(AppTheme.AccentPurple, AppTheme.AccentPink)))
            )
        }

        Spacer(Modifier.height(24.dp))

        // Step checklist
        Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
            steps.forEach { step ->
                val isDone = animatedProgress >= step.threshold
                val isActive = !isDone && animatedProgress >= (step.threshold - 0.15f)
                val alpha by animateFloatAsState(
                    when { isDone -> 1f; isActive -> 0.9f; else -> 0.35f },
                    tween(400), label = "a_${step.label}"
                )

                Row(
                    Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Box(
                        Modifier.size(32.dp).background(
                            when {
                                isDone -> AppTheme.AccentPurple.copy(alpha = 0.25f)
                                isActive -> AppTheme.AccentPink.copy(alpha = 0.15f)
                                else -> Color.White.copy(alpha = 0.05f)
                            }, CircleShape
                        ),
                        contentAlignment = Alignment.Center
                    ) {
                        when {
                            isDone -> Icon(Icons.Outlined.Check, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(16.dp))
                            isActive -> CircularProgressIndicator(Modifier.size(14.dp), AppTheme.AccentPink, strokeWidth = 2.dp)
                            else -> Icon(step.icon, null, tint = Color.White.copy(alpha = 0.3f), modifier = Modifier.size(16.dp))
                        }
                    }
                    Text(
                        step.label,
                        color = Color.White.copy(alpha = alpha),
                        style = MaterialTheme.typography.bodyMedium.copy(
                            fontWeight = if (isDone || isActive) FontWeight.Medium else FontWeight.Normal
                        )
                    )
                }
            }
        }

        Spacer(Modifier.height(16.dp))

        // Current status text
        AnimatedContent(
            targetState = statusText,
            transitionSpec = { fadeIn(tween(300)) togetherWith fadeOut(tween(200)) },
            label = "status"
        ) { text ->
            Text(
                text,
                color = if (isComplete) AppTheme.AccentPurple else AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.labelMedium.copy(
                    fontWeight = if (isComplete) FontWeight.SemiBold else FontWeight.Normal
                ),
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

// ═════════════════════════════════════════════════════════════════════════════

@Composable
private fun SetupLandingPage() {
    Column(
        Modifier.fillMaxSize().padding(horizontal = 32.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row(horizontalArrangement = Arrangement.spacedBy((-8).dp)) {
            Box(Modifier.size(56.dp).background(AppTheme.AccentPurple.copy(alpha = 0.2f), CircleShape), contentAlignment = Alignment.Center) {
                Icon(Icons.Outlined.Link, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(28.dp))
            }
            Box(Modifier.size(56.dp).background(AppTheme.AccentPink.copy(alpha = 0.2f), CircleShape), contentAlignment = Alignment.Center) {
                Icon(Icons.Outlined.Storage, null, tint = AppTheme.AccentPink, modifier = Modifier.size(28.dp))
            }
            Box(Modifier.size(56.dp).background(Color(0xFFFFB74D).copy(alpha = 0.2f), CircleShape), contentAlignment = Alignment.Center) {
                Icon(Icons.Outlined.AutoAwesome, null, tint = Color(0xFFFFB74D), modifier = Modifier.size(28.dp))
            }
        }

        Spacer(Modifier.height(28.dp))
        Text("Now let's set up\nyour data", color = Color.White, style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold), textAlign = TextAlign.Center)
        Spacer(Modifier.height(16.dp))
        Text("We'll connect your wearables, choose health metrics to track, then AI will personalise your entire app. Takes about 2 minutes.",
            color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyLarge, textAlign = TextAlign.Center, modifier = Modifier.padding(horizontal = 8.dp))
        Spacer(Modifier.height(28.dp))
        SetupStepPreview(Icons.Outlined.Link, "1. Connect", "WHOOP, Health Connect")
        Spacer(Modifier.height(10.dp))
        SetupStepPreview(Icons.Outlined.Storage, "2. Configure", "Choose which data to collect")
        Spacer(Modifier.height(10.dp))
        SetupStepPreview(Icons.Outlined.AutoAwesome, "3. AI Personalisation", "Answer a few questions, AI sets up everything")
    }
}

@Composable
private fun SetupStepPreview(icon: androidx.compose.ui.graphics.vector.ImageVector, title: String, subtitle: String) {
    Row(
        Modifier.fillMaxWidth().background(Color.White.copy(alpha = 0.04f), RoundedCornerShape(12.dp)).padding(horizontal = 16.dp, vertical = 12.dp),
        horizontalArrangement = Arrangement.spacedBy(12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(Modifier.size(40.dp).background(AppTheme.AccentPurple.copy(alpha = 0.15f), CircleShape), contentAlignment = Alignment.Center) {
            Icon(icon, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
        }
        Column {
            Text(title, color = Color.White, style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold))
            Text(subtitle, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
        }
    }
}

title: PainLocationScreen.kt
text:
package com.migraineme

import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.BorderStroke
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.LocationOn
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.lerp
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController

// ── Pain point data model ──────────────────────────────────────
data class PainPoint(
    val id: String,
    val label: String,
    val xPct: Float,   // 0..1 percentage position on image
    val yPct: Float,
    val view: PainView  // which view(s) this point appears on
)

enum class PainView { FRONT, BACK, BOTH }

// ── All pain points ────────────────────────────────────────────
val FRONT_PAIN_POINTS = listOf(
    PainPoint("vertex",          "Top of Head",       0.496f, 0.190f, PainView.BOTH),
    PainPoint("forehead_center", "Forehead Center",   0.499f, 0.257f, PainView.FRONT),
    PainPoint("forehead_left",   "Forehead Left",     0.341f, 0.257f, PainView.FRONT),
    PainPoint("forehead_right",  "Forehead Right",    0.654f, 0.253f, PainView.FRONT),
    PainPoint("brow_left",       "Left Brow",         0.386f, 0.312f, PainView.FRONT),
    PainPoint("brow_right",      "Right Brow",        0.624f, 0.315f, PainView.FRONT),
    PainPoint("temple_left",     "Left Temple",       0.241f, 0.332f, PainView.FRONT),
    PainPoint("temple_right",    "Right Temple",      0.756f, 0.338f, PainView.FRONT),
    PainPoint("eye_left",        "Left Eye",          0.354f, 0.365f, PainView.FRONT),
    PainPoint("eye_right",       "Right Eye",         0.656f, 0.365f, PainView.FRONT),
    PainPoint("ear_left",        "Left Ear",          0.249f, 0.402f, PainView.FRONT),
    PainPoint("ear_right",       "Right Ear",         0.744f, 0.402f, PainView.FRONT),
    PainPoint("nose_bridge",     "Nose Bridge",       0.496f, 0.360f, PainView.FRONT),
    PainPoint("sinus_left",      "Left Sinus",        0.391f, 0.410f, PainView.FRONT),
    PainPoint("sinus_right",     "Right Sinus",       0.609f, 0.410f, PainView.FRONT),
    PainPoint("jaw_left",        "Left Jaw / TMJ",    0.324f, 0.488f, PainView.FRONT),
    PainPoint("jaw_right",       "Right Jaw / TMJ",   0.680f, 0.492f, PainView.FRONT),
    PainPoint("teeth_left",      "Teeth Left",        0.448f, 0.492f, PainView.FRONT),
    PainPoint("teeth_right",     "Teeth Right",       0.555f, 0.492f, PainView.FRONT),
    PainPoint("neck_left",       "Neck Left",         0.365f, 0.595f, PainView.BOTH),
    PainPoint("neck_right",      "Neck Right",        0.637f, 0.598f, PainView.BOTH),
)

val BACK_PAIN_POINTS = listOf(
    PainPoint("vertex",            "Top of Head",         0.496f, 0.177f, PainView.BOTH),
    PainPoint("back_upper_left",   "Back Upper Left",     0.345f, 0.222f, PainView.BACK),
    PainPoint("back_upper_right",  "Back Upper Right",    0.651f, 0.222f, PainView.BACK),
    PainPoint("occipital_center",  "Occipital Center",    0.500f, 0.285f, PainView.BACK),
    PainPoint("behind_ear_left",   "Behind Left Ear",     0.298f, 0.339f, PainView.BACK),
    PainPoint("behind_ear_right",  "Behind Right Ear",    0.712f, 0.339f, PainView.BACK),
    PainPoint("base_skull_left",   "Base of Skull Left",  0.383f, 0.420f, PainView.BACK),
    PainPoint("base_skull_center", "Base of Skull Center", 0.500f, 0.405f, PainView.BACK),
    PainPoint("base_skull_right",  "Base of Skull Right", 0.627f, 0.420f, PainView.BACK),
    PainPoint("neck_left",         "Neck Left",           0.380f, 0.528f, PainView.BOTH),
    PainPoint("neck_right",        "Neck Right",          0.625f, 0.528f, PainView.BOTH),
    PainPoint("upper_back_left",   "Upper Back Left",     0.275f, 0.613f, PainView.BACK),
    PainPoint("upper_back_right",  "Upper Back Right",    0.725f, 0.613f, PainView.BACK),
    PainPoint("upper_back_center", "Upper Back Center",   0.500f, 0.662f, PainView.BACK),
    PainPoint("shoulder_left",     "Left Shoulder",       0.090f, 0.667f, PainView.BACK),
    PainPoint("shoulder_right",    "Right Shoulder",      0.900f, 0.667f, PainView.BACK),
    PainPoint("center_back",       "Center / Lower Back", 0.500f, 0.780f, PainView.BACK),
)

val ALL_PAIN_POINTS_MAP: Map<String, String> by lazy {
    (FRONT_PAIN_POINTS + BACK_PAIN_POINTS)
        .distinctBy { it.id }
        .associate { it.id to it.label }
}

// ── Main screen composable ─────────────────────────────────────
@OptIn(ExperimentalLayoutApi::class)
@Composable
fun PainLocationScreen(
    navController: NavController,
    vm: LogViewModel,
    onClose: () -> Unit = {}
) {
    val draft by vm.draft.collectAsState()
    val selected = remember { mutableStateListOf<String>() }
    var severityValue by rememberSaveable { mutableStateOf(5f) }

    // Sync from draft on first composition
    LaunchedEffect(draft.painLocations) {
        if (selected.isEmpty() && draft.painLocations.isNotEmpty()) {
            selected.addAll(draft.painLocations)
        }
    }
    LaunchedEffect(draft.migraine) {
        draft.migraine?.let { m ->
            severityValue = (m.severity ?: 5).coerceIn(1, 10).toFloat()
        }
    }

    var showBack by rememberSaveable { mutableStateOf(false) }
    val scroll = rememberScrollState()

    fun syncToDraft() { vm.setPainLocationsDraft(selected.toList()) }

    ScrollFadeContainer(scrollState = scroll) { scrollState ->
        ScrollableScreenContent(scrollState = scrollState, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Timing", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Pain", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // ── 1. Pain Hero Card ──
            HeroCard {
                Icon(Icons.Outlined.LocationOn, contentDescription = null, tint = AppTheme.AccentPink, modifier = Modifier.size(40.dp))
                Text("Pain", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    "Rate the severity and mark where you feel it",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // ── 2. Severity ──
            BaseCard {
                val sev = severityValue.toInt()
                val sevColor = lerp(AppTheme.AccentPurple, AppTheme.AccentPink, (sev - 1) / 9f)

                Text("Severity", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))

                Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.Center) {
                    Text("$sev", color = sevColor, style = MaterialTheme.typography.headlineLarge.copy(fontWeight = FontWeight.Bold))
                    Text(" / 10", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.titleMedium)
                }

                Slider(
                    value = severityValue,
                    onValueChange = { v ->
                        severityValue = v.coerceIn(1f, 10f)
                        vm.setMigraineDraft(severity = severityValue.toInt())
                    },
                    valueRange = 1f..10f,
                    steps = 8,
                    modifier = Modifier.fillMaxWidth(),
                    colors = SliderDefaults.colors(
                        thumbColor = AppTheme.AccentPurple,
                        activeTrackColor = AppTheme.AccentPurple,
                        inactiveTrackColor = AppTheme.TrackColor
                    )
                )

                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
                    Text("Mild", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                    Text("Severe", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // ── 3. Where did you feel the pain? (BaseCard) ──
            BaseCard {
                Text("Where did you feel the pain?", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Text(
                    "Tap the dots on the head to mark where it hurts",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )

                // Selected area count + chips
                if (selected.isNotEmpty()) {
                    Spacer(Modifier.height(6.dp))
                    Text(
                        "${selected.size} area${if (selected.size > 1) "s" else ""} selected",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Spacer(Modifier.height(4.dp))
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(6.dp),
                        verticalArrangement = Arrangement.spacedBy(6.dp)
                    ) {
                        selected.toList().forEach { id ->
                            val label = ALL_PAIN_POINTS_MAP[id] ?: id
                            AssistChip(
                                onClick = { selected.remove(id); syncToDraft() },
                                label = { Text(label, fontSize = 11.sp) },
                                trailingIcon = { Text("✕", fontSize = 10.sp, color = AppTheme.AccentPink) },
                                colors = AssistChipDefaults.assistChipColors(
                                    containerColor = AppTheme.AccentPurple.copy(alpha = 0.20f),
                                    labelColor = Color.White
                                ),
                                border = AssistChipDefaults.assistChipBorder(
                                    enabled = true,
                                    borderColor = AppTheme.AccentPurple.copy(alpha = 0.35f)
                                )
                            )
                        }
                    }
                }

                Spacer(Modifier.height(10.dp))

                // Front / Back toggle
                ViewToggle(showBack = showBack, onToggle = { showBack = it })

                Spacer(Modifier.height(12.dp))

                // Image with overlay dots
                PainPointOverlay(
                    imageRes = if (showBack) R.drawable.painpointsback else R.drawable.painpoints,
                    points = if (showBack) BACK_PAIN_POINTS else FRONT_PAIN_POINTS,
                    selected = selected,
                    onToggle = { id ->
                        if (id in selected) selected.remove(id) else selected.add(id)
                        syncToDraft()
                    }
                )
            }

            // Navigation
            Row(
                Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }
                Button(
                    onClick = { navController.navigate(Routes.PRODROMES_LOG) },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text("Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

// ── Front/Back toggle ──────────────────────────────────────────
@Composable
private fun ViewToggle(showBack: Boolean, onToggle: (Boolean) -> Unit) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(12.dp))
            .background(Color.White.copy(alpha = 0.08f))
            .padding(4.dp),
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        ToggleButton("Front", !showBack, { onToggle(false) }, Modifier.weight(1f))
        ToggleButton("Back", showBack, { onToggle(true) }, Modifier.weight(1f))
    }
}

@Composable
private fun ToggleButton(label: String, selected: Boolean, onClick: () -> Unit, modifier: Modifier = Modifier) {
    val bg by animateColorAsState(
        if (selected) AppTheme.AccentPurple else Color.Transparent,
        label = "toggleBg"
    )
    val fg by animateColorAsState(
        if (selected) Color.White else AppTheme.SubtleTextColor,
        label = "toggleFg"
    )

    Surface(
        modifier = modifier
            .clip(RoundedCornerShape(8.dp))
            .clickable(onClick = onClick),
        color = bg,
        shape = RoundedCornerShape(8.dp)
    ) {
        Text(
            text = label,
            modifier = Modifier
                .padding(vertical = 10.dp)
                .fillMaxWidth(),
            textAlign = TextAlign.Center,
            fontWeight = if (selected) FontWeight.SemiBold else FontWeight.Normal,
            color = fg,
            fontSize = 14.sp
        )
    }
}

// ── Image + dots overlay (ORIGINAL style) ──────────────────────
@Composable
private fun PainPointOverlay(
    imageRes: Int,
    points: List<PainPoint>,
    selected: List<String>,
    onToggle: (String) -> Unit
) {
    val density = LocalDensity.current
    var imageSize by remember { mutableStateOf(IntSize.Zero) }

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(16.dp))
    ) {
        // Head image
        Image(
            painter = painterResource(imageRes),
            contentDescription = "Pain location diagram",
            contentScale = ContentScale.FillWidth,
            modifier = Modifier
                .fillMaxWidth()
                .onGloballyPositioned { imageSize = it.size }
        )

        // Overlay dots
        if (imageSize.width > 0 && imageSize.height > 0) {
            points.forEach { point ->
                val isSelected = point.id in selected

                // Convert percentage to dp offset
                val xPx = point.xPct * imageSize.width
                val yPx = point.yPct * imageSize.height
                val xDp = with(density) { xPx.toDp() }
                val yDp = with(density) { yPx.toDp() }

                val dotSize = 30.dp

                // Pulsing glow for selected dots
                val infiniteTransition = rememberInfiniteTransition(label = "pulse_${point.id}")
                val glowAlpha by infiniteTransition.animateFloat(
                    initialValue = 0.3f,
                    targetValue = 0.7f,
                    animationSpec = infiniteRepeatable(
                        animation = tween(1200, easing = EaseInOutSine),
                        repeatMode = RepeatMode.Reverse
                    ),
                    label = "glow_${point.id}"
                )

                Box(
                    modifier = Modifier
                        .offset(
                            x = xDp - dotSize / 2,
                            y = yDp - dotSize / 2
                        )
                        .size(dotSize)
                        .then(
                            if (isSelected) Modifier.shadow(
                                elevation = 8.dp,
                                shape = CircleShape,
                                ambientColor = Color(0xFFB880FF).copy(alpha = glowAlpha),
                                spotColor = Color(0xFFB880FF).copy(alpha = glowAlpha)
                            ) else Modifier
                        )
                        .clip(CircleShape)
                        .background(
                            if (isSelected)
                                Brush.radialGradient(
                                    colors = listOf(
                                        Color(0xFFCE9FFF).copy(alpha = 0.80f),
                                        Color(0xFFAA70EE).copy(alpha = 0.55f)
                                    )
                                )
                            else
                                Brush.radialGradient(
                                    colors = listOf(
                                        Color(0xFF7B5EA8).copy(alpha = 0.55f),
                                        Color(0xFF6A4D96).copy(alpha = 0.40f)
                                    )
                                )
                        )
                        .clickable(
                            interactionSource = remember { MutableInteractionSource() },
                            indication = null
                        ) { onToggle(point.id) },
                    contentAlignment = Alignment.Center
                ) {
                    // Inner dot ring
                    Box(
                        modifier = Modifier
                            .size(if (isSelected) 14.dp else 10.dp)
                            .clip(CircleShape)
                            .background(
                                if (isSelected)
                                    Color(0xFFE0CCFF).copy(alpha = 0.90f)
                                else
                                    Color(0xFF8B6FBB).copy(alpha = 0.70f)
                            )
                    )
                }
            }
        }
    }
}

title: PermissionHelper.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.os.PowerManager
import androidx.core.content.ContextCompat
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.health.connect.client.records.NutritionRecord
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

object PermissionHelper {

    suspend fun hasHealthConnectNutrition(context: Context): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val status = HealthConnectClient.getSdkStatus(context)
                if (status != HealthConnectClient.SDK_AVAILABLE) return@withContext false

                val client = HealthConnectClient.getOrCreate(context)
                val granted = client.permissionController.getGrantedPermissions()
                HealthPermission.getReadPermission(NutritionRecord::class) in granted
            } catch (_: Exception) {
                false
            }
        }
    }

    suspend fun hasHealthConnectMenstruation(context: Context): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val status = HealthConnectClient.getSdkStatus(context)
                if (status != HealthConnectClient.SDK_AVAILABLE) return@withContext false

                val client = HealthConnectClient.getOrCreate(context)
                val granted = client.permissionController.getGrantedPermissions()
                HealthPermission.getReadPermission(MenstruationPeriodRecord::class) in granted
            } catch (_: Exception) {
                false
            }
        }
    }

    fun hasMicrophone(context: Context): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
    }

    fun hasScreenTime(context: Context): Boolean {
        return ScreenTimePermissionHelper.hasPermission(context)
    }

    fun isBatteryOptimizationExempt(context: Context): Boolean {
        val pm = context.getSystemService(Context.POWER_SERVICE) as? PowerManager
            ?: return false
        return pm.isIgnoringBatteryOptimizations(context.packageName)
    }
}

title: PhoneBehaviorCollector.kt
text:
// FILE: app/src/main/java/com/migraineme/PhoneBehaviorCollector.kt
package com.migraineme

import android.app.usage.UsageEvents
import android.app.usage.UsageStatsManager
import android.content.Context
import android.content.res.Configuration
import android.media.AudioManager
import android.os.Build
import android.provider.Settings
import android.util.Log
import java.time.LocalDate
import java.time.ZoneId

/**
 * Point-in-time snapshot of phone behavioral signals.
 */
data class PhoneBehaviorSnapshot(
    val brightness: Int,          // 0-255 raw Android brightness
    val volumePct: Int,           // 0-100 media volume as percentage
    val isDarkMode: Boolean,      // true = dark mode active
    val unlockCount: Int          // cumulative unlock count for the day so far
)

/**
 * Reads phone behavioral signals from Android system APIs.
 *
 * - Brightness: Settings.System.SCREEN_BRIGHTNESS (0-255)
 * - Volume: AudioManager media stream volume as percentage
 * - Dark mode: Configuration.uiMode night mask
 * - Unlock count: UsageStatsManager KEYGUARD_HIDDEN events (requires PACKAGE_USAGE_STATS)
 */
object PhoneBehaviorCollector {

    private const val TAG = "PhoneBehaviorCollector"

    /**
     * Collect a single snapshot of all phone behavioral metrics.
     *
     * @param context Application context
     * @return PhoneBehaviorSnapshot, or null on critical error
     */
    fun collectSnapshot(context: Context): PhoneBehaviorSnapshot? {
        return try {
            val brightness = getBrightness(context)
            val volumePct = getMediaVolumePct(context)
            val isDark = isDarkMode(context)
            val unlocks = getUnlockCountToday(context)

            Log.d(TAG, "Snapshot: brightness=$brightness, volume=$volumePct%, dark=$isDark, unlocks=$unlocks")

            PhoneBehaviorSnapshot(
                brightness = brightness,
                volumePct = volumePct,
                isDarkMode = isDark,
                unlockCount = unlocks
            )
        } catch (e: Exception) {
            Log.e(TAG, "Error collecting phone behavior snapshot", e)
            null
        }
    }

    // ─── Brightness ──────────────────────────────────────────────────────────

    /**
     * Read current screen brightness (0-255).
     * Falls back to 128 if adaptive brightness is on and manual value is unavailable.
     */
    fun getBrightness(context: Context): Int {
        return try {
            Settings.System.getInt(
                context.contentResolver,
                Settings.System.SCREEN_BRIGHTNESS,
                128 // default if unreadable
            )
        } catch (e: Exception) {
            Log.w(TAG, "Could not read brightness", e)
            128
        }
    }

    // ─── Volume ──────────────────────────────────────────────────────────────

    /**
     * Read current media volume as a percentage (0-100).
     */
    fun getMediaVolumePct(context: Context): Int {
        return try {
            val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as? AudioManager
                ?: return 50

            val current = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)
            val max = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)

            if (max <= 0) return 0
            ((current.toFloat() / max) * 100).toInt().coerceIn(0, 100)
        } catch (e: Exception) {
            Log.w(TAG, "Could not read media volume", e)
            50
        }
    }

    // ─── Dark Mode ───────────────────────────────────────────────────────────

    /**
     * Check if the device is currently in dark mode.
     */
    fun isDarkMode(context: Context): Boolean {
        return try {
            val nightModeFlags = context.resources.configuration.uiMode and
                    Configuration.UI_MODE_NIGHT_MASK
            nightModeFlags == Configuration.UI_MODE_NIGHT_YES
        } catch (e: Exception) {
            Log.w(TAG, "Could not read dark mode status", e)
            false
        }
    }

    // ─── Unlock Count ────────────────────────────────────────────────────────

    /**
     * Count KEYGUARD_HIDDEN events for today using UsageStatsManager.
     * Requires PACKAGE_USAGE_STATS permission.
     *
     * @return Number of unlocks today, or 0 if permission denied or error
     */
    fun getUnlockCountToday(context: Context): Int {
        return getUnlockCount(context, LocalDate.now().toString())
    }

    /**
     * Count KEYGUARD_HIDDEN events for a specific date.
     *
     * @param context Application context
     * @param date Date string in YYYY-MM-DD format
     * @return Number of unlocks on that date
     */
    fun getUnlockCount(context: Context, date: String): Int {
        return try {
            if (!ScreenTimeCollector.hasUsageStatsPermission(context)) {
                Log.w(TAG, "PACKAGE_USAGE_STATS permission not granted — unlock count unavailable")
                return 0
            }

            val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE)
                    as? UsageStatsManager ?: return 0

            val localDate = LocalDate.parse(date)
            val zoneId = ZoneId.systemDefault()
            val startMillis = localDate.atStartOfDay(zoneId).toInstant().toEpochMilli()
            val endMillis = localDate.plusDays(1).atStartOfDay(zoneId).toInstant().toEpochMilli()

            val events = usageStatsManager.queryEvents(startMillis, endMillis)
            val event = UsageEvents.Event()
            var count = 0

            while (events.hasNextEvent()) {
                events.getNextEvent(event)
                if (event.eventType == UsageEvents.Event.KEYGUARD_HIDDEN) {
                    count++
                }
            }

            Log.d(TAG, "Unlock count for $date: $count")
            count
        } catch (e: Exception) {
            Log.e(TAG, "Error counting unlocks for $date", e)
            0
        }
    }
}

title: PhoneBehaviorSyncWorker.kt
text:
// FILE: app/src/main/java/com/migraineme/PhoneBehaviorSyncWorker.kt
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.BackoffPolicy
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Instant
import java.util.concurrent.TimeUnit

/**
 * Phone behavior sync worker — triggered by FCM (hourly via sync_hourly).
 *
 * Collects a single snapshot of brightness, volume, dark mode, and unlock count,
 * then inserts one row into each of the 4 sample tables:
 *   - phone_brightness_samples
 *   - phone_volume_samples
 *   - phone_dark_mode_samples
 *   - phone_unlock_samples
 */
class PhoneBehaviorSyncWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        Log.d(TAG, "Worker started")

        try {
            val ctx = applicationContext

            // Get valid Supabase access token
            val access = SessionStore.getValidAccessToken(ctx)
            if (access.isNullOrBlank()) {
                Log.d(TAG, "No valid access token — skipping")
                return@withContext Result.success()
            }

            val userId = SessionStore.readUserId(ctx)
            if (userId.isNullOrBlank()) {
                Log.d(TAG, "No user ID — skipping")
                return@withContext Result.success()
            }

            // Check which metrics are enabled
            val enabledMetrics = try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(ctx)
                settings.filter { it.enabled }.map { it.metric }.toSet()
            } catch (e: Exception) {
                Log.w(TAG, "Failed to check metric settings: ${e.message}")
                return@withContext Result.success()
            }

            val anyEnabled = METRICS.any { it in enabledMetrics }
            if (!anyEnabled) {
                Log.d(TAG, "No phone behavior metrics enabled — skipping")
                return@withContext Result.success()
            }

            // Collect snapshot
            val snapshot = PhoneBehaviorCollector.collectSnapshot(ctx)
            if (snapshot == null) {
                Log.w(TAG, "Failed to collect snapshot")
                return@withContext Result.success()
            }

            val svc = SupabasePersonalService(ctx)
            val now = Instant.now().toString()
            var ok = 0
            var fail = 0

            // Insert brightness sample
            if ("phone_brightness_daily" in enabledMetrics) {
                runCatching {
                    svc.insertPhoneBrightnessSample(access, userId, now, snapshot.brightness)
                    ok++
                    Log.d(TAG, "Inserted brightness sample: ${snapshot.brightness}")
                }.onFailure { e ->
                    fail++
                    Log.e(TAG, "Failed to insert brightness sample", e)
                }
            }

            // Insert volume sample
            if ("phone_volume_daily" in enabledMetrics) {
                runCatching {
                    svc.insertPhoneVolumeSample(access, userId, now, snapshot.volumePct)
                    ok++
                    Log.d(TAG, "Inserted volume sample: ${snapshot.volumePct}%")
                }.onFailure { e ->
                    fail++
                    Log.e(TAG, "Failed to insert volume sample", e)
                }
            }

            // Insert dark mode sample
            if ("phone_dark_mode_daily" in enabledMetrics) {
                runCatching {
                    svc.insertPhoneDarkModeSample(access, userId, now, snapshot.isDarkMode)
                    ok++
                    Log.d(TAG, "Inserted dark mode sample: ${snapshot.isDarkMode}")
                }.onFailure { e ->
                    fail++
                    Log.e(TAG, "Failed to insert dark mode sample", e)
                }
            }

            // Insert unlock sample
            if ("phone_unlock_daily" in enabledMetrics) {
                runCatching {
                    svc.insertPhoneUnlockSample(access, userId, now, snapshot.unlockCount)
                    ok++
                    Log.d(TAG, "Inserted unlock sample: ${snapshot.unlockCount}")
                }.onFailure { e ->
                    fail++
                    Log.e(TAG, "Failed to insert unlock sample", e)
                }
            }

            Log.d(TAG, "Done: $ok inserted, $fail failed")
            Result.success()

        } catch (t: Throwable) {
            Log.e(TAG, "Worker error", t)
            Result.retry()
        }
    }

    companion object {
        private const val TAG = "PhoneBehaviorSync"
        private const val UNIQUE_WORK = "phone_behavior_sync"

        /** Metric keys that this worker serves (matched against metric_settings) */
        val METRICS = setOf(
            "phone_brightness_daily",
            "phone_volume_daily",
            "phone_dark_mode_daily",
            "phone_unlock_daily"
        )

        /**
         * Run once immediately — called by FCM handler.
         */
        fun runOnce(context: Context) {
            Log.d(TAG, "Enqueuing phone behavior sync")
            val req = OneTimeWorkRequestBuilder<PhoneBehaviorSyncWorker>()
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 5, TimeUnit.MINUTES)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_WORK, ExistingWorkPolicy.REPLACE, req
            )
        }
    }
}

title: PhoneSleepCollector.kt
text:
package com.migraineme

import android.app.usage.UsageEvents
import android.app.usage.UsageStatsManager
import android.content.Context
import android.util.Log
import java.time.LocalDate
import java.time.ZoneId

data class PhoneSleepData(
    val date: String,               // YYYY-MM-DD (the night's date = evening date)
    val fellAsleepMillis: Long,     // epoch millis of estimated sleep start
    val wokeUpMillis: Long,         // epoch millis of estimated wake up
    val durationMinutes: Long,      // total sleep duration in minutes
    val fellAsleepIso: String,      // ISO-8601 timestamp
    val wokeUpIso: String           // ISO-8601 timestamp
)

/**
 * Estimates sleep timing from phone usage patterns.
 *
 * Analyzes UsageStatsManager events to find the longest screen-off gap
 * during nighttime hours (20:00 → 12:00 next day).
 *
 * Logic:
 * - Query all MOVE_TO_FOREGROUND events in the 20:00–12:00 window
 * - The longest gap between consecutive foreground events = sleep period
 * - Start of gap = estimated fell asleep time
 * - End of gap = estimated woke up time
 *
 * Requires PACKAGE_USAGE_STATS permission.
 */
object PhoneSleepCollector {

    private const val TAG = "PhoneSleepCollector"
    private const val MIN_SLEEP_MINUTES = 120L  // ignore gaps shorter than 2 hours

    /**
     * Estimate sleep for a given night.
     *
     * @param context Application context
     * @param date The evening date (YYYY-MM-DD). Analyzes 20:00 on this date → 12:00 next day.
     * @return PhoneSleepData or null if no usable data / permission denied
     */
    fun estimateSleep(context: Context, date: String): PhoneSleepData? {
        try {
            if (!ScreenTimeCollector.hasUsageStatsPermission(context)) {
                Log.w(TAG, "PACKAGE_USAGE_STATS permission not granted")
                return null
            }

            val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE)
                    as? UsageStatsManager
            if (usageStatsManager == null) {
                Log.e(TAG, "UsageStatsManager not available")
                return null
            }

            val localDate = LocalDate.parse(date)
            val zoneId = ZoneId.systemDefault()

            // Window: 20:00 on date → 12:00 on date+1
            val windowStart = localDate.atTime(20, 0).atZone(zoneId).toInstant().toEpochMilli()
            val windowEnd = localDate.plusDays(1).atTime(12, 0).atZone(zoneId).toInstant().toEpochMilli()

            Log.d(TAG, "Analyzing sleep window for $date: 20:00-12:00")

            // Collect all MOVE_TO_FOREGROUND event timestamps
            val foregroundTimestamps = mutableListOf<Long>()

            // Add window boundaries as implicit events
            foregroundTimestamps.add(windowStart)

            val events = usageStatsManager.queryEvents(windowStart, windowEnd)
            val event = UsageEvents.Event()

            while (events.hasNextEvent()) {
                events.getNextEvent(event)
                if (event.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND) {
                    foregroundTimestamps.add(event.timeStamp)
                }
            }

            foregroundTimestamps.add(windowEnd)
            foregroundTimestamps.sort()

            if (foregroundTimestamps.size < 2) {
                Log.d(TAG, "Not enough events to estimate sleep for $date")
                return null
            }

            // Find the longest gap between consecutive foreground events
            var longestGapStart = 0L
            var longestGapEnd = 0L
            var longestGapMs = 0L

            for (i in 0 until foregroundTimestamps.size - 1) {
                val gapMs = foregroundTimestamps[i + 1] - foregroundTimestamps[i]
                if (gapMs > longestGapMs) {
                    longestGapMs = gapMs
                    longestGapStart = foregroundTimestamps[i]
                    longestGapEnd = foregroundTimestamps[i + 1]
                }
            }

            val durationMinutes = longestGapMs / 1000 / 60

            if (durationMinutes < MIN_SLEEP_MINUTES) {
                Log.d(TAG, "Longest gap for $date is ${durationMinutes}min — too short, skipping")
                return null
            }

            val fellAsleepInstant = java.time.Instant.ofEpochMilli(longestGapStart)
            val wokeUpInstant = java.time.Instant.ofEpochMilli(longestGapEnd)

            Log.d(TAG, "Estimated sleep for $date: ${fellAsleepInstant} → ${wokeUpInstant} (${durationMinutes}min)")

            return PhoneSleepData(
                date = date,
                fellAsleepMillis = longestGapStart,
                wokeUpMillis = longestGapEnd,
                durationMinutes = durationMinutes,
                fellAsleepIso = fellAsleepInstant.toString(),
                wokeUpIso = wokeUpInstant.toString()
            )

        } catch (e: Exception) {
            Log.e(TAG, "Error estimating sleep for $date", e)
            return null
        }
    }
}

title: PhoneSleepSyncWorker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.BackoffPolicy
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import java.util.concurrent.TimeUnit

/**
 * Phone-based sleep sync worker - triggered by FCM (hourly via sync_hourly).
 *
 * Estimates sleep from phone usage patterns (longest screen-off gap at night)
 * and writes to Supabase sleep tables with source = "phone".
 *
 * Only runs if:
 * - PACKAGE_USAGE_STATS permission is granted
 * - sleep_duration_daily metric is enabled with preferred_source or allowed_sources containing "phone"
 *
 * Writes to: sleep_duration_daily, fell_asleep_time_daily, woke_up_time_daily
 * (same tables as WHOOP/Health Connect, different source value)
 */
class PhoneSleepSyncWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        Log.d(TAG, "Worker started")

        try {
            // Check permission
            if (!ScreenTimeCollector.hasUsageStatsPermission(applicationContext)) {
                Log.d(TAG, "PACKAGE_USAGE_STATS permission not granted - skipping")
                return@withContext Result.success()
            }

            // Check if phone sleep is enabled in metric_settings
            if (!isPhoneSleepEnabled()) {
                Log.d(TAG, "Phone sleep not enabled in metric_settings - skipping")
                return@withContext Result.success()
            }

            // Get valid Supabase access token
            val access = SessionStore.getValidAccessToken(applicationContext)
            if (access.isNullOrBlank()) {
                Log.d(TAG, "No valid access token - skipping")
                return@withContext Result.success()
            }

            val svc = SupabasePersonalService(applicationContext)
            val today = LocalDate.now()
            val timezone = ZoneId.systemDefault().id

            // A sleep night for date D = 20:00 on D → 12:00 on D+1.
            // It is complete once we are past 12:00 on D+1, i.e. today >= D+2,
            // meaning we can finalize D = today - 2.
            val latestCompletable = today.minusDays(2)

            // Get latest finalized phone sleep date
            val latestStr = svc.latestPhoneSleepDate(access)
            val latestFinalized = latestStr?.let { runCatching { LocalDate.parse(it) }.getOrNull() }

            val toFinalize = if (latestFinalized == null) {
                listOf(latestCompletable)
            } else {
                val daysSince = ChronoUnit.DAYS.between(latestFinalized, latestCompletable)
                when {
                    daysSince <= 0 -> emptyList()
                    daysSince <= 7 -> (1..daysSince).map { latestFinalized.plusDays(it) }
                    else -> listOf(latestCompletable)
                }
            }

            if (toFinalize.isEmpty()) {
                Log.d(TAG, "No nights to finalize")
                return@withContext Result.success()
            }

            Log.d(TAG, "Finalizing ${toFinalize.size} nights of phone sleep")

            var ok = 0
            var fail = 0

            toFinalize.forEach { date ->
                runCatching {
                    val dateStr = date.toString()
                    val sleep = PhoneSleepCollector.estimateSleep(applicationContext, dateStr)

                    if (sleep == null) {
                        Log.w(TAG, "No sleep estimate for $dateStr")
                        fail++
                        return@forEach
                    }

                    val durationHours = sleep.durationMinutes / 60.0

                    svc.upsertPhoneSleepData(
                        accessToken = access,
                        date = dateStr,
                        durationHours = durationHours,
                        fellAsleepIso = sleep.fellAsleepIso,
                        wokeUpIso = sleep.wokeUpIso,
                        timezone = timezone
                    )

                    Log.d(TAG, "Finalized phone sleep for $dateStr: ${String.format("%.1f", durationHours)}h (${sleep.fellAsleepIso} → ${sleep.wokeUpIso})")
                    ok++
                }.onFailure { e ->
                    fail++
                    Log.e(TAG, "Failed to finalize phone sleep for $date", e)
                }
            }

            Log.d(TAG, "Phone sleep finalization complete: $ok ok, $fail fail")
            Result.success()

        } catch (t: Throwable) {
            Log.e(TAG, "Worker error", t)
            Result.retry()
        }
    }

    /**
     * Check metric_settings to see if phone sleep is enabled.
     * Returns true if sleep_duration_daily has preferred_source="phone"
     * or allowed_sources contains "phone".
     */
    private suspend fun isPhoneSleepEnabled(): Boolean {
        return try {
            val edge = EdgeFunctionsService()
            val settings = edge.getMetricSettings(applicationContext)

            val sleepSetting = settings.find { it.metric == "sleep_duration_daily" }
            if (sleepSetting == null || !sleepSetting.enabled) return false

            val preferred = sleepSetting.preferredSource?.lowercase() ?: ""
            val allowed = sleepSetting.allowedSources?.map { it.lowercase() } ?: emptyList()

            preferred == "phone" || allowed.contains("phone")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to check metric_settings: ${e.message}")
            false
        }
    }

    companion object {
        private const val TAG = "PhoneSleepSyncWorker"
        private const val UNIQUE_WORK = "phone_sleep_sync"

        fun runOnce(context: Context) {
            Log.d(TAG, "Enqueuing phone sleep sync")
            val req = OneTimeWorkRequestBuilder<PhoneSleepSyncWorker>()
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 5, TimeUnit.MINUTES)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_WORK, ExistingWorkPolicy.REPLACE, req
            )
        }
    }
}

title: PhysicalCardConfig.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color

object PhysicalCardConfig {
    // Metric keys
    const val METRIC_RECOVERY = "recovery"
    const val METRIC_HRV = "hrv"
    const val METRIC_RESTING_HR = "resting_hr"
    const val METRIC_SPO2 = "spo2"
    const val METRIC_SKIN_TEMP = "skin_temp"
    const val METRIC_RESPIRATORY_RATE = "respiratory_rate"
    const val METRIC_STRESS = "stress"
    const val METRIC_HIGH_HR_ZONES = "high_hr_zones"
    const val METRIC_STEPS = "steps"
    const val METRIC_WEIGHT = "weight"
    const val METRIC_BODY_FAT = "body_fat"
    const val METRIC_BLOOD_PRESSURE = "blood_pressure"
    const val METRIC_BLOOD_GLUCOSE = "blood_glucose"

    val ALL_PHYSICAL_METRICS: List<String> = listOf(
        METRIC_RECOVERY, METRIC_HRV, METRIC_RESTING_HR,
        METRIC_SPO2, METRIC_SKIN_TEMP, METRIC_RESPIRATORY_RATE,
        METRIC_STRESS, METRIC_HIGH_HR_ZONES, METRIC_STEPS,
        METRIC_WEIGHT, METRIC_BODY_FAT,
        METRIC_BLOOD_PRESSURE, METRIC_BLOOD_GLUCOSE
    )

    val DEFAULT_DISPLAY_METRICS: List<String> = listOf(
        METRIC_RECOVERY, METRIC_HRV, METRIC_RESTING_HR
    )

    val GRAPHABLE_METRICS: List<String> = listOf(
        METRIC_RECOVERY, METRIC_HRV, METRIC_RESTING_HR,
        METRIC_SPO2, METRIC_SKIN_TEMP, METRIC_RESPIRATORY_RATE,
        METRIC_STRESS, METRIC_HIGH_HR_ZONES, METRIC_STEPS,
        METRIC_WEIGHT, METRIC_BODY_FAT, METRIC_BLOOD_GLUCOSE
    )

    fun labelFor(metric: String): String = when (metric) {
        METRIC_RECOVERY -> "Recovery"
        METRIC_HRV -> "HRV"
        METRIC_RESTING_HR -> "Resting HR"
        METRIC_SPO2 -> "SpO2"
        METRIC_SKIN_TEMP -> "Skin Temp"
        METRIC_RESPIRATORY_RATE -> "Resp. Rate"
        METRIC_STRESS -> "Stress"
        METRIC_HIGH_HR_ZONES -> "High HR Zones"
        METRIC_STEPS -> "Steps"
        METRIC_WEIGHT -> "Weight"
        METRIC_BODY_FAT -> "Body Fat"
        METRIC_BLOOD_PRESSURE -> "Blood Pressure"
        METRIC_BLOOD_GLUCOSE -> "Blood Glucose"
        else -> metric
    }

    fun unitFor(metric: String): String = when (metric) {
        METRIC_RECOVERY -> "%"
        METRIC_HRV -> "ms"
        METRIC_RESTING_HR -> "bpm"
        METRIC_SPO2 -> "%"
        METRIC_SKIN_TEMP -> "°C"
        METRIC_RESPIRATORY_RATE -> "bpm"
        METRIC_STRESS -> ""
        METRIC_HIGH_HR_ZONES -> "min"
        METRIC_STEPS -> ""
        METRIC_WEIGHT -> "kg"
        METRIC_BODY_FAT -> "%"
        METRIC_BLOOD_PRESSURE -> "mmHg"
        METRIC_BLOOD_GLUCOSE -> "mg/dL"
        else -> ""
    }

    fun colorFor(metric: String): Color = when (metric) {
        METRIC_RECOVERY -> Color(0xFF81C784)
        METRIC_HRV -> Color(0xFF4FC3F7)
        METRIC_RESTING_HR -> Color(0xFFFF8A65)
        METRIC_SPO2 -> Color(0xFF7986CB)
        METRIC_SKIN_TEMP -> Color(0xFFFFB74D)
        METRIC_RESPIRATORY_RATE -> Color(0xFF9575CD)
        METRIC_STRESS -> Color(0xFFE57373)
        METRIC_HIGH_HR_ZONES -> Color(0xFFFF7043)
        METRIC_STEPS -> Color(0xFF66BB6A)
        METRIC_WEIGHT -> Color(0xFF78909C)
        METRIC_BODY_FAT -> Color(0xFFBA68C8)
        METRIC_BLOOD_PRESSURE -> Color(0xFFEF5350)
        METRIC_BLOOD_GLUCOSE -> Color(0xFFFFCA28)
        else -> Color(0xFF81C784)
    }

    /** Maps config metric key to Supabase table name for metric_settings lookup */
    fun metricToTable(metric: String): String = when (metric) {
        METRIC_RECOVERY -> "recovery_score_daily"
        METRIC_HRV -> "hrv_daily"
        METRIC_RESTING_HR -> "resting_hr_daily"
        METRIC_SPO2 -> "spo2_daily"
        METRIC_SKIN_TEMP -> "skin_temp_daily"
        METRIC_RESPIRATORY_RATE -> "respiratory_rate_daily"
        METRIC_STRESS -> "stress_index_daily"
        METRIC_HIGH_HR_ZONES -> "time_in_high_hr_zones_daily"
        METRIC_STEPS -> "steps_daily"
        METRIC_WEIGHT -> "weight_daily"
        METRIC_BODY_FAT -> "body_fat_daily"
        METRIC_BLOOD_PRESSURE -> "blood_pressure_daily"
        METRIC_BLOOD_GLUCOSE -> "blood_glucose_daily"
        else -> ""
    }
}

title: PhysicalCardConfigStore.kt
text:
package com.migraineme

import android.content.Context

data class PhysicalCardConfigData(
    val physicalDisplayMetrics: List<String>
)

object PhysicalCardConfigStore {
    private const val PREFS_NAME = "physical_card_config"
    private const val KEY_DISPLAY_METRICS = "physical_display_metrics"

    fun load(context: Context): PhysicalCardConfigData {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val metricsStr = prefs.getString(KEY_DISPLAY_METRICS, null)
        val metrics: List<String> = if (metricsStr.isNullOrBlank()) {
            PhysicalCardConfig.DEFAULT_DISPLAY_METRICS
        } else {
            metricsStr.split(",").filter { it.isNotBlank() }
        }
        return PhysicalCardConfigData(physicalDisplayMetrics = metrics)
    }

    fun save(context: Context, config: PhysicalCardConfigData) {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit()
            .putString(KEY_DISPLAY_METRICS, config.physicalDisplayMetrics.joinToString(","))
            .apply()
    }
}

title: PhysicalConfigScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.PhoneAndroid
import androidx.compose.material.icons.filled.Watch
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

/**
 * Determines the source type for a metric based on its preferred_source.
 */
private fun physicalSourceTypeFor(preferredSource: String?): String? = when (preferredSource) {
    "whoop", "garmin", "oura", "fitbit" -> "external"
    "health_connect" -> "external"
    "phone" -> "phone"
    null -> null
    else -> null
}

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun PhysicalConfigScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    val initialConfig = remember { PhysicalCardConfigStore.load(context) }
    var selectedMetrics by remember { mutableStateOf<Set<String>>(initialConfig.physicalDisplayMetrics.toSet()) }

    var metricSettings by remember {
        mutableStateOf<Map<String, EdgeFunctionsService.MetricSettingResponse>>(emptyMap())
    }
    var settingsLoaded by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        scope.launch {
            try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(context)
                metricSettings = settings.associateBy { it.metric }
            } catch (_: Exception) { }
            settingsLoaded = true
        }
    }

    fun saveConfig() {
        PhysicalCardConfigStore.save(
            context,
            PhysicalCardConfigData(physicalDisplayMetrics = selectedMetrics.toList())
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = {
                    saveConfig()
                    onBack()
                }) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }

            HeroCard {
                Text(
                    text = "Customize Physical Health",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Choose which physical health metrics to display on the Monitor screen.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            BaseCard {
                Text(
                    text = "Display Metrics (${selectedMetrics.size}/3)",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Select up to 3 metrics to show on the Monitor card.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
                Spacer(Modifier.height(12.dp))

                FlowRow(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (metric in PhysicalCardConfig.ALL_PHYSICAL_METRICS) {
                        val table = PhysicalCardConfig.metricToTable(metric)
                        val setting = metricSettings[table]
                        val source = physicalSourceTypeFor(setting?.preferredSource)

                        if (settingsLoaded && setting != null && !setting.enabled) continue

                        val isSelected = metric in selectedMetrics
                        val label = PhysicalCardConfig.labelFor(metric)
                        val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                        val slotIndex = if (isSelected) selectedMetrics.toList().indexOf(metric) else -1
                        val chipColor = if (slotIndex in slotColors.indices) slotColors[slotIndex] else AppTheme.AccentPurple
                        FilterChip(
                            selected = isSelected,
                            onClick = {
                                if (isSelected) {
                                    selectedMetrics = selectedMetrics.minus(metric)
                                } else if (selectedMetrics.size < 3) {
                                    selectedMetrics = selectedMetrics.plus(metric)
                                }
                                saveConfig()
                            },
                            label = {
                                Text(
                                    text = label,
                                    style = MaterialTheme.typography.labelSmall
                                )
                            },
                            leadingIcon = if (isSelected) {
                                {
                                    Icon(
                                        Icons.Default.Check,
                                        contentDescription = null,
                                        modifier = Modifier.size(18.dp)
                                    )
                                }
                            } else null,
                            trailingIcon = when (source) {
                                "external" -> {
                                    {
                                        Icon(
                                            Icons.Default.Watch,
                                            contentDescription = "External",
                                            modifier = Modifier.size(14.dp),
                                            tint = if (isSelected) chipColor else AppTheme.SubtleTextColor
                                        )
                                    }
                                }
                                "phone" -> {
                                    {
                                        Icon(
                                            Icons.Default.PhoneAndroid,
                                            contentDescription = "Phone",
                                            modifier = Modifier.size(14.dp),
                                            tint = if (isSelected) chipColor else AppTheme.SubtleTextColor
                                        )
                                    }
                                }
                                else -> null
                            },
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = chipColor.copy(alpha = 0.3f),
                                selectedLabelColor = chipColor,
                                containerColor = AppTheme.BaseCardContainer,
                                labelColor = AppTheme.BodyTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                                selectedBorderColor = chipColor,
                                enabled = true,
                                selected = isSelected
                            )
                        )
                    }
                }

                Spacer(Modifier.height(12.dp))
                Row(
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                        Icon(Icons.Default.Watch, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                        Text(text = "External", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                    Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                        Icon(Icons.Default.PhoneAndroid, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                        Text(text = "Phone", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }
    }
}

title: PhysicalDataHistoryScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.ChevronLeft
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// ─── Data model ──────────────────────────────────────────────────────────────

data class PhysicalDataEntry(
    val table: String,
    val label: String,
    val value: String,
    val source: String
)

// ─── Screen ──────────────────────────────────────────────────────────────────

@Composable
fun PhysicalDataHistoryScreen(
    onBack: () -> Unit,
    onNavigateToActivities: ((String) -> Unit)? = null
) {
    val context = LocalContext.current
    val scrollState = rememberSaveable(saver = ScrollState.Saver) { ScrollState(0) }
    val scope = rememberCoroutineScope()

    var selectedDateStr by rememberSaveable { mutableStateOf(LocalDate.now().toString()) }
    val selectedDate = LocalDate.parse(selectedDateStr)
    val today = LocalDate.now()

    var entries by remember { mutableStateOf<List<PhysicalDataEntry>>(emptyList()) }
    val physicalConfig = remember { PhysicalCardConfigStore.load(context) }
    var isLoading by remember { mutableStateOf(true) }
    var activityCount by remember { mutableStateOf(0) }

    val dateFormatter = DateTimeFormatter.ofPattern("EEEE, MMM d")

    fun loadEntries() {
        scope.launch {
            isLoading = true
            val token = SessionStore.readAccessToken(context) ?: return@launch
            val userId = SessionStore.readUserId(context) ?: return@launch
            entries = fetchPhysicalEntriesForDate(selectedDateStr, token, userId)
            activityCount = fetchActivityCount(context, selectedDateStr)
            isLoading = false
        }
    }

    LaunchedEffect(selectedDateStr) { loadEntries() }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.Start
        ) {
            IconButton(onClick = onBack) {
                Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
            }
        }

        HeroCard {
            Text(
                "Physical Health Data",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.height(4.dp))
            Text(
                "View physical health entries by day",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
        }

        // Date navigation
        BaseCard {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = { selectedDateStr = selectedDate.minusDays(1).toString() }) {
                    Icon(Icons.Default.ChevronLeft, contentDescription = "Previous day", tint = AppTheme.AccentPurple)
                }
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text(
                        when {
                            selectedDate == today -> "Today"
                            selectedDate == today.minusDays(1) -> "Yesterday"
                            else -> selectedDate.format(dateFormatter)
                        },
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                }
                IconButton(
                    onClick = { selectedDateStr = selectedDate.plusDays(1).toString() },
                    enabled = selectedDate < today
                ) {
                    Icon(
                        Icons.Default.ChevronRight,
                        contentDescription = "Next day",
                        tint = if (selectedDate < today) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f)
                    )
                }
            }
        }

        // Entries
        BaseCard {
            if (isLoading) {
                Row(
                    modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp),
                    horizontalArrangement = Arrangement.Center
                ) {
                    CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                }
            } else if (entries.isEmpty()) {
                Text(
                    "No physical health data for this day",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center,
                    modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp)
                )
            } else {
                // Map table names to config metric keys
                val tableToMetric = mapOf(
                    "recovery_score_daily" to PhysicalCardConfig.METRIC_RECOVERY,
                    "hrv_daily" to PhysicalCardConfig.METRIC_HRV,
                    "resting_hr_daily" to PhysicalCardConfig.METRIC_RESTING_HR,
                    "spo2_daily" to PhysicalCardConfig.METRIC_SPO2,
                    "skin_temp_daily" to PhysicalCardConfig.METRIC_SKIN_TEMP,
                    "respiratory_rate_daily" to PhysicalCardConfig.METRIC_RESPIRATORY_RATE,
                    "stress_index_daily" to PhysicalCardConfig.METRIC_STRESS,
                    "time_in_high_hr_zones_daily" to PhysicalCardConfig.METRIC_HIGH_HR_ZONES,
                    "steps_daily" to PhysicalCardConfig.METRIC_STEPS,
                    "weight_daily" to PhysicalCardConfig.METRIC_WEIGHT,
                    "body_fat_daily" to PhysicalCardConfig.METRIC_BODY_FAT,
                    "blood_pressure_daily" to PhysicalCardConfig.METRIC_BLOOD_PRESSURE,
                    "blood_glucose_daily" to PhysicalCardConfig.METRIC_BLOOD_GLUCOSE
                )

                // Best value per metric (prefer non-manual first, fallback manual)
                val bestByMetric = mutableMapOf<String, PhysicalDataEntry>()
                entries.forEach { entry ->
                    val metricKey = tableToMetric[entry.table] ?: return@forEach
                    val existing = bestByMetric[metricKey]
                    if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                        bestByMetric[metricKey] = entry
                    }
                }

                val selectedMetrics = physicalConfig.physicalDisplayMetrics.take(3)
                val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                // Top 3 selected metrics
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                    selectedMetrics.forEachIndexed { index, metric ->
                        val entry = bestByMetric[metric]
                        val value = entry?.value ?: "—"
                        val label = PhysicalCardConfig.labelFor(metric)
                        Column(horizontalAlignment = Alignment.CenterHorizontally) {
                            Text(value, color = slotColors.getOrElse(index) { slotColors.last() }, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
                            Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        }
                    }
                }

                Spacer(Modifier.height(4.dp))
                HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                Spacer(Modifier.height(8.dp))
                Text("All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                Spacer(Modifier.height(4.dp))

                // All metrics — flat list, no source grouping
                // Deduplicate: keep best entry per table (prefer non-manual)
                val bestByTable = mutableMapOf<String, PhysicalDataEntry>()
                entries.forEach { entry ->
                    val existing = bestByTable[entry.table]
                    if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                        bestByTable[entry.table] = entry
                    }
                }

                bestByTable.values
                    .filter { tableToMetric[it.table] !in selectedMetrics.toSet() }
                    .forEach { entry ->
                        PhysicalDataRow(entry = entry)
                    }

                // Activities row
                if (activityCount > 0) {
                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text("Activities", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onNavigateToActivities?.invoke(selectedDateStr) }
                            .padding(vertical = 6.dp),
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Text("💪", style = MaterialTheme.typography.bodyMedium)
                            Spacer(Modifier.width(8.dp))
                            Text(
                                "$activityCount ${if (activityCount == 1) "activity" else "activities"}",
                                color = AppTheme.BodyTextColor,
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                        Text("View →", color = Color(0xFFFF7043), style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
                    }
                }
            }
        }
    }
}

@Composable
private fun PhysicalDataRow(
    entry: PhysicalDataEntry
) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(entry.label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
            Text(entry.value, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
        }
    }
}

// ─── Supabase fetch ──────────────────────────────────────────────────────────

private suspend fun fetchPhysicalEntriesForDate(
    date: String,
    accessToken: String,
    userId: String
): List<PhysicalDataEntry> = withContext(Dispatchers.IO) {
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val key = BuildConfig.SUPABASE_ANON_KEY
    val entries = mutableListOf<PhysicalDataEntry>()
    val client = okhttp3.OkHttpClient()

    data class TableDef(val table: String, val label: String, val select: String)

    val tables = listOf(
        TableDef("recovery_score_daily", "Recovery", "date,source,value_pct"),
        TableDef("hrv_daily", "HRV", "date,source,value_rmssd_ms"),
        TableDef("resting_hr_daily", "Resting HR", "date,source,value_bpm"),
        TableDef("spo2_daily", "SpO2", "date,source,value_pct"),
        TableDef("skin_temp_daily", "Skin Temp", "date,source,value_celsius"),
        TableDef("respiratory_rate_daily", "Resp. Rate", "date,source,value_bpm"),
        TableDef("stress_index_daily", "Stress", "date,source,value"),
        TableDef("time_in_high_hr_zones_daily", "High HR Zones", "date,source,value_minutes"),
        TableDef("steps_daily", "Steps", "date,source,value_count"),
        TableDef("weight_daily", "Weight", "date,source,value_kg"),
        TableDef("body_fat_daily", "Body Fat", "date,source,value_pct"),
        TableDef("blood_pressure_daily", "Blood Pressure", "date,source,value_systolic,value_diastolic"),
        TableDef("blood_glucose_daily", "Blood Glucose", "date,source,value_mgdl")
    )

    for (td in tables) {
        try {
            val url = "$base/rest/v1/${td.table}?user_id=eq.$userId&date=eq.$date&select=${td.select}"
            val request = okhttp3.Request.Builder().url(url).get()
                .addHeader("apikey", key)
                .addHeader("Authorization", "Bearer $accessToken")
                .build()
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            if (response.isSuccessful && !body.isNullOrBlank()) {
                val arr = org.json.JSONArray(body)
                for (i in 0 until arr.length()) {
                    val obj = arr.getJSONObject(i)
                    val src = obj.optString("source", "unknown")
                    val value = formatPhysicalEntryValue(td.table, obj)
                    entries.add(PhysicalDataEntry(td.table, td.label, value, src))
                }
            }
        } catch (e: Exception) {
            Log.e("PhysicalDataHistory", "Failed to fetch ${td.table}: ${e.message}")
        }
    }
    entries
}

private fun formatPhysicalEntryValue(table: String, obj: org.json.JSONObject): String {
    return when (table) {
        "recovery_score_daily" -> {
            val v = obj.optDouble("value_pct")
            if (!v.isNaN()) "${v.toInt()}%" else "—"
        }
        "hrv_daily" -> {
            val v = obj.optDouble("value_rmssd_ms")
            if (!v.isNaN()) "${v.toInt()} ms" else "—"
        }
        "resting_hr_daily" -> {
            val v = obj.optDouble("value_bpm")
            if (!v.isNaN()) "${v.toInt()} bpm" else "—"
        }
        "spo2_daily" -> {
            val v = obj.optDouble("value_pct")
            if (!v.isNaN()) "${v.toInt()}%" else "—"
        }
        "skin_temp_daily" -> {
            val v = obj.optDouble("value_celsius")
            if (!v.isNaN()) String.format("%.1f°C", v) else "—"
        }
        "respiratory_rate_daily" -> {
            val v = obj.optDouble("value_bpm")
            if (!v.isNaN()) String.format("%.1f bpm", v) else "—"
        }
        "stress_index_daily" -> {
            val v = obj.optDouble("value")
            if (!v.isNaN()) String.format("%.0f", v) else "—"
        }
        "time_in_high_hr_zones_daily" -> {
            val v = obj.optDouble("value_minutes")
            if (!v.isNaN()) "${v.toInt()} min" else "—"
        }
        "steps_daily" -> {
            val v = obj.optInt("value_count", -1)
            if (v >= 0) "%,d".format(v) else "—"
        }
        "weight_daily" -> {
            val v = obj.optDouble("value_kg")
            if (!v.isNaN()) String.format("%.1f kg", v) else "—"
        }
        "body_fat_daily" -> {
            val v = obj.optDouble("value_pct")
            if (!v.isNaN()) String.format("%.1f%%", v) else "—"
        }
        "blood_pressure_daily" -> {
            val sys = obj.optDouble("value_systolic")
            val dia = obj.optDouble("value_diastolic")
            if (!sys.isNaN() && !dia.isNaN()) "${sys.toInt()}/${dia.toInt()} mmHg" else "—"
        }
        "blood_glucose_daily" -> {
            val v = obj.optDouble("value_mgdl")
            if (!v.isNaN()) String.format("%.0f mg/dL", v) else "—"
        }
        else -> "—"
    }
}

title: PhysicalHealthSyncStatus.kt
text:
package com.migraineme

/**
 * Mirrors SleepSyncStatus.kt style.
 * A simple sealed status used by PH worker or UI if needed.
 *
 * Not referenced anywhere unless you add it.
 * Safe placeholder for future use.
 */
sealed class PhysicalHealthSyncStatus {
    object Idle : PhysicalHealthSyncStatus()
    object Syncing : PhysicalHealthSyncStatus()
    object Success : PhysicalHealthSyncStatus()
    data class Error(val message: String?) : PhysicalHealthSyncStatus()
}

title: PhysicalHistoryGraph.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

data class PhysicalGraphDay(
    val date: String,
    val recovery: Double?,
    val hrv: Double?,
    val restingHr: Double?,
    val spo2: Double?,
    val skinTemp: Double?,
    val respiratoryRate: Double?,
    val stress: Double?,
    val highHrZones: Double?,
    val steps: Double?,
    val weight: Double?,
    val bodyFat: Double?,
    val bloodPressureSystolic: Double?,
    val bloodGlucose: Double?
)

data class PhysicalGraphResult(
    val days: List<PhysicalGraphDay>,
    val allTimeMin: Map<String, Float>,
    val allTimeMax: Map<String, Float>
)

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun PhysicalHistoryGraph(
    days: Int = 14,
    endDate: LocalDate = LocalDate.now(),
    onClick: (() -> Unit)? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    var graphResult by remember { mutableStateOf<PhysicalGraphResult?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    var selectedMetrics by remember { mutableStateOf<Set<String>>(setOf(PhysicalCardConfig.METRIC_RECOVERY)) }
    var migraineDates by remember { mutableStateOf<Set<String>>(emptySet()) }

    LaunchedEffect(days, endDate) {
        scope.launch {
            graphResult = loadPhysicalGraphData(context, days, endDate)
            migraineDates = MigraineOverlayHelper.fetchMigraineDates(context, days, endDate)
            isLoading = false
        }
    }

    val historyData: List<PhysicalGraphDay> = graphResult?.days ?: emptyList()
    val allTimeMin: Map<String, Float> = graphResult?.allTimeMin ?: emptyMap()
    val allTimeMax: Map<String, Float> = graphResult?.allTimeMax ?: emptyMap()
    val isNormalized = selectedMetrics.size >= 2
    val daysWithData: List<PhysicalGraphDay> = historyData.filter { day ->
        PhysicalCardConfig.GRAPHABLE_METRICS.any { getPhysicalDayValue(day, it) != null }
    }

    BaseCard(modifier = if (onClick != null) Modifier.clickable { onClick() } else Modifier) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "$days-Day Physical Health History",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            if (onClick != null) {
                Text("View Full →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
            }
        }

        Spacer(Modifier.height(8.dp))

        if (isLoading) {
            Row(
                modifier = Modifier.fillMaxWidth().height(150.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
            }
        } else if (historyData.isEmpty() || daysWithData.isEmpty()) {
            Text(
                text = "No physical health data available",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else if (selectedMetrics.isEmpty()) {
            Text(
                text = "Select a metric below",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else {
            // Legend
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                for (metric in selectedMetrics) {
                    val color = PhysicalCardConfig.colorFor(metric)
                    val label = PhysicalCardConfig.labelFor(metric)
                    val unit = PhysicalCardConfig.unitFor(metric)
                    val values: List<Float> = daysWithData.mapNotNull { getPhysicalDayValue(it, metric) }

                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Canvas(Modifier.size(8.dp)) { drawCircle(color) }
                        Spacer(Modifier.width(4.dp))
                        if (isNormalized) {
                            val minVal = allTimeMin[metric] ?: 0f
                            val maxVal = allTimeMax[metric] ?: 1f
                            Text(
                                text = "$label [${formatPhysicalValue(minVal, unit)}-${formatPhysicalValue(maxVal, unit)}]",
                                color = color,
                                style = MaterialTheme.typography.labelSmall
                            )
                        } else {
                            val avg = if (values.isNotEmpty()) values.average().toFloat() else 0f
                            Text(
                                text = "$label (avg: ${formatPhysicalValue(avg, unit)})",
                                color = color,
                                style = MaterialTheme.typography.labelSmall
                            )
                        }
                    }
                }
            }

            if (isNormalized) {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "⚠️ Normalized 0-1 scale • Dotted = $days days avg",
                    color = Color(0xFFFFB74D),
                    style = MaterialTheme.typography.labelSmall
                )
            } else if (daysWithData.isNotEmpty()) {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Dotted line = $days-day average",
                    color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                    style = MaterialTheme.typography.labelSmall
                )
            }

            if (migraineDates.isNotEmpty()) {
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Canvas(Modifier.size(8.dp)) { drawRect(Color(0xFFE57373).copy(alpha = 0.35f)) }
                    Spacer(Modifier.width(4.dp))
                    Text(
                        text = "Red bands = migraine days",
                        color = Color(0xFFE57373),
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            }

            Spacer(Modifier.height(8.dp))

            if (daysWithData.isEmpty()) {
                Text(
                    text = "No logged days in this period",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(vertical = 16.dp)
                )
            } else {
                val yAxisWidth = 50.dp

                val yTop: String
                val yMid: String
                val yBot: String

                if (isNormalized) {
                    yTop = "1.0"
                    yMid = "0.5"
                    yBot = "0.0"
                } else {
                    val metric = selectedMetrics.first()
                    val unit = PhysicalCardConfig.unitFor(metric)
                    val values: List<Float> = daysWithData.mapNotNull { getPhysicalDayValue(it, metric) }
                    val max = values.maxOrNull() ?: 1f
                    val min = values.minOrNull() ?: 0f
                    yTop = formatPhysicalValue(max, unit)
                    yMid = formatPhysicalValue((max + min) / 2, unit)
                    yBot = formatPhysicalValue(min, unit)
                }

                Row(modifier = Modifier.fillMaxWidth().height(150.dp)) {
                    Column(
                        modifier = Modifier.width(yAxisWidth).fillMaxHeight(),
                        verticalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(text = yTop, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = yMid, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = yBot, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }

                    Canvas(modifier = Modifier.weight(1f).fillMaxHeight()) {
                        val padding = 8.dp.toPx()
                        val graphWidth = size.width - padding * 2
                        val graphHeight = size.height - padding * 2
                        val dashWidth = 6.dp.toPx()
                        val gapWidth = 4.dp.toPx()

                        // Draw migraine bands
                        with(MigraineOverlayHelper) {
                            drawMigraineBands(
                                dateList = historyData.map { it.date },
                                migraineDates = migraineDates,
                                padding = padding,
                                graphWidth = graphWidth,
                                graphHeight = graphHeight
                            )
                        }

                        for (metric in selectedMetrics) {
                            val color = PhysicalCardConfig.colorFor(metric)

                            val indexedValues: List<Pair<Int, Float>> = historyData.mapIndexedNotNull { i, day ->
                                val value = getPhysicalDayValue(day, metric)
                                if (value != null) Pair(i, value) else null
                            }

                            if (indexedValues.isEmpty()) continue

                            val values: List<Float> = indexedValues.map { it.second }

                            val minVal: Float
                            val maxVal: Float
                            if (isNormalized) {
                                minVal = allTimeMin[metric] ?: 0f
                                maxVal = (allTimeMax[metric] ?: 1f).coerceAtLeast(minVal + 0.1f)
                            } else {
                                minVal = values.minOrNull() ?: 0f
                                maxVal = (values.maxOrNull() ?: 1f).coerceAtLeast(minVal + 0.1f)
                            }
                            val range = maxVal - minVal

                            val plotPoints: List<Pair<Int, Float>> = indexedValues.map { (idx, value) ->
                                Pair(idx, ((value - minVal) / range).coerceIn(0f, 1f))
                            }

                            // Dotted average
                            if (plotPoints.isNotEmpty()) {
                                val avgNormalized = plotPoints.map { it.second }.average().toFloat()
                                val avgY = padding + graphHeight - (avgNormalized * graphHeight)
                                var x = padding
                                while (x < size.width - padding) {
                                    drawLine(
                                        color.copy(alpha = 0.5f),
                                        Offset(x, avgY),
                                        Offset((x + dashWidth).coerceAtMost(size.width - padding), avgY),
                                        strokeWidth = 1.5.dp.toPx()
                                    )
                                    x += dashWidth + gapWidth
                                }
                            }

                            // Line
                            if (plotPoints.size > 1) {
                                val path = Path()
                                plotPoints.forEachIndexed { i, pair ->
                                    val x = padding + (pair.first.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                    val y = padding + graphHeight - (pair.second * graphHeight)
                                    if (i == 0) path.moveTo(x, y) else path.lineTo(x, y)
                                }
                                drawPath(path, color, style = Stroke(2.dp.toPx(), cap = StrokeCap.Round, join = StrokeJoin.Round))
                            }

                            // Dots
                            for (pair in plotPoints) {
                                val x = padding + (pair.first.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                val y = padding + graphHeight - (pair.second * graphHeight)
                                drawCircle(color, 4.dp.toPx(), Offset(x, y))
                            }
                        }
                    }
                }

                // Date labels
                Spacer(Modifier.height(4.dp))
                Row(
                    modifier = Modifier.fillMaxWidth().padding(start = yAxisWidth),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    val fmt = DateTimeFormatter.ofPattern("MMM d")
                    if (historyData.isNotEmpty()) {
                        val firstLabel = try { LocalDate.parse(historyData.first().date).format(fmt) } catch (_: Exception) { historyData.first().date }
                        val lastLabel = try { LocalDate.parse(historyData.last().date).format(fmt) } catch (_: Exception) { historyData.last().date }
                        Text(text = firstLabel, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = lastLabel, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }

        Spacer(Modifier.height(12.dp))

        Text(
            text = "Select Metrics" + if (selectedMetrics.size > 1) " (${selectedMetrics.size} selected)" else "",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )
        Spacer(Modifier.height(8.dp))

        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(6.dp),
            verticalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            for (metric in PhysicalCardConfig.GRAPHABLE_METRICS) {
                val isSelected = metric in selectedMetrics
                val chipColor = PhysicalCardConfig.colorFor(metric)
                val chipLabel = PhysicalCardConfig.labelFor(metric)

                FilterChip(
                    selected = isSelected,
                    onClick = {
                        selectedMetrics = if (isSelected) {
                            selectedMetrics.minus(metric)
                        } else {
                            selectedMetrics.plus(metric)
                        }
                    },
                    label = { Text(text = chipLabel, style = MaterialTheme.typography.labelSmall) },
                    colors = FilterChipDefaults.filterChipColors(
                        selectedContainerColor = chipColor.copy(alpha = 0.3f),
                        selectedLabelColor = chipColor,
                        containerColor = AppTheme.BaseCardContainer,
                        labelColor = AppTheme.SubtleTextColor
                    ),
                    border = FilterChipDefaults.filterChipBorder(
                        borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        selectedBorderColor = chipColor,
                        enabled = true,
                        selected = isSelected
                    )
                )
            }
        }
    }
}

private fun getPhysicalDayValue(day: PhysicalGraphDay, metric: String): Float? {
    return when (metric) {
        PhysicalCardConfig.METRIC_RECOVERY -> day.recovery?.toFloat()
        PhysicalCardConfig.METRIC_HRV -> day.hrv?.toFloat()
        PhysicalCardConfig.METRIC_RESTING_HR -> day.restingHr?.toFloat()
        PhysicalCardConfig.METRIC_SPO2 -> day.spo2?.toFloat()
        PhysicalCardConfig.METRIC_SKIN_TEMP -> day.skinTemp?.toFloat()
        PhysicalCardConfig.METRIC_RESPIRATORY_RATE -> day.respiratoryRate?.toFloat()
        PhysicalCardConfig.METRIC_STRESS -> day.stress?.toFloat()
        PhysicalCardConfig.METRIC_HIGH_HR_ZONES -> day.highHrZones?.toFloat()
        PhysicalCardConfig.METRIC_STEPS -> day.steps?.toFloat()
        PhysicalCardConfig.METRIC_WEIGHT -> day.weight?.toFloat()
        PhysicalCardConfig.METRIC_BODY_FAT -> day.bodyFat?.toFloat()
        PhysicalCardConfig.METRIC_BLOOD_PRESSURE -> day.bloodPressureSystolic?.toFloat()
        PhysicalCardConfig.METRIC_BLOOD_GLUCOSE -> day.bloodGlucose?.toFloat()
        else -> null
    }
}

private fun formatPhysicalValue(value: Float, unit: String): String {
    return when (unit) {
        "%", "bpm", "min", "mmHg", "mg/dL" -> "${value.toInt()}$unit"
        "ms" -> "${value.toInt()} ms"
        "°C" -> String.format("%.1f°C", value)
        "kg" -> String.format("%.1f kg", value)
        "" -> "%,d".format(value.toInt())
        else -> String.format("%.1f%s", value, unit)
    }
}

private suspend fun loadPhysicalGraphData(
    ctx: android.content.Context,
    days: Int,
    endDate: LocalDate = LocalDate.now()
): PhysicalGraphResult = withContext(Dispatchers.IO) {
    try {
        val token = SessionStore.getValidAccessToken(ctx) ?: return@withContext PhysicalGraphResult(emptyList(), emptyMap(), emptyMap())
        val userId = SessionStore.readUserId(ctx) ?: return@withContext PhysicalGraphResult(emptyList(), emptyMap(), emptyMap())
        val physService = SupabasePhysicalHealthService(ctx)

        val startDate = endDate.minusDays(days.toLong() - 1)
        val startStr = startDate.toString()
        val endStr = endDate.toString()
        val fetchLimit = days + 14

        // Fetch from SupabasePhysicalHealthService
        val recoveryList = try { physService.fetchRecoveryScoreDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val hrvList = try { physService.fetchHrvDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val rhrList = try { physService.fetchRestingHrDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val spo2List = try { physService.fetchSpo2Daily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val skinTempList = try { physService.fetchSkinTempDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val stressList = try { physService.fetchStressIndexDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val highHrList = try { physService.fetchHighHrDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }

        // Fetch from direct REST for tables without fetch methods
        val client = okhttp3.OkHttpClient()
        val stepsList = fetchDailyDoubles(client, token, "steps_daily", userId, "value_count", fetchLimit)
        val weightList = fetchDailyDoubles(client, token, "weight_daily", userId, "value_kg", fetchLimit)
        val bodyFatList = fetchDailyDoubles(client, token, "body_fat_daily", userId, "value_pct", fetchLimit)
        val respRateList = fetchDailyDoubles(client, token, "respiratory_rate_daily", userId, "value_bpm", fetchLimit)
        val glucoseList = fetchDailyDoubles(client, token, "blood_glucose_daily", userId, "value_mgdl", fetchLimit)
        val bpList = fetchDailyBp(client, token, userId, fetchLimit)

        // Build maps by date
        val recoveryMap = recoveryList.associateBy { it.date }
        val hrvMap = hrvList.associateBy { it.date }
        val rhrMap = rhrList.associateBy { it.date }
        val spo2Map = spo2List.associateBy { it.date }
        val skinTempMap = skinTempList.associateBy { it.date }
        val stressMap = stressList.associateBy { it.date }
        val highHrMap = highHrList.associateBy { it.date }
        val stepsMap = stepsList.associateBy { it.first }
        val weightMap = weightList.associateBy { it.first }
        val bodyFatMap = bodyFatList.associateBy { it.first }
        val respRateMap = respRateList.associateBy { it.first }
        val glucoseMap = glucoseList.associateBy { it.first }
        val bpMap = bpList.associateBy { it.first }

        // Collect all dates that have any data
        val allDates = mutableSetOf<String>()
        recoveryMap.keys.forEach { allDates.add(it) }
        hrvMap.keys.forEach { allDates.add(it) }
        rhrMap.keys.forEach { allDates.add(it) }
        spo2Map.keys.forEach { allDates.add(it) }
        skinTempMap.keys.forEach { allDates.add(it) }
        stressMap.keys.forEach { allDates.add(it) }
        highHrMap.keys.forEach { allDates.add(it) }
        stepsMap.keys.forEach { allDates.add(it) }
        weightMap.keys.forEach { allDates.add(it) }
        bodyFatMap.keys.forEach { allDates.add(it) }
        respRateMap.keys.forEach { allDates.add(it) }
        glucoseMap.keys.forEach { allDates.add(it) }
        bpMap.keys.forEach { allDates.add(it) }

        val graphDays = allDates
            .filter { it >= startStr && it <= endStr }
            .sorted()
            .map { date ->
                PhysicalGraphDay(
                    date = date,
                    recovery = recoveryMap[date]?.value_pct,
                    hrv = hrvMap[date]?.value_rmssd_ms,
                    restingHr = rhrMap[date]?.value_bpm,
                    spo2 = spo2Map[date]?.value_pct,
                    skinTemp = skinTempMap[date]?.value_celsius,
                    respiratoryRate = respRateMap[date]?.second,
                    stress = stressMap[date]?.value,
                    highHrZones = highHrMap[date]?.value_minutes,
                    steps = stepsMap[date]?.second,
                    weight = weightMap[date]?.second,
                    bodyFat = bodyFatMap[date]?.second,
                    bloodPressureSystolic = bpMap[date]?.second,
                    bloodGlucose = glucoseMap[date]?.second
                )
            }

        val allTimeMin = mutableMapOf<String, Float>()
        val allTimeMax = mutableMapOf<String, Float>()

        for (metric in PhysicalCardConfig.GRAPHABLE_METRICS) {
            val values: List<Float> = graphDays.mapNotNull { getPhysicalDayValue(it, metric) }
            if (values.isNotEmpty()) {
                allTimeMin[metric] = values.minOrNull() ?: 0f
                allTimeMax[metric] = values.maxOrNull() ?: 1f
            }
        }

        PhysicalGraphResult(graphDays, allTimeMin, allTimeMax)
    } catch (_: Exception) {
        PhysicalGraphResult(emptyList(), emptyMap(), emptyMap())
    }
}

/** Fetch date+value pairs from a simple daily table via REST */
private fun fetchDailyDoubles(
    client: okhttp3.OkHttpClient,
    token: String,
    table: String,
    userId: String,
    column: String,
    limit: Int
): List<Pair<String, Double>> {
    return try {
        val url = "${BuildConfig.SUPABASE_URL}/rest/v1/$table?user_id=eq.$userId&select=date,$column&order=date.desc&limit=$limit"
        val request = okhttp3.Request.Builder().url(url).get()
            .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
            .addHeader("Authorization", "Bearer $token").build()
        val response = client.newCall(request).execute()
        val body = response.body?.string()
        if (response.isSuccessful && !body.isNullOrBlank()) {
            val arr = org.json.JSONArray(body)
            (0 until arr.length()).mapNotNull { i ->
                val obj = arr.getJSONObject(i)
                val date = obj.optString("date", "")
                val value = obj.optDouble(column)
                if (date.isNotBlank() && !value.isNaN()) Pair(date, value) else null
            }
        } else emptyList()
    } catch (_: Exception) { emptyList() }
}

/** Fetch blood pressure (systolic) date+value pairs via REST */
private fun fetchDailyBp(
    client: okhttp3.OkHttpClient,
    token: String,
    userId: String,
    limit: Int
): List<Pair<String, Double>> {
    return try {
        val url = "${BuildConfig.SUPABASE_URL}/rest/v1/blood_pressure_daily?user_id=eq.$userId&select=date,value_systolic&order=date.desc&limit=$limit"
        val request = okhttp3.Request.Builder().url(url).get()
            .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
            .addHeader("Authorization", "Bearer $token").build()
        val response = client.newCall(request).execute()
        val body = response.body?.string()
        if (response.isSuccessful && !body.isNullOrBlank()) {
            val arr = org.json.JSONArray(body)
            (0 until arr.length()).mapNotNull { i ->
                val obj = arr.getJSONObject(i)
                val date = obj.optString("date", "")
                val value = obj.optDouble("value_systolic")
                if (date.isNotBlank() && !value.isNaN()) Pair(date, value) else null
            }
        } else emptyList()
    } catch (_: Exception) { emptyList() }
}

title: PredictedMenstruationHelper.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import java.time.LocalDate

object PredictedMenstruationHelper {

    private const val TAG = "PredictedMenstruation"

    suspend fun ensureExists(context: Context) {
        try {
            val appContext = context.applicationContext
            val accessToken = SessionStore.getValidAccessToken(appContext) ?: return

            val db = SupabaseDbService(
                BuildConfig.SUPABASE_URL,
                BuildConfig.SUPABASE_ANON_KEY
            )

            // Check if predicted trigger already exists
            val allTriggers = db.getAllTriggers(accessToken)
            val existing = allTriggers.firstOrNull { trigger ->
                trigger.type == "menstruation_predicted" &&
                        trigger.source == "system"
            }

            if (existing != null) {
                Log.d(TAG, "Predicted trigger already exists")
                return
            }

            // Get menstruation settings
            val menstruationService = SupabaseMenstruationService(appContext)
            val settings = menstruationService.getSettings(accessToken) ?: run {
                // Create default settings if they don't exist
                menstruationService.updateSettings(
                    accessToken = accessToken,
                    lastMenstruationDate = null,
                    avgCycleLength = 28,
                    autoUpdateAverage = true
                )
                MenstruationSettings(
                    lastMenstruationDate = null,
                    avgCycleLength = 28,
                    autoUpdateAverage = true
                )
            }

            // Get last real menstruation trigger
            val lastPeriod = allTriggers
                .filter { it.type == "menstruation" && it.source != "system" }
                .maxByOrNull { it.startAt }

            // Calculate predicted date
            val predictedDate = if (lastPeriod != null) {
                val lastDate = LocalDate.parse(lastPeriod.startAt.substring(0, 10))
                lastDate.plusDays(settings.avgCycleLength.toLong())
            } else if (settings.lastMenstruationDate != null) {
                settings.lastMenstruationDate.plusDays(settings.avgCycleLength.toLong())
            } else {
                LocalDate.now().plusDays(settings.avgCycleLength.toLong())
            }

            // Create predicted trigger using insertTrigger
            db.insertTrigger(
                accessToken = accessToken,
                migraineId = null,
                type = "menstruation_predicted",
                startAt = "${predictedDate}T09:00:00Z",
                notes = "Predicted menstruation"
            )

            Log.d(TAG, "Created predicted trigger for date: $predictedDate")

        } catch (e: Exception) {
            Log.e(TAG, "Failed to ensure predicted trigger exists", e)
        }
    }

    suspend fun delete(context: Context) {
        try {
            val appContext = context.applicationContext
            val accessToken = SessionStore.getValidAccessToken(appContext) ?: return

            val db = SupabaseDbService(
                BuildConfig.SUPABASE_URL,
                BuildConfig.SUPABASE_ANON_KEY
            )

            // Find predicted trigger
            val allTriggers = db.getAllTriggers(accessToken)
            val predicted = allTriggers.firstOrNull { trigger ->
                trigger.type == "menstruation_predicted" &&
                        trigger.source == "system"
            }

            if (predicted == null) {
                Log.d(TAG, "No predicted trigger found")
                return
            }

            // Update to inactive using updateTrigger
            db.updateTrigger(
                accessToken = accessToken,
                id = predicted.id,
                type = predicted.type,
                startAt = predicted.startAt,
                notes = predicted.notes,
                migraineId = predicted.migraineId
            )

            Log.d(TAG, "Deactivated predicted trigger")

        } catch (e: Exception) {
            Log.e(TAG, "Failed to delete predicted trigger", e)
        }
    }
}

title: ProdromeIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

/**
 * Custom prodrome icons for MigraineMe.
 * Style: 24dp viewport, 2dp stroke, rounded caps/joins, no fill.
 * Each prodrome's icon_key maps to one ImageVector.
 *
 * Manual prodromes (18 unique icon keys):
 *   Autonomic:   yawning, nasal_congestion, tearing
 *   Cognitive:    brainfog  (Difficulty focusing, Word-finding trouble)
 *   Digestive:    food_cravings, loss_appetite
 *   Mood:         mood_change, irritability, euphoria, depression
 *   Physical:     neck (Muscle tension), frequent_urination
 *   Sensitivity:  light, sound, smell
 *   Sensory:      tingling (Tingling, Numbness)
 *   Sleep:        difficulty_sleeping, excessive_sleeping
 *
 * Auto-metric prodromes (7 icon keys):
 *   duration, score, disturbances, recovery, spo2, skin_temp, resp_rate
 */
object ProdromeIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    // ─── AUTONOMIC ───────────────────────────────────────────

    /** yawning — open mouth face */
    val Yawning: ImageVector by lazy {
        ImageVector.Builder("Yawning", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 5f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 19f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(15f, 14f)
                arcTo(3f, 2.5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 9f, 14f)
                arcTo(3f, 2.5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 15f, 14f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 10f); lineTo(10f, 10f)
                moveTo(14f, 10f); lineTo(16f, 10f)
            }
        }.build()
    }

    /** nasal_congestion — stuffy nose */
    val NasalCongestion: ImageVector by lazy {
        ImageVector.Builder("NasalCongestion", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 3f); lineTo(12f, 12f)
                curveTo(12f, 16f, 8f, 17f, 7f, 15f)
                moveTo(12f, 12f); curveTo(12f, 16f, 16f, 17f, 17f, 15f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(4f, 10f); lineTo(7f, 10f)
                moveTo(4f, 13f); lineTo(6f, 13f)
                moveTo(17f, 10f); lineTo(20f, 10f)
                moveTo(18f, 13f); lineTo(20f, 13f)
            }
        }.build()
    }

    /** tearing — eye with tear drop */
    val Tearing: ImageVector by lazy {
        ImageVector.Builder("Tearing", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); curveTo(5f, 7f, 9f, 5f, 12f, 5f)
                curveTo(15f, 5f, 19f, 7f, 22f, 12f)
                curveTo(19f, 17f, 15f, 19f, 12f, 19f)
                curveTo(9f, 19f, 5f, 17f, 2f, 12f)
                moveTo(14f, 12f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 12f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 14f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 17f); curveTo(17f, 17f, 15f, 20f, 17f, 22f)
                curveTo(19f, 20f, 17f, 17f, 17f, 17f)
            }
        }.build()
    }

    // ─── COGNITIVE ───────────────────────────────────────────

    /** brainfog — cloud over head */
    val BrainFog: ImageVector by lazy {
        ImageVector.Builder("BrainFog", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 22f); lineTo(6f, 16f)
                arcTo(6f, 6f, 0f, isMoreThanHalf = true, isPositiveArc = true, 18f, 16f)
                lineTo(18f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 11f); lineTo(18f, 11f)
                curveTo(20f, 11f, 21f, 9f, 20f, 7f); curveTo(19f, 5f, 17f, 5f, 16f, 6f)
                curveTo(16f, 4f, 14f, 3f, 12f, 3f); curveTo(10f, 3f, 8f, 4f, 8f, 6f)
                curveTo(7f, 5f, 5f, 5f, 4f, 7f); curveTo(3f, 9f, 4f, 11f, 6f, 11f)
            }
        }.build()
    }

    // ─── DIGESTIVE ───────────────────────────────────────────

    /** food_cravings — fork and knife with heart */
    val FoodCravings: ImageVector by lazy {
        ImageVector.Builder("FoodCravings", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(7f, 2f); lineTo(7f, 10f)
                moveTo(5f, 2f); lineTo(5f, 6f); curveTo(5f, 8f, 7f, 10f, 7f, 10f)
                moveTo(9f, 2f); lineTo(9f, 6f); curveTo(9f, 8f, 7f, 10f, 7f, 10f)
                moveTo(7f, 10f); lineTo(7f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 2f); curveTo(19f, 2f, 20f, 5f, 20f, 8f)
                curveTo(20f, 10f, 18f, 11f, 17f, 11f); lineTo(17f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 18f)
                curveTo(10f, 16f, 10f, 14f, 11f, 13.5f); curveTo(11.5f, 13f, 12f, 13.5f, 12f, 14f)
                curveTo(12f, 13.5f, 12.5f, 13f, 13f, 13.5f); curveTo(14f, 14f, 14f, 16f, 12f, 18f)
            }
        }.build()
    }

    /** loss_appetite — plate with minus */
    val LossAppetite: ImageVector by lazy {
        ImageVector.Builder("LossAppetite", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(20f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 4f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 20f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 12f); lineTo(16f, 12f)
            }
        }.build()
    }

    // ─── MOOD ────────────────────────────────────────────────

    /** mood_change — two-face (happy/sad) */
    val MoodChange: ImageVector by lazy {
        ImageVector.Builder("MoodChange", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(20f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 4f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 20f, 12f)
                moveTo(12f, 4f); lineTo(12f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(8f, 9f); lineTo(8.1f, 9f)
                moveTo(7f, 14f); curveTo(8f, 16f, 10f, 16f, 11f, 14f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(16f, 9f); lineTo(16.1f, 9f)
                moveTo(13f, 16f); curveTo(14f, 14f, 16f, 14f, 17f, 16f)
            }
        }.build()
    }

    /** irritability — face with anger lines */
    val Irritability: ImageVector by lazy {
        ImageVector.Builder("Irritability", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 12f)
                arcTo(5f, 5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 7f, 12f)
                arcTo(5f, 5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 17f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 11f); lineTo(10.1f, 11f)
                moveTo(14f, 11f); lineTo(14.1f, 11f)
                moveTo(10f, 15f); curveTo(11f, 14f, 13f, 14f, 14f, 15f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 4f); lineTo(6f, 7f)
                moveTo(21f, 4f); lineTo(18f, 7f)
                moveTo(12f, 1f); lineTo(12f, 4f)
                moveTo(3f, 20f); lineTo(6f, 17f)
                moveTo(21f, 20f); lineTo(18f, 17f)
            }
        }.build()
    }

    /** euphoria — face with stars */
    val Euphoria: ImageVector by lazy {
        ImageVector.Builder("Euphoria", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 5f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 19f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(9f, 8f); lineTo(9.5f, 10f); lineTo(8f, 11f); lineTo(10f, 11f); lineTo(9f, 8f)
                moveTo(15f, 8f); lineTo(15.5f, 10f); lineTo(14f, 11f); lineTo(16f, 11f); lineTo(15f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(8f, 14f); curveTo(9f, 17f, 15f, 17f, 16f, 14f)
            }
        }.build()
    }

    /** depression — sad face with tear */
    val Depression: ImageVector by lazy {
        ImageVector.Builder("Depression", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(19f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 5f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 19f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(9f, 10f); lineTo(9.1f, 10f)
                moveTo(15f, 10f); lineTo(15.1f, 10f)
                moveTo(9f, 16f); curveTo(10f, 14f, 14f, 14f, 15f, 16f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(9f, 11f); lineTo(9f, 13f)
            }
        }.build()
    }

    // ─── PHYSICAL ────────────────────────────────────────────

    /** neck — neck/shoulder with pain lines */
    val Neck: ImageVector by lazy {
        ImageVector.Builder("Neck", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(16f, 7f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 8f, 7f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 16f, 7f)
                moveTo(10f, 11f); lineTo(10f, 14f)
                moveTo(14f, 11f); lineTo(14f, 14f)
                moveTo(10f, 14f); curveTo(6f, 14f, 3f, 17f, 3f, 20f)
                moveTo(14f, 14f); curveTo(18f, 14f, 21f, 17f, 21f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(5f, 12f); lineTo(7f, 13f)
                moveTo(19f, 12f); lineTo(17f, 13f)
            }
        }.build()
    }

    /** frequent_urination — droplet with repeat arrows */
    val FrequentUrination: ImageVector by lazy {
        ImageVector.Builder("FrequentUrination", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 3f); curveTo(10f, 3f, 4f, 10f, 4f, 14f)
                arcTo(6f, 6f, 0f, isMoreThanHalf = false, isPositiveArc = false, 16f, 14f)
                curveTo(16f, 10f, 10f, 3f, 10f, 3f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(18f, 8f); lineTo(21f, 8f); lineTo(21f, 11f)
                moveTo(21f, 16f); lineTo(18f, 16f); lineTo(18f, 13f)
            }
        }.build()
    }

    // ─── SENSITIVITY ─────────────────────────────────────────

    /** light — eye with brightness rays */
    val Light: ImageVector by lazy {
        ImageVector.Builder("Light", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); curveTo(5f, 7f, 9f, 5f, 12f, 5f)
                curveTo(15f, 5f, 19f, 7f, 22f, 12f)
                curveTo(19f, 17f, 15f, 19f, 12f, 19f)
                curveTo(9f, 19f, 5f, 17f, 2f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 1f); lineTo(12f, 3f)
                moveTo(4f, 4f); lineTo(6f, 6f)
                moveTo(20f, 4f); lineTo(18f, 6f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 12f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 12f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 14f, 12f)
            }
        }.build()
    }

    /** sound — ear with waves */
    val Sound: ImageVector by lazy {
        ImageVector.Builder("Sound", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); curveTo(17f, 2f, 20f, 6f, 20f, 10f)
                curveTo(20f, 13f, 18f, 14f, 16f, 14f)
                curveTo(14f, 14f, 14f, 16f, 14f, 18f)
                curveTo(14f, 20f, 12f, 22f, 10f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 8f); curveTo(2f, 10f, 2f, 14f, 4f, 16f)
                moveTo(7f, 9f); curveTo(5.5f, 11f, 5.5f, 13f, 7f, 15f)
            }
        }.build()
    }

    /** smell — nose with wavy lines */
    val Smell: ImageVector by lazy {
        ImageVector.Builder("Smell", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 3f); lineTo(12f, 12f); curveTo(12f, 16f, 8f, 17f, 7f, 15f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(15f, 10f); curveTo(15f, 8f, 17f, 8f, 17f, 10f); curveTo(17f, 12f, 15f, 12f, 15f, 14f)
                moveTo(18f, 8f); curveTo(18f, 6f, 20f, 6f, 20f, 8f); curveTo(20f, 10f, 18f, 10f, 18f, 12f)
                moveTo(21f, 6f); curveTo(21f, 4f, 23f, 4f, 23f, 6f); curveTo(23f, 8f, 21f, 8f, 21f, 10f)
            }
        }.build()
    }

    // ─── SENSORY ─────────────────────────────────────────────

    /** tingling — hand with dots */
    val Tingling: ImageVector by lazy {
        ImageVector.Builder("Tingling", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f); lineTo(12f, 14f)
                moveTo(8f, 14f); lineTo(8f, 6f)
                moveTo(12f, 14f); lineTo(12f, 4f)
                moveTo(16f, 14f); lineTo(16f, 6f)
                moveTo(20f, 14f); lineTo(20f, 10f)
                moveTo(8f, 14f); curveTo(6f, 14f, 4f, 16f, 4f, 18f)
                lineTo(4f, 20f); lineTo(12f, 22f)
                moveTo(20f, 14f); lineTo(20f, 18f); lineTo(12f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(6f, 3f); lineTo(6.1f, 3f)
                moveTo(3f, 8f); lineTo(3.1f, 8f)
                moveTo(22f, 6f); lineTo(22.1f, 6f)
            }
        }.build()
    }

    // ─── SLEEP ───────────────────────────────────────────────

    /** difficulty_sleeping — bed with X */
    val DifficultySleeping: ImageVector by lazy {
        ImageVector.Builder("DifficultySleeping", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 18f); lineTo(22f, 18f)
                moveTo(2f, 12f); lineTo(22f, 12f); lineTo(22f, 18f)
                moveTo(2f, 12f); lineTo(2f, 18f)
                moveTo(4f, 12f); lineTo(4f, 10f); lineTo(8f, 10f); lineTo(8f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(14f, 3f); lineTo(20f, 9f)
                moveTo(20f, 3f); lineTo(14f, 9f)
            }
        }.build()
    }

    /** excessive_sleeping — bed with ZZZ */
    val ExcessiveSleeping: ImageVector by lazy {
        ImageVector.Builder("ExcessiveSleeping", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 18f); lineTo(22f, 18f)
                moveTo(2f, 12f); lineTo(22f, 12f); lineTo(22f, 18f)
                moveTo(2f, 12f); lineTo(2f, 18f)
                moveTo(4f, 12f); lineTo(4f, 10f); lineTo(8f, 10f); lineTo(8f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 3f); lineTo(18f, 3f); lineTo(14f, 7f); lineTo(18f, 7f)
                moveTo(19f, 1f); lineTo(22f, 1f); lineTo(19f, 4f); lineTo(22f, 4f)
            }
        }.build()
    }

    // ─── AUTO-METRIC ICONS ───────────────────────────────────

    /** duration — hourglass */
    val Duration: ImageVector by lazy {
        ImageVector.Builder("Duration", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 2f); lineTo(18f, 2f)
                moveTo(6f, 22f); lineTo(18f, 22f)
                moveTo(7f, 2f); curveTo(7f, 8f, 12f, 10f, 12f, 12f)
                curveTo(12f, 14f, 7f, 16f, 7f, 22f)
                moveTo(17f, 2f); curveTo(17f, 8f, 12f, 10f, 12f, 12f)
                curveTo(12f, 14f, 17f, 16f, 17f, 22f)
            }
        }.build()
    }

    /** score — star */
    val Score: ImageVector by lazy {
        ImageVector.Builder("Score", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(14.5f, 9f); lineTo(22f, 9f); lineTo(16f, 13.5f)
                lineTo(18f, 21f); lineTo(12f, 16.5f); lineTo(6f, 21f); lineTo(8f, 13.5f)
                lineTo(2f, 9f); lineTo(9.5f, 9f); close()
            }
        }.build()
    }

    /** disturbances — zigzag */
    val Disturbances: ImageVector by lazy {
        ImageVector.Builder("Disturbances", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 4f); lineTo(10f, 10f); lineTo(6f, 14f); lineTo(12f, 20f)
                moveTo(14f, 4f); lineTo(20f, 10f); lineTo(16f, 14f); lineTo(20f, 20f)
            }
        }.build()
    }

    /** recovery — battery with plus */
    val Recovery: ImageVector by lazy {
        ImageVector.Builder("Recovery", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 6f); lineTo(18f, 6f); lineTo(18f, 18f); lineTo(4f, 18f); close()
                moveTo(18f, 10f); lineTo(20f, 10f); lineTo(20f, 14f); lineTo(18f, 14f)
                moveTo(11f, 9f); lineTo(11f, 15f)
                moveTo(8f, 12f); lineTo(14f, 12f)
            }
        }.build()
    }

    /** spo2 — O2 molecule */
    val SpO2: ImageVector by lazy {
        ImageVector.Builder("SpO2", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 8f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 2f, 8f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 16f); curveTo(12f, 14f, 16f, 14f, 16f, 16f); curveTo(16f, 18f, 12f, 20f, 12f, 20f); lineTo(16f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(18f, 4f); curveTo(18f, 4f, 14f, 8f, 18f, 11f); curveTo(22f, 8f, 18f, 4f, 18f, 4f)
            }
        }.build()
    }

    /** skin_temp — thermometer */
    val SkinTemp: ImageVector by lazy {
        ImageVector.Builder("SkinTemp", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(10f, 3f); lineTo(14f, 3f); lineTo(14f, 14f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 14f)
                lineTo(10f, 3f)
                moveTo(13f, 17f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 11f, 17f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 13f, 17f)
                moveTo(12f, 15f); lineTo(12f, 7f)
            }
        }.build()
    }

    /** resp_rate — lungs */
    val RespRate: ImageVector by lazy {
        ImageVector.Builder("RespRate", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 8f)
                moveTo(12f, 8f); curveTo(8f, 8f, 4f, 12f, 4f, 16f); curveTo(4f, 20f, 8f, 20f, 12f, 18f)
                moveTo(12f, 8f); curveTo(16f, 8f, 20f, 12f, 20f, 16f); curveTo(20f, 20f, 16f, 20f, 12f, 18f)
            }
        }.build()
    }

    // ─── LOOKUP ──────────────────────────────────────────────

    data class ProdromePickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<ProdromePickerIcon> by lazy { listOf(
        // Autonomic
        ProdromePickerIcon("yawning", "Yawning", Yawning),
        ProdromePickerIcon("nasal_congestion", "Nasal congestion", NasalCongestion),
        ProdromePickerIcon("tearing", "Tearing", Tearing),
        // Cognitive
        ProdromePickerIcon("brainfog", "Brain fog", BrainFog),
        // Digestive
        ProdromePickerIcon("food_cravings", "Food cravings", FoodCravings),
        ProdromePickerIcon("loss_appetite", "Loss of appetite", LossAppetite),
        // Mood
        ProdromePickerIcon("mood_change", "Mood change", MoodChange),
        ProdromePickerIcon("irritability", "Irritability", Irritability),
        ProdromePickerIcon("euphoria", "Euphoria", Euphoria),
        ProdromePickerIcon("depression", "Depression", Depression),
        // Physical
        ProdromePickerIcon("neck", "Neck / tension", Neck),
        ProdromePickerIcon("frequent_urination", "Frequent urination", FrequentUrination),
        // Sensitivity
        ProdromePickerIcon("light", "Light sensitivity", Light),
        ProdromePickerIcon("sound", "Sound sensitivity", Sound),
        ProdromePickerIcon("smell", "Smell sensitivity", Smell),
        // Sensory
        ProdromePickerIcon("tingling", "Tingling", Tingling),
        // Sleep
        ProdromePickerIcon("difficulty_sleeping", "Difficulty sleeping", DifficultySleeping),
        ProdromePickerIcon("excessive_sleeping", "Excessive sleeping", ExcessiveSleeping),
        // Auto-metric
        ProdromePickerIcon("duration", "Duration", Duration),
        ProdromePickerIcon("score", "Score", Score),
        ProdromePickerIcon("disturbances", "Disturbances", Disturbances),
        ProdromePickerIcon("recovery", "Recovery", Recovery),
        ProdromePickerIcon("spo2", "SpO2", SpO2),
        ProdromePickerIcon("skin_temp", "Skin temp", SkinTemp),
        ProdromePickerIcon("resp_rate", "Resp rate", RespRate),
    ) }

    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: ProdromeLogScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun ProdromeLogScreen(
    navController: NavController,
    vm: ProdromeViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {},
    quickLogMode: Boolean = false,
    onSave: (() -> Unit)? = null,
    linkedMigraineId: String? = null,
    onMigraineSelect: ((String?) -> Unit)? = null
) {
    val rawPool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    // Show all prodromes in the logging wizard (including NONE prediction)
    // so system-detected anomalies are surfaced. Collapse display_group items
    // into a single entry (e.g. "Light sensitivity" instead of "Brightness low" + "Dark mode high")
    val pool = remember(rawPool) {
        val visible = rawPool
        val standalone = visible.filter { it.displayGroup == null }
        val grouped = visible.filter { it.displayGroup != null }
            .groupBy { it.displayGroup!! }
            .map { (groupName, members) ->
                val first = members.first()
                val severityOrder = listOf("HIGH", "MILD", "LOW", "NONE")
                val bestSeverity = members.map { it.predictionValue?.uppercase() ?: "NONE" }
                    .minByOrNull { sev -> severityOrder.indexOf(sev) } ?: "NONE"
                SupabaseDbService.UserProdromeRow(
                    id = "group_${groupName}",
                    label = groupName,
                    iconKey = first.iconKey,
                    category = first.category,
                    predictionValue = bestSeverity,
                    displayGroup = groupName
                )
            }
        standalone + grouped
    }
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken, draft.migraine?.beganAtIso) {
        authState.accessToken?.let {
            vm.loadAll(it)
            vm.loadRecent(it, draft.migraine?.beganAtIso)
        }
    }

    // Recent prodromes: type → days ago
    val recentDaysAgo by vm.recentDaysAgo.collectAsState()
    val recentStartAts by vm.recentStartAts.collectAsState()
    var hasAutoSelected by remember { mutableStateOf(false) }

    // Reset auto-select when migraine date changes
    LaunchedEffect(draft.migraine?.beganAtIso) {
        hasAutoSelected = false
    }

    // ── Rebuild helpers ──
    fun rebuildDraftWithProdromes(prodromes: List<ProdromeDraft>) {
        logVm.replaceProdromes(prodromes)
    }

    // ── Time dialog: add new ──
    var showAddTimeDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }

    // ── Auto-select recent prodromes (once, on first load — wizard only) ──
    // Only auto-select when user has explicitly set a migraine date
    LaunchedEffect(recentDaysAgo, pool) {
        if (!quickLogMode && !hasAutoSelected && recentDaysAgo.isNotEmpty() && pool.isNotEmpty() && draft.migraine?.beganAtIso != null) {
            val currentLabels = draft.prodromes.map { it.type }.toSet()
            val poolLabelsSet = pool.map { it.label }.toSet()
            val toAdd = recentDaysAgo.keys
                .filter { it in poolLabelsSet && it !in currentLabels }
            if (toAdd.isNotEmpty()) {
                val newProdromes = draft.prodromes + toAdd.map { ProdromeDraft(it, startAtIso = recentStartAts[it]) }
                rebuildDraftWithProdromes(newProdromes)
            }
            hasAutoSelected = true
        }
    }

    // ── Time dialog: edit existing ──
    var showEditTimeDialog by remember { mutableStateOf(false) }
    var editIndex by remember { mutableStateOf<Int?>(null) }

    fun onProdromeTap(label: String) {
        val existingIdx = draft.prodromes.indexOfFirst { it.type == label }
        if (existingIdx >= 0) {
            val updated = draft.prodromes.toMutableList().apply { removeAt(existingIdx) }
            rebuildDraftWithProdromes(updated)
        } else {
            pendingLabel = label
            showAddTimeDialog = true
        }
    }

    // Add dialog
    if (showAddTimeDialog && pendingLabel != null) {
        ProdromeTimeDialog(
            title = pendingLabel!!,
            initialIso = null,
            onDismiss = { showAddTimeDialog = false },
            onSkip = {
                val updated = draft.prodromes + ProdromeDraft(pendingLabel!!, startAtIso = null)
                rebuildDraftWithProdromes(updated)
                showAddTimeDialog = false
            },
            onConfirm = { iso ->
                val updated = draft.prodromes + ProdromeDraft(pendingLabel!!, startAtIso = iso)
                rebuildDraftWithProdromes(updated)
                showAddTimeDialog = false
            }
        )
    }

    // Edit dialog
    if (showEditTimeDialog && editIndex != null && editIndex!! in draft.prodromes.indices) {
        val editing = draft.prodromes[editIndex!!]
        ProdromeTimeDialog(
            title = editing.type,
            initialIso = editing.startAtIso,
            onDismiss = { showEditTimeDialog = false },
            onSkip = {
                val updated = draft.prodromes.toMutableList().apply {
                    set(editIndex!!, editing.copy(startAtIso = null))
                }
                rebuildDraftWithProdromes(updated)
                showEditTimeDialog = false
            },
            onConfirm = { iso ->
                val updated = draft.prodromes.toMutableList().apply {
                    set(editIndex!!, editing.copy(startAtIso = iso))
                }
                rebuildDraftWithProdromes(updated)
                showEditTimeDialog = false
            }
        )
    }

    // Frequent labels
    val poolLabels = remember(pool) { pool.map { it.label }.toSet() }
    val frequentLabels = remember(frequent, poolLabels) {
        frequent.mapNotNull { it.prodrome?.label }.filter { it in poolLabels }.toSet()
    }
    val selectedLabels = remember(draft.prodromes) { draft.prodromes.map { it.type }.toSet() }

    // Group pool by category
    val grouped = remember(pool) {
        pool.groupBy { it.category ?: "Other" }.toSortedMap()
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                if (!quickLogMode) {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                        Spacer(Modifier.width(4.dp))
                        Text("Pain", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                    }
                } else {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    }
                }
                Text("Prodromes", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                if (!quickLogMode) {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Outlined.Close, "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                    }
                } else {
                    Spacer(Modifier.size(28.dp))
                }
            }

            // ── Selected prodromes card (hero area) ──
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawProdromeEye(Color(0xFFCE93D8)) } }
                )
                Text("Prodromes", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.prodromes.isEmpty()) "Select early warning signs"
                    else "${draft.prodromes.size} prodrome${if (draft.prodromes.size > 1) "s" else ""} selected",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
                if (draft.prodromes.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.prodromes.forEachIndexed { index, p ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 3.dp)
                                .clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f))
                                .padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            // Icon in the selected row
                            val rowIcon = pool.find { it.label == p.type }?.iconKey?.let { ProdromeIcons.forKey(it) }
                            if (rowIcon != null) {
                                Icon(
                                    imageVector = rowIcon,
                                    contentDescription = null,
                                    tint = Color(0xFFCE93D8),
                                    modifier = Modifier.size(20.dp)
                                )
                                Spacer(Modifier.width(8.dp))
                            }
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    p.type,
                                    color = AppTheme.BodyTextColor,
                                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
                                )
                                Text(
                                    if (p.startAtIso == null) "Same as migraine start"
                                    else formatProdromeTime(p.startAtIso),
                                    color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                    style = MaterialTheme.typography.labelSmall
                                )
                            }
                            Icon(
                                Icons.Outlined.Edit,
                                contentDescription = "Edit time",
                                tint = AppTheme.AccentPurple.copy(alpha = 0.7f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        editIndex = index
                                        showEditTimeDialog = true
                                    }
                            )
                            Spacer(Modifier.width(8.dp))
                            Icon(
                                Icons.Outlined.Close,
                                contentDescription = "Remove",
                                tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        val updated = draft.prodromes.toMutableList().apply { removeAt(index) }
                                        rebuildDraftWithProdromes(updated)
                                    }
                            )
                        }
                    }
                }
            }

            // Manage card
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Prodromes", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_PRODROMES) })
                }
            }

            if (quickLogMode && onMigraineSelect != null) {
                val firstIso = draft.prodromes.firstOrNull()?.startAtIso
                MigrainePickerCard(itemStartAtIso = firstIso, authVm = authVm, selectedMigraineId = linkedMigraineId, onSelect = onMigraineSelect)
            }

            // ── Prodromes card: Frequent, then categories ──
            BaseCard {
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { prod ->
                            ProdromeButton(prod.label, prod.label in selectedLabels, prod.iconKey, daysAgo = recentDaysAgo[prod.label]) {
                                onProdromeTap(prod.label)
                            }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }

                val categoryEntries = grouped.entries.toList()
                categoryEntries.forEachIndexed { catIndex, (category, items) ->
                    val nonFreqItems = items.filter { it.label !in frequentLabels }
                    if (nonFreqItems.isNotEmpty()) {
                        Text(category, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreqItems.forEach { prod ->
                                ProdromeButton(prod.label, prod.label in selectedLabels, prod.iconKey, daysAgo = recentDaysAgo[prod.label]) {
                                    onProdromeTap(prod.label)
                                }
                            }
                        }
                        val hasMore = categoryEntries.drop(catIndex + 1).any { (_, its) -> its.any { it.label !in frequentLabels } }
                        if (hasMore) {
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                        }
                    }
                }

                if (pool.isEmpty()) {
                    Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // Nav buttons
            Row(
                Modifier.fillMaxWidth().padding(vertical = 8.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Cancel" else "Back") }
                Button(
                    onClick = { if (quickLogMode) onSave?.invoke() else navController.navigate(Routes.TRIGGERS) },
                    enabled = !quickLogMode || draft.prodromes.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Save" else "Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

/* ────────────────────────────────────────────────
 *  Time dialog
 * ──────────────────────────────────────────────── */

@Composable
private fun ProdromeTimeDialog(
    title: String,
    initialIso: String?,
    onDismiss: () -> Unit,
    onSkip: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf(initialIso) }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text(
                    "When did this start?",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
                Text(
                    "Time: ${formatProdromeTime(pickedIso)}",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
                AppDateTimePicker(
                    label = "Select time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        },
        confirmButton = {
            TextButton(onClick = { onConfirm(pickedIso) }) {
                Text("Set time", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
                TextButton(onClick = onSkip) {
                    Text("Skip", color = Color(0xFFCE93D8))
                }
            }
        }
    )
}

/* ────────────────────────────────────────────────
 *  Prodrome circle button — renders ProdromeIcons
 * ──────────────────────────────────────────────── */

@Composable
private fun ProdromeButton(label: String, isSelected: Boolean, iconKey: String? = null, daysAgo: Int? = null, onClick: () -> Unit) {
    val accent = Color(0xFFCE93D8)

    // Graduated colors based on recency
    // null/not-recent + not-selected = default unselected
    // selected + no recent history = current accent
    // selected + recent = tinted by how recent
    val (circleColor, borderColor) = when {
        isSelected && daysAgo == null -> accent.copy(alpha = 0.40f) to accent.copy(alpha = 0.7f) // manually selected, no recent history
        isSelected && daysAgo == 0   -> accent.copy(alpha = 0.50f) to accent.copy(alpha = 0.85f) // today
        isSelected && daysAgo == 1   -> Color(0xFF9575CD).copy(alpha = 0.35f) to Color(0xFF9575CD).copy(alpha = 0.65f) // yesterday - bluer purple
        isSelected && daysAgo == 2   -> Color(0xFF7986CB).copy(alpha = 0.30f) to Color(0xFF7986CB).copy(alpha = 0.55f) // 2 days - indigo
        isSelected && daysAgo == 3   -> Color(0xFF64B5F6).copy(alpha = 0.25f) to Color(0xFF64B5F6).copy(alpha = 0.45f) // 3 days - blue
        else -> Color.White.copy(alpha = 0.08f) to Color.White.copy(alpha = 0.12f)
    }
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor

    val icon = ProdromeIcons.forKey(iconKey)

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(72.dp)
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            modifier = Modifier
                .size(52.dp)
                .clip(CircleShape)
                .background(circleColor)
                .border(width = 1.5.dp, color = borderColor, shape = CircleShape),
            contentAlignment = Alignment.Center
        ) {
            if (icon != null) {
                Icon(
                    imageVector = icon,
                    contentDescription = label,
                    tint = iconTint,
                    modifier = Modifier.size(24.dp)
                )
            } else {
                Text(
                    label.take(2).uppercase(),
                    color = iconTint,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(
            label,
            color = textColor,
            style = MaterialTheme.typography.labelSmall,
            textAlign = TextAlign.Center,
            maxLines = 2,
            modifier = Modifier.fillMaxWidth()
        )
        if (isSelected && daysAgo != null && daysAgo > 0) {
            Text(
                when (daysAgo) {
                    1 -> "yesterday"
                    2 -> "2d ago"
                    3 -> "3d ago"
                    else -> ""
                },
                color = Color.White.copy(alpha = 0.5f),
                style = MaterialTheme.typography.labelSmall.copy(fontSize = 9.sp),
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

/* ────────────────────────────────────────────────
 *  Format helper
 * ──────────────────────────────────────────────── */

private fun formatProdromeTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime()
            ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull()
            ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}




title: ProdromeViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class ProdromeViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserProdromeRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserProdromeRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.ProdromePrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.ProdromePrefRow>> = _frequent

    /** Map of prodrome type → days ago (0=today, 1=yesterday, 2=two days, 3=three days). Lowest value wins if logged multiple times. */
    private val _recentDaysAgo = MutableStateFlow<Map<String, Int>>(emptyMap())
    val recentDaysAgo: StateFlow<Map<String, Int>> = _recentDaysAgo

    /** Map of prodrome type → most recent start_at ISO string. */
    private val _recentStartAts = MutableStateFlow<Map<String, String>>(emptyMap())
    val recentStartAts: StateFlow<Map<String, String>> = _recentStartAts

    private fun safeSortPrefs(prefs: List<SupabaseDbService.ProdromePrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllProdromePool(accessToken)
                val prefs = db.getProdromePrefs(accessToken)
                _pool.value = p
                _frequent.value = safeSortPrefs(prefs.filter { it.status == "frequent" })
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
            }
        }
    }

    fun loadRecent(accessToken: String, referenceDate: String? = null) {
        viewModelScope.launch {
            try {
                val refDate = referenceDate?.let {
                    try { java.time.LocalDate.parse(it.substring(0, 10)) } catch (_: Exception) { null }
                } ?: java.time.LocalDate.now()
                val rows = db.getRecentProdromes(accessToken, daysBack = 3, referenceDate = refDate.toString())
                val map = mutableMapOf<String, Int>()
                val isoMap = mutableMapOf<String, String>()
                for (row in rows) {
                    val type = row.type ?: continue
                    val startAt = row.startAt ?: continue
                    val date = try {
                        java.time.LocalDate.parse(startAt.substring(0, 10))
                    } catch (_: Exception) { continue }
                    val daysAgo = kotlin.math.abs(java.time.temporal.ChronoUnit.DAYS.between(date, refDate).toInt())
                    if (daysAgo in 0..3) {
                        val existing = map[type]
                        if (existing == null || daysAgo < existing) {
                            map[type] = daysAgo
                            isoMap[type] = startAt
                        }
                    }
                }
                _recentDaysAgo.value = map
                _recentStartAts.value = isoMap
            } catch (e: Exception) {
                e.printStackTrace()
                _recentDaysAgo.value = emptyMap()
                _recentStartAts.value = emptyMap()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null, predictionValue: String? = "NONE") {
        viewModelScope.launch {
            try {
                db.upsertProdromeToPool(accessToken, label.trim(), category, predictionValue)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, prodromeId: String) {
        viewModelScope.launch {
            try {
                db.deleteProdromeFromPool(accessToken, prodromeId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, prodromeId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertProdromePref(accessToken, prodromeId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteProdromePref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun setPrediction(accessToken: String, prodromeId: String, value: String) {
        viewModelScope.launch {
            try {
                db.updateProdromePoolItem(accessToken, prodromeId, predictionValue = value)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun setCategory(accessToken: String, prodromeId: String, category: String?) {
        viewModelScope.launch {
            try {
                db.updateProdromePoolItem(accessToken, prodromeId, category = category)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


title: ProfileScreen.kt
text:
// FILE: app/src/main/java/com/migraineme/ProfileScreen.kt
package com.migraineme

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.provider.OpenableColumns
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.expandVertically
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.shrinkVertically
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.*
import java.io.ByteArrayOutputStream
import java.io.OutputStream
import java.net.HttpURLConnection
import java.net.URL
import kotlin.math.max

@Composable
fun ProfileScreen(
    authVm: AuthViewModel = viewModel(),
    onNavigateChangePassword: () -> Unit
) {
    val auth by authVm.state.collectAsState()
    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    val profile = remember { mutableStateOf<SupabaseProfileService.Profile?>(null) }
    val profileError = remember { mutableStateOf<String?>(null) }
    val profileLoading = remember { mutableStateOf(false) }

    val isEditing = remember { mutableStateOf(false) }
    val editName = remember { mutableStateOf("") }
    val selectedMigraineType = remember { mutableStateOf<SupabaseProfileService.MigraineType?>(null) }
    val migraineMenuExpanded = remember { mutableStateOf(false) }

    val avatarBitmap = remember { mutableStateOf<androidx.compose.ui.graphics.ImageBitmap?>(null) }
    val avatarUploadErrorDialog = remember { mutableStateOf<String?>(null) }
    val avatarUploading = remember { mutableStateOf(false) }

    val canChangePassword = remember { mutableStateOf(false) }

    // ── AI Setup Profile state ──
    var aiProfile by remember { mutableStateOf<JsonObject?>(null) }
    var aiProfileLoading by remember { mutableStateOf(false) }

    LaunchedEffect(auth.accessToken, auth.userId) {
        val token = auth.accessToken
        if (token.isNullOrBlank()) {
            canChangePassword.value = false
            return@LaunchedEffect
        }
        val storedProvider = SessionStore.readAuthProvider(context)
        if (!storedProvider.isNullOrBlank()) {
            canChangePassword.value = storedProvider == "email"
            return@LaunchedEffect
        }
        try {
            val user = withContext(Dispatchers.IO) { SupabaseAuthService.getUser(token) }
            canChangePassword.value = user.identities?.any { it.provider == "email" } == true
        } catch (_: Throwable) {
            canChangePassword.value = false
        }
    }

    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        if (uri == null) return@rememberLauncherForActivityResult
        val token = auth.accessToken
        val userId = auth.userId
        if (token.isNullOrBlank() || userId.isNullOrBlank()) {
            avatarUploadErrorDialog.value = "You must be signed in to update your profile picture."
            return@rememberLauncherForActivityResult
        }
        runCatching {
            val bmp = decodePreviewBitmap(context, uri, 512)
            if (bmp != null) avatarBitmap.value = bmp.asImageBitmap()
        }
        profileLoading.value = true
        profileError.value = null
        avatarUploading.value = true
        scope.launch {
            try {
                val publicUrl = withContext(Dispatchers.IO) {
                    uploadAvatarToSupabaseStorage(context, token, userId, uri)
                }
                val cacheBustedUrl = "$publicUrl?v=${System.currentTimeMillis()}"
                val updated = withContext(Dispatchers.IO) {
                    SupabaseProfileService.updateProfile(accessToken = token, userId = userId, displayName = null, avatarUrl = cacheBustedUrl, migraineType = null)
                }
                profile.value = updated
                runCatching {
                    val bmp = withContext(Dispatchers.IO) { URL(cacheBustedUrl).openStream().use { BitmapFactory.decodeStream(it) } }
                    avatarBitmap.value = bmp?.asImageBitmap()
                }
            } catch (t: Throwable) {
                avatarUploadErrorDialog.value = t.message ?: "Failed to upload profile picture."
            } finally {
                avatarUploading.value = false
                profileLoading.value = false
            }
        }
    }

    // Load profile
    LaunchedEffect(auth.accessToken, auth.userId) {
        val token = auth.accessToken
        val userId = auth.userId
        if (token.isNullOrBlank() || userId.isNullOrBlank()) return@LaunchedEffect
        profileLoading.value = true
        profileError.value = null
        try {
            val result = withContext(Dispatchers.IO) {
                SupabaseProfileService.ensureProfile(accessToken = token, userId = userId, displayNameHint = null, avatarUrlHint = null)
            }
            profile.value = result
            editName.value = result.displayName.orEmpty()
            selectedMigraineType.value = result.migraineType
        } catch (t: Throwable) {
            profileError.value = t.message
        } finally {
            profileLoading.value = false
        }
    }

    // Load AI setup profile
    LaunchedEffect(auth.accessToken, auth.userId) {
        val token = auth.accessToken
        val userId = auth.userId
        if (token.isNullOrBlank() || userId.isNullOrBlank()) return@LaunchedEffect
        aiProfileLoading = true
        try {
            val result = withContext(Dispatchers.IO) {
                val baseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
                val fetchUrl = "$baseUrl/rest/v1/ai_setup_profiles?user_id=eq.$userId&select=answers,ai_config,frequency,duration,experience,trigger_areas,clinical_assessment,summary,gender,age_range,trajectory,seasonal_pattern,tracks_cycle"
                val conn = (URL(fetchUrl).openConnection() as HttpURLConnection).apply {
                    requestMethod = "GET"
                    setRequestProperty("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    setRequestProperty("Authorization", "Bearer $token")
                    setRequestProperty("Accept", "application/json")
                }
                try {
                    val code = conn.responseCode
                    if (code in 200..299) {
                        val text = conn.inputStream.bufferedReader().readText()
                        val arr = Json.parseToJsonElement(text).jsonArray
                        arr.firstOrNull()?.jsonObject
                    } else null
                } finally {
                    conn.disconnect()
                }
            }
            aiProfile = result
        } catch (_: Throwable) {
            aiProfile = null
        } finally {
            aiProfileLoading = false
        }
    }

    // Load avatar
    LaunchedEffect(profile.value?.avatarUrl) {
        val url = profile.value?.avatarUrl?.trim()
        if (url.isNullOrBlank()) { avatarBitmap.value = null; return@LaunchedEffect }
        avatarBitmap.value = null
        try {
            val bmp = withContext(Dispatchers.IO) { URL(url).openStream().use { BitmapFactory.decodeStream(it) } }
            avatarBitmap.value = bmp?.asImageBitmap()
        } catch (_: Throwable) { avatarBitmap.value = null }
    }

    fun saveInline() {
        val token = auth.accessToken ?: return
        val userId = auth.userId ?: return
        profileLoading.value = true
        profileError.value = null
        scope.launch {
            try {
                val updated = withContext(Dispatchers.IO) {
                    SupabaseProfileService.updateProfile(accessToken = token, userId = userId, displayName = editName.value.trim().ifBlank { null }, avatarUrl = null, migraineType = selectedMigraineType.value)
                }
                profile.value = updated
                isEditing.value = false
            } catch (t: Throwable) { profileError.value = t.message } finally { profileLoading.value = false }
        }
    }

    fun cancelInline() {
        profile.value?.let { editName.value = it.displayName.orEmpty(); selectedMigraineType.value = it.migraineType }
        migraineMenuExpanded.value = false
        isEditing.value = false
    }

    // ── Dialogs ──
    if (avatarUploading.value) {
        AlertDialog(
            onDismissRequest = {},
            confirmButton = {},
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            title = { Text("Updating picture") },
            text = {
                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    CircularProgressIndicator(modifier = Modifier.size(22.dp), color = AppTheme.AccentPurple)
                    Text("Uploading and updating profile…")
                }
            }
        )
    }

    avatarUploadErrorDialog.value?.let { msg ->
        AlertDialog(
            onDismissRequest = { avatarUploadErrorDialog.value = null },
            containerColor = Color(0xFF1E0A2E),
            titleContentColor = Color.White,
            textContentColor = AppTheme.BodyTextColor,
            title = { Text("Upload failed") },
            text = { Text(msg) },
            confirmButton = { TextButton(onClick = { avatarUploadErrorDialog.value = null }) { Text("OK", color = AppTheme.AccentPurple) } }
        )
    }

    // ═══════════════════════════════════════════════════════════════
    // UI
    // ═══════════════════════════════════════════════════════════════

    Column(
        Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(horizontal = 20.dp, vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // ── Header ──
        Text("Profile", color = Color.White, style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold))

        // ── Profile Card ──
        val current = profile.value
        val headerName = current?.displayName?.takeIf { it.isNotBlank() } ?: "Name not set"

        Card(
            colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer),
            shape = AppTheme.BaseCardShape,
            border = AppTheme.BaseCardBorder,
        ) {
            Column(Modifier.padding(16.dp)) {
                Row(verticalAlignment = Alignment.Top) {
                    // Avatar
                    Box(
                        Modifier.size(72.dp)
                            .clip(CircleShape)
                            .background(Brush.linearGradient(listOf(AppTheme.AccentPurple.copy(alpha = 0.3f), AppTheme.AccentPink.copy(alpha = 0.2f)))),
                        contentAlignment = Alignment.Center
                    ) {
                        val bmp = avatarBitmap.value
                        if (bmp != null) {
                            Image(bitmap = bmp, contentDescription = "Avatar", contentScale = ContentScale.Crop, modifier = Modifier.fillMaxSize().clip(CircleShape))
                        } else {
                            Text(headerName.trim().firstOrNull()?.uppercase() ?: "?", color = Color.White, style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold))
                        }
                    }

                    Spacer(Modifier.width(16.dp))

                    Column(Modifier.weight(1f)) {
                        if (isEditing.value) {
                            OutlinedTextField(
                                value = editName.value, onValueChange = { editName.value = it },
                                label = { Text("Name", color = AppTheme.SubtleTextColor) },
                                singleLine = true,
                                enabled = auth.accessToken != null && !profileLoading.value,
                                textStyle = MaterialTheme.typography.bodyMedium.copy(color = Color.White),
                                colors = OutlinedTextFieldDefaults.colors(focusedBorderColor = AppTheme.AccentPurple, unfocusedBorderColor = AppTheme.TrackColor, cursorColor = AppTheme.AccentPurple),
                                modifier = Modifier.fillMaxWidth()
                            )
                        } else {
                            Text(headerName, color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold), maxLines = 1, overflow = TextOverflow.Ellipsis)
                        }

                        Spacer(Modifier.height(4.dp))

                        if (isEditing.value) {
                            Spacer(Modifier.height(8.dp))
                            OutlinedButton(
                                onClick = { migraineMenuExpanded.value = true },
                                enabled = auth.accessToken != null && !profileLoading.value,
                                shape = RoundedCornerShape(10.dp),
                                border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                                colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple),
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                Text(selectedMigraineType.value?.label ?: "Select migraine type", style = MaterialTheme.typography.bodySmall)
                            }
                        } else {
                            Text(current?.migraineType?.label ?: "Migraine type not set", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        }

                        Spacer(Modifier.height(4.dp))
                        Text("ID: ${auth.userId?.take(8) ?: "—"}…", color = AppTheme.SubtleTextColor.copy(alpha = 0.4f), style = MaterialTheme.typography.labelSmall)
                    }

                    // Edit / Save / Cancel buttons
                    Column(horizontalAlignment = Alignment.End) {
                        if (isEditing.value) {
                            IconButton(onClick = { saveInline() }, enabled = auth.accessToken != null && !profileLoading.value, modifier = Modifier.size(36.dp)) {
                                Icon(Icons.Outlined.Check, "Save", tint = AppTheme.AccentPurple)
                            }
                            IconButton(onClick = { cancelInline() }, enabled = !profileLoading.value, modifier = Modifier.size(36.dp)) {
                                Icon(Icons.Outlined.Close, "Cancel", tint = AppTheme.SubtleTextColor)
                            }
                        } else {
                            IconButton(onClick = { isEditing.value = true }, enabled = auth.accessToken != null && !profileLoading.value, modifier = Modifier.size(36.dp)) {
                                Icon(Icons.Outlined.Edit, "Edit", tint = AppTheme.AccentPurple)
                            }
                        }
                    }
                }

                // Edit avatar button
                if (isEditing.value) {
                    Spacer(Modifier.height(8.dp))
                    OutlinedButton(
                        onClick = { imagePickerLauncher.launch("image/*") },
                        enabled = auth.accessToken != null && !profileLoading.value,
                        shape = RoundedCornerShape(10.dp),
                        border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPink.copy(alpha = 0.5f)),
                        colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPink),
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(Icons.Outlined.CameraAlt, null, Modifier.size(16.dp))
                        Spacer(Modifier.width(6.dp))
                        Text("Change profile picture", style = MaterialTheme.typography.bodySmall)
                    }
                }

                // Migraine type dropdown
                DropdownMenu(expanded = migraineMenuExpanded.value, onDismissRequest = { migraineMenuExpanded.value = false }) {
                    DropdownMenuItem(text = { Text("Not set") }, onClick = { selectedMigraineType.value = null; migraineMenuExpanded.value = false })
                    SupabaseProfileService.MigraineType.entries.forEach { option ->
                        DropdownMenuItem(text = { Text(option.label) }, onClick = { selectedMigraineType.value = option; migraineMenuExpanded.value = false })
                    }
                }
            }
        }

        // ── Error ──
        profileError.value?.let {
            Text(it, color = Color(0xFFEF5350), style = MaterialTheme.typography.bodySmall)
        }

        // ── AI Migraine Profile ──
        if (aiProfileLoading) {
            Card(colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer), shape = AppTheme.BaseCardShape, border = AppTheme.BaseCardBorder) {
                Row(Modifier.padding(20.dp).fillMaxWidth(), horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically) {
                    CircularProgressIndicator(Modifier.size(18.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                    Spacer(Modifier.width(10.dp))
                    Text("Loading migraine profile…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }
        }

        if (aiProfile != null) {
            AiMigraineProfileCard(aiProfile!!)
        }

        // ── Change Password ──
        if (canChangePassword.value) {
            OutlinedButton(
                onClick = { onNavigateChangePassword() },
                enabled = auth.accessToken != null && !profileLoading.value,
                modifier = Modifier.fillMaxWidth(),
                shape = RoundedCornerShape(12.dp),
                border = androidx.compose.foundation.BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
            ) {
                Icon(Icons.Outlined.Lock, null, Modifier.size(18.dp))
                Spacer(Modifier.width(8.dp))
                Text("Change password")
            }
        }

        Spacer(Modifier.height(32.dp))
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// AI Migraine Profile Card
// ═══════════════════════════════════════════════════════════════════════════

@Composable
private fun AiMigraineProfileCard(data: JsonObject) {
    val summary = data["summary"]?.jsonPrimitive?.contentOrNull
    val clinicalAssessment = data["clinical_assessment"]?.jsonPrimitive?.contentOrNull
    val frequency = data["frequency"]?.jsonPrimitive?.contentOrNull
    val duration = data["duration"]?.jsonPrimitive?.contentOrNull
    val experience = data["experience"]?.jsonPrimitive?.contentOrNull
    val trajectory = data["trajectory"]?.jsonPrimitive?.contentOrNull
    val gender = data["gender"]?.jsonPrimitive?.contentOrNull
    val ageRange = data["age_range"]?.jsonPrimitive?.contentOrNull
    val seasonalPattern = data["seasonal_pattern"]?.jsonPrimitive?.contentOrNull
    val tracksCycle = data["tracks_cycle"]?.jsonPrimitive?.booleanOrNull
    val triggerAreas = try {
        data["trigger_areas"]?.jsonArray?.mapNotNull { it.jsonPrimitive.contentOrNull }
    } catch (_: Exception) { null }

    val answers = try { data["answers"]?.jsonObject } catch (_: Exception) { null }
    val freeText = answers?.get("free_text")?.jsonPrimitive?.contentOrNull

    var expanded by remember { mutableStateOf(true) }

    Card(
        colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer),
        shape = AppTheme.BaseCardShape,
        border = AppTheme.BaseCardBorder,
    ) {
        Column(Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(12.dp)) {

            // Header
            Row(
                Modifier.fillMaxWidth().clickable { expanded = !expanded },
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(10.dp)
            ) {
                Box(
                    Modifier.size(38.dp)
                        .background(Brush.linearGradient(listOf(AppTheme.AccentPink.copy(alpha = 0.3f), AppTheme.AccentPurple.copy(alpha = 0.2f))), RoundedCornerShape(12.dp)),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(Icons.Outlined.Psychology, null, tint = Color.White, modifier = Modifier.size(20.dp))
                }
                Column(Modifier.weight(1f)) {
                    Text("Your Migraine Profile", color = Color.White, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold))
                    Text("From AI setup questionnaire", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
                Icon(if (expanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore, null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(20.dp))
            }

            AnimatedVisibility(visible = expanded, enter = expandVertically() + fadeIn(), exit = shrinkVertically() + fadeOut()) {
                Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {

                    // Summary
                    if (!summary.isNullOrBlank()) {
                        Row(
                            Modifier.fillMaxWidth()
                                .background(AppTheme.AccentPurple.copy(alpha = 0.1f), RoundedCornerShape(12.dp))
                                .padding(12.dp),
                            horizontalArrangement = Arrangement.spacedBy(10.dp)
                        ) {
                            Icon(Icons.Outlined.AutoAwesome, null, tint = AppTheme.AccentPink, modifier = Modifier.size(18.dp))
                            Text(summary, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                        }
                    }

                    // Quick stats row
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        if (frequency != null) ProfileStatChip(Icons.Outlined.CalendarMonth, frequency, Modifier.weight(1f))
                        if (duration != null) ProfileStatChip(Icons.Outlined.Timer, duration, Modifier.weight(1f))
                    }
                    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        if (experience != null) ProfileStatChip(Icons.Outlined.History, experience, Modifier.weight(1f))
                        if (trajectory != null) ProfileStatChip(Icons.Outlined.TrendingUp, trajectory, Modifier.weight(1f))
                    }

                    // Demographics
                    val demoItems = listOfNotNull(
                        gender?.let { "Gender" to it },
                        ageRange?.let { "Age" to it },
                        seasonalPattern?.let { "Seasonal" to it },
                        if (tracksCycle == true) "Cycle" to "Tracking" else null,
                    )
                    if (demoItems.isNotEmpty()) {
                        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                            demoItems.forEach { (label, value) ->
                                Box(
                                    Modifier
                                        .clip(RoundedCornerShape(8.dp))
                                        .background(AppTheme.TrackColor.copy(alpha = 0.4f))
                                        .padding(horizontal = 10.dp, vertical = 6.dp)
                                ) {
                                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                        Text(value, color = Color.White, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold), maxLines = 1)
                                        Text(label, color = AppTheme.SubtleTextColor.copy(alpha = 0.6f), style = MaterialTheme.typography.labelSmall)
                                    }
                                }
                            }
                        }
                    }

                    // Trigger areas
                    if (!triggerAreas.isNullOrEmpty()) {
                        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
                            Text("Trigger areas", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                                triggerAreas.forEach { area ->
                                    Box(
                                        Modifier
                                            .clip(RoundedCornerShape(8.dp))
                                            .background(triggerAreaColor(area).copy(alpha = 0.15f))
                                            .border(1.dp, triggerAreaColor(area).copy(alpha = 0.3f), RoundedCornerShape(8.dp))
                                            .padding(horizontal = 10.dp, vertical = 6.dp)
                                    ) {
                                        Text(area, color = triggerAreaColor(area), style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
                                    }
                                }
                            }
                        }
                    }

                    // Clinical assessment
                    if (!clinicalAssessment.isNullOrBlank()) {
                        var assessmentExpanded by remember { mutableStateOf(false) }
                        Column(
                            Modifier.fillMaxWidth()
                                .clip(RoundedCornerShape(12.dp))
                                .background(Color(0xFF1A1A2E).copy(alpha = 0.9f))
                                .border(1.dp, AppTheme.AccentPink.copy(alpha = 0.2f), RoundedCornerShape(12.dp))
                                .clickable { assessmentExpanded = !assessmentExpanded }
                                .padding(12.dp)
                        ) {
                            Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                Icon(Icons.Outlined.MedicalInformation, null, tint = AppTheme.AccentPink, modifier = Modifier.size(16.dp))
                                Text("AI Clinical Assessment", color = Color.White, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold), modifier = Modifier.weight(1f))
                                Icon(if (assessmentExpanded) Icons.Outlined.ExpandLess else Icons.Outlined.ExpandMore, null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(16.dp))
                            }
                            AnimatedVisibility(visible = assessmentExpanded) {
                                Text(clinicalAssessment, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall, modifier = Modifier.padding(top = 8.dp))
                            }
                        }
                    }

                    // Free text notes
                    if (!freeText.isNullOrBlank()) {
                        Column(
                            Modifier.fillMaxWidth()
                                .clip(RoundedCornerShape(12.dp))
                                .background(AppTheme.TrackColor.copy(alpha = 0.3f))
                                .padding(12.dp)
                        ) {
                            Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(6.dp)) {
                                Icon(Icons.Outlined.FormatQuote, null, tint = AppTheme.SubtleTextColor, modifier = Modifier.size(16.dp))
                                Text("Your notes", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold))
                            }
                            Spacer(Modifier.height(4.dp))
                            Text(freeText, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodySmall)
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun ProfileStatChip(icon: ImageVector, text: String, modifier: Modifier = Modifier) {
    Row(
        modifier
            .clip(RoundedCornerShape(10.dp))
            .background(AppTheme.TrackColor.copy(alpha = 0.4f))
            .padding(horizontal = 10.dp, vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(6.dp)
    ) {
        Icon(icon, null, tint = AppTheme.AccentPurple, modifier = Modifier.size(16.dp))
        Text(text, color = Color.White, style = MaterialTheme.typography.labelSmall, maxLines = 1, overflow = TextOverflow.Ellipsis)
    }
}

private fun triggerAreaColor(area: String): Color = when (area.lowercase()) {
    "sleep" -> Color(0xFF7C4DFF)
    "stress" -> Color(0xFFEF5350)
    "weather" -> Color(0xFF4FC3F7)
    "screen time" -> Color(0xFFFFB74D)
    "diet" -> Color(0xFF81C784)
    "exercise" -> Color(0xFFFF8A65)
    "hormones" -> Color(0xFFCE93D8)
    "environment" -> Color(0xFF4DD0E1)
    "physical" -> Color(0xFFA1887F)
    else -> Color(0xFFB97BFF)
}

// ═══════════════════════════════════════════════════════════════════════════
// Helper functions (unchanged)
// ═══════════════════════════════════════════════════════════════════════════

private fun decodePreviewBitmap(
    context: android.content.Context,
    uri: Uri,
    maxDim: Int
): Bitmap? {
    val resolver = context.contentResolver
    val bytes = resolver.openInputStream(uri)?.use { it.readBytes() } ?: return null
    val bounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    BitmapFactory.decodeByteArray(bytes, 0, bytes.size, bounds)
    val srcW = bounds.outWidth
    val srcH = bounds.outHeight
    if (srcW <= 0 || srcH <= 0) return null
    var sample = 1
    while ((srcW / sample) > maxDim * 2 || (srcH / sample) > maxDim * 2) {
        sample *= 2
        if (sample >= 128) break
    }
    val opts = BitmapFactory.Options().apply { inSampleSize = max(1, sample) }
    val decoded = BitmapFactory.decodeByteArray(bytes, 0, bytes.size, opts) ?: return null
    val maxSide = max(decoded.width, decoded.height)
    if (maxSide <= maxDim) return decoded
    val scale = maxDim.toFloat() / maxSide.toFloat()
    val newW = (decoded.width * scale).toInt().coerceAtLeast(1)
    val newH = (decoded.height * scale).toInt().coerceAtLeast(1)
    val scaled = Bitmap.createScaledBitmap(decoded, newW, newH, true)
    if (scaled !== decoded) decoded.recycle()
    return scaled
}

private fun uploadAvatarToSupabaseStorage(
    context: android.content.Context,
    accessToken: String,
    userId: String,
    uri: Uri
): String {
    val maxOutputBytes = 2 * 1024 * 1024
    val maxInputBytes = 10 * 1024 * 1024
    val maxDim = 1024

    val resolver = context.contentResolver
    val rawMime = resolver.getType(uri)?.lowercase()
    val allowedMimes = setOf("image/jpeg", "image/jpg", "image/png", "image/webp")
    if (rawMime != null && rawMime !in allowedMimes) {
        throw IllegalStateException("Please choose an image (JPG/PNG/WebP).")
    }

    val declaredSize = runCatching {
        resolver.query(uri, arrayOf(OpenableColumns.SIZE), null, null, null)?.use { c ->
            val idx = c.getColumnIndex(OpenableColumns.SIZE)
            if (idx >= 0 && c.moveToFirst() && !c.isNull(idx)) c.getLong(idx) else null
        }
    }.getOrNull()

    if (declaredSize != null && declaredSize > maxInputBytes) {
        throw IllegalStateException("Image is too large. Please choose an image under 10 MB.")
    }

    val originalBytes = readAllBytesWithLimit(resolver, uri, maxInputBytes)
        ?: throw IllegalStateException("Could not read selected image.")

    val bounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    BitmapFactory.decodeByteArray(originalBytes, 0, originalBytes.size, bounds)
    val srcW = bounds.outWidth
    val srcH = bounds.outHeight
    if (srcW <= 0 || srcH <= 0) throw IllegalStateException("Selected file is not a valid image.")

    val sample = computePowerOfTwoSampleSize(srcW, srcH, maxDim * 2)
    val decodeOpts = BitmapFactory.Options().apply { inSampleSize = sample }
    val decoded: Bitmap = BitmapFactory.decodeByteArray(originalBytes, 0, originalBytes.size, decodeOpts)
        ?: throw IllegalStateException("Could not decode selected image.")

    val scaled = scaleDown(decoded, maxDim)
    if (scaled !== decoded) decoded.recycle()
    val jpegBytes = compressJpegUnderLimit(scaled, maxOutputBytes)
    scaled.recycle()

    val baseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
    val anonKey = BuildConfig.SUPABASE_ANON_KEY
    val bucket = "avatars"
    val objectPath = "$userId.jpg"
    val putUrl = "$baseUrl/storage/v1/object/$bucket/$objectPath?upsert=true"
    val conn = (URL(putUrl).openConnection() as HttpURLConnection).apply {
        requestMethod = "PUT"
        doOutput = true
        setRequestProperty("Authorization", "Bearer $accessToken")
        setRequestProperty("apikey", anonKey)
        setRequestProperty("Content-Type", "image/jpeg")
        setRequestProperty("Content-Length", jpegBytes.size.toString())
    }
    try {
        conn.outputStream.use { os: OutputStream -> os.write(jpegBytes); os.flush() }
        val code = conn.responseCode
        if (code !in 200..299) {
            val err = runCatching { conn.errorStream?.readBytes()?.toString(Charsets.UTF_8) }.getOrNull()
            throw IllegalStateException("Upload failed ($code). ${err ?: ""}".trim())
        }
    } finally { conn.disconnect() }
    return "$baseUrl/storage/v1/object/public/$bucket/$objectPath"
}

private fun readAllBytesWithLimit(resolver: android.content.ContentResolver, uri: Uri, maxBytes: Int): ByteArray? {
    resolver.openInputStream(uri)?.use { input ->
        val buffer = ByteArray(8 * 1024)
        val baos = ByteArrayOutputStream()
        var total = 0
        while (true) {
            val r = input.read(buffer)
            if (r <= 0) break
            total += r
            if (total > maxBytes) throw IllegalStateException("Image is too large. Please choose an image under 10 MB.")
            baos.write(buffer, 0, r)
        }
        return baos.toByteArray()
    }
    return null
}

private fun computePowerOfTwoSampleSize(srcW: Int, srcH: Int, targetMaxDim: Int): Int {
    var inSampleSize = 1
    if (srcW <= 0 || srcH <= 0) return 1
    while ((srcW / inSampleSize) > targetMaxDim || (srcH / inSampleSize) > targetMaxDim) {
        inSampleSize *= 2
        if (inSampleSize >= 128) break
    }
    return max(1, inSampleSize)
}

private fun scaleDown(bmp: Bitmap, maxDim: Int): Bitmap {
    val w = bmp.width; val h = bmp.height; val maxSide = max(w, h)
    if (maxSide <= maxDim) return bmp
    val scale = maxDim.toFloat() / maxSide.toFloat()
    val newW = (w * scale).toInt().coerceAtLeast(1)
    val newH = (h * scale).toInt().coerceAtLeast(1)
    return Bitmap.createScaledBitmap(bmp, newW, newH, true)
}

private fun compressJpegUnderLimit(bmp: Bitmap, maxBytes: Int): ByteArray {
    var quality = 92
    while (quality >= 10) {
        val baos = ByteArrayOutputStream()
        bmp.compress(Bitmap.CompressFormat.JPEG, quality, baos)
        val bytes = baos.toByteArray()
        if (bytes.size <= maxBytes) return bytes
        quality -= 10
    }
    val baos = ByteArrayOutputStream()
    bmp.compress(Bitmap.CompressFormat.JPEG, 10, baos)
    return baos.toByteArray()
}

title: QuickLogMedicineScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant

@Composable
fun QuickLogMedicineScreen(
    navController: NavController,
    authVm: AuthViewModel,
    medicineVm: MedicineViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val scope = rememberCoroutineScope()
    val snackbarHostState = remember { SnackbarHostState() }
    
    val authState by authVm.state.collectAsState()
    val pool by medicineVm.pool.collectAsState()
    val frequent by medicineVm.frequent.collectAsState()
    
    // Load medicine options
    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { medicineVm.loadAll(it) }
    }
    
    // Form state
    var selectedMedicine by rememberSaveable { mutableStateOf<String?>(null) }
    var menuOpen by rememberSaveable { mutableStateOf(false) }
    var amount by rememberSaveable { mutableStateOf("") }
    var startAtIso by rememberSaveable { mutableStateOf<String?>(null) }
    var notes by rememberSaveable { mutableStateOf("") }
    var saving by remember { mutableStateOf(false) }
    
    val scrollState = rememberScrollState()
    
    // Get labels for display
    val frequentLabels = remember(frequent, pool) {
        frequent.mapNotNull { pref -> pool.find { it.id == pref.medicineId }?.label }
    }
    val allLabels = remember(pool) { pool.map { it.label } }

    Box {
        ScrollFadeContainer(scrollState = scrollState) { scroll ->
            ScrollableScreenContent(scrollState = scroll) {
                // Back navigation
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Start
                ) {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = "Back",
                            tint = Color.White
                        )
                    }
                }
                
                // Hero Card - Medicine Selection
                HeroCard {
                    Text(
                        "Quick Log Medicine",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    
                    Text(
                        "Log a medicine without a migraine",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Medicine dropdown
                    Box(Modifier.fillMaxWidth()) {
                        OutlinedTextField(
                            value = selectedMedicine ?: "Select medicine...",
                            onValueChange = {},
                            readOnly = true,
                            label = { Text("Medicine", color = AppTheme.SubtleTextColor) },
                            trailingIcon = {
                                IconButton(onClick = { menuOpen = true }) {
                                    Text("▼", color = Color.White)
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            colors = OutlinedTextFieldDefaults.colors(
                                focusedTextColor = Color.White,
                                unfocusedTextColor = Color.White,
                                focusedBorderColor = AppTheme.AccentPurple,
                                unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                            )
                        )
                        
                        DropdownMenu(
                            expanded = menuOpen,
                            onDismissRequest = { menuOpen = false }
                        ) {
                            if (frequentLabels.isNotEmpty()) {
                                DropdownMenuItem(
                                    text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                                    onClick = {},
                                    enabled = false
                                )
                                frequentLabels.forEach { label ->
                                    DropdownMenuItem(
                                        text = { Text(label) },
                                        onClick = {
                                            selectedMedicine = label
                                            menuOpen = false
                                        }
                                    )
                                }
                                Divider()
                            }
                            
                            if (allLabels.isNotEmpty()) {
                                DropdownMenuItem(
                                    text = { Text("All", fontWeight = FontWeight.Bold) },
                                    onClick = {},
                                    enabled = false
                                )
                                allLabels.forEach { label ->
                                    DropdownMenuItem(
                                        text = { Text(label) },
                                        onClick = {
                                            selectedMedicine = label
                                            menuOpen = false
                                        }
                                    )
                                }
                            }
                        }
                    }
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_MEDICINES) }) {
                            Text("Manage Medicines", color = AppTheme.AccentPurple)
                        }
                    }
                }
                
                // Details Card
                BaseCard {
                    Text(
                        "Details",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    
                    // Amount
                    OutlinedTextField(
                        value = amount,
                        onValueChange = { amount = it },
                        label = { Text("Amount (e.g., 500mg, 2 tablets)", color = AppTheme.SubtleTextColor) },
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                        )
                    )
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Time picker
                    Column(Modifier.fillMaxWidth()) {
                        Text("When did you take this?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        Spacer(Modifier.height(4.dp))
                        AppDateTimePicker(
                            label = startAtIso?.let { formatIsoForDisplay(it) } ?: "Select time..."
                        ) { iso ->
                            startAtIso = iso
                        }
                    }
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Notes
                    OutlinedTextField(
                        value = notes,
                        onValueChange = { notes = it },
                        label = { Text("Notes (optional)", color = AppTheme.SubtleTextColor) },
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                        ),
                        minLines = 2
                    )
                }
                
                // Action Buttons
                BaseCard {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        OutlinedButton(
                            onClick = { navController.popBackStack() },
                            colors = ButtonDefaults.outlinedButtonColors(
                                contentColor = Color.White
                            )
                        ) {
                            Text("Cancel")
                        }
                        
                        Button(
                            onClick = {
                                val token = authState.accessToken
                                val medicine = selectedMedicine
                                if (token.isNullOrBlank() || medicine.isNullOrBlank()) return@Button
                                
                                saving = true
                                scope.launch {
                                    try {
                                        withContext(Dispatchers.IO) {
                                            val db = SupabaseDbService(
                                                BuildConfig.SUPABASE_URL,
                                                BuildConfig.SUPABASE_ANON_KEY
                                            )
                                            db.insertMedicine(
                                                accessToken = token,
                                                migraineId = null, // Standalone medicine
                                                name = medicine,
                                                amount = amount.ifBlank { null },
                                                startAt = startAtIso ?: Instant.now().toString(),
                                                notes = notes.ifBlank { null }
                                            )
                                        }
                                        snackbarHostState.showSnackbar("Medicine logged!")
                                        navController.popBackStack()
                                    } catch (e: Exception) {
                                        snackbarHostState.showSnackbar("Error: ${e.message}")
                                    } finally {
                                        saving = false
                                    }
                                }
                            },
                            enabled = !saving && selectedMedicine != null,
                            colors = ButtonDefaults.buttonColors(
                                containerColor = AppTheme.AccentPurple
                            )
                        ) {
                            Text(if (saving) "Saving..." else "Log Medicine")
                        }
                    }
                }
            }
        }
        
        SnackbarHost(
            hostState = snackbarHostState,
            modifier = Modifier.padding(16.dp)
        )
    }
}

private fun formatIsoForDisplay(iso: String): String {
    return try {
        val instant = java.time.OffsetDateTime.parse(iso)
        instant.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        try {
            val ldt = java.time.LocalDateTime.parse(iso.removeSuffix("Z"))
            ldt.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
        } catch (_: Exception) {
            iso
        }
    }
}

title: QuickLogReliefScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant

@Composable
fun QuickLogReliefScreen(
    navController: NavController,
    authVm: AuthViewModel,
    reliefVm: ReliefViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val scope = rememberCoroutineScope()
    val snackbarHostState = remember { SnackbarHostState() }
    
    val authState by authVm.state.collectAsState()
    val pool by reliefVm.pool.collectAsState()
    val frequent by reliefVm.frequent.collectAsState()
    
    // Load relief options
    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { reliefVm.loadAll(it) }
    }
    
    // Form state
    var selectedRelief by rememberSaveable { mutableStateOf<String?>(null) }
    var menuOpen by rememberSaveable { mutableStateOf(false) }
    var durationMinutes by rememberSaveable { mutableStateOf("") }
    var startAtIso by rememberSaveable { mutableStateOf<String?>(null) }
    var notes by rememberSaveable { mutableStateOf("") }
    var saving by remember { mutableStateOf(false) }
    
    val scrollState = rememberScrollState()
    
    // Get labels for display
    val frequentLabels = remember(frequent, pool) {
        frequent.mapNotNull { pref -> pool.find { it.id == pref.reliefId }?.label }
    }
    val allLabels = remember(pool) { pool.map { it.label } }

    Box {
        ScrollFadeContainer(scrollState = scrollState) { scroll ->
            ScrollableScreenContent(scrollState = scroll) {
                // Back navigation
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Start
                ) {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = "Back",
                            tint = Color.White
                        )
                    }
                }
                
                // Hero Card - Relief Selection
                HeroCard {
                    Text(
                        "Quick Log Relief",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    
                    Text(
                        "Log a relief method without a migraine",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Relief dropdown
                    Box(Modifier.fillMaxWidth()) {
                        OutlinedTextField(
                            value = selectedRelief ?: "Select relief...",
                            onValueChange = {},
                            readOnly = true,
                            label = { Text("Relief", color = AppTheme.SubtleTextColor) },
                            trailingIcon = {
                                IconButton(onClick = { menuOpen = true }) {
                                    Text("▼", color = Color.White)
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            colors = OutlinedTextFieldDefaults.colors(
                                focusedTextColor = Color.White,
                                unfocusedTextColor = Color.White,
                                focusedBorderColor = AppTheme.AccentPurple,
                                unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                            )
                        )
                        
                        DropdownMenu(
                            expanded = menuOpen,
                            onDismissRequest = { menuOpen = false }
                        ) {
                            if (frequentLabels.isNotEmpty()) {
                                DropdownMenuItem(
                                    text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                                    onClick = {},
                                    enabled = false
                                )
                                frequentLabels.forEach { label ->
                                    DropdownMenuItem(
                                        text = { Text(label) },
                                        onClick = {
                                            selectedRelief = label
                                            menuOpen = false
                                        }
                                    )
                                }
                                Divider()
                            }
                            
                            if (allLabels.isNotEmpty()) {
                                DropdownMenuItem(
                                    text = { Text("All", fontWeight = FontWeight.Bold) },
                                    onClick = {},
                                    enabled = false
                                )
                                allLabels.forEach { label ->
                                    DropdownMenuItem(
                                        text = { Text(label) },
                                        onClick = {
                                            selectedRelief = label
                                            menuOpen = false
                                        }
                                    )
                                }
                            }
                        }
                    }
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_RELIEFS) }) {
                            Text("Manage Reliefs", color = AppTheme.AccentPurple)
                        }
                    }
                }
                
                // Details Card
                BaseCard {
                    Text(
                        "Details",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    
                    // Duration
                    OutlinedTextField(
                        value = durationMinutes,
                        onValueChange = { durationMinutes = it.filter { c -> c.isDigit() } },
                        label = { Text("Duration (minutes)", color = AppTheme.SubtleTextColor) },
                        modifier = Modifier.fillMaxWidth(),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                        )
                    )
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Time picker
                    Column(Modifier.fillMaxWidth()) {
                        Text("When did you do this?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        Spacer(Modifier.height(4.dp))
                        AppDateTimePicker(
                            label = startAtIso?.let { formatIsoForDisplay(it) } ?: "Select time..."
                        ) { iso ->
                            startAtIso = iso
                        }
                    }
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Notes
                    OutlinedTextField(
                        value = notes,
                        onValueChange = { notes = it },
                        label = { Text("Notes (optional)", color = AppTheme.SubtleTextColor) },
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                        ),
                        minLines = 2
                    )
                }
                
                // Action Buttons
                BaseCard {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        OutlinedButton(
                            onClick = { navController.popBackStack() },
                            colors = ButtonDefaults.outlinedButtonColors(
                                contentColor = Color.White
                            )
                        ) {
                            Text("Cancel")
                        }
                        
                        Button(
                            onClick = {
                                val token = authState.accessToken
                                val relief = selectedRelief
                                if (token.isNullOrBlank() || relief.isNullOrBlank()) return@Button
                                
                                saving = true
                                scope.launch {
                                    try {
                                        withContext(Dispatchers.IO) {
                                            val db = SupabaseDbService(
                                                BuildConfig.SUPABASE_URL,
                                                BuildConfig.SUPABASE_ANON_KEY
                                            )
                                            db.insertRelief(
                                                accessToken = token,
                                                migraineId = null, // Standalone relief
                                                type = relief,
                                                startAt = startAtIso ?: Instant.now().toString(),
                                                notes = notes.ifBlank { null }
                                            )
                                        }
                                        snackbarHostState.showSnackbar("Relief logged!")
                                        navController.popBackStack()
                                    } catch (e: Exception) {
                                        snackbarHostState.showSnackbar("Error: ${e.message}")
                                    } finally {
                                        saving = false
                                    }
                                }
                            },
                            enabled = !saving && selectedRelief != null,
                            colors = ButtonDefaults.buttonColors(
                                containerColor = AppTheme.AccentPurple
                            )
                        ) {
                            Text(if (saving) "Saving..." else "Log Relief")
                        }
                    }
                }
            }
        }
        
        SnackbarHost(
            hostState = snackbarHostState,
            modifier = Modifier.padding(16.dp)
        )
    }
}

private fun formatIsoForDisplay(iso: String): String {
    return try {
        val instant = java.time.OffsetDateTime.parse(iso)
        instant.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        try {
            val ldt = java.time.LocalDateTime.parse(iso.removeSuffix("Z"))
            ldt.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
        } catch (_: Exception) {
            iso
        }
    }
}

title: QuickLogStrip.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Check
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant

/**
 * Quick Log Strip — sits above the gauge on the Home screen.
 *
 * Five icon buttons: Migraine, Trigger, Prodrome, Medicine, Relief.
 * Tap → shows favorites bottom sheet (skippable) → saves instantly with timestamp = now.
 * No extra input required. Straight into journal.
 */

// ─── Data types for the strip ───────────────────────────────────────

enum class QuickLogCategory(val label: String, val color: Color) {
    MIGRAINE("Migraine", Color(0xFFE57373)),
    TRIGGER("Trigger", Color(0xFFFFB74D)),
    PRODROME("Prodrome", Color(0xFF9575CD)),
    MEDICINE("Medicine", Color(0xFF4FC3F7)),
    RELIEF("Relief", Color(0xFF81C784));
}

data class QuickLogFavorite(
    val label: String,
    val iconKey: String? = null,
    val category: QuickLogCategory? = null,
)

// ─── Main Strip Composable ──────────────────────────────────────────

@Composable
fun QuickLogStrip(
    authVm: AuthViewModel,
    triggerVm: TriggerViewModel,
    medicineVm: MedicineViewModel,
    reliefVm: ReliefViewModel,
    prodromeVm: ProdromeViewModel,
    symptomVm: SymptomViewModel,
    onLogComplete: () -> Unit = {},   // callback to refresh home data
) {
    val ctx = LocalContext.current.applicationContext
    val scope = rememberCoroutineScope()
    val authState by authVm.state.collectAsState()

    // Load all pools on mount
    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { token ->
            triggerVm.loadAll(token)
            medicineVm.loadAll(token)
            reliefVm.loadAll(token)
            prodromeVm.loadAll(token)
            symptomVm.loadAll(token)
        }
    }

    // Favorites from each VM
    val triggerPool by triggerVm.pool.collectAsState()
    val triggerFreq by triggerVm.frequent.collectAsState()
    val medicinePool by medicineVm.pool.collectAsState()
    val medicineFreq by medicineVm.frequent.collectAsState()
    val reliefPool by reliefVm.pool.collectAsState()
    val reliefFreq by reliefVm.frequent.collectAsState()
    val prodromePool by prodromeVm.pool.collectAsState()
    val prodromeFreq by prodromeVm.frequent.collectAsState()
    val symptomFavs by symptomVm.favorites.collectAsState()

    // Build favorite lists
    val triggerFavs = remember(triggerFreq, triggerPool) {
        triggerFreq.mapNotNull { pref ->
            triggerPool.find { it.id == pref.triggerId }?.let {
                QuickLogFavorite(it.label, it.iconKey, QuickLogCategory.TRIGGER)
            }
        }
    }
    val medicineFavs = remember(medicineFreq, medicinePool) {
        medicineFreq.mapNotNull { pref ->
            medicinePool.find { it.id == pref.medicineId }?.let {
                // Medicines use category as icon key (e.g. "Triptan", "Analgesic")
                QuickLogFavorite(it.label, it.category, QuickLogCategory.MEDICINE)
            }
        }
    }
    val reliefFavs = remember(reliefFreq, reliefPool) {
        reliefFreq.mapNotNull { pref ->
            reliefPool.find { it.id == pref.reliefId }?.let {
                QuickLogFavorite(it.label, it.iconKey, QuickLogCategory.RELIEF)
            }
        }
    }
    val prodromeFavs = remember(prodromeFreq, prodromePool) {
        prodromeFreq.mapNotNull { pref ->
            prodromePool.find { it.id == pref.prodromeId }?.let {
                QuickLogFavorite(it.label, it.iconKey, QuickLogCategory.PRODROME)
            }
        }
    }
    val migraineFavs = remember(symptomFavs) {
        symptomFavs.mapNotNull { it.symptom?.let { s ->
            QuickLogFavorite(s.label, s.iconKey, QuickLogCategory.MIGRAINE)
        } }
    }

    // Sheet state
    var activeCategory by remember { mutableStateOf<QuickLogCategory?>(null) }
    var saving by remember { mutableStateOf(false) }
    var savedLabel by remember { mutableStateOf<String?>(null) }

    // Confirmation toast
    LaunchedEffect(savedLabel) {
        if (savedLabel != null) {
            delay(1800)
            savedLabel = null
        }
    }

    fun favsFor(cat: QuickLogCategory): List<QuickLogFavorite> = when (cat) {
        QuickLogCategory.MIGRAINE -> migraineFavs
        QuickLogCategory.TRIGGER -> triggerFavs
        QuickLogCategory.PRODROME -> prodromeFavs
        QuickLogCategory.MEDICINE -> medicineFavs
        QuickLogCategory.RELIEF -> reliefFavs
    }

    fun doSave(cat: QuickLogCategory, label: String?) {
        val token = authState.accessToken ?: return
        saving = true
        scope.launch {
            try {
                withContext(Dispatchers.IO) {
                    val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                    val now = Instant.now().toString()
                    when (cat) {
                        QuickLogCategory.MIGRAINE -> db.insertMigraine(
                            accessToken = token,
                            type = label ?: "Migraine",
                            severity = 5,
                            startAt = now,
                            endAt = null,
                            notes = null
                        )
                        QuickLogCategory.TRIGGER -> db.insertTrigger(
                            accessToken = token,
                            migraineId = null,
                            type = label ?: "Unknown",
                            startAt = now,
                            notes = null
                        )
                        QuickLogCategory.PRODROME -> db.insertProdrome(
                            accessToken = token,
                            migraineId = null,
                            type = label ?: "Unknown",
                            startAt = now,
                            notes = null
                        )
                        QuickLogCategory.MEDICINE -> db.insertMedicine(
                            accessToken = token,
                            migraineId = null,
                            name = label ?: "Unknown",
                            amount = null,
                            startAt = now,
                            notes = null
                        )
                        QuickLogCategory.RELIEF -> db.insertRelief(
                            accessToken = token,
                            migraineId = null,
                            type = label ?: "Unknown",
                            startAt = now,
                            notes = null
                        )
                    }
                }
                savedLabel = "${cat.label}: ${label ?: cat.label}"
                activeCategory = null
                onLogComplete()
            } catch (e: Exception) {
                Log.e("QuickLogStrip", "Save failed", e)
            } finally {
                saving = false
            }
        }
    }

    // ── UI ──

    Column {
        // Saved confirmation
        AnimatedVisibility(
            visible = savedLabel != null,
            enter = fadeIn() + slideInVertically(),
            exit = fadeOut() + slideOutVertically()
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 4.dp)
                    .background(Color(0xFF2E7D32).copy(alpha = 0.85f), RoundedCornerShape(12.dp))
                    .padding(horizontal = 16.dp, vertical = 10.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.Center
            ) {
                Icon(Icons.Outlined.Check, null, tint = Color.White, modifier = Modifier.size(18.dp))
                Spacer(Modifier.width(8.dp))
                Text(
                    "Logged: ${savedLabel ?: ""}",
                    color = Color.White,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium)
                )
            }
        }

        // Quick log card
        BaseCard {
            Text(
                "Quick log",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                QuickLogCategory.entries.forEach { cat ->
                    QuickLogButton(
                        category = cat,
                        onClick = {
                            val favs = favsFor(cat)
                            if (favs.isEmpty()) {
                                doSave(cat, cat.label)
                            } else {
                                activeCategory = cat
                            }
                        }
                    )
                }
            }
        }
    }

    // ── Bottom sheet for favorites ──
    if (activeCategory != null) {
        val cat = activeCategory!!
        val favs = favsFor(cat)

        QuickLogFavoritesSheet(
            category = cat,
            favorites = favs,
            saving = saving,
            onSelect = { label -> doSave(cat, label) },
            onSkip = { doSave(cat, cat.label) },
            onDismiss = { activeCategory = null }
        )
    }
}

// ─── Single Quick Log Button ────────────────────────────────────────

@Composable
private fun QuickLogButton(
    category: QuickLogCategory,
    onClick: () -> Unit
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(58.dp)
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            modifier = Modifier
                .size(42.dp)
                .clip(CircleShape)
                .background(category.color.copy(alpha = 0.15f))
                .border(1.dp, category.color.copy(alpha = 0.35f), CircleShape),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .size(22.dp)
                    .drawBehind {
                        HubIcons.run {
                            when (category) {
                                QuickLogCategory.MIGRAINE -> drawMigraineStarburst(category.color)
                                QuickLogCategory.TRIGGER -> drawTriggerBolt(category.color)
                                QuickLogCategory.PRODROME -> drawProdromeEye(category.color)
                                QuickLogCategory.MEDICINE -> drawMedicinePill(category.color)
                                QuickLogCategory.RELIEF -> drawReliefLeaf(category.color)
                            }
                        }
                    }
            )
        }
        Spacer(Modifier.height(4.dp))
        Text(
            category.label,
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelSmall.copy(fontSize = 10.sp),
            textAlign = TextAlign.Center,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis
        )
    }
}

// ─── Favorites Bottom Sheet ─────────────────────────────────────────

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
private fun QuickLogFavoritesSheet(
    category: QuickLogCategory,
    favorites: List<QuickLogFavorite>,
    saving: Boolean,
    onSelect: (String) -> Unit,
    onSkip: () -> Unit,
    onDismiss: () -> Unit,
) {
    val sheetState = rememberModalBottomSheetState(skipPartiallyExpanded = true)

    ModalBottomSheet(
        onDismissRequest = onDismiss,
        sheetState = sheetState,
        containerColor = AppTheme.BaseCardContainer.copy(alpha = 0.92f),
        contentColor = Color.White,
        dragHandle = {
            Box(
                Modifier.fillMaxWidth().padding(top = 12.dp),
                contentAlignment = Alignment.Center
            ) {
                Box(
                    Modifier
                        .width(32.dp)
                        .height(4.dp)
                        .background(Color.White.copy(alpha = 0.2f), RoundedCornerShape(2.dp))
                )
            }
        }
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .verticalScroll(rememberScrollState())
                .padding(horizontal = 20.dp, vertical = 16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Header
            Text(
                "Quick ${category.label}",
                color = Color.White,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
            )
            Spacer(Modifier.height(4.dp))
            Text(
                "Tap a favourite to log it now",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
            Spacer(Modifier.height(16.dp))

            // Favorites grid — circle icons like the rest of the app
            FlowRow(
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(14.dp),
                modifier = Modifier.fillMaxWidth()
            ) {
                favorites.forEach { fav ->
                    FavoriteCircleButton(
                        label = fav.label,
                        iconKey = fav.iconKey,
                        category = category,
                        enabled = !saving,
                        onClick = { onSelect(fav.label) }
                    )
                }
            }

            Spacer(Modifier.height(20.dp))

            // Skip button — logs with default label
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                TextButton(onClick = onDismiss, enabled = !saving) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
                Button(
                    onClick = onSkip,
                    enabled = !saving,
                    colors = ButtonDefaults.buttonColors(containerColor = category.color.copy(alpha = 0.8f))
                ) {
                    Text(
                        if (saving) "Saving…" else "Skip — just log \"${category.label}\"",
                        style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                }
            }

            Spacer(Modifier.height(16.dp))
        }
    }
}

@Composable
private fun FavoriteCircleButton(
    label: String,
    iconKey: String?,
    category: QuickLogCategory,
    enabled: Boolean,
    onClick: () -> Unit
) {
    // Resolve icon from the appropriate icon set
    // Try iconKey first, then fall back to label-based matching
    val icon: androidx.compose.ui.graphics.vector.ImageVector? = when (category) {
        QuickLogCategory.TRIGGER -> TriggerIcons.forKey(iconKey) ?: TriggerIcons.forKey(label.lowercase())
        QuickLogCategory.PRODROME -> ProdromeIcons.forKey(iconKey) ?: ProdromeIcons.forKey(label.lowercase())
        QuickLogCategory.MEDICINE -> MedicineIcons.forKey(iconKey) ?: MedicineIcons.forKey(label)
        QuickLogCategory.RELIEF -> ReliefIcons.forKey(iconKey) ?: ReliefIcons.forKey(label.lowercase())
        QuickLogCategory.MIGRAINE -> SymptomIcons.forLabel(label, iconKey)
    }

    val bg = category.color.copy(alpha = 0.15f)
    val border = category.color.copy(alpha = 0.40f)
    val iconTint = Color.White
    val textColor = AppTheme.BodyTextColor

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(72.dp)
            .clickable(
                enabled = enabled,
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            Modifier
                .size(52.dp)
                .clip(CircleShape)
                .background(bg)
                .border(1.5.dp, border, CircleShape),
            contentAlignment = Alignment.Center
        ) {
            if (icon != null) {
                Icon(icon, contentDescription = label, tint = iconTint, modifier = Modifier.size(24.dp))
            } else {
                Text(
                    label.take(2).uppercase(),
                    color = iconTint,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(
            label,
            color = textColor,
            style = MaterialTheme.typography.labelSmall,
            textAlign = TextAlign.Center,
            maxLines = 2,
            modifier = Modifier.fillMaxWidth()
        )
    }
}

title: QuickLogTriggerScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.Instant

@Composable
fun QuickLogTriggerScreen(
    navController: NavController,
    authVm: AuthViewModel,
    triggerVm: TriggerViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val scope = rememberCoroutineScope()
    val snackbarHostState = remember { SnackbarHostState() }
    
    val authState by authVm.state.collectAsState()
    val rawPool by triggerVm.pool.collectAsState()
    val frequent by triggerVm.frequent.collectAsState()

    // Hide triggers with prediction = NONE
    val pool = remember(rawPool) { rawPool.filter { it.predictionValue?.uppercase() != "NONE" } }
    
    // Load trigger options
    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { triggerVm.loadAll(it) }
    }
    
    // Form state
    var selectedTrigger by rememberSaveable { mutableStateOf<String?>(null) }
    var menuOpen by rememberSaveable { mutableStateOf(false) }
    var startAtIso by rememberSaveable { mutableStateOf<String?>(null) }
    var notes by rememberSaveable { mutableStateOf("") }
    var saving by remember { mutableStateOf(false) }
    
    val scrollState = rememberScrollState()
    
    // Get labels for display
    val frequentLabels = remember(frequent, pool) {
        frequent.mapNotNull { pref -> pool.find { it.id == pref.triggerId }?.label }
    }
    val allLabels = remember(pool) { pool.map { it.label } }

    Box {
        ScrollFadeContainer(scrollState = scrollState) { scroll ->
            ScrollableScreenContent(scrollState = scroll) {
                // Back navigation
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.Start
                ) {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = "Back",
                            tint = Color.White
                        )
                    }
                }
                
                // Hero Card - Trigger Selection
                HeroCard {
                    Text(
                        "Quick Log Trigger",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    
                    Text(
                        "Log a trigger without a migraine",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Trigger dropdown
                    Box(Modifier.fillMaxWidth()) {
                        OutlinedTextField(
                            value = selectedTrigger ?: "Select trigger...",
                            onValueChange = {},
                            readOnly = true,
                            label = { Text("Trigger", color = AppTheme.SubtleTextColor) },
                            trailingIcon = {
                                IconButton(onClick = { menuOpen = true }) {
                                    Text("▼", color = Color.White)
                                }
                            },
                            modifier = Modifier.fillMaxWidth(),
                            colors = OutlinedTextFieldDefaults.colors(
                                focusedTextColor = Color.White,
                                unfocusedTextColor = Color.White,
                                focusedBorderColor = AppTheme.AccentPurple,
                                unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                            )
                        )
                        
                        DropdownMenu(
                            expanded = menuOpen,
                            onDismissRequest = { menuOpen = false }
                        ) {
                            if (frequentLabels.isNotEmpty()) {
                                DropdownMenuItem(
                                    text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                                    onClick = {},
                                    enabled = false
                                )
                                frequentLabels.forEach { label ->
                                    DropdownMenuItem(
                                        text = { Text(label) },
                                        onClick = {
                                            selectedTrigger = label
                                            menuOpen = false
                                        }
                                    )
                                }
                                Divider()
                            }
                            
                            if (allLabels.isNotEmpty()) {
                                DropdownMenuItem(
                                    text = { Text("All", fontWeight = FontWeight.Bold) },
                                    onClick = {},
                                    enabled = false
                                )
                                allLabels.forEach { label ->
                                    DropdownMenuItem(
                                        text = { Text(label) },
                                        onClick = {
                                            selectedTrigger = label
                                            menuOpen = false
                                        }
                                    )
                                }
                            }
                        }
                    }
                    
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_TRIGGERS) }) {
                            Text("Manage Triggers", color = AppTheme.AccentPurple)
                        }
                    }
                }
                
                // Details Card
                BaseCard {
                    Text(
                        "Details",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    
                    // Time picker
                    Column(Modifier.fillMaxWidth()) {
                        Text("When did this happen?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        Spacer(Modifier.height(4.dp))
                        AppDateTimePicker(
                            label = startAtIso?.let { formatIsoForDisplay(it) } ?: "Select time..."
                        ) { iso ->
                            startAtIso = iso
                        }
                    }
                    
                    Spacer(Modifier.height(8.dp))
                    
                    // Notes
                    OutlinedTextField(
                        value = notes,
                        onValueChange = { notes = it },
                        label = { Text("Notes (optional)", color = AppTheme.SubtleTextColor) },
                        modifier = Modifier.fillMaxWidth(),
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedTextColor = Color.White,
                            unfocusedTextColor = Color.White,
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = Color.White.copy(alpha = 0.3f)
                        ),
                        minLines = 2
                    )
                }
                
                // Action Buttons
                BaseCard {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        OutlinedButton(
                            onClick = { navController.popBackStack() },
                            colors = ButtonDefaults.outlinedButtonColors(
                                contentColor = Color.White
                            )
                        ) {
                            Text("Cancel")
                        }
                        
                        Button(
                            onClick = {
                                val token = authState.accessToken
                                val trigger = selectedTrigger
                                if (token.isNullOrBlank() || trigger.isNullOrBlank()) return@Button
                                
                                saving = true
                                scope.launch {
                                    try {
                                        withContext(Dispatchers.IO) {
                                            val db = SupabaseDbService(
                                                BuildConfig.SUPABASE_URL,
                                                BuildConfig.SUPABASE_ANON_KEY
                                            )
                                            db.insertTrigger(
                                                accessToken = token,
                                                migraineId = null, // Standalone trigger
                                                type = trigger,
                                                startAt = startAtIso ?: Instant.now().toString(),
                                                notes = notes.ifBlank { null }
                                            )
                                        }
                                        snackbarHostState.showSnackbar("Trigger logged!")
                                        navController.popBackStack()
                                    } catch (e: Exception) {
                                        snackbarHostState.showSnackbar("Error: ${e.message}")
                                    } finally {
                                        saving = false
                                    }
                                }
                            },
                            enabled = !saving && selectedTrigger != null,
                            colors = ButtonDefaults.buttonColors(
                                containerColor = AppTheme.AccentPurple
                            )
                        ) {
                            Text(if (saving) "Saving..." else "Log Trigger")
                        }
                    }
                }
            }
        }
        
        SnackbarHost(
            hostState = snackbarHostState,
            modifier = Modifier.padding(16.dp)
        )
    }
}

private fun formatIsoForDisplay(iso: String): String {
    return try {
        val instant = java.time.OffsetDateTime.parse(iso)
        instant.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        try {
            val ldt = java.time.LocalDateTime.parse(iso.removeSuffix("Z"))
            ldt.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
        } catch (_: Exception) {
            iso
        }
    }
}

title: QuickMigraineScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun QuickMigraineScreen(
    navController: NavController,
    authVm: AuthViewModel,
    symptomVm: SymptomViewModel,
    onClose: () -> Unit = {}
) {
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()
    val scope = rememberCoroutineScope()

    // Symptom pools
    val painCharacter by symptomVm.painCharacter.collectAsState()
    val accompanying by symptomVm.accompanying.collectAsState()
    val favorites by symptomVm.favorites.collectAsState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { symptomVm.loadAll(it) }
    }

    // State
    val selectedSymptoms = remember { mutableStateListOf<String>() }
    var severity by rememberSaveable { mutableStateOf(5) }
    var beganAtIso by rememberSaveable { mutableStateOf<String?>(null) }
    var endedAtIso by rememberSaveable { mutableStateOf<String?>(null) }
    var saving by remember { mutableStateOf(false) }

    fun save() {
        val token = authState.accessToken ?: return
        saving = true
        scope.launch {
            try {
                val db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
                val typeLabel = if (selectedSymptoms.isEmpty()) "Migraine" else selectedSymptoms.joinToString(", ")
                db.insertMigraine(
                    accessToken = token,
                    type = typeLabel,
                    severity = severity,
                    startAt = beganAtIso ?: Instant.now().toString(),
                    endAt = endedAtIso,
                    notes = null,
                    painLocations = null
                )
                navController.popBackStack()
            } catch (e: Exception) {
                e.printStackTrace()
                saving = false
            }
        }
    }

    // Split frequent by category
    val freqPainIds = favorites.filter { it.symptom?.category == "pain_character" }.mapNotNull { it.symptom?.label }.toSet()
    val freqAccompIds = favorites.filter { it.symptom?.category == "accompanying" }.mapNotNull { it.symptom?.label }.toSet()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Spacer(Modifier.width(48.dp))
                Text("Quick Log", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) {
                    Icon(Icons.Outlined.Close, "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Box(Modifier.size(40.dp).drawBehind { HubIcons.run { drawMigraineStarburst(AppTheme.AccentPink) } })
                Text("Log a migraine", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (selectedSymptoms.isEmpty()) "Select symptoms below"
                    else "${selectedSymptoms.size} symptom${if (selectedSymptoms.size > 1) "s" else ""} selected",
                    color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center
                )
            }

            // ── Severity ──
            BaseCard {
                Text("Severity", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Spacer(Modifier.height(8.dp))
                Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
                    Text("$severity", color = AppTheme.AccentPink, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                        modifier = Modifier.width(36.dp), textAlign = TextAlign.Center)
                    Slider(
                        value = severity.toFloat(),
                        onValueChange = { severity = it.toInt() },
                        valueRange = 1f..10f,
                        steps = 8,
                        modifier = Modifier.weight(1f),
                        colors = SliderDefaults.colors(
                            thumbColor = AppTheme.AccentPink,
                            activeTrackColor = AppTheme.AccentPink,
                            inactiveTrackColor = Color.White.copy(alpha = 0.1f)
                        )
                    )
                    Text("/10", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // ── Timing ──
            BaseCard {
                Text("Timing", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                Spacer(Modifier.height(8.dp))

                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    Column(Modifier.weight(1f)) {
                        Text("Started", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Spacer(Modifier.height(4.dp))
                        AppDateTimePicker(label = formatQuickTime(beganAtIso) ?: "Now", onDateTimeSelected = { beganAtIso = it })
                    }
                    Column(Modifier.weight(1f)) {
                        Text("Ended", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Spacer(Modifier.height(4.dp))
                        AppDateTimePicker(label = formatQuickTime(endedAtIso) ?: "Still going", onDateTimeSelected = { endedAtIso = it })
                    }
                }
            }

            // ── Symptoms ──
            // Pain character
            BaseCard {
                Text("Pain character", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))

                if (freqPainIds.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        painCharacter.filter { it.label in freqPainIds }.forEach { s ->
                            QuickSymptomButton(s.label, s.label in selectedSymptoms, s.iconKey) {
                                if (s.label in selectedSymptoms) selectedSymptoms.remove(s.label) else selectedSymptoms.add(s.label)
                            }
                        }
                    }
                    val rest = painCharacter.filter { it.label !in freqPainIds }
                    if (rest.isNotEmpty()) HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }
                val nonFreqPain = painCharacter.filter { it.label !in freqPainIds }
                if (nonFreqPain.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        nonFreqPain.forEach { s ->
                            QuickSymptomButton(s.label, s.label in selectedSymptoms, s.iconKey) {
                                if (s.label in selectedSymptoms) selectedSymptoms.remove(s.label) else selectedSymptoms.add(s.label)
                            }
                        }
                    }
                }
            }

            // Accompanying
            BaseCard {
                Text("Accompanying", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))

                if (freqAccompIds.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        accompanying.filter { it.label in freqAccompIds }.forEach { s ->
                            QuickSymptomButton(s.label, s.label in selectedSymptoms, s.iconKey) {
                                if (s.label in selectedSymptoms) selectedSymptoms.remove(s.label) else selectedSymptoms.add(s.label)
                            }
                        }
                    }
                    val rest = accompanying.filter { it.label !in freqAccompIds }
                    if (rest.isNotEmpty()) HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }
                val nonFreqAccomp = accompanying.filter { it.label !in freqAccompIds }
                if (nonFreqAccomp.isNotEmpty()) {
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        nonFreqAccomp.forEach { s ->
                            QuickSymptomButton(s.label, s.label in selectedSymptoms, s.iconKey) {
                                if (s.label in selectedSymptoms) selectedSymptoms.remove(s.label) else selectedSymptoms.add(s.label)
                            }
                        }
                    }
                }
            }

            // ── Save ──
            Button(
                onClick = { save() },
                enabled = !saving,
                modifier = Modifier.fillMaxWidth().height(48.dp),
                colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink)
            ) {
                Text(if (saving) "Saving…" else "Save Migraine", fontWeight = FontWeight.SemiBold)
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun QuickSymptomButton(label: String, isSelected: Boolean, iconKey: String? = null, onClick: () -> Unit) {
    val icon = SymptomIcons.forLabel(label, iconKey)
    val circleColor = if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.40f) else Color.White.copy(alpha = 0.08f)
    val borderColor = if (isSelected) AppTheme.AccentPurple.copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.width(72.dp).clickable(remember { MutableInteractionSource() }, null, onClick = onClick)
    ) {
        Box(
            Modifier.size(52.dp).clip(CircleShape).background(circleColor).border(1.5.dp, borderColor, CircleShape),
            contentAlignment = Alignment.Center
        ) {
            if (icon != null) {
                Icon(icon, contentDescription = null, tint = iconTint, modifier = Modifier.size(26.dp))
            } else {
                Text(label.take(2).uppercase(), color = iconTint, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold))
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(label, color = textColor, style = MaterialTheme.typography.labelSmall, textAlign = TextAlign.Center, maxLines = 2, modifier = Modifier.fillMaxWidth())
    }
}

private fun formatQuickTime(iso: String?): String? {
    if (iso.isNullOrBlank()) return null
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime()
            ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull()
            ?: return null
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) { null }
}

title: ReliefIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

object ReliefIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    val Breathing: ImageVector by lazy {
        ImageVector.Builder("Breathing", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 8f); curveTo(4f, 8f, 8f, 6f, 12f, 8f); curveTo(16f, 10f, 20f, 8f, 20f, 8f)
                moveTo(4f, 12f); curveTo(4f, 12f, 8f, 10f, 12f, 12f); curveTo(16f, 14f, 20f, 12f, 20f, 12f)
                moveTo(4f, 16f); curveTo(4f, 16f, 8f, 14f, 12f, 16f); curveTo(16f, 18f, 20f, 16f, 20f, 16f)
            }
        }.build()
    }

    val BoxBreathing: ImageVector by lazy {
        ImageVector.Builder("BoxBreathing", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 6f); lineTo(18f, 6f); lineTo(18f, 18f); lineTo(6f, 18f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(11f, 4f); lineTo(13f, 6f); lineTo(11f, 8f)
                moveTo(16f, 11f); lineTo(18f, 13f); lineTo(20f, 11f)
                moveTo(13f, 16f); lineTo(11f, 18f); lineTo(13f, 20f)
                moveTo(8f, 13f); lineTo(6f, 11f); lineTo(4f, 13f)
            }
        }.build()
    }

    val Ice: ImageVector by lazy {
        ImageVector.Builder("Ice", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 22f); moveTo(4.5f, 7.5f); lineTo(19.5f, 16.5f); moveTo(19.5f, 7.5f); lineTo(4.5f, 16.5f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 2f); lineTo(10f, 4f); moveTo(12f, 2f); lineTo(14f, 4f)
                moveTo(12f, 22f); lineTo(10f, 20f); moveTo(12f, 22f); lineTo(14f, 20f)
            }
        }.build()
    }

    val Heat: ImageVector by lazy {
        ImageVector.Builder("Heat", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f); curveTo(8f, 22f, 5f, 18f, 5f, 14f); curveTo(5f, 10f, 8f, 8f, 9f, 5f)
                curveTo(10f, 2f, 12f, 2f, 12f, 2f); curveTo(12f, 2f, 14f, 2f, 15f, 5f)
                curveTo(16f, 8f, 19f, 10f, 19f, 14f); curveTo(19f, 18f, 16f, 22f, 12f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f); curveTo(10f, 22f, 9f, 19f, 9f, 17f); curveTo(9f, 15f, 12f, 13f, 12f, 13f)
                curveTo(12f, 13f, 15f, 15f, 15f, 17f); curveTo(15f, 19f, 14f, 22f, 12f, 22f)
            }
        }.build()
    }

    val Darkness: ImageVector by lazy {
        ImageVector.Builder("Darkness", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(20f, 12f); curveTo(20f, 16.4f, 16.4f, 20f, 12f, 20f); curveTo(7.6f, 20f, 4f, 16.4f, 4f, 12f)
                curveTo(4f, 7.6f, 7.6f, 4f, 12f, 4f); curveTo(10f, 6f, 9f, 10f, 11f, 14f); curveTo(13f, 18f, 17f, 18f, 20f, 12f)
            }
        }.build()
    }

    val EyeMask: ImageVector by lazy {
        ImageVector.Builder("EyeMask", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); curveTo(2f, 9f, 5f, 7f, 8f, 7f); curveTo(10f, 7f, 11f, 9f, 12f, 9f)
                curveTo(13f, 9f, 14f, 7f, 16f, 7f); curveTo(19f, 7f, 22f, 9f, 22f, 12f)
                curveTo(22f, 15f, 19f, 17f, 16f, 17f); curveTo(14f, 17f, 13f, 15f, 12f, 15f)
                curveTo(11f, 15f, 10f, 17f, 8f, 17f); curveTo(5f, 17f, 2f, 15f, 2f, 12f)
            }
        }.build()
    }

    val Sunglasses: ImageVector by lazy {
        ImageVector.Builder("Sunglasses", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 10f); lineTo(22f, 10f)
                moveTo(3f, 10f); curveTo(3f, 10f, 3f, 16f, 7f, 16f); curveTo(11f, 16f, 11f, 10f, 11f, 10f)
                moveTo(13f, 10f); curveTo(13f, 10f, 13f, 16f, 17f, 16f); curveTo(21f, 16f, 21f, 10f, 21f, 10f)
                moveTo(11f, 11f); curveTo(11f, 12f, 13f, 12f, 13f, 11f)
            }
        }.build()
    }

    val Water: ImageVector by lazy {
        ImageVector.Builder("Water", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); curveTo(12f, 2f, 5f, 10f, 5f, 15f); curveTo(5f, 19f, 8f, 22f, 12f, 22f)
                curveTo(16f, 22f, 19f, 19f, 19f, 15f); curveTo(19f, 10f, 12f, 2f, 12f, 2f)
            }
        }.build()
    }

    val Electrolytes: ImageVector by lazy {
        ImageVector.Builder("Electrolytes", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); curveTo(12f, 2f, 5f, 10f, 5f, 15f); curveTo(5f, 19f, 8f, 22f, 12f, 22f)
                curveTo(16f, 22f, 19f, 19f, 19f, 15f); curveTo(19f, 10f, 12f, 2f, 12f, 2f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 12f); lineTo(12f, 18f); moveTo(9f, 15f); lineTo(15f, 15f)
            }
        }.build()
    }

    val Massage: ImageVector by lazy {
        ImageVector.Builder("Massage", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 20f); curveTo(6f, 20f, 4f, 16f, 4f, 13f); curveTo(4f, 11f, 5f, 10f, 7f, 10f); lineTo(11f, 10f)
                moveTo(8f, 10f); lineTo(8f, 5f); moveTo(11f, 10f); lineTo(11f, 4f); moveTo(14f, 10f); lineTo(14f, 5f)
                moveTo(14f, 10f); curveTo(16f, 10f, 17f, 11f, 17f, 13f); lineTo(17f, 14f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(19f, 8f); lineTo(21f, 7f); moveTo(19f, 11f); lineTo(21f, 11f); moveTo(19f, 14f); lineTo(21f, 15f)
            }
        }.build()
    }

    val Acupressure: ImageVector by lazy {
        ImageVector.Builder("Acupressure", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 13f)
                moveTo(9f, 4f); curveTo(9f, 4f, 9f, 2f, 12f, 2f); curveTo(15f, 2f, 15f, 4f, 15f, 4f)
                moveTo(9f, 4f); lineTo(9f, 10f); moveTo(15f, 4f); lineTo(15f, 10f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 16f); curveTo(8f, 16f, 10f, 14f, 12f, 14f); curveTo(14f, 14f, 16f, 16f, 16f, 16f)
                moveTo(6f, 19f); curveTo(6f, 19f, 9f, 17f, 12f, 17f); curveTo(15f, 17f, 18f, 19f, 18f, 19f)
                moveTo(4f, 22f); curveTo(4f, 22f, 8f, 20f, 12f, 20f); curveTo(16f, 20f, 20f, 22f, 20f, 22f)
            }
        }.build()
    }

    val Meditation: ImageVector by lazy {
        ImageVector.Builder("Meditation", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 5f); arcTo(2f, 2f, 0f, true, true, 10f, 5f); arcTo(2f, 2f, 0f, true, true, 14f, 5f)
                moveTo(12f, 7f); lineTo(12f, 14f)
                moveTo(12f, 14f); curveTo(12f, 14f, 7f, 14f, 6f, 18f)
                moveTo(12f, 14f); curveTo(12f, 14f, 17f, 14f, 18f, 18f)
                moveTo(5f, 20f); lineTo(19f, 20f)
                moveTo(12f, 10f); lineTo(6f, 12f); moveTo(12f, 10f); lineTo(18f, 12f)
            }
        }.build()
    }

    val Progressive: ImageVector by lazy {
        ImageVector.Builder("Progressive", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); curveTo(3f, 6f, 5f, 18f, 7f, 12f); curveTo(8f, 8f, 10f, 16f, 12f, 12f)
                curveTo(13f, 10f, 15f, 14f, 17f, 12f); curveTo(18f, 11f, 20f, 13f, 22f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(4f, 20f); lineTo(20f, 20f); moveTo(8f, 18f); lineTo(16f, 18f)
            }
        }.build()
    }

    val Walk: ImageVector by lazy {
        ImageVector.Builder("Walk", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 14f)
                moveTo(12f, 9f); lineTo(7f, 12f); moveTo(12f, 9f); lineTo(17f, 11f)
                moveTo(12f, 14f); lineTo(8f, 22f); moveTo(12f, 14f); lineTo(16f, 22f)
            }
        }.build()
    }

    val Stretch: ImageVector by lazy {
        ImageVector.Builder("Stretch", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 14f)
                moveTo(12f, 9f); lineTo(5f, 5f); moveTo(12f, 9f); lineTo(19f, 5f)
                moveTo(12f, 14f); lineTo(8f, 22f); moveTo(12f, 14f); lineTo(16f, 22f)
            }
        }.build()
    }

    val Yoga: ImageVector by lazy {
        ImageVector.Builder("Yoga", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(14f, 4f); arcTo(2f, 2f, 0f, true, true, 10f, 4f); arcTo(2f, 2f, 0f, true, true, 14f, 4f)
                moveTo(12f, 6f); lineTo(12f, 16f)
                moveTo(12f, 9f); lineTo(7f, 4f); moveTo(12f, 9f); lineTo(17f, 4f)
                moveTo(12f, 16f); lineTo(12f, 22f)
                moveTo(12f, 14f); lineTo(15f, 16f); lineTo(12f, 18f)
            }
        }.build()
    }

    val Rest: ImageVector by lazy {
        ImageVector.Builder("Rest", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 20f); lineTo(3f, 12f); lineTo(21f, 12f); lineTo(21f, 20f)
                moveTo(3f, 12f); curveTo(3f, 12f, 5f, 9f, 8f, 9f); curveTo(10f, 9f, 10f, 12f, 10f, 12f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(15f, 3f); lineTo(19f, 3f); lineTo(15f, 7f); lineTo(19f, 7f)
            }
        }.build()
    }

    val Coffee: ImageVector by lazy {
        ImageVector.Builder("Coffee", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 10f); lineTo(4f, 18f); curveTo(4f, 20f, 6f, 21f, 8f, 21f); lineTo(14f, 21f)
                curveTo(16f, 21f, 18f, 20f, 18f, 18f); lineTo(18f, 10f); close()
                moveTo(18f, 12f); curveTo(20f, 12f, 21f, 13f, 21f, 14.5f); curveTo(21f, 16f, 20f, 17f, 18f, 17f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 7f); curveTo(8f, 5f, 9f, 4f, 8f, 3f)
                moveTo(11f, 7f); curveTo(11f, 5f, 12f, 4f, 11f, 3f)
                moveTo(14f, 7f); curveTo(14f, 5f, 15f, 4f, 14f, 3f)
            }
        }.build()
    }

    val Ginger: ImageVector by lazy {
        ImageVector.Builder("Ginger", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 11f); lineTo(4f, 18f); curveTo(4f, 20f, 6f, 21f, 8f, 21f); lineTo(14f, 21f)
                curveTo(16f, 21f, 18f, 20f, 18f, 18f); lineTo(18f, 11f); close()
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(11f, 9f); curveTo(11f, 9f, 13f, 4f, 17f, 3f); curveTo(17f, 3f, 15f, 7f, 11f, 9f)
                moveTo(14f, 5f); lineTo(11f, 9f)
            }
        }.build()
    }

    val Peppermint: ImageVector by lazy {
        ImageVector.Builder("Peppermint", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f); curveTo(12f, 22f, 4f, 16f, 4f, 10f); curveTo(4f, 4f, 12f, 2f, 12f, 2f)
                curveTo(12f, 2f, 20f, 4f, 20f, 10f); curveTo(20f, 16f, 12f, 22f, 12f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(12f, 6f); lineTo(12f, 18f)
                moveTo(8f, 10f); lineTo(12f, 12f); moveTo(16f, 10f); lineTo(12f, 12f)
            }
        }.build()
    }

    val Bath: ImageVector by lazy {
        ImageVector.Builder("Bath", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); lineTo(22f, 12f)
                moveTo(4f, 12f); lineTo(4f, 17f); curveTo(4f, 20f, 7f, 21f, 12f, 21f)
                curveTo(17f, 21f, 20f, 20f, 20f, 17f); lineTo(20f, 12f)
                moveTo(4f, 12f); lineTo(4f, 5f); curveTo(4f, 4f, 5f, 3f, 6f, 3f); lineTo(7f, 3f)
            }
        }.build()
    }

    val Shower: ImageVector by lazy {
        ImageVector.Builder("Shower", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 4f); lineTo(16f, 4f); lineTo(16f, 8f)
                moveTo(12f, 8f); lineTo(20f, 8f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(13f, 11f); lineTo(13f, 14f)
                moveTo(16f, 11f); lineTo(16f, 15f)
                moveTo(19f, 11f); lineTo(19f, 14f)
                moveTo(14.5f, 16f); lineTo(14.5f, 19f)
                moveTo(17.5f, 16f); lineTo(17.5f, 19f)
                moveTo(16f, 20f); lineTo(16f, 22f)
            }
        }.build()
    }

    val FreshAir: ImageVector by lazy {
        ImageVector.Builder("FreshAir", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(3f, 8f); curveTo(3f, 8f, 8f, 8f, 10f, 8f); curveTo(13f, 8f, 13f, 5f, 10f, 5f)
                moveTo(3f, 12f); curveTo(3f, 12f, 12f, 12f, 15f, 12f); curveTo(18f, 12f, 18f, 9f, 15f, 9f)
                moveTo(3f, 16f); curveTo(3f, 16f, 9f, 16f, 11f, 16f); curveTo(14f, 16f, 14f, 19f, 11f, 19f)
            }
        }.build()
    }

    val Quiet: ImageVector by lazy {
        ImageVector.Builder("Quiet", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 4f); curveTo(16f, 4f, 19f, 7f, 19f, 11f); curveTo(19f, 14f, 17f, 15f, 15f, 15f)
                curveTo(13f, 15f, 13f, 13f, 13f, 12f); curveTo(13f, 10f, 15f, 9f, 15f, 11f)
                moveTo(12f, 4f); curveTo(8f, 4f, 6f, 7f, 6f, 11f); curveTo(6f, 16f, 8f, 18f, 10f, 20f)
            }
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(4f, 4f); lineTo(20f, 20f)
            }
        }.build()
    }

    val Other: ImageVector by lazy {
        ImageVector.Builder("ReliefOther", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 21f); curveTo(12f, 21f, 3f, 15f, 3f, 9f); curveTo(3f, 6f, 5f, 4f, 7.5f, 4f)
                curveTo(9f, 4f, 11f, 5f, 12f, 7f); curveTo(13f, 5f, 15f, 4f, 16.5f, 4f)
                curveTo(19f, 4f, 21f, 6f, 21f, 9f); curveTo(21f, 15f, 12f, 21f, 12f, 21f)
            }
        }.build()
    }

    data class ReliefPickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<ReliefPickerIcon> by lazy { listOf(
        ReliefPickerIcon("breathing", "Breathing", Breathing),
        ReliefPickerIcon("box_breathing", "Box breathing", BoxBreathing),
        ReliefPickerIcon("ice", "Cold / Ice", Ice),
        ReliefPickerIcon("heat", "Heat", Heat),
        ReliefPickerIcon("darkness", "Dark room", Darkness),
        ReliefPickerIcon("eye_mask", "Eye mask", EyeMask),
        ReliefPickerIcon("sunglasses", "Sunglasses", Sunglasses),
        ReliefPickerIcon("water", "Water", Water),
        ReliefPickerIcon("electrolytes", "Electrolytes", Electrolytes),
        ReliefPickerIcon("massage", "Massage", Massage),
        ReliefPickerIcon("acupressure", "Acupressure", Acupressure),
        ReliefPickerIcon("meditation", "Meditation", Meditation),
        ReliefPickerIcon("progressive", "Relaxation", Progressive),
        ReliefPickerIcon("walk", "Walk", Walk),
        ReliefPickerIcon("stretch", "Stretch", Stretch),
        ReliefPickerIcon("yoga", "Yoga", Yoga),
        ReliefPickerIcon("rest", "Rest / Nap", Rest),
        ReliefPickerIcon("coffee", "Caffeine", Coffee),
        ReliefPickerIcon("ginger", "Ginger tea", Ginger),
        ReliefPickerIcon("peppermint", "Peppermint", Peppermint),
        ReliefPickerIcon("bath", "Bath", Bath),
        ReliefPickerIcon("shower", "Shower", Shower),
        ReliefPickerIcon("fresh_air", "Fresh air", FreshAir),
        ReliefPickerIcon("quiet", "Quiet", Quiet),
        ReliefPickerIcon("other", "Other", Other),
    ) }

    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: ReliefScale.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color

/** How much relief a medicine or relief method provided — per-log value, not a pool characteristic. */
enum class ReliefScale(val display: String, val color: Color) {
    NONE("None",  Color(0xFF666666)),
    LOW("Low",    Color(0xFFE57373)),
    MILD("Mild",  Color(0xFFFFB74D)),
    HIGH("High",  Color(0xFF81C784));

    companion object {
        fun fromString(s: String?): ReliefScale =
            entries.find { it.name.equals(s, ignoreCase = true) } ?: NONE
    }
}

title: ReliefsScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/* ────────────────────────────────────────────────
 *  Relief scale enum (per-log value, not a pool characteristic)
 * ──────────────────────────────────────────────── */

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun ReliefsScreen(
    navController: NavController,
    vm: ReliefViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {},
    quickLogMode: Boolean = false,
    onSave: (() -> Unit)? = null,
    linkedMigraineId: String? = null,
    onMigraineSelect: ((String?) -> Unit)? = null
) {
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    // ── Rebuild helpers ──
    fun rebuildDraftWithRels(rels: List<ReliefDraft>) {
        logVm.replaceReliefs(rels)
    }

    // ── Add dialog state ──
    var showAddDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }

    // ── Edit dialog state ──
    var showEditDialog by remember { mutableStateOf(false) }
    var editIndex by remember { mutableStateOf<Int?>(null) }

    fun onReliefTap(label: String) {
        val existingIdx = draft.rels.indexOfFirst { it.type == label }
        if (existingIdx >= 0) {
            val updated = draft.rels.toMutableList().apply { removeAt(existingIdx) }
            rebuildDraftWithRels(updated)
        } else {
            pendingLabel = label
            showAddDialog = true
        }
    }

    // Add dialog
    if (showAddDialog && pendingLabel != null) {
        ReliefAddDialog(
            title = pendingLabel!!,
            onDismiss = { showAddDialog = false },
            onSkip = {
                val updated = draft.rels + ReliefDraft(type = pendingLabel!!, startAtIso = null, endAtIso = null, reliefScale = "NONE")
                rebuildDraftWithRels(updated)
                showAddDialog = false
            },
            onConfirm = { startIso, endIso, relief ->
                val updated = draft.rels + ReliefDraft(
                    type = pendingLabel!!,
                    startAtIso = startIso,
                    endAtIso = endIso,
                    reliefScale = relief
                )
                rebuildDraftWithRels(updated)
                showAddDialog = false
            }
        )
    }

    // Edit dialog
    if (showEditDialog && editIndex != null && editIndex!! in draft.rels.indices) {
        val editing = draft.rels[editIndex!!]
        ReliefEditDialog(
            title = editing.type,
            initialStartIso = editing.startAtIso,
            initialEndIso = editing.endAtIso,
            initialRelief = editing.reliefScale ?: "NONE",
            onDismiss = { showEditDialog = false },
            onConfirm = { startIso, endIso, relief ->
                val updated = draft.rels.toMutableList().apply {
                    set(editIndex!!, editing.copy(
                        startAtIso = startIso,
                        endAtIso = endIso,
                        reliefScale = relief
                    ))
                }
                rebuildDraftWithRels(updated)
                showEditDialog = false
            }
        )
    }

    // Frequent labels
    val frequentLabels = remember(frequent) { frequent.mapNotNull { it.relief?.label }.toSet() }
    val selectedLabels = remember(draft.rels) { draft.rels.map { it.type }.toSet() }

    // Group pool by category
    val grouped = remember(pool) {
        pool.groupBy { it.category ?: "Other" }.toSortedMap()
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                if (!quickLogMode) {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                        Spacer(Modifier.width(4.dp))
                        Text("Medicines", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                    }
                } else {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    }
                }
                Text("Reliefs", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                if (!quickLogMode) {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                    }
                } else {
                    Spacer(Modifier.size(28.dp))
                }
            }

            // ── HeroCard ──
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawReliefLeaf(Color(0xFF81C784)) } }
                )
                Text("Reliefs", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.rels.isEmpty()) "Add reliefs that helped"
                    else "${draft.rels.size} relief${if (draft.rels.size > 1) "s" else ""} added",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
                if (draft.rels.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.rels.forEachIndexed { index, r ->
                        val relief = ReliefScale.fromString(r.reliefScale)
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 3.dp)
                                .clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f))
                                .padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    r.type,
                                    color = AppTheme.BodyTextColor,
                                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
                                )
                                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                                    Text(
                                        if (r.startAtIso == null) "Same as migraine start"
                                        else formatReliefTime(r.startAtIso),
                                        color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                        style = MaterialTheme.typography.labelSmall
                                    )
                                    if (r.endAtIso != null) {
                                        Text(
                                            "→ ${formatReliefTime(r.endAtIso)}",
                                            color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                            style = MaterialTheme.typography.labelSmall
                                        )
                                    }
                                    if (r.startAtIso != null && r.endAtIso != null) {
                                        deriveDurationMinutes(r.startAtIso, r.endAtIso)?.let { mins ->
                                            Text(
                                                "• ${mins}min",
                                                color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                                style = MaterialTheme.typography.labelSmall
                                            )
                                        }
                                    }
                                }
                                // Relief scale
                                Text(
                                    "Relief: ${relief.display}",
                                    color = relief.color,
                                    style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.SemiBold)
                                )
                            }
                            Icon(
                                Icons.Outlined.Edit,
                                contentDescription = "Edit",
                                tint = AppTheme.AccentPurple.copy(alpha = 0.7f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        editIndex = index
                                        showEditDialog = true
                                    }
                            )
                            Spacer(Modifier.width(8.dp))
                            Icon(
                                Icons.Outlined.Close,
                                contentDescription = "Remove",
                                tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        val updated = draft.rels.toMutableList().apply { removeAt(index) }
                                        rebuildDraftWithRels(updated)
                                    }
                            )
                        }
                    }
                }
            }

            // Manage card (own card)
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Reliefs", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_RELIEFS) })
                }
            }

            if (quickLogMode && onMigraineSelect != null) {
                val firstIso = draft.rels.firstOrNull()?.startAtIso
                MigrainePickerCard(itemStartAtIso = firstIso, authVm = authVm, selectedMigraineId = linkedMigraineId, onSelect = onMigraineSelect)
            }

            // ── Single reliefs card: Frequent → divider → categories ──
            BaseCard {
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { rel ->
                            ReliefButton(rel.label, rel.label in selectedLabels) {
                                onReliefTap(rel.label)
                            }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }

                val categoryEntries = grouped.entries.toList()
                categoryEntries.forEachIndexed { catIndex, (category, items) ->
                    val nonFreqItems = items.filter { it.label !in frequentLabels }
                    if (nonFreqItems.isNotEmpty()) {
                        Text(category, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreqItems.forEach { rel ->
                                ReliefButton(rel.label, rel.label in selectedLabels) {
                                    onReliefTap(rel.label)
                                }
                            }
                        }
                        val hasMore = categoryEntries.drop(catIndex + 1).any { (_, its) -> its.any { it.label !in frequentLabels } }
                        if (hasMore) {
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                        }
                    }
                }

                if (pool.isEmpty()) {
                    Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // Navigation
            Row(
                Modifier.fillMaxWidth().padding(vertical = 8.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Cancel" else "Back") }
                Button(
                    onClick = { if (quickLogMode) onSave?.invoke() else navController.navigate(Routes.LOCATIONS) },
                    enabled = !quickLogMode || draft.rels.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Save" else "Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

/* ────────────────────────────────────────────────
 *  Add dialog: duration + start time + end time
 * ──────────────────────────────────────────────── */

@Composable
private fun ReliefAddDialog(
    title: String,
    onDismiss: () -> Unit,
    onSkip: () -> Unit,
    onConfirm: (startIso: String?, endIso: String?, relief: String) -> Unit
) {
    var startIso by remember { mutableStateOf<String?>(null) }
    var endIso by remember { mutableStateOf<String?>(null) }
    var selectedRelief by remember { mutableStateOf(ReliefScale.NONE) }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                // Start time
                Text("When did you start?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Text("Start: ${formatReliefTime(startIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select start time", onDateTimeSelected = { iso -> startIso = iso })

                // End time
                Text("When did you stop? (optional)", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Text("End: ${formatReliefTime(endIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select end time", onDateTimeSelected = { iso -> endIso = iso })

                // Relief scale
                Text("How much relief?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    ReliefScale.entries.forEach { scale ->
                        FilterChip(
                            selected = selectedRelief == scale,
                            onClick = { selectedRelief = scale },
                            label = { Text(scale.display, style = MaterialTheme.typography.labelSmall) },
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = scale.color.copy(alpha = 0.3f),
                                selectedLabelColor = Color.White,
                                containerColor = Color.White.copy(alpha = 0.06f),
                                labelColor = AppTheme.SubtleTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                enabled = true,
                                selected = selectedRelief == scale,
                                borderColor = Color.White.copy(alpha = 0.12f),
                                selectedBorderColor = scale.color.copy(alpha = 0.6f)
                            )
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = { onConfirm(startIso, endIso, selectedRelief.name) }) {
                Text("Add", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
                TextButton(onClick = onSkip) {
                    Text("Skip", color = Color(0xFF81C784))
                }
            }
        }
    )
}

/* ────────────────────────────────────────────────
 *  Edit dialog: duration + start + end
 * ──────────────────────────────────────────────── */

@Composable
private fun ReliefEditDialog(
    title: String,
    initialStartIso: String?,
    initialEndIso: String?,
    initialRelief: String,
    onDismiss: () -> Unit,
    onConfirm: (startIso: String?, endIso: String?, relief: String) -> Unit
) {
    var startIso by remember { mutableStateOf(initialStartIso) }
    var endIso by remember { mutableStateOf(initialEndIso) }
    var selectedRelief by remember { mutableStateOf(ReliefScale.fromString(initialRelief)) }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text("Edit $title") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Start: ${formatReliefTime(startIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select start time", onDateTimeSelected = { iso -> startIso = iso })

                Text("End: ${formatReliefTime(endIso)}", color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
                AppDateTimePicker(label = "Select end time", onDateTimeSelected = { iso -> endIso = iso })

                Text("How much relief?", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    ReliefScale.entries.forEach { scale ->
                        FilterChip(
                            selected = selectedRelief == scale,
                            onClick = { selectedRelief = scale },
                            label = { Text(scale.display, style = MaterialTheme.typography.labelSmall) },
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = scale.color.copy(alpha = 0.3f),
                                selectedLabelColor = Color.White,
                                containerColor = Color.White.copy(alpha = 0.06f),
                                labelColor = AppTheme.SubtleTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                enabled = true,
                                selected = selectedRelief == scale,
                                borderColor = Color.White.copy(alpha = 0.12f),
                                selectedBorderColor = scale.color.copy(alpha = 0.6f)
                            )
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = { onConfirm(startIso, endIso, selectedRelief.name) }) {
                Text("Save", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel", color = AppTheme.SubtleTextColor)
            }
        }
    )
}

/* ────────────────────────────────────────────────
 *  Relief circle button
 * ──────────────────────────────────────────────── */

@Composable
private fun ReliefButton(label: String, isSelected: Boolean, onClick: () -> Unit) {
    val circleColor = if (isSelected) Color(0xFF81C784).copy(alpha = 0.40f) else Color.White.copy(alpha = 0.08f)
    val borderColor = if (isSelected) Color(0xFF81C784).copy(alpha = 0.7f) else Color.White.copy(alpha = 0.12f)
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(72.dp)
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            modifier = Modifier
                .size(52.dp)
                .clip(CircleShape)
                .background(circleColor)
                .border(width = 1.5.dp, color = borderColor, shape = CircleShape),
            contentAlignment = Alignment.Center
        ) {
            Text(
                label.take(2).uppercase(),
                color = iconTint,
                style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
            )
        }
        Spacer(Modifier.height(4.dp))
        Text(
            label,
            color = textColor,
            style = MaterialTheme.typography.labelSmall,
            textAlign = TextAlign.Center,
            maxLines = 2,
            modifier = Modifier.fillMaxWidth()
        )
    }
}

/* ────────────────────────────────────────────────
 *  Format helper
 * ──────────────────────────────────────────────── */

private fun formatReliefTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime()
            ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull()
            ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}

/** Derive duration in minutes from two ISO timestamps (client-side preview). */
private fun deriveDurationMinutes(startIso: String, endIso: String): Int? {
    return try {
        fun parseInstant(s: String): Instant? =
            runCatching { OffsetDateTime.parse(s).toInstant() }.getOrNull()
                ?: runCatching { Instant.parse(s) }.getOrNull()
                ?: runCatching { LocalDateTime.parse(s).atZone(ZoneId.systemDefault()).toInstant() }.getOrNull()

        val s = parseInstant(startIso) ?: return null
        val e = parseInstant(endIso) ?: return null
        val mins = java.time.Duration.between(s, e).toMinutes().toInt()
        if (mins >= 0) mins else null
    } catch (_: Exception) { null }
}


title: ReliefViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class ReliefViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserReliefRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserReliefRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.ReliefPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.ReliefPrefRow>> = _frequent

    private fun sortPrefs(prefs: List<SupabaseDbService.ReliefPrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            runCatching {
                val p = db.getAllReliefPool(accessToken)
                val f = db.getReliefPrefs(accessToken)
                _pool.value = p
                _frequent.value = sortPrefs(f)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null) {
        viewModelScope.launch {
            runCatching {
                db.upsertReliefToPool(accessToken, label, category)
                loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromPool(accessToken: String, reliefId: String) {
        viewModelScope.launch {
            runCatching {
                db.deleteReliefFromPool(accessToken, reliefId)
                loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun addToFrequent(accessToken: String, reliefId: String) {
        viewModelScope.launch {
            runCatching {
                val pos = (_frequent.value.maxOfOrNull { it.position } ?: -1) + 1
                db.insertReliefPref(accessToken, reliefId, pos, "frequent")
                loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            runCatching {
                db.deleteReliefPref(accessToken, prefId)
                loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun setCategory(accessToken: String, reliefId: String, category: String?) {
        viewModelScope.launch {
            runCatching {
                db.setReliefCategory(accessToken, reliefId, category)
                loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun setAutomation(accessToken: String, reliefId: String, enabled: Boolean) {
        viewModelScope.launch {
            runCatching {
                db.setReliefAutomation(accessToken, reliefId, enabled)
                loadAll(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }
}


title: ReportPdfGenerator.kt
text:
// FILE: ReportPdfGenerator.kt
package com.migraineme

import android.content.Context
import android.content.Intent
import android.graphics.*
import android.graphics.pdf.PdfDocument
import android.util.Log
import android.widget.Toast
import androidx.core.content.FileProvider
import java.io.File
import java.io.FileOutputStream
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sin

class ReportPdfGenerator(private val context: Context) {

    companion object { private const val TAG = "ReportPDF" }

    // ═══════ Theme ═══════
    private val BG     = Color.parseColor("#1A0028")
    private val CARD   = Color.parseColor("#2A0C3C")
    private val ACCENT = Color.parseColor("#B97BFF")
    private val PINK   = Color.parseColor("#FF7BB0")
    private val TITLE  = Color.parseColor("#DCCEFF")
    private val BODY   = Color.parseColor("#D0D0D0")
    private val SUBTLE = Color.parseColor("#9E9E9E")
    private val BORDER = Color.parseColor("#3D1F52")
    private val SM     = Color.parseColor("#81C784")
    private val SMO    = Color.parseColor("#FFB74D")
    private val SS     = Color.parseColor("#E57373")
    private val LOG_COLORS = mapOf(
        "Triggers" to Color.parseColor("#FF8A65"), "Prodromes" to Color.parseColor("#FFD54F"),
        "Symptoms" to Color.parseColor("#E57373"), "Medicines" to Color.parseColor("#4FC3F7"),
        "Reliefs" to Color.parseColor("#81C784"), "Activities" to Color.parseColor("#BA68C8"),
        "Missed Activities" to Color.parseColor("#FF7043"), "Locations" to Color.parseColor("#4DD0E1")
    )
    private val BAR_COLORS = listOf(Color.parseColor("#FF8A65"), Color.parseColor("#BA68C8"),
        Color.parseColor("#4FC3F7"), Color.parseColor("#81C784"))

    // ═══════ Page ═══════
    private val PW = 595; private val PH = 842; private val M = 36f
    private lateinit var doc: PdfDocument
    private var pn = 0; private var page: PdfDocument.Page? = null
    private var cv: Canvas? = null; private var y = 0f

    data class TimelineCapture(
        val migraine: MigraineSpan,
        val autoBitmap: Bitmap,
        val fullBitmap: Bitmap,
        val events: List<LegendEvent> = emptyList(),
        val autoMetricNames: List<LegendMetric> = emptyList(),
        val fullMetricNames: List<LegendMetric> = emptyList()
    )

    data class LegendEvent(
        val index: Int,
        val name: String,
        val category: String,
        val color: Int,
        val isAutomated: Boolean
    )

    data class LegendMetric(
        val name: String,
        val unit: String,
        val color: Int
    )

    data class ReportData(
        val filteredMigraines: List<MigraineSpan>,
        val timeFrameLabel: String,
        val spiders: InsightsViewModel.FilteredSpiders,
        val enabledMetrics: List<MetricSeries>,
        val autoMetricKeys: Set<String>,
        val allDailyMetrics: Map<String, List<InsightsViewModel.DailyValue>>,
        val timelineCaptures: List<TimelineCapture> = emptyList()
    )

    // ═══════ Public ═══════

    fun generate(data: ReportData): File? {
        return try {
            doc = PdfDocument(); pn = 0; newPage()
            drawCover(data)
            drawStats(data)
            drawLogCompact(data)

            // ── Full Symptoms breakdown ──
            if (hasSymptomsData(data)) { newPage(); drawSymptomsBreakdown(data) }

            // ── All other spider types: each starts on a new page ──
            listOf(
                data.spiders.prodromes, data.spiders.triggers,
                data.spiders.medicines, data.spiders.reliefs,
                data.spiders.locations, data.spiders.activities,
                data.spiders.missedActivities
            ).forEach { sp ->
                if (sp != null && sp.totalLogged > 0) {
                    newPage()
                    drawFullBreakdown(sp, data)
                }
            }

            if (data.timelineCaptures.isNotEmpty()) { newPage(); drawTimelines(data) }
            if (data.enabledMetrics.isNotEmpty()) { newPage(); drawMetrics(data) }
            footer(); finishPage()

            val dir = File(context.cacheDir, "reports"); dir.mkdirs()
            val f = File(dir, "MigraineMe_Report_${System.currentTimeMillis()}.pdf")
            FileOutputStream(f).use { doc.writeTo(it) }; doc.close()
            Log.d(TAG, "Saved ${f.length() / 1024}KB"); f
        } catch (e: Exception) { Log.e(TAG, "Generate failed", e); try { doc.close() } catch (_: Exception) {}; null }
    }

    fun share(file: File) {
        try {
            val uri = FileProvider.getUriForFile(context, "${context.packageName}.provider", file)
            context.startActivity(Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(uri, "application/pdf"); addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK)
            })
        } catch (_: Exception) { try {
            val uri = FileProvider.getUriForFile(context, "${context.packageName}.provider", file)
            context.startActivity(Intent.createChooser(Intent(Intent.ACTION_SEND).apply {
                type = "application/pdf"; putExtra(Intent.EXTRA_STREAM, uri)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_ACTIVITY_NEW_TASK)
            }, "Share Report").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
        } catch (e: Exception) { Toast.makeText(context, "Cannot share: ${e.message}", Toast.LENGTH_LONG).show() } }
    }

    // ═══════ Page mgmt ═══════
    private fun newPage() { finishPage(); pn++; page = doc.startPage(PdfDocument.PageInfo.Builder(PW, PH, pn).create()); cv = page!!.canvas; cv!!.drawColor(BG); y = M }
    private fun finishPage() { page?.let { pageNum(); doc.finishPage(it) }; page = null; cv = null }
    private fun need(h: Float) { if (y + h > PH - M - 20f) newPage() }
    private fun pageNum() { cv?.drawText("$pn", PW / 2f, PH - 10f, tp(SUBTLE, 7f, a = Paint.Align.CENTER)) }
    private fun footer() {
        val p = tp(SUBTLE, 7f, a = Paint.Align.CENTER)
        p.letterSpacing = 0.02f
        cv?.drawText("Generated by MigraineMe  ·  For informational purposes only", PW / 2f, PH - 22f, p)
    }

    // ═══════ Text helpers ═══════

    /** Major section heading — full-width banner with colored left accent */
    private fun heading(t: String, col: Int = ACCENT) {
        need(80f); val c = cv ?: return
        val l = M; val r = PW - M; val top = y; val h = 34f
        // Background strip
        c.drawRoundRect(RectF(l, top, r, top + h), 10f, 10f, fp(Color.parseColor("#2E1245")))
        // Colored left accent bar
        c.drawRoundRect(RectF(l, top, l + 4f, top + h), 2f, 2f, fp(col))
        // Subtle colored glow along top
        c.drawLine(l + 12f, top, r - 12f, top, sp(col, 0.5f, 30))
        // Text in the section color
        c.drawText(t, l + 16f, top + 22f, tp(col, 15f, b = true))
        y += h + 12f
    }

    /** Sub-heading — smaller banner tinted with the section color */
    private fun subHead(t: String, col: Int) {
        need(60f); val c = cv ?: return
        val l = M + 6f; val r = PW - M; val top = y; val h = 22f
        // Base dark bg
        c.drawRoundRect(RectF(l, top, r, top + h), 6f, 6f, fp(Color.parseColor("#1E0E30")))
        // Color tint overlay
        c.drawRoundRect(RectF(l, top, r, top + h), 6f, 6f, fp(col, 25))
        // Colored left accent
        c.drawRoundRect(RectF(l, top + 3f, l + 3f, top + h - 3f), 1.5f, 1.5f, fp(col))
        // Text
        c.drawText(t, l + 12f, top + 15f, tp(col, 9.5f, b = true))
        y += h + 6f
    }

    /** Prominent sub-heading — wider banner, stronger color tint */
    private fun prominentSubHead(t: String, col: Int) {
        need(70f); val c = cv ?: return
        val l = M; val r = PW - M; val top = y; val h = 28f
        // Base dark bg
        c.drawRoundRect(RectF(l, top, r, top + h), 8f, 8f, fp(Color.parseColor("#1E0E30")))
        // Stronger color tint overlay
        c.drawRoundRect(RectF(l, top, r, top + h), 8f, 8f, fp(col, 35))
        // Colored left bar (thicker)
        c.drawRoundRect(RectF(l, top, l + 5f, top + h), 3f, 3f, fp(col, 200))
        // Colored dot
        c.drawCircle(l + 18f, top + h / 2f, 3.5f, fp(col))
        // Text in white for contrast on tinted bg
        c.drawText(t, l + 28f, top + 18f, tp(TITLE, 11f, b = true))
        y += h + 8f
    }

    /** Category header card — colored top edge and subtle color tint */
    private fun catHeader(title: String, sub: String, col: Int, badgeText: String? = null, badgeCol: Int? = null) {
        need(50f); val c = cv ?: return
        val l = M; val r = PW - M; val top = y; val h = 44f
        // Card background with color tint
        c.drawRoundRect(RectF(l, top, r, top + h), 12f, 12f, fp(CARD, 180))
        c.drawRoundRect(RectF(l, top, r, top + h), 12f, 12f, fp(col, 15))
        // Colored top edge
        c.drawRoundRect(RectF(l + 8f, top, r - 8f, top + 3f), 1.5f, 1.5f, fp(col, 160))
        // Border
        c.drawRoundRect(RectF(l, top, r, top + h), 12f, 12f, sp(col, 0.6f, 30))
        // Title
        c.drawText(title.take(36), l + 12f, top + 18f, tp(Color.WHITE, 11f, b = true))
        // Subtitle
        c.drawText(sub, l + 12f, top + 32f, tp(SUBTLE, 8f))
        // Badge
        if (badgeText != null && badgeCol != null) {
            val tw = tp(badgeCol, 8f, true).measureText(badgeText)
            c.drawRoundRect(RectF(r - tw - 18f, top + 8f, r - 4f, top + 22f), 5f, 5f, fp(badgeCol, 45))
            c.drawText(badgeText, r - tw / 2f - 11f, top + 18f, tp(badgeCol, 8f, true, Paint.Align.CENTER))
        }
        y += h + 6f
    }

    private fun tp(col: Int, sz: Float, b: Boolean = false, a: Paint.Align = Paint.Align.LEFT) = Paint().apply {
        color = col; textSize = sz; isAntiAlias = true; textAlign = a
        if (sz <= 10f) letterSpacing = 0.02f
        if (b) typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
    }
    private fun fp(col: Int, al: Int = 255) = Paint().apply { color = col; alpha = al; style = Paint.Style.FILL; isAntiAlias = true }
    private fun sp(col: Int, w: Float = 1f, al: Int = 255) = Paint().apply { color = col; alpha = al; style = Paint.Style.STROKE; strokeWidth = w; isAntiAlias = true }

    // ═══════ Card (matches BaseCard: rounded 14pt, semi-transparent bg, subtle white border) ═══════
    private inline fun card(h: Float, draw: (Canvas, Float, Float, Float, Float) -> Unit) {
        need(h + 14f); val c = cv ?: return
        val l = M; val t = y; val r = PW - M; val bo = y + h
        // Card background — semi-transparent like BaseCardContainer
        c.drawRoundRect(RectF(l, t, r, bo), 14f, 14f, fp(CARD, 166)) // 0.65 alpha = ~166
        // Very subtle white border like BaseCardBorder (0.08 opacity)
        c.drawRoundRect(RectF(l, t, r, bo), 14f, 14f, sp(Color.WHITE, 0.8f, 20))
        val pad = if (h <= 50f) 8f else 12f
        draw(c, l + pad, t + pad, r - pad, bo - pad)
        y = bo + 8f
    }

    /** Hero card — for main section content, slightly more prominent border */
    private inline fun heroCard(h: Float, draw: (Canvas, Float, Float, Float, Float) -> Unit) {
        need(h + 14f); val c = cv ?: return
        val l = M; val t = y; val r = PW - M; val bo = y + h
        // Slightly more opaque background
        c.drawRoundRect(RectF(l, t, r, bo), 16f, 16f, fp(CARD, 199)) // 0.78 alpha = ~199
        // Gradient-ish border: purple top/left, pink bottom/right
        c.drawRoundRect(RectF(l, t, r, bo), 16f, 16f, sp(ACCENT, 1.2f, 100))
        // Pink accent on bottom edge
        c.drawLine(l + 20f, bo, r - 20f, bo, sp(PINK, 0.8f, 60))
        val pad = 14f
        draw(c, l + pad, t + pad, r - pad, bo - pad)
        y = bo + 10f
    }

    // ═══════ Cover ═══════
    private fun drawCover(d: ReportData) {
        val c = cv ?: return

        // Decorative top accent line
        val grad = LinearGradient(M, 60f, PW - M, 60f, ACCENT, PINK, Shader.TileMode.CLAMP)
        val gp = Paint().apply { shader = grad; strokeWidth = 2f; style = Paint.Style.STROKE; isAntiAlias = true }
        c.drawLine(M + 40f, 80f, PW - M - 40f, 80f, gp)

        y = 140f
        c.drawText("MigraineMe", PW / 2f, y, tp(TITLE, 32f, true, Paint.Align.CENTER)); y += 26f
        c.drawText("Insights Report", PW / 2f, y, tp(ACCENT, 16f, a = Paint.Align.CENTER)); y += 44f

        // Decorative divider
        c.drawLine(PW / 2f - 60f, y, PW / 2f + 60f, y, gp)
        y += 28f

        c.drawText(d.timeFrameLabel, PW / 2f, y, tp(BODY, 12f, a = Paint.Align.CENTER)); y += 18f
        if (d.filteredMigraines.isNotEmpty()) {
            val fmt = DateTimeFormatter.ofPattern("dd MMM yyyy")
            val fr = d.filteredMigraines.last().start.atZone(ZoneId.systemDefault()).format(fmt)
            val to = d.filteredMigraines.first().start.atZone(ZoneId.systemDefault()).format(fmt)
            c.drawText("$fr  –  $to", PW / 2f, y, tp(SUBTLE, 11f, a = Paint.Align.CENTER))
        }
        y += 50f
    }

    // ═══════ Summary stats ═══════
    private fun drawStats(d: ReportData) {
        val m = d.filteredMigraines; if (m.isEmpty()) return
        val avgS = m.mapNotNull { it.severity }.let { if (it.isEmpty()) 0.0 else it.average() }
        val avgD = m.mapNotNull { mg -> mg.end?.let { (it.toEpochMilli() - mg.start.toEpochMilli()) / 3600000.0 } }.let { if (it.isEmpty()) 0.0 else it.average() }
        heroCard(65f) { c, l, t, r, _ ->
            val cw = (r - l) / 3f
            listOf(Triple(m.size.toString(), "Migraines", 0), Triple(String.format("%.1f", avgS), "Avg Severity", 0), Triple(String.format("%.1fh", avgD), "Avg Duration", 0))
                .forEachIndexed { i, (v, lb, _) -> val cx = l + i * cw + cw / 2f; c.drawText(v, cx, t + 26f, tp(Color.WHITE, 20f, true, Paint.Align.CENTER)); c.drawText(lb, cx, t + 40f, tp(SUBTLE, 9f, a = Paint.Align.CENTER)) }
        }
    }

    // ═══════════════════════════════════════════════════════════════
    //  SYMPTOMS BREAKDOWN (matches SymptomsBreakdownContent exactly)
    // ═══════════════════════════════════════════════════════════════

    private fun hasSymptomsData(d: ReportData): Boolean {
        return d.spiders.painChar?.axes?.isNotEmpty() == true ||
            d.spiders.accompanying?.axes?.isNotEmpty() == true ||
            d.spiders.painLocations?.axes?.isNotEmpty() == true ||
            d.spiders.severityCounts.isNotEmpty() ||
            d.spiders.durationStats != null
    }

    private fun drawSymptomsBreakdown(d: ReportData) {
        val hasPC = d.spiders.painChar?.axes?.isNotEmpty() == true
        val hasAC = d.spiders.accompanying?.axes?.isNotEmpty() == true
        val hasPL = d.spiders.painLocations?.axes?.isNotEmpty() == true
        val hasSev = d.spiders.severityCounts.isNotEmpty()
        val hasDur = d.spiders.durationStats != null
        if (!hasPC && !hasAC && !hasPL && !hasSev && !hasDur) return

        heading("Symptoms", Color.parseColor("#E57373"))

        // Pain Character
        if (hasPC) drawSpiderSection("Pain Character", d.spiders.painChar!!, Color.parseColor("#EF5350"))

        // Accompanying Experience
        if (hasAC) drawSpiderSection("Accompanying Experience", d.spiders.accompanying!!, Color.parseColor("#BA68C8"))

        // Pain Locations
        if (hasPL) drawSpiderSection("Pain Locations", d.spiders.painLocations!!, Color.parseColor("#FF8A65"))

        // Severity Distribution
        if (hasSev) drawSeveritySection(d.spiders.severityCounts)

        // Duration
        if (hasDur) drawDurationSection(d.spiders.durationStats!!)
    }

    /** SpiderSection: title, logged count, spider/bar/stat with 1/2/3 logic */
    private fun drawSpiderSection(title: String, spider: SpiderData, col: Int) {
        val axes = spider.axes; if (axes.isEmpty()) return
        subHead("$title — ${spider.totalLogged} logged · ${axes.size} types", col)
        drawAxesVisual(axes, col, null)
    }

    private fun drawSeveritySection(cts: List<Pair<Int, Int>>) {
        val sevCol = Color.parseColor("#4FC3F7")
        val total = cts.sumOf { it.second }; val vals = cts.flatMap { (s, c) -> List(c) { s } }
        if (vals.isEmpty()) return
        val mn = vals.min(); val mx = vals.max(); val avg = vals.average()
        subHead("Severity Distribution — $total migraines rated", sevCol)
        // Stats row
        heroCard(46f) { c, l, t, r, _ ->
            val cw = (r - l) / 3f
            listOf(Triple("$mn", "Lowest", SM), Triple(String.format("%.1f", avg), "Average", sevCol), Triple("$mx", "Highest", SS))
                .forEachIndexed { i, (v, lb, cl) -> val cx = l + i * cw + cw / 2f; c.drawText(v, cx, t + 16f, tp(cl, 16f, true, Paint.Align.CENTER)); c.drawText(lb, cx, t + 28f, tp(SUBTLE, 8f, a = Paint.Align.CENTER)) }
        }
        val sevAxes = cts.map { (s, c) -> SpiderAxis("Level $s", c.toFloat()) }
        drawAxesVisual(sevAxes, sevCol, null)
    }

    private fun drawDurationSection(stats: InsightsViewModel.DurationStats) {
        val durCol = Color.parseColor("#81C784")
        subHead("Duration — ${stats.durations.size} migraines with end time", durCol)
        heroCard(46f) { c, l, t, r, _ ->
            val cw = (r - l) / 3f
            listOf(Triple(fmtDur(stats.minHours), "Shortest", SM), Triple(fmtDur(stats.avgHours), "Average", durCol), Triple(fmtDur(stats.maxHours), "Longest", SS))
                .forEachIndexed { i, (v, lb, cl) -> val cx = l + i * cw + cw / 2f; c.drawText(v, cx, t + 16f, tp(cl, 16f, true, Paint.Align.CENTER)); c.drawText(lb, cx, t + 28f, tp(SUBTLE, 8f, a = Paint.Align.CENTER)) }
        }
        // Buckets
        if (stats.durations.size > 1) {
            val buckets = mutableMapOf<String, Int>()
            for (h in stats.durations) {
                val b = when { h < 1f -> "< 1h"; h < 4f -> "1-4h"; h < 12f -> "4-12h"; h < 24f -> "12-24h"; h < 48f -> "1 day"; h < 72f -> "2 days"; else -> "3+ days" }
                buckets[b] = (buckets[b] ?: 0) + 1
            }
            val ordered = listOf("< 1h", "1-4h", "4-12h", "12-24h", "1 day", "2 days", "3+ days")
            val durAxes = ordered.filter { (buckets[it] ?: 0) > 0 }.map { SpiderAxis(it, (buckets[it] ?: 0).toFloat()) }
            drawAxesVisual(durAxes, durCol, null)
        }
    }

    private fun fmtDur(h: Float) = when { h < 1f -> "${(h * 60).toInt()}m"; h < 24f -> "%.1fh".format(h); else -> "%.1fd".format(h / 24f) }

    // ═══════════════════════════════════════════════════════════════
    //  FULL BREAKDOWN (matches InsightsBreakdownScreen)
    //  Categories Overview → Usage vs Effectiveness → Per-Category cards
    // ═══════════════════════════════════════════════════════════════

    private fun drawFullBreakdown(sp: SpiderData, data: ReportData) {
        val col = LOG_COLORS[sp.logType] ?: ACCENT
        heading("${sp.logType} — ${sp.totalLogged} logged · ${sp.breakdown.size} categories", col)

        // 1. Categories Overview spider
        prominentSubHead("Categories Overview", col)
        drawAxesVisual(sp.axes, col, null)

        // 2. Usage vs Effectiveness (Medicines / Reliefs only)
        if (sp.logType == "Medicines" || sp.logType == "Reliefs") {
            val eff = if (sp.logType == "Medicines") data.spiders.medicineEffectiveness else data.spiders.reliefEffectiveness
            if (eff.isNotEmpty() && eff.size >= 3) {
                prominentSubHead("Usage vs Effectiveness", col)
                val countAxes = eff.map { SpiderAxis(it.category, it.count.toFloat()) }
                val reliefAxes = eff.map { SpiderAxis(it.category, it.avgRelief, 3f) }
                drawDualSpider(countAxes, col, reliefAxes, Color.WHITE)
                // Legend
                need(14f); val c = cv ?: return
                c.drawCircle(M + 20f, y + 5f, 4f, fp(col)); c.drawText("Count", M + 28f, y + 9f, tp(SUBTLE, 8f))
                c.drawCircle(M + 80f, y + 5f, 4f, fp(Color.WHITE, 150)); c.drawText("Avg Relief", M + 88f, y + 9f, tp(SUBTLE, 8f))
                y += 14f
            }
        }

        // 3. Per-category subcategory spider cards
        val isMedRel = sp.logType == "Medicines" || sp.logType == "Reliefs"
        val itemEffMap = when (sp.logType) {
            "Medicines" -> data.spiders.medicineItemEffectiveness
            "Reliefs" -> data.spiders.reliefItemEffectiveness
            else -> emptyMap()
        }
        val catEff = if (isMedRel) {
            if (sp.logType == "Medicines") data.spiders.medicineEffectiveness else data.spiders.reliefEffectiveness
        } else emptyList()

        for (cat in sp.breakdown) {
            val effItem = catEff.find { it.category == cat.categoryName }
            val cardTitle = cat.categoryName
            val cardSub = "${cat.totalCount} logged · ${cat.items.size} types"

            // Effectiveness badge
            val badgeText = effItem?.let {
                when { it.avgRelief >= 2.5f -> "High"; it.avgRelief >= 1.5f -> "Mild"; it.avgRelief >= 0.5f -> "Low"; else -> "None" }
            }
            val badgeCol = effItem?.let {
                when { it.avgRelief >= 2.5f -> SM; it.avgRelief >= 1.5f -> SMO; it.avgRelief >= 0.5f -> SS; else -> Color.parseColor("#666666") }
            }

            catHeader(cardTitle, cardSub, col, badgeText, badgeCol)

            // Sub-axes
            val subAxes = cat.items.map { SpiderAxis(it.first, it.second.toFloat()) }
            val subRelief = if (isMedRel && itemEffMap.isNotEmpty()) {
                cat.items.map { SpiderAxis(it.first, itemEffMap[it.first.lowercase()] ?: 0f, 3f) }
            } else null

            drawAxesVisual(subAxes, col, subRelief)
        }
    }

    // ═══════════════════════════════════════════════════════════════
    //  VISUAL RENDERERS (1/2/3+ logic)
    // ═══════════════════════════════════════════════════════════════

    private fun drawAxesVisual(axes: List<SpiderAxis>, col: Int, secondAxes: List<SpiderAxis>?) {
        if (axes.isEmpty()) return
        when {
            axes.size >= 3 -> if (secondAxes != null && secondAxes.size == axes.size) drawDualSpider(axes, col, secondAxes, Color.WHITE) else drawSpiderWeb(axes, col)
            axes.size == 2 -> drawProportionalBar(axes, col, secondAxes)
            else -> drawStatCard(axes[0], col, secondAxes?.firstOrNull())
        }
    }

    private fun drawSpiderWeb(axes: List<SpiderAxis>, col: Int) {
        val n = axes.size
        val h = if (n > 6) 260f else 220f
        card(h) { c, l, t, r, b ->
            val cx = (l + r) / 2f; val cy = (t + b) / 2f
            val rad = min((r - l) / 2f - 48f, (b - t) / 2f - 24f)
            drawGrid(c, n, cx, cy, rad)
            val maxV = axes.mapNotNull { it.maxValue }.maxOrNull()?.takeIf { it > 0f } ?: axes.maxOf { it.value }.takeIf { it > 0f } ?: 1f
            drawFill(c, axes, cx, cy, rad, maxV, col, 50, 1.5f)
            drawLabels(c, axes, n, cx, cy, rad)
        }
    }

    private fun drawDualSpider(primary: List<SpiderAxis>, col: Int, secondary: List<SpiderAxis>, secCol: Int) {
        val n = primary.size
        val h = if (n > 6) 260f else 220f
        card(h) { c, l, t, r, b ->
            val cx = (l + r) / 2f; val cy = (t + b) / 2f
            val rad = min((r - l) / 2f - 48f, (b - t) / 2f - 24f)
            drawGrid(c, n, cx, cy, rad)

            // Primary polygon (count)
            val maxV1 = primary.mapNotNull { it.maxValue }.maxOrNull()?.takeIf { it > 0f } ?: primary.maxOf { it.value }.takeIf { it > 0f } ?: 1f
            drawFill(c, primary, cx, cy, rad, maxV1, col, 40, 1.5f)

            // At each vertex, draw effectiveness circle (sized by relief value)
            for (i in 0 until n) {
                val a = Math.PI * 2 * i / n - Math.PI / 2
                val norm = (primary[i].value / maxV1).coerceIn(0f, 1f)
                val frac = if (primary[i].value > 0f && norm < 0.08f) 0.08f else norm
                val px = cx + (frac * rad * cos(a)).toFloat()
                val py = cy + (frac * rad * sin(a)).toFloat()

                // Effectiveness circle at this vertex
                if (i < secondary.size) {
                    val reliefVal = secondary[i].value
                    val maxRelief = secondary[i].maxValue ?: 3f
                    val reliefFrac = (reliefVal / maxRelief).coerceIn(0f, 1f)
                    if (reliefFrac > 0f) {
                        val maxCircleR = rad * 0.12f
                        val circleR = maxCircleR * reliefFrac
                        c.drawCircle(px, py, circleR, fp(secCol, 50))
                        c.drawCircle(px, py, circleR, sp(secCol, 1.5f, 100))
                    }
                }

                // Vertex dot
                c.drawCircle(px, py, 3.5f, fp(col))
                c.drawCircle(px, py, 1.5f, fp(Color.WHITE))
            }

            drawLabels(c, primary, n, cx, cy, rad, secondary)
        }
    }

    private fun drawGrid(c: Canvas, n: Int, cx: Float, cy: Float, rad: Float) {
        val g = sp(Color.WHITE, 0.5f, 20)
        // Circular grid rings
        for (ring in 1..4) {
            val rr = rad * ring / 4f
            c.drawCircle(cx, cy, rr, g)
        }
        // Axis lines from centre to each tip
        for (i in 0 until n) { val a = Math.PI * 2 * i / n - Math.PI / 2; c.drawLine(cx, cy, cx + (rad * cos(a)).toFloat(), cy + (rad * sin(a)).toFloat(), g) }
    }

    private fun drawFill(c: Canvas, axes: List<SpiderAxis>, cx: Float, cy: Float, rad: Float, maxV: Float, col: Int, fa: Int, sw: Float) {
        val n = axes.size; val fill = Path(); val stroke = Path()
        for (i in 0 until n) { val a = Math.PI * 2 * i / n - Math.PI / 2; val v = (axes[i].value / maxV).coerceIn(0f, 1f) * rad; val px = cx + (v * cos(a)).toFloat(); val py = cy + (v * sin(a)).toFloat(); if (i == 0) { fill.moveTo(px, py); stroke.moveTo(px, py) } else { fill.lineTo(px, py); stroke.lineTo(px, py) } }
        fill.close(); stroke.close(); c.drawPath(fill, fp(col, fa)); c.drawPath(stroke, sp(col, sw))
    }

    private fun drawLabels(c: Canvas, axes: List<SpiderAxis>, n: Int, cx: Float, cy: Float, rad: Float, secondAxes: List<SpiderAxis>? = null) {
        val fontSize = if (n > 8) 5.5f else if (n > 5) 6f else 7f
        val maxChars = if (n > 8) 16 else if (n > 5) 18 else 22
        val offset = if (n > 8) 12f else 16f
        val lp = tp(BODY, fontSize)
        lp.letterSpacing = 0.03f
        for (i in 0 until n) {
            val a = Math.PI * 2 * i / n - Math.PI / 2
            val lx = cx + ((rad + offset) * cos(a)).toFloat()
            val ly = cy + ((rad + offset) * sin(a)).toFloat()
            val align = when { cos(a) > 0.3 -> Paint.Align.LEFT; cos(a) < -0.3 -> Paint.Align.RIGHT; else -> Paint.Align.CENTER }
            lp.textAlign = align
            // Label with count: "Analgesic (2)"
            c.drawText("${cleanLabel(axes[i].label).take(maxChars)} (${axes[i].value.toInt()})", lx, ly + 3f, lp)

            // Relief effectiveness label below
            if (secondAxes != null && i < secondAxes.size) {
                val rv = secondAxes[i].value
                val rl = when { rv >= 2.5f -> "High"; rv >= 1.5f -> "Mild"; rv >= 0.5f -> "Low"; else -> "None" }
                val rc = when { rv >= 2.5f -> SM; rv >= 1.5f -> SMO; rv >= 0.5f -> SS; else -> Color.parseColor("#999999") }
                val rp = tp(rc, fontSize - 0.5f)
                rp.textAlign = align
                c.drawText(rl, lx, ly + 3f + fontSize + 2f, rp)
            }
        }
    }

    /** Clean up label text: add space after colons, underscores to spaces, capitalize */
    private fun cleanLabel(raw: String): String {
        return raw
            .replace("_", " ")
            .replace(":", ": ")
            .replace(":  ", ": ")  // avoid double space if already had space
            .replaceFirstChar { it.uppercase() }
    }

    private fun drawProportionalBar(axes: List<SpiderAxis>, col: Int, relief: List<SpiderAxis>? = null) {
        val total = axes.sumOf { it.value.toDouble() }.toFloat().coerceAtLeast(1f)
        val hasRelief = relief != null && relief.isNotEmpty()
        val h = if (hasRelief) 78f else 66f
        card(h) { c, l, t, r, _ ->
            axes.forEachIndexed { i, axis ->
                val ac = BAR_COLORS.getOrElse(i) { col }; val pct = (axis.value / total * 100).toInt()
                val x = if (i == 0) l else r; val align = if (i == 0) Paint.Align.LEFT else Paint.Align.RIGHT
                c.drawText(cleanLabel(axis.label), x, t + 12f, tp(ac, 10f, true, align))
                c.drawText("${axis.value.toInt()} ($pct%)", x, t + 24f, tp(SUBTLE, 8f, a = align))
                // Effectiveness badge under percentage
                if (hasRelief && i < relief!!.size) {
                    val rv = relief[i].value
                    val rl = when { rv >= 2.5f -> "High"; rv >= 1.5f -> "Mild"; rv >= 0.5f -> "Low"; else -> "None" }
                    val rc = when { rv >= 2.5f -> SM; rv >= 1.5f -> SMO; rv >= 0.5f -> SS; else -> Color.parseColor("#666666") }
                    val tw = tp(rc, 6.5f, true).measureText(rl) + 10f
                    val bx = if (i == 0) l else r - tw
                    c.drawRoundRect(RectF(bx, t + 28f, bx + tw, t + 40f), 3f, 3f, fp(rc, 40))
                    c.drawText(rl, bx + tw / 2f, t + 37f, tp(rc, 6.5f, true, Paint.Align.CENTER))
                }
            }
            val by = t + (if (hasRelief) 46f else 32f); var bx = l
            axes.forEachIndexed { i, axis -> val pw = (axis.value / total) * (r - l); c.drawRoundRect(RectF(bx, by, bx + pw, by + 10f), 5f, 5f, fp(BAR_COLORS.getOrElse(i) { col }, 200)); bx += pw }
        }
    }

    private fun drawStatCard(axis: SpiderAxis, col: Int, relief: SpiderAxis? = null) {
        val h = if (relief != null) 68f else 56f
        card(h) { c, l, t, r, _ ->
            val cx = (l + r) / 2f
            c.drawText("${axis.value.toInt()}", cx, t + 22f, tp(col, 24f, true, Paint.Align.CENTER))
            c.drawText(cleanLabel(axis.label), cx, t + 36f, tp(BODY, 10f, a = Paint.Align.CENTER))
            if (relief != null) {
                val rv = relief.value
                val rl = when { rv >= 2.5f -> "High"; rv >= 1.5f -> "Mild"; rv >= 0.5f -> "Low"; else -> "None" }
                val rc = when { rv >= 2.5f -> SM; rv >= 1.5f -> SMO; rv >= 0.5f -> SS; else -> Color.parseColor("#666666") }
                val tw = tp(rc, 7f, true).measureText(rl) + 10f
                c.drawRoundRect(RectF(cx - tw / 2f, t + 42f, cx + tw / 2f, t + 54f), 3f, 3f, fp(rc, 40))
                c.drawText(rl, cx, t + 51f, tp(rc, 7f, true, Paint.Align.CENTER))
            }
        }
    }

    // ═══════ Metrics ═══════
    private fun drawMetrics(d: ReportData) {
        heading("Health Metrics", Color.parseColor("#4DD0E1"))
        val zone = ZoneId.systemDefault()

        // Compute date range from filtered migraines (with padding for window)
        val migDates = d.filteredMigraines.map { mg ->
            val dateStr = mg.start.atZone(zone).toLocalDate().toString()
            Triple(dateStr, mg.severity ?: 0, mg)
        }
        val migLocalDates = d.filteredMigraines.map { it.start.atZone(zone).toLocalDate() }
        val rangeStart = migLocalDates.minOrNull()?.minusDays(7)?.toString()
        val rangeEnd = migLocalDates.maxOrNull()?.let { last ->
            d.filteredMigraines.find { it.start.atZone(zone).toLocalDate() == last }?.end
                ?.let { it.atZone(zone).toLocalDate().plusDays(7).toString() }
                ?: last.plusDays(7).toString()
        }

        d.enabledMetrics.forEach { series ->
            val allValues = d.allDailyMetrics[series.key] ?: return@forEach; if (allValues.isEmpty()) return@forEach
            // Filter to timeframe range
            val values = if (rangeStart != null && rangeEnd != null) {
                allValues.filter { it.date >= rangeStart && it.date <= rangeEnd }
            } else allValues
            if (values.isEmpty()) return@forEach
            val sorted = values.sortedBy { it.date }; val argb = cToA(series.color)
            card(110f) { c, l, t, r, b ->
                // Label line
                c.drawText("${series.label}  (${series.unit})", l, t + 12f, tp(ACCENT, 10f, true))
                if (series.key in d.autoMetricKeys) {
                    val aw = tp(PINK, 6f, true).measureText("AUTO") + 10f
                    val labelW = tp(ACCENT, 10f, true).measureText("${series.label}  (${series.unit})")
                    val ax = l + labelW + 10f
                    c.drawRoundRect(RectF(ax, t + 2f, ax + aw, t + 14f), 4f, 4f, fp(PINK, 30))
                    c.drawText("AUTO", ax + 5f, t + 11f, tp(PINK, 6f, true))
                }
                if (sorted.size < 2) { c.drawText("${sorted.firstOrNull()?.value ?: "N/A"}", l, t + 40f, tp(BODY, 11f)); return@card }
                val minV = sorted.minOf { it.value }; val maxV = sorted.maxOf { it.value }; val rng = if (maxV - minV < 0.001) 1.0 else maxV - minV
                val yAxisW = 30f // space for Y labels
                val cl2 = l + yAxisW; val ct = t + 24f; val cb = b - 18f; val cw = r - cl2; val ch = cb - ct

                // Date range for X mapping
                val firstDate = sorted.first().date; val lastDate = sorted.last().date
                val daySpan = java.time.temporal.ChronoUnit.DAYS.between(
                    java.time.LocalDate.parse(firstDate), java.time.LocalDate.parse(lastDate)
                ).toFloat().coerceAtLeast(1f)
                fun dateX(ds: String): Float {
                    val days = java.time.temporal.ChronoUnit.DAYS.between(
                        java.time.LocalDate.parse(firstDate), java.time.LocalDate.parse(ds)
                    ).toFloat()
                    return cl2 + (days / daySpan) * cw
                }
                fun valY(v: Double): Float = cb - ((v - minV) / rng).toFloat() * ch

                // Y-axis: 3 horizontal gridlines (min, mid, max)
                val gridP = sp(BORDER, 0.5f, 30)
                val yLabelP = tp(SUBTLE, 5.5f, a = Paint.Align.RIGHT)
                val midV = (minV + maxV) / 2.0
                listOf(maxV, midV, minV).forEach { v ->
                    val gy = valY(v)
                    c.drawLine(cl2, gy, r, gy, gridP)
                    c.drawText(String.format("%.1f", v), cl2 - 3f, gy + 3f, yLabelP)
                }

                // X-axis line
                c.drawLine(cl2, cb, r, cb, sp(BORDER, 0.5f, 50))

                // X-axis date labels — show ~4-5 evenly spaced
                val xDateFmt = DateTimeFormatter.ofPattern("dd MMM")
                val labelCount = 5.coerceAtMost(daySpan.toInt() + 1)
                val xLabelP = tp(SUBTLE, 5.5f, a = Paint.Align.CENTER)
                for (i in 0 until labelCount) {
                    val frac = if (labelCount <= 1) 0f else i.toFloat() / (labelCount - 1)
                    val daysOff = (frac * daySpan).toLong()
                    val ld = java.time.LocalDate.parse(firstDate).plusDays(daysOff)
                    val dx = cl2 + frac * cw
                    c.drawText(ld.format(xDateFmt), dx, cb + 10f, xLabelP)
                    // Small tick
                    c.drawLine(dx, cb, dx, cb + 3f, sp(BORDER, 0.5f, 50))
                }

                // Y-axis vertical line
                c.drawLine(cl2, ct, cl2, cb, sp(BORDER, 0.5f, 50))

                // Draw migraine markers (behind the line)
                val dashP = Paint().apply {
                    color = PINK; alpha = 100; style = Paint.Style.STROKE; strokeWidth = 1f; isAntiAlias = true
                    pathEffect = DashPathEffect(floatArrayOf(4f, 3f), 0f)
                }
                val sevP = tp(PINK, 6f, true, Paint.Align.CENTER)
                for ((mDate, sev, _) in migDates) {
                    val daysFromStart = java.time.temporal.ChronoUnit.DAYS.between(
                        java.time.LocalDate.parse(firstDate), java.time.LocalDate.parse(mDate)
                    ).toFloat()
                    if (daysFromStart < 0 || daysFromStart > daySpan) continue
                    val mx = cl2 + (daysFromStart / daySpan) * cw
                    val dashPath = Path(); dashPath.moveTo(mx, ct); dashPath.lineTo(mx, cb)
                    c.drawPath(dashPath, dashP)
                    if (sev > 0) {
                        c.drawRoundRect(RectF(mx - 7f, ct - 8f, mx + 7f, ct), 3f, 3f, fp(PINK, 60))
                        c.drawText("$sev", mx, ct - 1.5f, sevP)
                    }
                }

                // Sparkline using date-based X
                val path = Path()
                sorted.forEachIndexed { i, dv ->
                    val x = dateX(dv.date); val py = valY(dv.value)
                    if (i == 0) path.moveTo(x, py) else path.lineTo(x, py)
                }
                c.drawPath(path, sp(argb, 1.5f))
                // Data points
                sorted.forEach { dv -> c.drawCircle(dateX(dv.date), valY(dv.value).toFloat(), 1.5f, fp(argb)) }

                // Avg line
                val avg = sorted.map { it.value }.average()
                val avgY = valY(avg)
                val avgDashP = Paint().apply {
                    color = argb; alpha = 60; style = Paint.Style.STROKE; strokeWidth = 0.5f; isAntiAlias = true
                    pathEffect = DashPathEffect(floatArrayOf(3f, 3f), 0f)
                }
                val avgPath = Path(); avgPath.moveTo(cl2, avgY); avgPath.lineTo(r, avgY)
                c.drawPath(avgPath, avgDashP)
                c.drawText("Avg: ${String.format("%.1f", avg)}", l, cb + 10f, tp(SUBTLE, 5.5f))
            }
        }
    }

    // ═══════ Timelines ═══════
    private fun drawTimelines(d: ReportData) {
        heading("Migraine Timelines", ACCENT)
        val fmt = DateTimeFormatter.ofPattern("dd MMM yyyy  HH:mm")
        val contentWidth = PW - 2 * M

        for (cap in d.timelineCaptures) {
            val mg = cap.migraine
            val dateStr = mg.start.atZone(ZoneId.systemDefault()).format(fmt)
            val sevStr = mg.severity?.let { "Severity $it" } ?: ""
            val durStr = mg.end?.let {
                val h = (it.toEpochMilli() - mg.start.toEpochMilli()) / 3600000.0
                String.format("%.1fh", h)
            } ?: "ongoing"
            subHead("$dateStr  ·  $sevStr  ·  $durStr", ACCENT)

            // Auto-detected metrics graph + legend
            drawTimelineBitmap(cap.autoBitmap, contentWidth, "Auto-detected Metrics")
            drawMetricLegend(cap.autoMetricNames)
            drawEventLegend(cap.events)

            // Full overlay graph + legend (only if different)
            if (cap.fullBitmap !== cap.autoBitmap) {
                drawTimelineBitmap(cap.fullBitmap, contentWidth, "All Metrics Overlay")
                drawMetricLegend(cap.fullMetricNames)
            }
        }
    }

    private fun drawTimelineBitmap(bmp: Bitmap, contentWidth: Float, label: String) {
        val scale = contentWidth / bmp.width.toFloat()
        val scaledH = bmp.height * scale
        need(scaledH + 28f)
        val c = cv ?: return
        c.drawText(label, M + 4f, y + 10f, tp(SUBTLE, 7.5f, b = true))
        y += 14f
        val src = Rect(0, 0, bmp.width, bmp.height)
        val dst = RectF(M, y, M + contentWidth, y + scaledH)
        c.drawRoundRect(RectF(M - 2f, y - 2f, M + contentWidth + 2f, y + scaledH + 2f), 8f, 8f, sp(BORDER, 0.8f, 50))
        c.drawBitmap(bmp, src, dst, Paint().apply { isFilterBitmap = true; isAntiAlias = true })
        y += scaledH + 8f
    }

    /** Draw metric line legend — colored line + label */
    private fun drawMetricLegend(metrics: List<LegendMetric>) {
        if (metrics.isEmpty()) return
        val cols = 3
        val colW = (PW - 2 * M) / cols
        val rows = (metrics.size + cols - 1) / cols
        val rowH = 12f
        need(rows * rowH + 8f)
        val c = cv ?: return

        metrics.forEachIndexed { i, m ->
            val col = i % cols
            val row = i / cols
            val x = M + col * colW
            val ly = y + row * rowH

            // Colored line
            c.drawLine(x, ly + 5f, x + 16f, ly + 5f, sp(m.color, 2f))
            // Diamond point
            c.drawCircle(x + 8f, ly + 5f, 2.5f, fp(m.color))
            // Label
            c.drawText("${m.name} (${m.unit})", x + 20f, ly + 8f, tp(BODY, 6.5f))
        }
        y += rows * rowH + 6f
    }

    /** Draw event legend — colored dot per category + numbered item names matching graph */
    private fun drawEventLegend(events: List<LegendEvent>) {
        if (events.isEmpty()) return
        val byCat = events.groupBy { it.category }
        val c = cv ?: return

        for ((cat, items) in byCat) {
            val catColor = items.first().color

            need(22f)
            // Category dot + name
            c.drawCircle(M + 6f, y + 5f, 3.5f, fp(catColor))
            c.drawText("$cat:", M + 14f, y + 8f, tp(catColor, 7f, b = true))

            // Numbered items matching graph dot numbers
            val textP = tp(BODY, 6.5f)
            val maxW = PW - 2 * M - 20f
            val itemTexts = items.map { "#${it.index} ${it.name}" }
            val joined = itemTexts.joinToString("  ·  ")
            val measured = textP.measureText(joined)

            if (measured <= maxW) {
                y += 11f
                c.drawText(joined, M + 18f, y + 7f, textP)
                y += 10f
            } else {
                // Wrap into lines
                val remaining = itemTexts.toMutableList()
                while (remaining.isNotEmpty()) {
                    var line = remaining.removeFirst()
                    while (remaining.isNotEmpty() && textP.measureText("$line  ·  ${remaining.first()}") <= maxW) {
                        line += "  ·  ${remaining.removeFirst()}"
                    }
                    y += 10f; need(10f)
                    c.drawText(line, M + 18f, y + 7f, textP)
                }
                y += 4f
            }
        }
        y += 4f
    }

    // ═══════ Log (compact, on cover page) ═══════
    private fun drawLogCompact(d: ReportData) {
        val m = d.filteredMigraines; if (m.isEmpty()) return
        subHead("Migraine Log (${m.size})", PINK)
        val fmt = DateTimeFormatter.ofPattern("dd MMM yy  HH:mm")
        card(28f) { c, l, t, r, _ ->
            c.drawText("Date", l, t + 9f, tp(ACCENT, 7f, true))
            c.drawText("Sev", l + (r - l) * 0.40f, t + 9f, tp(ACCENT, 7f, true))
            c.drawText("Duration", l + (r - l) * 0.48f, t + 9f, tp(ACCENT, 7f, true))
            c.drawText("Type", l + (r - l) * 0.65f, t + 9f, tp(ACCENT, 7f, true))
        }
        m.forEach { mg ->
            card(26f) { c, l, t, r, _ ->
                c.drawText(mg.start.atZone(ZoneId.systemDefault()).format(fmt), l, t + 9f, tp(BODY, 7f))
                val sc = when { (mg.severity ?: 0) <= 3 -> SM; (mg.severity ?: 0) <= 6 -> SMO; else -> SS }
                c.drawText(mg.severity?.toString() ?: "–", l + (r - l) * 0.42f, t + 9f, tp(sc, 7.5f, true))
                c.drawText(mg.end?.let { String.format("%.1fh", (it.toEpochMilli() - mg.start.toEpochMilli()) / 3600000.0) } ?: "ongoing", l + (r - l) * 0.48f, t + 9f, tp(BODY, 7f))
                c.drawText(mg.label?.take(30) ?: "–", l + (r - l) * 0.65f, t + 9f, tp(BODY, 6.5f))
            }
        }
    }

    // ═══════ Log (full, kept for reference) ═══════
    private fun drawLog(d: ReportData) {
        val m = d.filteredMigraines; if (m.isEmpty()) return; heading("Migraine Log (${m.size})", PINK)
        val fmt = DateTimeFormatter.ofPattern("dd MMM yy  HH:mm")
        card(32f) { c, l, t, r, _ ->
            c.drawText("Date", l, t + 10f, tp(ACCENT, 8f, true))
            c.drawText("Sev", l + (r - l) * 0.38f, t + 10f, tp(ACCENT, 8f, true))
            c.drawText("Duration", l + (r - l) * 0.48f, t + 10f, tp(ACCENT, 8f, true))
            c.drawText("Type", l + (r - l) * 0.65f, t + 10f, tp(ACCENT, 8f, true))
        }
        m.forEach { mg ->
            card(30f) { c, l, t, r, _ ->
                c.drawText(mg.start.atZone(ZoneId.systemDefault()).format(fmt), l, t + 10f, tp(BODY, 7.5f))
                val sc = when { (mg.severity ?: 0) <= 3 -> SM; (mg.severity ?: 0) <= 6 -> SMO; else -> SS }
                c.drawText(mg.severity?.toString() ?: "–", l + (r - l) * 0.40f, t + 10f, tp(sc, 8f, true))
                c.drawText(mg.end?.let { String.format("%.1fh", (it.toEpochMilli() - mg.start.toEpochMilli()) / 3600000.0) } ?: "ongoing", l + (r - l) * 0.48f, t + 10f, tp(BODY, 7.5f))
                c.drawText(mg.label?.take(30) ?: "–", l + (r - l) * 0.65f, t + 10f, tp(BODY, 7f))
            }
        }
    }

    private fun cToA(c: androidx.compose.ui.graphics.Color): Int = Color.argb((c.alpha * 255).toInt(), (c.red * 255).toInt(), (c.green * 255).toInt(), (c.blue * 255).toInt())
}

title: ReviewLogScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun ReviewLogScreen(navController: NavHostController, authVm: AuthViewModel, vm: LogViewModel, onClose: () -> Unit = {}) {
    val authState by authVm.state.collectAsState()
    val draft by vm.draft.collectAsState()
    val scrollState = rememberScrollState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Notes", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Review Log", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawReviewCheck(AppTheme.AccentPurple) } }
                )
                Text("Review Log", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    "Review your entries before saving",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // Migraine
            draft.migraine?.let { m ->
                ReviewSection(drawIcon = { HubIcons.run { drawMigraineStarburst(it) } }, title = "Migraine", iconTint = AppTheme.AccentPink) {
                    if (m.symptoms.isNotEmpty()) {
                        Text("Symptoms", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                        Text(
                            m.symptoms.joinToString(" • "),
                            color = AppTheme.BodyTextColor,
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                    ReviewRow("Severity", m.severity?.toString() ?: "-")
                    ReviewRow("Start", formatIsoDdMmYyHm(m.beganAtIso))
                    ReviewRow("End", formatIsoDdMmYyHm(m.endedAtIso))
                    if (!m.note.isNullOrBlank()) ReviewRow("Note", m.note)
                }
            }

            // Pain Locations
            if (draft.painLocations.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawMigraineStarburst(it) } }, title = "Pain Locations (${draft.painLocations.size})", iconTint = AppTheme.AccentPink) {
                    val labels = draft.painLocations.mapNotNull { ALL_PAIN_POINTS_MAP[it] }
                    Text(
                        labels.joinToString(" • "),
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }

            // Triggers
            if (draft.triggers.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawTriggerBolt(it) } }, title = "Triggers (${draft.triggers.size})", iconTint = Color(0xFFFFB74D)) {
                    draft.triggers.forEach { t ->
                        ReviewRow(t.type, formatIsoDdMmYyHm(t.startAtIso))
                    }
                }
            }

            // Medicines
            if (draft.meds.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawMedicinePill(it) } }, title = "Medicines (${draft.meds.size})", iconTint = Color(0xFF4FC3F7)) {
                    draft.meds.forEach { m ->
                        ReviewRow(m.name ?: "?", "${m.amount ?: "-"} · ${formatIsoDdMmYyHm(m.startAtIso)}")
                    }
                }
            }

            // Reliefs
            if (draft.rels.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawReliefLeaf(it) } }, title = "Reliefs (${draft.rels.size})", iconTint = Color(0xFF81C784)) {
                    draft.rels.forEach { r ->
                        ReviewRow(r.type, "${formatIsoDdMmYyHm(r.startAtIso)}${if (r.endAtIso != null) " → ${formatIsoDdMmYyHm(r.endAtIso)}" else ""}")
                    }
                }
            }

            // Locations
            if (draft.locations.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawLocationPin(it) } }, title = "Locations (${draft.locations.size})", iconTint = Color(0xFF64B5F6)) {
                    draft.locations.forEach { loc ->
                        ReviewRow(loc.type, formatIsoDdMmYyHm(loc.startAtIso))
                    }
                }
            }

            // Activities
            if (draft.activities.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawActivityPulse(it) } }, title = "Activities (${draft.activities.size})", iconTint = Color(0xFFFF8A65)) {
                    draft.activities.forEach { act ->
                        ReviewRow(act.type, formatIsoDdMmYyHm(act.startAtIso))
                    }
                }
            }

            // Missed Activities
            if (draft.missedActivities.isNotEmpty()) {
                ReviewSection(drawIcon = { HubIcons.run { drawMissedActivity(it) } }, title = "Missed (${draft.missedActivities.size})", iconTint = Color(0xFFEF9A9A)) {
                    draft.missedActivities.forEach { ma ->
                        ReviewRow(ma.type, formatIsoDdMmYyHm(ma.startAtIso))
                    }
                }
            }

            // Empty state
            if (draft.migraine == null && draft.triggers.isEmpty() && draft.meds.isEmpty() && draft.rels.isEmpty() && draft.locations.isEmpty() && draft.activities.isEmpty() && draft.missedActivities.isEmpty()) {
                BaseCard {
                    Text("Nothing to review yet", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
                }
            }

            // Save
            Button(
                onClick = {
                    val token = authState.accessToken ?: return@Button
                    val migraine = draft.migraine
                    val editId = vm.editMigraineId.value ?: draft.editMigraineId
                    println("DEBUG ReviewLogScreen Save: editMigraineId.value=${vm.editMigraineId.value}, draft.editMigraineId=${draft.editMigraineId}, resolved editId=$editId")
                    if (migraine != null) {
                        if (editId != null) {
                            vm.updateFull(
                                accessToken = token,
                                migraineId = editId,
                                type = migraine.type,
                                severity = migraine.severity,
                                beganAtIso = migraine.beganAtIso ?: "",
                                endedAtIso = migraine.endedAtIso,
                                note = migraine.note,
                                meds = draft.meds,
                                rels = draft.rels,
                                painLocations = draft.painLocations
                            )
                        } else {
                            vm.addFull(
                                accessToken = token,
                                type = migraine.type,
                                severity = migraine.severity,
                                beganAtIso = migraine.beganAtIso ?: "",
                                endedAtIso = migraine.endedAtIso,
                                note = migraine.note,
                                meds = draft.meds,
                                rels = draft.rels,
                                painLocations = draft.painLocations
                            )
                        }
                    }
                    vm.clearDraft()
                    navController.popBackStack(Routes.JOURNAL, inclusive = false)
                },
                modifier = Modifier.fillMaxWidth().height(52.dp),
                colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple),
                shape = AppTheme.BaseCardShape
            ) {
                val editId by vm.editMigraineId.collectAsState()
                val isEdit = editId != null || draft.editMigraineId != null
                Text(if (isEdit) "Update Log" else "Save Log", style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
            }

            // Back
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Start) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

@Composable
private fun ReviewSection(
    drawIcon: DrawScope.(Color) -> Unit,
    title: String,
    iconTint: Color,
    content: @Composable ColumnScope.() -> Unit
) {
    BaseCard {
        Row(verticalAlignment = Alignment.CenterVertically) {
            Box(
                modifier = Modifier
                    .size(20.dp)
                    .drawBehind { drawIcon(iconTint) }
            )
            Spacer(Modifier.width(8.dp))
            Text(title, color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
        }
        content()
    }
}

@Composable
private fun ReviewRow(label: String, value: String) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
        Text(value, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium)
    }
}

private fun formatIsoDdMmYyHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "-"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) { "-" }
}


title: RiskColors.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color

/**
 * Color scheme for food risk metrics (tyramine, alcohol, gluten).
 * Light → dark intensity maps to low → high risk.
 * Designed for dark purple background.
 */
object RiskColors {
    // Tyramine — warm reds
    val TyramineHigh = Color(0xFFEF5350)
    val TyramineMedium = Color(0xFFEF9A9A)
    val TyramineLow = Color(0xFFFFCDD2)

    // Alcohol — ambers/oranges
    val AlcoholHigh = Color(0xFFFF8F00)
    val AlcoholMedium = Color(0xFFFFB74D)
    val AlcoholLow = Color(0xFFFFE0B2)

    // Gluten — blues
    val GlutenHigh = Color(0xFF1E88E5)
    val GlutenMedium = Color(0xFF64B5F6)
    val GlutenLow = Color(0xFFBBDEFB)

    /** Get the color for a risk metric at a given level (0-3) */
    fun colorFor(metric: String, level: Int): Color = when (metric) {
        MonitorCardConfig.METRIC_TYRAMINE_EXPOSURE -> when (level) {
            3 -> TyramineHigh; 2 -> TyramineMedium; 1 -> TyramineLow; else -> Color.Unspecified
        }
        MonitorCardConfig.METRIC_ALCOHOL_EXPOSURE -> when (level) {
            3 -> AlcoholHigh; 2 -> AlcoholMedium; 1 -> AlcoholLow; else -> Color.Unspecified
        }
        MonitorCardConfig.METRIC_GLUTEN_EXPOSURE -> when (level) {
            3 -> GlutenHigh; 2 -> GlutenMedium; 1 -> GlutenLow; else -> Color.Unspecified
        }
        else -> Color.Unspecified
    }

    /** Format a risk level (0-3) to display text + color */
    fun formatRiskLevel(metric: String, level: Int): Pair<String, Color> {
        val label = when (level) { 3 -> "High"; 2 -> "Medium"; 1 -> "Low"; else -> "None" }
        val color = colorFor(metric, level).takeIf { it != Color.Unspecified } ?: AppTheme.SubtleTextColor
        return label to color
    }
}

title: RiskDetailScreen.kt
text:
package com.migraineme

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.FastOutSlowInEasing
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.lerp
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import kotlin.math.cos
import kotlin.math.sin

@Composable
fun RiskDetailScreen(
    navController: NavController,
    state: HomeUiState
) {
    val scrollState = rememberScrollState()

    var selectedDay by remember { mutableStateOf(0) }
    val dayData = if (selectedDay in state.dayRisks.indices) state.dayRisks[selectedDay] else null
    val displayScore = dayData?.score ?: state.riskScore
    val displayZone = dayData?.zone ?: state.riskZone
    val displayPercent = dayData?.percent ?: state.riskPercent
    val displayTriggers = dayData?.topTriggers ?: state.triggersAtRisk
    val displayRecommendation = state.aiRecommendation

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {

            // Back button
            Button(
                onClick = { navController.popBackStack() },
                colors = ButtonDefaults.buttonColors(containerColor = Color.White.copy(alpha = 0.08f)),
                contentPadding = PaddingValues(horizontal = 16.dp, vertical = 6.dp)
            ) {
                Text("\u2190 Back", color = Color.White, style = MaterialTheme.typography.labelLarge)
            }

            // Gauge + forecast — exact same as HomeScreen
            DetailHeroCard(
                riskPercent = displayPercent,
                riskScore = displayScore,
                riskZone = displayZone,
                forecast = state.forecast,
                selectedDay = selectedDay,
                dayRisks = state.dayRisks,
                onDaySelected = { selectedDay = it }
            )

            // ALL triggers — not limited to 3
            DetailTriggersCard(
                triggers = displayTriggers,
                gaugeMax = state.gaugeMaxScore
            )

            // Recommendation
            DetailRecoCard(recommendation = displayRecommendation)
        }
    }
}

// Below: exact copies of HomeScreen composables, renamed to avoid conflict.

@Composable
private fun DetailHeroCard(
    riskPercent: Int,
    riskScore: Double = 0.0,
    riskZone: RiskZone = RiskZone.NONE,
    forecast: List<Int> = listOf(0, 0, 0, 0, 0, 0, 0),
    selectedDay: Int = 0,
    dayRisks: List<DayRisk> = emptyList(),
    onDaySelected: (Int) -> Unit = {},
    modifier: Modifier = Modifier
) {
    val clamped = riskPercent.coerceIn(0, 100)

    val zoneColor = when (riskZone) {
        RiskZone.HIGH -> Color(0xFFE57373)
        RiskZone.MILD -> Color(0xFFFFB74D)
        RiskZone.LOW -> Color(0xFF81C784)
        RiskZone.NONE -> AppTheme.SubtleTextColor
    }

    // Day label for selected day
    val dayLabel = if (selectedDay == 0) "Risk today" else {
        val date = dayRisks.getOrNull(selectedDay)?.date
        if (date != null) "Risk · ${date.format(java.time.format.DateTimeFormatter.ofPattern("EEE d MMM"))}"
        else "Risk"
    }

    HeroCard(modifier = modifier) {
        Text(
            dayLabel,
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        DetailGauge(
            percent = clamped,
            diameter = 220.dp,
            stroke = 16.dp,
            trackColor = AppTheme.TrackColor,
            progressColor = AppTheme.AccentPurple
        )

        // Score display
        Text(
            "%.1f".format(riskScore),
            color = Color.White,
            style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold)
        )

        // Zone label
        Text(
            riskZone.label,
            color = zoneColor,
            style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        DetailOutlook(
            values = forecast,
            selectedDay = selectedDay,
            dayRisks = dayRisks,
            onDaySelected = onDaySelected
        )
    }
}

@Composable
private fun DetailOutlook(
    values: List<Int>,
    selectedDay: Int = 0,
    dayRisks: List<DayRisk> = emptyList(),
    onDaySelected: (Int) -> Unit = {},
    modifier: Modifier = Modifier
) {
    val zone = ZoneId.systemDefault()
    val today = LocalDate.now(zone)
    val dayFmt = DateTimeFormatter.ofPattern("EEE")

    Column(
        modifier = modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(6.dp),
        horizontalAlignment = Alignment.Start
    ) {
        Text(
            "7-day forecast",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            for (i in 0 until 7) {
                val percent = values.getOrNull(i)?.coerceIn(0, 100) ?: 0
                val date = today.plusDays(i.toLong())
                val dayLabel = if (i == 0) "Today" else date.format(dayFmt)
                val isSelected = i == selectedDay

                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(2.dp),
                    modifier = Modifier.clickable { onDaySelected(i) }
                ) {
                    Box(contentAlignment = Alignment.Center) {
                        if (isSelected) {
                            Box(
                                modifier = Modifier
                                    .size(42.dp)
                                    .background(
                                        color = AppTheme.AccentPurple.copy(alpha = 0.25f),
                                        shape = CircleShape
                                    )
                            )
                        }
                        DetailMini(
                            percent = percent,
                            size = 36.dp,
                            strokeWidth = 3.5.dp
                        )
                    }
                    Text(
                        dayLabel,
                        color = if (isSelected) AppTheme.AccentPurple else if (i == 0) Color.White else AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall.copy(
                            fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal
                        )
                    )
                }
            }
        }
    }
}

@Composable
private fun DetailMini(
    percent: Int,
    size: Dp,
    strokeWidth: Dp
) {
    val clamped = percent.coerceIn(0, 100)
    val p = clamped / 100f

    val progressColor = lerp(AppTheme.AccentPurple, AppTheme.AccentPink, p)

    Box(
        modifier = Modifier.width(size).height(size * 0.62f),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val sw = strokeWidth.toPx()
            val radius = (minOf(this.size.width, this.size.height * 2f) / 2f) - sw
            val cx = this.size.width / 2f; val cy = this.size.height
            drawArc(AppTheme.TrackColor, 180f, 180f, false,
                Offset(cx - radius, cy - radius), Size(radius * 2f, radius * 2f),
                style = Stroke(sw * 0.7f, cap = StrokeCap.Round))
            if (p > 0f) {
                drawArc(progressColor, 180f, 180f * p, false,
                    Offset(cx - radius, cy - radius), Size(radius * 2f, radius * 2f),
                    style = Stroke(sw, cap = StrokeCap.Round))
            }
        }
    }
}

@Composable
private fun DetailTriggersCard(
    triggers: List<TriggerScore>,
    gaugeMax: Double = 10.0
) {
    if (triggers.isEmpty()) return

    BaseCard {
        Text(
            "All contributors",
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        Spacer(Modifier.height(8.dp))

        triggers.forEach { t ->
            val sevColor = when (t.severity.uppercase()) {
                "HIGH" -> Color(0xFFE57373)
                "MILD" -> Color(0xFFFFB74D)
                else -> Color(0xFF81C784)
            }
            val sevBg = sevColor.copy(alpha = 0.12f)
            val totalPts = triggers.sumOf { it.score }.coerceAtLeast(1)
            val pctOfTotal = (t.score * 100) / totalPts
            val barFraction = (t.score.toFloat() / gaugeMax.toFloat()).coerceIn(0f, 1f)

            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 4.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier
                        .size(6.dp)
                        .background(sevColor, CircleShape)
                )

                Column(
                    modifier = Modifier
                        .weight(1f)
                        .padding(horizontal = 12.dp, vertical = 8.dp),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    // Top row: name + severity chip
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            t.name,
                            color = Color.White,
                            style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium),
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis,
                            modifier = Modifier.weight(1f)
                        )

                        Spacer(Modifier.width(8.dp))

                        Box(
                            modifier = Modifier
                                .background(
                                    color = sevBg,
                                    shape = RoundedCornerShape(12.dp)
                                )
                                .padding(horizontal = 8.dp, vertical = 2.dp)
                        ) {
                            Text(
                                t.severity,
                                color = sevColor,
                                style = MaterialTheme.typography.labelSmall.copy(fontWeight = FontWeight.Bold)
                            )
                        }
                    }

                    // Progress bar
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(4.dp)
                            .background(
                                color = AppTheme.TrackColor,
                                shape = RoundedCornerShape(2.dp)
                            )
                    ) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth(barFraction)
                                .height(4.dp)
                                .background(
                                    color = sevColor,
                                    shape = RoundedCornerShape(2.dp)
                                )
                        )
                    }

                    // Bottom row: points + days active
                    Text(
                        "${pctOfTotal}% of risk · ${t.score} pts · ${if (t.daysActive == 1) "today only" else "${t.daysActive} days active"}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            }
        }
    }
}

@Composable
private fun DetailRecoCard(recommendation: String) {
    BaseCard {
        Text(
            "Recommendation",
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )
        Text(
            recommendation.ifBlank { "—" },
            color = AppTheme.BodyTextColor
        )
    }
}

@Composable
private fun DetailGauge(
    percent: Int,
    diameter: Dp,
    stroke: Dp,
    trackColor: Color,
    progressColor: Color
) {
    val clamped = percent.coerceIn(0, 100)

    val anim = remember { Animatable(0f) }
    LaunchedEffect(clamped) {
        anim.animateTo(
            targetValue = clamped.toFloat(),
            animationSpec = tween(durationMillis = 900, easing = FastOutSlowInEasing)
        )
    }
    val p = (anim.value / 100f).coerceIn(0f, 1f)

    val progressStroke = stroke
    val trackStroke = (stroke.value * 0.72f).dp

    val width = diameter
    val height = diameter * 0.62f

    Box(
        modifier = Modifier.width(width).height(height),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val radius = (minOf(size.width, size.height * 2f) / 2f) - progressStroke.toPx()
            val cx = size.width / 2f
            val cy = size.height

            val startAngle = 180f
            val fullSweep = 180f
            val sweep = fullSweep * p

            drawArc(
                color = trackColor,
                startAngle = startAngle,
                sweepAngle = fullSweep,
                useCenter = false,
                topLeft = Offset(cx - radius, cy - radius),
                size = Size(radius * 2f, radius * 2f),
                style = Stroke(width = trackStroke.toPx(), cap = StrokeCap.Round)
            )

            val tickCount = 11
            val tickOuter = radius + trackStroke.toPx() * 0.10f
            val tickInner = radius - trackStroke.toPx() * 0.55f
            for (i in 0 until tickCount) {
                val a = startAngle + (fullSweep / (tickCount - 1)) * i
                val rad = Math.toRadians(a.toDouble())
                val ox = cx + cos(rad).toFloat() * tickOuter
                val oy = cy + sin(rad).toFloat() * tickOuter
                val ix = cx + cos(rad).toFloat() * tickInner
                val iy = cy + sin(rad).toFloat() * tickInner
                drawLine(
                    color = Color.White.copy(alpha = 0.14f),
                    start = Offset(ix, iy),
                    end = Offset(ox, oy),
                    strokeWidth = 2.dp.toPx(),
                    cap = StrokeCap.Round
                )
            }

            drawArc(
                color = progressColor.copy(alpha = 0.22f),
                startAngle = startAngle,
                sweepAngle = sweep,
                useCenter = false,
                topLeft = Offset(cx - radius, cy - radius),
                size = Size(radius * 2f, radius * 2f),
                style = Stroke(width = (progressStroke.toPx() * 1.75f), cap = StrokeCap.Round)
            )

            val segs = 42
            val segSweep = sweep / segs
            for (j in 0 until segs) {
                val t = if (segs == 1) 1f else j / (segs - 1f)
                val c = lerp(AppTheme.AccentPurple, AppTheme.AccentPink, t)
                val sa = startAngle + segSweep * j
                drawArc(
                    color = c,
                    startAngle = sa,
                    sweepAngle = segSweep.coerceAtLeast(0f),
                    useCenter = false,
                    topLeft = Offset(cx - radius, cy - radius),
                    size = Size(radius * 2f, radius * 2f),
                    style = Stroke(width = progressStroke.toPx(), cap = StrokeCap.Round)
                )
            }

            val endAngle = startAngle + sweep
            val endRad = Math.toRadians(endAngle.toDouble())
            val ex = cx + cos(endRad).toFloat() * radius
            val ey = cy + sin(endRad).toFloat() * radius
            drawCircle(
                color = Color.White.copy(alpha = 0.90f),
                radius = (progressStroke.toPx() * 0.42f),
                center = Offset(ex, ey)
            )
            drawCircle(
                color = AppTheme.AccentPink.copy(alpha = 0.95f),
                radius = (progressStroke.toPx() * 0.30f),
                center = Offset(ex, ey)
            )
        }
    }
}


title: RiskIcons.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.CornerRadius
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

/**
 * Geometric cheese wedge — triangle with holes. Represents tyramine.
 */
@Composable
fun CheeseIcon(color: Color, size: Dp = 13.dp) {
    Canvas(modifier = Modifier.size(size)) {
        val w = this.size.width
        val h = this.size.height
        val holeBg = Color(0xFF1E0A2E)
        val triangle = Path().apply {
            moveTo(w * 0.0625f, h * 0.8125f)
            lineTo(w * 0.5f, h * 0.125f)
            lineTo(w * 0.9375f, h * 0.8125f)
            close()
        }
        drawPath(triangle, color)
        drawCircle(holeBg, radius = w * 0.08f, center = Offset(w * 0.4375f, h * 0.5625f))
        drawCircle(holeBg, radius = w * 0.0625f, center = Offset(w * 0.6563f, h * 0.7188f))
    }
}

/**
 * Geometric wine glass — goblet silhouette. Represents alcohol.
 */
@Composable
fun WineGlassIcon(color: Color, size: Dp = 13.dp) {
    Canvas(modifier = Modifier.size(size)) {
        val w = this.size.width
        val h = this.size.height
        // Bowl
        val bowl = Path().apply {
            moveTo(w * 0.2813f, h * 0.0938f)
            lineTo(w * 0.7188f, h * 0.0938f)
            lineTo(w * 0.5938f, h * 0.4688f)
            quadraticBezierTo(w * 0.5f, h * 0.5625f, w * 0.4063f, h * 0.4688f)
            close()
        }
        drawPath(bowl, color)
        // Stem
        drawRect(color, topLeft = Offset(w * 0.4375f, h * 0.5313f), size = Size(w * 0.125f, h * 0.2188f))
        // Base
        drawRoundRect(
            color,
            topLeft = Offset(w * 0.3125f, h * 0.7813f),
            size = Size(w * 0.375f, h * 0.0938f),
            cornerRadius = CornerRadius(w * 0.05f)
        )
    }
}

/**
 * Geometric wheat stalk — stem with grain kernels. Represents gluten.
 */
@Composable
fun WheatIcon(color: Color, size: Dp = 13.dp) {
    Canvas(modifier = Modifier.size(size)) {
        val w = this.size.width
        val h = this.size.height
        // Main stem
        drawLine(color, Offset(w * 0.5f, h * 0.1875f), Offset(w * 0.5f, h * 0.9063f), strokeWidth = w * 0.075f)
        // Grain kernels — ellipses on each side
        val kernelYs = listOf(0.2188f, 0.375f, 0.5313f)
        kernelYs.forEach { yFrac ->
            val cy = h * yFrac
            // Left kernel
            drawOval(color, topLeft = Offset(w * 0.12f, cy - h * 0.045f), size = Size(w * 0.32f, h * 0.09f))
            // Right kernel
            drawOval(color, topLeft = Offset(w * 0.56f, cy - h * 0.045f), size = Size(w * 0.32f, h * 0.09f))
        }
    }
}

/**
 * Vertical risk bar — height indicates level.
 */
@Composable
fun RiskBar(color: Color, level: String, maxHeight: Dp = 12.dp) {
    val fraction = when (level) {
        "high" -> 1f
        "medium" -> 0.67f
        "low" -> 0.33f
        else -> 0f
    }
    if (fraction > 0f) {
        val barHeight = maxHeight * fraction
        Canvas(modifier = Modifier.width(3.dp).height(barHeight)) {
            drawRoundRect(color, cornerRadius = CornerRadius(this.size.width / 2f))
        }
    }
}

/**
 * Combined icon + vertical bar badge for search results.
 * Shows nothing if level is "none".
 */
@Composable
fun TyramineRiskBadge(color: Color, level: String) {
    if (level == "none") return
    Row(verticalAlignment = Alignment.Bottom) {
        Spacer(Modifier.width(5.dp))
        CheeseIcon(color, 13.dp)
        Spacer(Modifier.width(1.dp))
        RiskBar(color, level)
    }
}

@Composable
fun AlcoholRiskBadge(color: Color, level: String) {
    if (level == "none") return
    Row(verticalAlignment = Alignment.Bottom) {
        Spacer(Modifier.width(5.dp))
        WineGlassIcon(color, 13.dp)
        Spacer(Modifier.width(1.dp))
        RiskBar(color, level)
    }
}

@Composable
fun GlutenRiskBadge(color: Color, level: String) {
    if (level == "none") return
    Row(verticalAlignment = Alignment.Bottom) {
        Spacer(Modifier.width(5.dp))
        WheatIcon(color, 13.dp)
        Spacer(Modifier.width(1.dp))
        RiskBar(color, level)
    }
}

title: RiskWeightsScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Risk Model Settings Screen
 *
 * Two sections:
 *
 * 1. Gauge Thresholds — the score boundaries that define gauge zones:
 *      None=0, Low=3, Mild=5, High=10
 *    "If my total score is ≥ X, I'm in zone Y"
 *
 * 2. Decay Weights — how much each trigger/prodrome severity contributes
 *    per day (today through +6 days):
 *      HIGH  | 10 | 5 | 2.5 | 0 | 0 | 0 | 0
 *      MILD  |  6 | 3 | 1.5 | 0 | 0 | 0 | 0
 *      LOW   |  3 | 1.5 | 0 | 0 | 0 | 0 | 0
 */
@Composable
fun RiskWeightsScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val edge = remember { EdgeFunctionsService() }
    val scrollState = rememberScrollState()

    // ── Loading / saving state ──
    var loading by remember { mutableStateOf(true) }
    var saving by remember { mutableStateOf(false) }
    var error by remember { mutableStateOf<String?>(null) }
    var saveSuccess by remember { mutableStateOf(false) }

    // ── Gauge thresholds state ──
    val zones = listOf("NONE", "LOW", "MILD", "HIGH")
    var thresholdNone by remember { mutableStateOf("0") }
    var thresholdLow by remember { mutableStateOf("3") }
    var thresholdMild by remember { mutableStateOf("5") }
    var thresholdHigh by remember { mutableStateOf("10") }

    // ── Decay weights state — separate state per severity for reliable recomposition ──
    val severities = listOf("HIGH", "MILD", "LOW")
    val dayLabels = listOf("Today", "+1d", "+2d", "+3d", "+4d", "+5d", "+6d")

    var highDays by remember { mutableStateOf(listOf("10", "5", "2.5", "0", "0", "0", "0")) }
    var mildDays by remember { mutableStateOf(listOf("6", "3", "1.5", "0", "0", "0", "0")) }
    var lowDays by remember { mutableStateOf(listOf("3", "1.5", "0", "0", "0", "0", "0")) }

    fun getDays(sev: String): List<String> = when (sev) {
        "HIGH" -> highDays
        "MILD" -> mildDays
        "LOW" -> lowDays
        else -> listOf("0","0","0","0","0","0","0")
    }

    fun setDays(sev: String, days: List<String>) {
        when (sev) {
            "HIGH" -> highDays = days
            "MILD" -> mildDays = days
            "LOW" -> lowDays = days
        }
    }

    fun getThreshold(zone: String): String = when (zone) {
        "NONE" -> thresholdNone
        "LOW" -> thresholdLow
        "MILD" -> thresholdMild
        "HIGH" -> thresholdHigh
        else -> "0"
    }

    fun setThreshold(zone: String, value: String) {
        when (zone) {
            "NONE" -> thresholdNone = value
            "LOW" -> thresholdLow = value
            "MILD" -> thresholdMild = value
            "HIGH" -> thresholdHigh = value
        }
    }

    // ── Load from Supabase ──
    LaunchedEffect(Unit) {
        // Fetch on IO thread
        val thresholdResult = withContext(Dispatchers.IO) {
            try {
                edge.getRiskGaugeThresholds(context)
            } catch (e: Exception) {
                Log.e("RiskWeightsScreen", "Failed to load thresholds: ${e.message}", e)
                null
            }
        }

        val weightResult = withContext(Dispatchers.IO) {
            try {
                edge.getRiskDecayWeights(context)
            } catch (e: Exception) {
                Log.e("RiskWeightsScreen", "Failed to load weights: ${e.message}", e)
                null
            }
        }

        // Apply state on Main thread
        if (thresholdResult != null) {
            Log.d("RiskWeightsScreen", "Loaded ${thresholdResult.size} threshold rows")
            for (row in thresholdResult) {
                when (row.zone.uppercase()) {
                    "NONE" -> thresholdNone = fmt(row.minValue)
                    "LOW" -> thresholdLow = fmt(row.minValue)
                    "MILD" -> thresholdMild = fmt(row.minValue)
                    "HIGH" -> thresholdHigh = fmt(row.minValue)
                }
            }
        } else {
            error = "Failed to load thresholds"
        }

        if (weightResult != null) {
            Log.d("RiskWeightsScreen", "Loaded ${weightResult.size} weight rows")
            for (row in weightResult) {
                val days = listOf(
                    fmt(row.day0), fmt(row.day1), fmt(row.day2),
                    fmt(row.day3), fmt(row.day4), fmt(row.day5), fmt(row.day6)
                )
                Log.d("RiskWeightsScreen", "  ${row.severity}: $days")
                when (row.severity.uppercase()) {
                    "HIGH" -> highDays = days
                    "MILD" -> mildDays = days
                    "LOW" -> lowDays = days
                }
            }
        } else {
            error = (error?.let { "$it\n" } ?: "") + "Failed to load weights"
        }

        loading = false
    }

    // ── Save handler ──
    fun save() {
        scope.launch {
            saving = true
            error = null
            saveSuccess = false

            withContext(Dispatchers.IO) {
                try {
                    var allOk = true

                    // Save gauge thresholds
                    for (zone in zones) {
                        val minVal = getThreshold(zone).toDoubleOrNull() ?: 0.0
                        val ok = edge.upsertRiskGaugeThreshold(
                            context = context,
                            zone = zone,
                            minValue = minVal
                        )
                        if (!ok) allOk = false
                    }

                    // Save decay weights
                    for (sev in severities) {
                        val vals = getDays(sev)
                        val ok = edge.upsertRiskDecayWeight(
                            context = context,
                            severity = sev,
                            day0 = vals.getOrNull(0)?.toDoubleOrNull() ?: 0.0,
                            day1 = vals.getOrNull(1)?.toDoubleOrNull() ?: 0.0,
                            day2 = vals.getOrNull(2)?.toDoubleOrNull() ?: 0.0,
                            day3 = vals.getOrNull(3)?.toDoubleOrNull() ?: 0.0,
                            day4 = vals.getOrNull(4)?.toDoubleOrNull() ?: 0.0,
                            day5 = vals.getOrNull(5)?.toDoubleOrNull() ?: 0.0,
                            day6 = vals.getOrNull(6)?.toDoubleOrNull() ?: 0.0
                        )
                        if (!ok) allOk = false
                    }

                    if (allOk) {
                        // Recalculate risk scores with the new thresholds/weights
                        edge.triggerRecalcRiskScores(context)
                        saveSuccess = true
                    }
                    else error = "Some rows failed to save"
                } catch (e: Exception) {
                    error = "Save failed: ${e.message}"
                }
            }
            saving = false
        }
    }

    // ── Reset to defaults ──
    fun resetDefaults() {
        thresholdNone = "0"
        thresholdLow = "3"
        thresholdMild = "5"
        thresholdHigh = "10"

        highDays = listOf("10", "5", "2.5", "0", "0", "0", "0")
        mildDays = listOf("6", "3", "1.5", "0", "0", "0", "0")
        lowDays  = listOf("3", "1.5", "0", "0", "0", "0", "0")
    }

    // ── UI ──
    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar
            Row(
                Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = onBack) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back", tint = Color.White)
                }
                Text(
                    "Risk Model",
                    color = Color.White,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.size(48.dp))
            }

            if (loading) {
                Box(Modifier.fillMaxWidth().padding(32.dp), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator(color = AppTheme.AccentPurple)
                }
            } else {

                // ─────────────────────────────────────────────────────────
                // Section 1: Gauge Thresholds
                // ─────────────────────────────────────────────────────────
                BaseCard {
                    Text(
                        "Gauge Thresholds",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Text(
                        "The minimum score needed to enter each risk zone on the gauge. " +
                        "When your total trigger + prodrome score reaches a threshold, the gauge moves into that zone.",
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )

                    Row(
                        Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        zones.forEach { zone ->
                            val zoneCol = zoneColor(zone)
                            Column(
                                modifier = Modifier.weight(1f),
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.spacedBy(4.dp)
                            ) {
                                Text(
                                    zone,
                                    color = zoneCol,
                                    style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.Bold),
                                    textAlign = TextAlign.Center
                                )
                                OutlinedTextField(
                                    value = getThreshold(zone),
                                    onValueChange = { newVal ->
                                        setThreshold(zone, newVal.filter { it.isDigit() || it == '.' })
                                    },
                                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                                    singleLine = true,
                                    textStyle = MaterialTheme.typography.bodyMedium.copy(
                                        textAlign = TextAlign.Center,
                                        color = Color.White
                                    ),
                                    modifier = Modifier.fillMaxWidth().height(50.dp),
                                    colors = OutlinedTextFieldDefaults.colors(
                                        unfocusedBorderColor = Color.White.copy(alpha = 0.15f),
                                        focusedBorderColor = AppTheme.AccentPurple,
                                        cursorColor = AppTheme.AccentPurple
                                    )
                                )
                            }
                        }
                    }
                }

                // ─────────────────────────────────────────────────────────
                // Section 2: Decay Weights
                // ─────────────────────────────────────────────────────────
                BaseCard {
                    Text(
                        "Decay Weights",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Text(
                        "How much each trigger or prodrome contributes to your risk score based on its severity and how many days ago it occurred.",
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }

                // One card per severity — fits properly on phone
                severities.forEach { sev ->
                    val sevColor = severityColor(sev)
                    val days = getDays(sev)

                    BaseCard {
                        Text(
                            sev,
                            color = sevColor,
                            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold)
                        )

                        // Row 1: Today, +1d, +2d, +3d
                        Row(
                            Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            for (dayIdx in 0 until 4) {
                                Column(
                                    modifier = Modifier.weight(1f),
                                    horizontalAlignment = Alignment.CenterHorizontally,
                                    verticalArrangement = Arrangement.spacedBy(2.dp)
                                ) {
                                    Text(
                                        dayLabels[dayIdx],
                                        color = AppTheme.SubtleTextColor,
                                        style = MaterialTheme.typography.labelSmall,
                                        textAlign = TextAlign.Center
                                    )
                                    OutlinedTextField(
                                        value = days.getOrElse(dayIdx) { "0" },
                                        onValueChange = { newVal ->
                                            val filtered = newVal.filter { it.isDigit() || it == '.' }
                                            val updated = days.toMutableList()
                                            if (dayIdx < updated.size) {
                                                updated[dayIdx] = filtered
                                            }
                                            setDays(sev, updated)
                                        },
                                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                                        singleLine = true,
                                        textStyle = MaterialTheme.typography.bodyMedium.copy(
                                            textAlign = TextAlign.Center,
                                            color = Color.White
                                        ),
                                        modifier = Modifier.fillMaxWidth().height(50.dp),
                                        colors = OutlinedTextFieldDefaults.colors(
                                            unfocusedBorderColor = Color.White.copy(alpha = 0.15f),
                                            focusedBorderColor = sevColor,
                                            cursorColor = sevColor
                                        )
                                    )
                                }
                            }
                        }

                        // Row 2: +4d, +5d, +6d
                        Row(
                            Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(8.dp)
                        ) {
                            for (dayIdx in 4 until 7) {
                                Column(
                                    modifier = Modifier.weight(1f),
                                    horizontalAlignment = Alignment.CenterHorizontally,
                                    verticalArrangement = Arrangement.spacedBy(2.dp)
                                ) {
                                    Text(
                                        dayLabels[dayIdx],
                                        color = AppTheme.SubtleTextColor,
                                        style = MaterialTheme.typography.labelSmall,
                                        textAlign = TextAlign.Center
                                    )
                                    OutlinedTextField(
                                        value = days.getOrElse(dayIdx) { "0" },
                                        onValueChange = { newVal ->
                                            val filtered = newVal.filter { it.isDigit() || it == '.' }
                                            val updated = days.toMutableList()
                                            if (dayIdx < updated.size) {
                                                updated[dayIdx] = filtered
                                            }
                                            setDays(sev, updated)
                                        },
                                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                                        singleLine = true,
                                        textStyle = MaterialTheme.typography.bodyMedium.copy(
                                            textAlign = TextAlign.Center,
                                            color = Color.White
                                        ),
                                        modifier = Modifier.fillMaxWidth().height(50.dp),
                                        colors = OutlinedTextFieldDefaults.colors(
                                            unfocusedBorderColor = Color.White.copy(alpha = 0.15f),
                                            focusedBorderColor = sevColor,
                                            cursorColor = sevColor
                                        )
                                    )
                                }
                            }
                            // Empty spacer to balance the row
                            Spacer(Modifier.weight(1f))
                        }
                    }
                }

                // ── Error / success ──
                error?.let {
                    Text(it, color = Color(0xFFE57373), style = MaterialTheme.typography.bodySmall)
                }
                if (saveSuccess) {
                    Text("Saved successfully", color = Color(0xFF81C784), style = MaterialTheme.typography.bodySmall)
                }

                // ── Buttons ──
                Row(
                    Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    OutlinedButton(
                        onClick = { resetDefaults() },
                        modifier = Modifier.weight(1f),
                        colors = ButtonDefaults.outlinedButtonColors(contentColor = Color.White)
                    ) {
                        Text("Reset Defaults")
                    }

                    Button(
                        onClick = { save() },
                        modifier = Modifier.weight(1f),
                        enabled = !saving,
                        colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                    ) {
                        if (saving) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(18.dp),
                                color = Color.White,
                                strokeWidth = 2.dp
                            )
                        } else {
                            Text("Save")
                        }
                    }
                }

                // ── How it works ──
                BaseCard {
                    Text(
                        "How it works",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Text(
                        "Each trigger and prodrome you log has a severity (High, Mild, Low, None). " +
                        "The decay weight for that severity and how many days ago it was logged " +
                        "determines its point contribution to your total risk score.\n\n" +
                        "For example with defaults: a High-severity trigger logged today " +
                        "contributes 10 points. Tomorrow it contributes 5, the day after 2.5.\n\n" +
                        "All active contributions are summed into a total score. " +
                        "The gauge thresholds then map that total to a zone:\n" +
                        "• Score ≥ 10 → High\n" +
                        "• Score ≥ 5 → Mild\n" +
                        "• Score ≥ 3 → Low\n" +
                        "• Score < 3 → None",
                        color = AppTheme.BodyTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
        }
    }
}

private fun zoneColor(zone: String): Color = when (zone) {
    "HIGH" -> Color(0xFFE57373)
    "MILD" -> Color(0xFFFFB74D)
    "LOW"  -> Color(0xFF81C784)
    "NONE" -> Color(0xFF666666)
    else   -> Color.White
}

private fun severityColor(severity: String): Color = when (severity) {
    "HIGH" -> Color(0xFFE57373)
    "MILD" -> Color(0xFFFFB74D)
    "LOW"  -> Color(0xFF81C784)
    else   -> Color.White
}

/** Format a Double for display: strip trailing zeros (e.g. 5.0 → "5", 2.5 → "2.5") */
private fun fmt(v: Double): String {
    return if (v == v.toLong().toDouble()) v.toLong().toString()
    else v.toBigDecimal().stripTrailingZeros().toPlainString()
}


title: ScreenOnReceiver.kt
text:
// FILE: ScreenOnReceiver.kt
package com.migraineme

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log

/**
 * Triggers ambient noise sampling when user unlocks the phone,
 * but only if last successful (non-zero) sample was >30 min ago.
 * 
 * Register in AndroidManifest.xml:
 * <receiver android:name=".ScreenOnReceiver" android:exported="false">
 *     <intent-filter>
 *         <action android:name="android.intent.action.USER_PRESENT" />
 *     </intent-filter>
 * </receiver>
 */
class ScreenOnReceiver : BroadcastReceiver() {

    companion object {
        private const val TAG = "ScreenOnReceiver"
        private const val MIN_INTERVAL_MS = 30 * 60 * 1000L // 30 minutes
    }

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action != Intent.ACTION_USER_PRESENT) return

        Log.d(TAG, "User unlocked phone")

        // Check if noise sampling is enabled
        if (!AmbientNoisePrefs.isEnabled(context)) {
            Log.d(TAG, "Noise sampling not enabled — skip")
            return
        }

        // Check last successful sample time
        val lastSampleTime = AmbientNoisePrefs.getLastSuccessfulSampleTime(context)
        val now = System.currentTimeMillis()
        val elapsed = now - lastSampleTime

        if (elapsed < MIN_INTERVAL_MS) {
            Log.d(TAG, "Last sample was ${elapsed / 1000 / 60}min ago — skip (need 30min)")
            return
        }

        Log.d(TAG, "Last sample was ${elapsed / 1000 / 60}min ago — triggering new sample")
        AmbientNoiseSampleWorker.scheduleImmediate(context)
    }
}

title: ScreenTimeCollector.kt
text:
package com.migraineme

import android.app.AppOpsManager
import android.app.usage.UsageStatsManager
import android.content.Context
import android.os.Build
import android.os.Process
import android.util.Log
import java.time.LocalDate
import java.time.ZoneId

data class ScreenTimeData(
    val date: String, // YYYY-MM-DD
    val totalSeconds: Int,
    val appCount: Int
)

/**
 * Utility to extract daily screen time from Android's UsageStatsManager.
 *
 * Requires PACKAGE_USAGE_STATS permission (granted via Settings > Apps > Special Access).
 */
object ScreenTimeCollector {

    private const val TAG = "ScreenTimeCollector"

    /**
     * Get total screen time for a specific date in the device's timezone.
     *
     * @param context Application context
     * @param date The date to query (YYYY-MM-DD format)
     * @return ScreenTimeData with total seconds and app count, or null if permission denied or error
     */
    fun getDailyScreenTime(context: Context, date: String): ScreenTimeData? {
        try {
            if (!hasUsageStatsPermission(context)) {
                Log.w(TAG, "PACKAGE_USAGE_STATS permission not granted")
                return null
            }

            val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager
            if (usageStatsManager == null) {
                Log.e(TAG, "UsageStatsManager not available")
                return null
            }

            // Parse the date and get start/end of day in device timezone
            val localDate = LocalDate.parse(date)
            val zoneId = ZoneId.systemDefault()

            val startOfDay = localDate.atStartOfDay(zoneId)
            val endOfDay = localDate.plusDays(1).atStartOfDay(zoneId)

            val startMillis = startOfDay.toInstant().toEpochMilli()
            val endMillis = endOfDay.toInstant().toEpochMilli()

            Log.d(TAG, "Querying screen time for $date ($startMillis to $endMillis)")

            // Query usage stats for the day
            val usageStatsList = usageStatsManager.queryUsageStats(
                UsageStatsManager.INTERVAL_DAILY,
                startMillis,
                endMillis
            )

            if (usageStatsList.isNullOrEmpty()) {
                Log.d(TAG, "No usage stats found for $date")
                return ScreenTimeData(date, 0, 0)
            }

            // Sum up total foreground time across all apps
            var totalTimeInForeground = 0L
            var appCount = 0

            for (usageStats in usageStatsList) {
                val timeInForeground = usageStats.totalTimeInForeground
                if (timeInForeground > 0) {
                    totalTimeInForeground += timeInForeground
                    appCount++
                }
            }

            val totalSeconds = (totalTimeInForeground / 1000).toInt()
            Log.d(TAG, "Total screen time for $date: ${totalSeconds}s across $appCount apps")

            return ScreenTimeData(date, totalSeconds, appCount)

        } catch (e: Exception) {
            Log.e(TAG, "Error getting screen time for $date", e)
            return null
        }
    }

    /**
     * Get screen time during late-night window: 22:00 on [date] to 06:00 on [date+1].
     * Uses INTERVAL_BEST to get finer-grained buckets that can be filtered by hour.
     *
     * @param context Application context
     * @param date The evening date (YYYY-MM-DD). Window = this date 22:00 → next day 06:00.
     * @return ScreenTimeData with total seconds and app count for the late-night window, or null on error
     */
    fun getLateNightScreenTime(context: Context, date: String): ScreenTimeData? {
        try {
            if (!hasUsageStatsPermission(context)) {
                Log.w(TAG, "PACKAGE_USAGE_STATS permission not granted")
                return null
            }

            val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager
            if (usageStatsManager == null) {
                Log.e(TAG, "UsageStatsManager not available")
                return null
            }

            val localDate = LocalDate.parse(date)
            val zoneId = ZoneId.systemDefault()

            // Window: 22:00 on date → 06:00 on date+1
            val windowStart = localDate.atTime(22, 0).atZone(zoneId)
            val windowEnd = localDate.plusDays(1).atTime(6, 0).atZone(zoneId)

            val startMillis = windowStart.toInstant().toEpochMilli()
            val endMillis = windowEnd.toInstant().toEpochMilli()

            Log.d(TAG, "Querying late-night screen time for $date (22:00-06:00): $startMillis to $endMillis")

            // INTERVAL_BEST gives us the finest granularity available
            val usageStatsList = usageStatsManager.queryUsageStats(
                UsageStatsManager.INTERVAL_BEST,
                startMillis,
                endMillis
            )

            if (usageStatsList.isNullOrEmpty()) {
                Log.d(TAG, "No late-night usage stats for $date")
                return ScreenTimeData(date, 0, 0)
            }

            var totalTimeInForeground = 0L
            var appCount = 0

            for (usageStats in usageStatsList) {
                val timeInForeground = usageStats.totalTimeInForeground
                if (timeInForeground > 0) {
                    totalTimeInForeground += timeInForeground
                    appCount++
                }
            }

            val totalSeconds = (totalTimeInForeground / 1000).toInt()
            Log.d(TAG, "Late-night screen time for $date: ${totalSeconds}s across $appCount apps")

            return ScreenTimeData(date, totalSeconds, appCount)

        } catch (e: Exception) {
            Log.e(TAG, "Error getting late-night screen time for $date", e)
            return null
        }
    }

    /**
     * Check if the app has PACKAGE_USAGE_STATS permission.
     */
    fun hasUsageStatsPermission(context: Context): Boolean {
        return try {
            val appOps = context.getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager
            val mode = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                appOps.unsafeCheckOpNoThrow(
                    AppOpsManager.OPSTR_GET_USAGE_STATS,
                    Process.myUid(),
                    context.packageName
                )
            } else {
                @Suppress("DEPRECATION")
                appOps.checkOpNoThrow(
                    AppOpsManager.OPSTR_GET_USAGE_STATS,
                    Process.myUid(),
                    context.packageName
                )
            }
            mode == AppOpsManager.MODE_ALLOWED
        } catch (e: Exception) {
            Log.e(TAG, "Error checking usage stats permission", e)
            false
        }
    }

    /**
     * Get yesterday's screen time (most common use case for daily sync).
     */
    fun getYesterdayScreenTime(context: Context): ScreenTimeData? {
        val yesterday = LocalDate.now().minusDays(1).toString()
        return getDailyScreenTime(context, yesterday)
    }
}

title: ScreenTimePermissionDialog.kt
text:
package com.migraineme

import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable

/**
 * Dialog to explain Screen Time / Usage Access permission and direct user to settings.
 *
 * Intended for features that rely on Android Usage Stats (screen time/app usage).
 */
@Composable
fun ScreenTimePermissionDialog(
    onDismiss: () -> Unit,
    onOpenSettings: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Screen Time Access") },
        text = {
            Text(
                "To show screen time insights, MigraineMe needs Usage Access permission.\n\n" +
                        "This lets Android share app usage totals with MigraineMe. " +
                        "MigraineMe does not read your content.\n\n" +
                        "You'll be taken to Settings where you can grant this permission."
            )
        },
        confirmButton = {
            TextButton(onClick = onOpenSettings) {
                Text("Open Settings")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Not Now")
            }
        }
    )
}

title: ScreenTimePermissionHelper.kt
text:
package com.migraineme

import android.content.Context
import android.content.Intent
import android.provider.Settings

/**
 * Helper for managing PACKAGE_USAGE_STATS permission requests.
 * 
 * Unlike normal runtime permissions, PACKAGE_USAGE_STATS cannot be requested via
 * ActivityResultContracts - the user must grant it in Settings.
 * 
 * This helper:
 * 1. Checks if permission is granted
 * 2. Opens Settings to the Usage Access page if needed
 * 3. Tracks whether we've requested permission (to avoid annoying users repeatedly)
 */
object ScreenTimePermissionHelper {
    
    private const val PREFS = "screen_time_permission"
    private const val KEY_REQUESTED = "requested_once"
    
    /**
     * Check if PACKAGE_USAGE_STATS permission is granted.
     */
    fun hasPermission(context: Context): Boolean {
        return ScreenTimeCollector.hasUsageStatsPermission(context)
    }
    
    /**
     * Check if we've already requested permission once (to avoid annoying users).
     */
    fun hasRequestedBefore(context: Context): Boolean {
        return context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .getBoolean(KEY_REQUESTED, false)
    }
    
    /**
     * Mark that we've requested permission (so we don't keep asking).
     */
    fun markAsRequested(context: Context) {
        context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .edit()
            .putBoolean(KEY_REQUESTED, true)
            .apply()
    }
    
    /**
     * Open Android Settings to the Usage Access page where user can grant permission.
     * This is the only way to request PACKAGE_USAGE_STATS permission.
     */
    fun openUsageAccessSettings(context: Context) {
        val intent = Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        context.startActivity(intent)
        markAsRequested(context)
    }
    
    /**
     * Should we request permission now?
     * Returns true if:
     * - Permission is not granted AND
     * - We haven't requested before (or force is true)
     */
    fun shouldRequestPermission(context: Context, force: Boolean = false): Boolean {
        if (hasPermission(context)) return false
        if (force) return true
        return !hasRequestedBefore(context)
    }
}

title: ScreenTimeSyncWorker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.BackoffPolicy
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import java.util.concurrent.TimeUnit

/**
 * Screen time sync worker - triggered by FCM (hourly).
 *
 * Does THREE things each run:
 * 1. Updates screen_time_live with TODAY's running total (upserts same row)
 * 2. Finalizes any COMPLETED days (yesterday and before) to screen_time_daily
 * 3. Finalizes late-night screen time (22:00–06:00) for completed nights
 */
class ScreenTimeSyncWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        Log.d(TAG, "Worker started")

        try {
            // Check permission
            if (!ScreenTimeCollector.hasUsageStatsPermission(applicationContext)) {
                Log.d(TAG, "PACKAGE_USAGE_STATS permission not granted - skipping")
                return@withContext Result.success()
            }

            // Get valid Supabase access token
            val access = SessionStore.getValidAccessToken(applicationContext)
            if (access.isNullOrBlank()) {
                Log.d(TAG, "No valid access token - skipping")
                return@withContext Result.success()
            }

            val svc = SupabasePersonalService(applicationContext)
            val today = LocalDate.now()
            val yesterday = today.minusDays(1)
            val timezone = ZoneId.systemDefault().id

            // ========== 1. UPDATE TODAY'S LIVE DATA ==========
            runCatching {
                val todayData = ScreenTimeCollector.getDailyScreenTime(applicationContext, today.toString())
                if (todayData != null) {
                    val totalHours = todayData.totalSeconds / 3600.0
                    svc.upsertScreenTimeLive(
                        accessToken = access,
                        date = today.toString(),
                        totalHours = totalHours,
                        appCount = todayData.appCount,
                        source = "android",
                        timezone = timezone
                    )
                    Log.d(TAG, "Updated live screen time for today: ${String.format("%.2f", totalHours)}h")
                }
            }.onFailure { e ->
                Log.e(TAG, "Failed to update live screen time", e)
            }

            // ========== 2. FINALIZE COMPLETED DAYS ==========
            // Get the latest date in screen_time_daily
            val latestDailyStr = svc.latestScreenTimeDate(access, source = "android")
            val latestDaily = latestDailyStr?.let { runCatching { LocalDate.parse(it) }.getOrNull() }

            // Determine which completed days need to be finalized
            val toFinalize = if (latestDaily == null) {
                // No daily data yet - finalize yesterday only
                listOf(yesterday)
            } else {
                val daysSince = ChronoUnit.DAYS.between(latestDaily, yesterday)
                when {
                    daysSince <= 0 -> emptyList() // Already up to date
                    daysSince <= 7 -> (1..daysSince).map { latestDaily.plusDays(it) }
                    else -> listOf(yesterday) // Gap too large, just do yesterday
                }
            }

            if (toFinalize.isNotEmpty()) {
                Log.d(TAG, "Finalizing ${toFinalize.size} days to screen_time_daily")

                var ok = 0
                var fail = 0

                toFinalize.forEach { date ->
                    runCatching {
                        val dateStr = date.toString()
                        val screenTime = ScreenTimeCollector.getDailyScreenTime(applicationContext, dateStr)

                        if (screenTime == null) {
                            Log.w(TAG, "No screen time data for $dateStr")
                            fail++
                            return@forEach
                        }

                        val totalHours = screenTime.totalSeconds / 3600.0
                        val flags = mapOf(
                            "app_count" to screenTime.appCount.toString(),
                            "source" to "android"
                        )

                        svc.upsertScreenTimeDaily(
                            accessToken = access,
                            date = dateStr,
                            totalHours = totalHours,
                            source = "android",
                            qualityFlags = flags
                        )

                        Log.d(TAG, "Finalized screen time for $dateStr: ${String.format("%.2f", totalHours)}h")
                        ok++
                    }.onFailure { e ->
                        fail++
                        Log.e(TAG, "Failed to finalize $date", e)
                    }
                }

                Log.d(TAG, "Finalized $ok of ${toFinalize.size} days (fail=$fail)")
            }

            // ========== 3. FINALIZE LATE-NIGHT SCREEN TIME ==========
            // A late-night window for date D = 22:00 on D → 06:00 on D+1.
            // It is complete once we are past 06:00 on D+1, i.e. today >= D+2,
            // meaning we can finalize D = today - 2 (yesterday's evening is not yet complete).
            runCatching {
                val latestLateNightStr = svc.latestScreenTimeLateNightDate(access, source = "android")
                val latestLateNight = latestLateNightStr?.let { runCatching { LocalDate.parse(it) }.getOrNull() }

                // The most recent completable night is day-before-yesterday
                val latestCompletable = today.minusDays(2)

                val nightsToFinalize = if (latestLateNight == null) {
                    listOf(latestCompletable)
                } else {
                    val daysSince = ChronoUnit.DAYS.between(latestLateNight, latestCompletable)
                    when {
                        daysSince <= 0 -> emptyList()
                        daysSince <= 7 -> (1..daysSince).map { latestLateNight.plusDays(it) }
                        else -> listOf(latestCompletable)
                    }
                }

                var lnOk = 0
                var lnFail = 0

                nightsToFinalize.forEach { date ->
                    runCatching {
                        val dateStr = date.toString()
                        val lateNight = ScreenTimeCollector.getLateNightScreenTime(applicationContext, dateStr)

                        if (lateNight == null) {
                            Log.w(TAG, "No late-night screen time data for $dateStr")
                            lnFail++
                            return@forEach
                        }

                        val totalHours = lateNight.totalSeconds / 3600.0
                        svc.upsertScreenTimeLateNight(
                            accessToken = access,
                            date = dateStr,
                            totalHours = totalHours,
                            appCount = lateNight.appCount,
                            source = "android",
                            timezone = timezone
                        )

                        Log.d(TAG, "Finalized late-night screen time for $dateStr: ${String.format("%.2f", totalHours)}h")
                        lnOk++
                    }.onFailure { e ->
                        lnFail++
                        Log.e(TAG, "Failed to finalize late-night for $date", e)
                    }
                }

                if (nightsToFinalize.isNotEmpty()) {
                    Log.d(TAG, "Finalized late-night: $lnOk of ${nightsToFinalize.size} (fail=$lnFail)")
                }
            }.onFailure { e ->
                Log.e(TAG, "Failed late-night screen time finalization", e)
            }

            Result.success()

        } catch (t: Throwable) {
            Log.e(TAG, "Worker error", t)
            Result.retry()
        }
    }

    companion object {
        private const val TAG = "ScreenTimeSyncWorker"
        private const val UNIQUE_WORK = "screen_time_sync"

        /**
         * Run once immediately - called by FCM handler.
         */
        fun runOnce(context: Context) {
            Log.d(TAG, "Enqueuing screen time sync")
            val req = OneTimeWorkRequestBuilder<ScreenTimeSyncWorker>()
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 5, TimeUnit.MINUTES)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_WORK, ExistingWorkPolicy.REPLACE, req
            )
        }
    }
}

title: SessionStore.kt
text:
// FILE: app/src/main/java/com/migraineme/SessionStore.kt
package com.migraineme

import android.content.Context
import android.content.Context.MODE_PRIVATE
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

object SessionStore {
    private const val PREFS = "session_prefs"

    private const val KEY_ACCESS = "access_token"
    private const val KEY_REFRESH = "refresh_token"
    private const val KEY_EXPIRES_IN = "expires_in_seconds"
    private const val KEY_OBTAINED_AT = "obtained_at_ms"

    private const val KEY_USER_ID = "user_id"
    private const val KEY_AUTH_PROVIDER = "auth_provider" // "email" | "google" | "facebook" | null
    private const val KEY_FCM_TOKEN = "fcm_token"

    // Small skew so we refresh a bit before expiry to avoid edge failures in workers.
    private const val EXPIRY_SKEW_MS = 60_000L

    private val refreshMutex = Mutex()

    fun saveAccessToken(context: Context, token: String) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_ACCESS, token)
            .apply()
    }

    fun saveRefreshToken(context: Context, refreshToken: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_REFRESH, refreshToken)
            .apply()
    }

    fun saveExpiresIn(context: Context, expiresInSeconds: Long?) {
        val prefs = context.getSharedPreferences(PREFS, MODE_PRIVATE).edit()
        if (expiresInSeconds == null) {
            prefs.remove(KEY_EXPIRES_IN)
        } else {
            prefs.putLong(KEY_EXPIRES_IN, expiresInSeconds)
        }
        prefs.apply()
    }

    fun saveObtainedAt(context: Context, obtainedAtMs: Long) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putLong(KEY_OBTAINED_AT, obtainedAtMs)
            .apply()
    }

    /**
     * Saves the user id separately so UI (e.g., Profile) can display a stable identity
     * without needing a network call.
     */
    fun saveUserId(context: Context, userId: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_USER_ID, userId)
            .apply()
    }

    /**
     * Persists which auth method was used for this session.
     * Expected values: "email", "google", "facebook"
     */
    fun saveAuthProvider(context: Context, provider: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_AUTH_PROVIDER, provider)
            .apply()
    }

    fun readAuthProvider(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_AUTH_PROVIDER, null)
    }

    /**
     * Save FCM token for push notifications
     */
    fun saveFcmToken(context: Context, token: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_FCM_TOKEN, token)
            .apply()
    }

    /**
     * Read FCM token
     */
    fun readFcmToken(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_FCM_TOKEN, null)
    }

    /**
     * New canonical session writer.
     *
     * Note: first three params match your old call sites (context, token, userId),
     * so existing positional calls still work.
     */
    fun saveSession(
        context: Context,
        accessToken: String,
        userId: String?,
        provider: String? = null,
        refreshToken: String? = null,
        expiresIn: Long? = null,
        obtainedAtMs: Long = System.currentTimeMillis()
    ) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_ACCESS, accessToken)
            .putString(KEY_REFRESH, refreshToken)
            .apply()

        saveUserId(context, userId)
        saveAuthProvider(context, provider)
        saveExpiresIn(context, expiresIn)
        saveObtainedAt(context, obtainedAtMs)
    }

    fun readAccessToken(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_ACCESS, null)
    }

    fun readRefreshToken(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_REFRESH, null)
    }

    fun readExpiresIn(context: Context): Long? {
        val prefs = context.getSharedPreferences(PREFS, MODE_PRIVATE)
        return if (prefs.contains(KEY_EXPIRES_IN)) prefs.getLong(KEY_EXPIRES_IN, 0L) else null
    }

    fun readObtainedAt(context: Context): Long? {
        val prefs = context.getSharedPreferences(PREFS, MODE_PRIVATE)
        return if (prefs.contains(KEY_OBTAINED_AT)) prefs.getLong(KEY_OBTAINED_AT, 0L) else null
    }

    fun readUserId(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_USER_ID, null)
    }

    fun clear(context: Context) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE).edit().clear().apply()
    }

    /**
     * Returns a valid access token.
     *
     * - If the current access token is not expired (with skew), return it.
     * - If expired and refresh_token exists, refresh via Supabase and persist new tokens.
     * - If we cannot refresh, returns null (workers should treat as "skip").
     *
     * IMPORTANT: Ensure KEY_USER_ID is always present when an access token is present.
     * WHOOP token ownership checks depend on a stable Supabase user_id in SessionStore.
     */
    suspend fun getValidAccessToken(context: Context): String? {
        return refreshMutex.withLock {
            val access = readAccessToken(context)
            if (access.isNullOrBlank()) return@withLock null

            // CHANGE #1:
            // If user_id is missing, derive it from the access token JWT and persist it.
            val existingUserId = readUserId(context)
            if (existingUserId.isNullOrBlank()) {
                val derived = JwtUtils.extractUserIdFromAccessToken(access)
                if (!derived.isNullOrBlank()) {
                    saveUserId(context, derived)
                }
            }

            val expiresIn = readExpiresIn(context)
            val obtainedAt = readObtainedAt(context)

            // If we don't have expiry metadata, assume it's still usable (backward compatibility).
            if (expiresIn == null || obtainedAt == null) {
                return@withLock access
            }

            val expiresAt = obtainedAt + (expiresIn * 1000L)
            val now = System.currentTimeMillis()

            // Still valid (with skew) -> return.
            if (now + EXPIRY_SKEW_MS < expiresAt) {
                return@withLock access
            }

            // Expired -> refresh.
            val refresh = readRefreshToken(context)
            if (refresh.isNullOrBlank()) {
                return@withLock null
            }

            return@withLock try {
                val ses = SupabaseAuthService.refreshSession(refresh)

                val newAccess = ses.accessToken
                if (newAccess.isNullOrBlank()) {
                    null
                } else {
                    // CHANGE #2:
                    // Always derive userId from the refreshed access token (do not depend on existing prefs).
                    val newUserId =
                        JwtUtils.extractUserIdFromAccessToken(newAccess)
                            ?: readUserId(context)

                    // Supabase may rotate refresh tokens; persist both.
                    saveSession(
                        context = context,
                        accessToken = newAccess,
                        userId = newUserId,
                        provider = readAuthProvider(context),
                        refreshToken = ses.refreshToken ?: refresh,
                        expiresIn = ses.expiresIn,
                        obtainedAtMs = System.currentTimeMillis()
                    )
                    newAccess
                }
            } catch (_: Throwable) {
                null
            }
        }
    }
}

title: SharedComponents.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.CornerRadius
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

/**
 * A container that fades from transparent to a solid color as the user scrolls.
 * Used by Home and Insights screens to fade out the background image.
 *
 * @param scrollState The scroll state to track
 * @param fadeColor The color to fade to (default: AppTheme.FadeColor)
 * @param fadeDistance How much scroll distance before fully opaque (default: AppTheme.FadeDistance)
 * @param content The screen content
 */
@Composable
fun ScrollFadeContainer(
    scrollState: ScrollState = rememberScrollState(),
    fadeColor: Color = AppTheme.FadeColor,
    fadeDistance: Dp = AppTheme.FadeDistance,
    content: @Composable (ScrollState) -> Unit
) {
    val density = LocalDensity.current
    
    val fadeAlpha by remember(scrollState, density) {
        derivedStateOf {
            val fadePx = with(density) { fadeDistance.toPx() }
            if (fadePx <= 0f) 1f else (scrollState.value / fadePx).coerceIn(0f, 1f)
        }
    }
    
    Box(Modifier.fillMaxSize()) {
        // Fade overlay
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(fadeColor.copy(alpha = fadeAlpha))
        )
        
        content(scrollState)
    }
}

/**
 * Standard scrollable content layout for Home/Insights screens.
 * Includes the logo reveal spacer at the top.
 *
 * @param scrollState The scroll state
 * @param logoRevealHeight Height of spacer to show background (default: AppTheme.LogoRevealHeight)
 * @param content The cards/content to display
 */
@Composable
fun ScrollableScreenContent(
    scrollState: ScrollState,
    logoRevealHeight: Dp = AppTheme.LogoRevealHeight,
    content: @Composable ColumnScope.() -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Space at top to reveal background image
        Spacer(Modifier.height(logoRevealHeight))
        
        content()
    }
}

/**
 * A hero card with gradient border, used for primary content on Home/Insights.
 * Features:
 * - Gradient border (purple to pink)
 * - Top gradient accent line
 * - Inner radial glow
 *
 * @param modifier Modifier for the card
 * @param content The card content
 */
@Composable
fun HeroCard(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val borderBrush = remember {
        Brush.linearGradient(
            colors = listOf(
                AppTheme.AccentPurple.copy(alpha = 0.60f),
                AppTheme.AccentPink.copy(alpha = 0.55f)
            )
        )
    }
    
    Box(modifier = modifier.fillMaxWidth()) {
        // Gradient border
        Canvas(modifier = Modifier.matchParentSize()) {
            val strokePx = 2.dp.toPx()
            val cr = CornerRadius(24.dp.toPx(), 24.dp.toPx())
            drawRoundRect(
                brush = borderBrush,
                topLeft = Offset(strokePx / 2f, strokePx / 2f),
                size = Size(size.width - strokePx, size.height - strokePx),
                cornerRadius = cr,
                style = Stroke(width = strokePx)
            )
        }
        
        Card(
            modifier = Modifier.fillMaxWidth(),
            shape = AppTheme.HeroCardShape,
            colors = CardDefaults.cardColors(containerColor = AppTheme.HeroCardContainer),
            elevation = CardDefaults.cardElevation(0.dp)
        ) {
            Column(modifier = Modifier.fillMaxWidth()) {
                // Top gradient accent line
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(3.dp)
                        .background(
                            Brush.horizontalGradient(
                                colors = listOf(AppTheme.AccentPurple, AppTheme.AccentPink)
                            )
                        )
                )
                
                // Content with inner glow
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    // Subtle inner glow (visual only)
                    Box(
                        modifier = Modifier
                            .matchParentSize()
                            .background(
                                Brush.radialGradient(
                                    colors = listOf(
                                        AppTheme.AccentPurple.copy(alpha = 0.18f),
                                        Color.Transparent
                                    ),
                                    center = Offset(0f, 0f),
                                    radius = 800f
                                )
                            )
                    )
                    
                    Column(
                        modifier = Modifier.fillMaxWidth(),
                        verticalArrangement = Arrangement.spacedBy(10.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        content = content
                    )
                }
            }
        }
    }
}

/**
 * A standard base card for secondary content on Home/Insights.
 * Simpler than HeroCard - just a semi-transparent card with subtle border.
 *
 * @param modifier Modifier for the card
 * @param content The card content
 */
@Composable
fun BaseCard(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        shape = AppTheme.BaseCardShape,
        colors = CardDefaults.cardColors(containerColor = AppTheme.BaseCardContainer),
        elevation = CardDefaults.cardElevation(0.dp),
        border = AppTheme.BaseCardBorder
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(10.dp),
            content = content
        )
    }
}

title: SignupScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@Composable
fun SignupScreen(
    authVm: AuthViewModel,
    onSignedUpAndLoggedIn: () -> Unit,
    onNavigateToLogin: () -> Unit
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var confirm by remember { mutableStateOf("") }
    var error by remember { mutableStateOf<String?>(null) }
    var info by remember { mutableStateOf<String?>(null) }
    var busy by remember { mutableStateOf(false) }

    val scope = remember { CoroutineScope(Dispatchers.Main) }
    val ctx = androidx.compose.ui.platform.LocalContext.current
    val appCtx = ctx.applicationContext

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Create account", style = MaterialTheme.typography.titleLarge)

        OutlinedTextField(
            value = email,
            onValueChange = { email = it },
            label = { Text("Email") },
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = password,
            onValueChange = { password = it },
            label = { Text("Password") },
            singleLine = true,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = confirm,
            onValueChange = { confirm = it },
            label = { Text("Confirm password") },
            singleLine = true,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        if (error != null) {
            Text(error!!, color = MaterialTheme.colorScheme.error)
        }
        if (info != null) {
            Text(info!!, color = MaterialTheme.colorScheme.primary)
        }

        Button(
            onClick = {
                error = null; info = null
                if (password != confirm) {
                    error = "Passwords do not match."
                    return@Button
                }
                busy = true
                scope.launch {
                    try {
                        val ses = SupabaseAuthService.signUpWithEmail(email.trim(), password)
                        val access = ses.accessToken

                        if (!access.isNullOrBlank()) {
                            val userId = JwtUtils.extractUserIdFromAccessToken(access)

                            SessionStore.saveSession(
                                context = appCtx,
                                accessToken = access,
                                userId = userId,
                                provider = "email",
                                refreshToken = ses.refreshToken,
                                expiresIn = ses.expiresIn,
                                obtainedAtMs = System.currentTimeMillis()
                            )

                            authVm.setSession(access, userId)
                            onSignedUpAndLoggedIn()
                        } else {
                            info = "Check your email to confirm your account, then sign in."
                        }
                    } catch (e: Exception) {
                        error = e.message ?: "Sign up failed."
                    } finally {
                        busy = false
                    }
                }
            },
            enabled = !busy && email.isNotBlank() && password.isNotBlank() && confirm.isNotBlank(),
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(if (busy) "Creating account..." else "Create account")
        }

        TextButton(
            onClick = onNavigateToLogin,
            modifier = Modifier
                .fillMaxWidth()
                .align(Alignment.CenterHorizontally)
        ) {
            Text("Back")
        }
    }
}

title: SleepCardConfig.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color

object SleepCardConfig {
    const val METRIC_DURATION = "duration"
    const val METRIC_FELL_ASLEEP = "fell_asleep"
    const val METRIC_WOKE_UP = "woke_up"
    const val METRIC_SCORE = "score"
    const val METRIC_EFFICIENCY = "efficiency"
    const val METRIC_DISTURBANCES = "disturbances"
    const val METRIC_STAGES_DEEP = "stages_deep"
    const val METRIC_STAGES_REM = "stages_rem"
    const val METRIC_STAGES_LIGHT = "stages_light"

    val ALL_SLEEP_METRICS: List<String> = listOf(
        METRIC_DURATION, METRIC_FELL_ASLEEP, METRIC_WOKE_UP,
        METRIC_SCORE, METRIC_EFFICIENCY, METRIC_DISTURBANCES,
        METRIC_STAGES_DEEP, METRIC_STAGES_REM, METRIC_STAGES_LIGHT
    )

    val DEFAULT_DISPLAY_METRICS: List<String> = listOf(
        METRIC_DURATION, METRIC_FELL_ASLEEP, METRIC_WOKE_UP
    )

    val GRAPHABLE_METRICS: List<String> = listOf(
        METRIC_DURATION, METRIC_SCORE, METRIC_EFFICIENCY,
        METRIC_DISTURBANCES, METRIC_STAGES_DEEP, METRIC_STAGES_REM, METRIC_STAGES_LIGHT
    )

    val WEARABLE_ONLY_METRICS: Set<String> = setOf(
        METRIC_SCORE, METRIC_EFFICIENCY, METRIC_DISTURBANCES,
        METRIC_STAGES_DEEP, METRIC_STAGES_REM, METRIC_STAGES_LIGHT
    )

    fun labelFor(metric: String): String = when (metric) {
        METRIC_DURATION -> "Duration"
        METRIC_FELL_ASLEEP -> "Fell Asleep"
        METRIC_WOKE_UP -> "Woke Up"
        METRIC_SCORE -> "Score"
        METRIC_EFFICIENCY -> "Efficiency"
        METRIC_DISTURBANCES -> "Disturbances"
        METRIC_STAGES_DEEP -> "Deep Sleep"
        METRIC_STAGES_REM -> "REM Sleep"
        METRIC_STAGES_LIGHT -> "Light Sleep"
        else -> metric
    }

    fun unitFor(metric: String): String = when (metric) {
        METRIC_DURATION -> "h"
        METRIC_SCORE -> "%"
        METRIC_EFFICIENCY -> "%"
        METRIC_STAGES_DEEP -> "h"
        METRIC_STAGES_REM -> "h"
        METRIC_STAGES_LIGHT -> "h"
        else -> ""
    }

    fun colorFor(metric: String): Color = when (metric) {
        METRIC_DURATION -> Color(0xFF7986CB)
        METRIC_FELL_ASLEEP -> Color(0xFF9575CD)
        METRIC_WOKE_UP -> Color(0xFF64B5F6)
        METRIC_SCORE -> Color(0xFF4FC3F7)
        METRIC_EFFICIENCY -> Color(0xFF81C784)
        METRIC_DISTURBANCES -> Color(0xFFFF8A65)
        METRIC_STAGES_DEEP -> Color(0xFF3F51B5)
        METRIC_STAGES_REM -> Color(0xFF7986CB)
        METRIC_STAGES_LIGHT -> Color(0xFFB0BEC5)
        else -> Color(0xFF7986CB)
    }
}

title: SleepCardConfigStore.kt
text:
package com.migraineme

import android.content.Context

data class SleepCardConfigData(
    val sleepDisplayMetrics: List<String>
)

object SleepCardConfigStore {
    private const val PREFS_NAME = "sleep_card_config"
    private const val KEY_DISPLAY_METRICS = "sleep_display_metrics"

    fun load(context: Context): SleepCardConfigData {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val metricsStr = prefs.getString(KEY_DISPLAY_METRICS, null)
        val metrics: List<String> = if (metricsStr.isNullOrBlank()) {
            SleepCardConfig.DEFAULT_DISPLAY_METRICS
        } else {
            metricsStr.split(",").filter { it.isNotBlank() }
        }
        return SleepCardConfigData(sleepDisplayMetrics = metrics)
    }

    fun save(context: Context, config: SleepCardConfigData) {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit()
            .putString(KEY_DISPLAY_METRICS, config.sleepDisplayMetrics.joinToString(","))
            .apply()
    }
}

title: SleepConfigScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.PhoneAndroid
import androidx.compose.material.icons.filled.Watch
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

/**
 * Maps a sleep graph metric key to its Supabase metric_settings table name.
 */
private fun sleepMetricToTable(metric: String): String = when (metric) {
    SleepCardConfig.METRIC_DURATION -> "sleep_duration_daily"
    SleepCardConfig.METRIC_SCORE -> "sleep_score_daily"
    SleepCardConfig.METRIC_EFFICIENCY -> "sleep_efficiency_daily"
    SleepCardConfig.METRIC_DISTURBANCES -> "sleep_disturbances_daily"
    SleepCardConfig.METRIC_STAGES_DEEP,
    SleepCardConfig.METRIC_STAGES_REM,
    SleepCardConfig.METRIC_STAGES_LIGHT -> "sleep_stages_daily"
    else -> ""
}

/**
 * Determines the source type for a metric based on its preferred_source.
 * Returns: "wearable", "phone", or null if no source.
 */
private fun sourceTypeFor(preferredSource: String?): String? = when (preferredSource) {
    "whoop", "garmin", "oura", "fitbit" -> "external"
    "health_connect" -> "external"
    "phone" -> "phone"
    null -> null
    else -> null
}

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun SleepConfigScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    val initialConfig = remember { SleepCardConfigStore.load(context) }
    var selectedMetrics by remember { mutableStateOf<Set<String>>(initialConfig.sleepDisplayMetrics.toSet()) }

    // Load metric settings to know which sources are active
    var metricSettings by remember {
        mutableStateOf<Map<String, EdgeFunctionsService.MetricSettingResponse>>(emptyMap())
    }
    var settingsLoaded by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        scope.launch {
            try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(context)
                metricSettings = settings.associateBy { it.metric }
            } catch (_: Exception) { }
            settingsLoaded = true
        }
    }

    fun saveConfig() {
        SleepCardConfigStore.save(
            context,
            SleepCardConfigData(sleepDisplayMetrics = selectedMetrics.toList())
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = {
                    saveConfig()
                    onBack()
                }) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }

            HeroCard {
                Text(
                    text = "Customize Sleep",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Choose which sleep metrics to display on the Monitor screen.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            BaseCard {
                Text(
                    text = "Display Metrics (${selectedMetrics.size}/3)",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Select up to 3 sleep metrics to show on the Monitor card.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
                Spacer(Modifier.height(12.dp))

                FlowRow(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (metric in SleepCardConfig.ALL_SLEEP_METRICS) {
                        val table = sleepMetricToTable(metric)
                        val setting = metricSettings[table]
                        val source = sourceTypeFor(setting?.preferredSource)

                        // Only hide if settings are loaded AND the metric is explicitly disabled
                        if (settingsLoaded && setting != null && !setting.enabled) continue

                        val isSelected = metric in selectedMetrics
                        val label = SleepCardConfig.labelFor(metric)
                        val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                        val slotIndex = if (isSelected) selectedMetrics.toList().indexOf(metric) else -1
                        val chipColor = if (slotIndex in slotColors.indices) slotColors[slotIndex] else AppTheme.AccentPurple
                        FilterChip(
                            selected = isSelected,
                            onClick = {
                                if (isSelected) {
                                    selectedMetrics = selectedMetrics.minus(metric)
                                } else if (selectedMetrics.size < 3) {
                                    selectedMetrics = selectedMetrics.plus(metric)
                                }
                                saveConfig()
                            },
                            label = {
                                Text(
                                    text = label,
                                    style = MaterialTheme.typography.labelSmall
                                )
                            },
                            leadingIcon = if (isSelected) {
                                {
                                    Icon(
                                        Icons.Default.Check,
                                        contentDescription = null,
                                        modifier = Modifier.size(18.dp)
                                    )
                                }
                            } else null,
                            trailingIcon = when (source) {
                                "external" -> {
                                    {
                                        Icon(
                                            Icons.Default.Watch,
                                            contentDescription = "External",
                                            modifier = Modifier.size(14.dp),
                                            tint = if (isSelected) chipColor else AppTheme.SubtleTextColor
                                        )
                                    }
                                }
                                "phone" -> {
                                    {
                                        Icon(
                                            Icons.Default.PhoneAndroid,
                                            contentDescription = "Phone",
                                            modifier = Modifier.size(14.dp),
                                            tint = if (isSelected) chipColor else AppTheme.SubtleTextColor
                                        )
                                    }
                                }
                                else -> null
                            },
                            colors = FilterChipDefaults.filterChipColors(
                                selectedContainerColor = chipColor.copy(alpha = 0.3f),
                                selectedLabelColor = chipColor,
                                containerColor = AppTheme.BaseCardContainer,
                                labelColor = AppTheme.BodyTextColor
                            ),
                            border = FilterChipDefaults.filterChipBorder(
                                borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                                selectedBorderColor = chipColor,
                                enabled = true,
                                selected = isSelected
                            )
                        )
                    }
                }

                Spacer(Modifier.height(12.dp))
                Row(
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                        Icon(Icons.Default.Watch, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                        Text(text = "External", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                    Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                        Icon(Icons.Default.PhoneAndroid, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                        Text(text = "Phone", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }
    }
}

title: SleepDataHistoryScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.ChevronLeft
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.delete
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// ─── Data models ─────────────────────────────────────────────────────────────

data class SleepDataEntry(
    val table: String,
    val label: String,
    val value: String,
    val source: String
)

@Serializable
private data class SleepRowGeneric(
    val date: String? = null,
    val source: String? = null,
    @SerialName("value_hours") val valueHours: Double? = null,
    @SerialName("value_at") val valueAt: String? = null,
    @SerialName("value_count") val valueCount: Int? = null,
    @SerialName("value_pct") val valuePct: Double? = null,
    @SerialName("value_sws_hm") val valueSwsHm: Double? = null,
    @SerialName("value_rem_hm") val valueRemHm: Double? = null,
    @SerialName("value_light_hm") val valueLightHm: Double? = null
)

// ─── Supabase helpers ────────────────────────────────────────────────────────

private val client = HttpClient {
    install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
}

private suspend fun fetchSleepEntriesForDate(
    date: String,
    accessToken: String,
    userId: String
): List<SleepDataEntry> = withContext(Dispatchers.IO) {
    val base = BuildConfig.SUPABASE_URL.trimEnd('/')
    val key = BuildConfig.SUPABASE_ANON_KEY
    val entries = mutableListOf<SleepDataEntry>()

    data class TableDef(val table: String, val label: String, val select: String)

    val tables = listOf(
        TableDef("sleep_duration_daily", "Duration", "date,source,value_hours"),
        TableDef("fell_asleep_time_daily", "Fell Asleep", "date,source,value_at"),
        TableDef("woke_up_time_daily", "Woke Up", "date,source,value_at"),
        TableDef("sleep_score_daily", "Score", "date,source,value_pct"),
        TableDef("sleep_efficiency_daily", "Efficiency", "date,source,value_pct"),
        TableDef("sleep_disturbances_daily", "Disturbances", "date,source,value_count"),
        TableDef("sleep_stages_daily", "Sleep Stages", "date,source,value_sws_hm,value_rem_hm,value_light_hm")
    )

    for (td in tables) {
        try {
            val rows: List<SleepRowGeneric> = client.get("$base/rest/v1/${td.table}") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", key)
                parameter("user_id", "eq.$userId")
                parameter("date", "eq.$date")
                parameter("select", td.select)
            }.body()

            for (row in rows) {
                val src = row.source ?: "unknown"
                val value = when {
                    row.valueHours != null -> {
                        val totalMin = (row.valueHours * 60).toInt()
                        "${totalMin / 60}h ${totalMin % 60}m"
                    }
                    row.valueAt != null -> {
                        try {
                            row.valueAt.substringAfter("T").take(5)
                        } catch (_: Exception) { row.valueAt }
                    }
                    row.valuePct != null -> "${row.valuePct.toInt()}%"
                    row.valueCount != null -> "${row.valueCount}"
                    row.valueSwsHm != null -> {
                        fun fmt(h: Double): String { val m = (h * 60).toInt(); return "${m / 60}h ${m % 60}m" }
                        "Deep ${fmt(row.valueSwsHm)} · REM ${fmt(row.valueRemHm ?: 0.0)} · Light ${fmt(row.valueLightHm ?: 0.0)}"
                    }
                    else -> "—"
                }
                entries.add(SleepDataEntry(td.table, td.label, value, src))
            }
        } catch (e: Exception) {
            Log.e("SleepDataHistory", "Failed to fetch ${td.table}: ${e.message}")
        }
    }
    entries
}

private suspend fun deleteSleepEntry(
    table: String,
    date: String,
    accessToken: String,
    userId: String
): Boolean = withContext(Dispatchers.IO) {
    try {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val resp = client.delete("$base/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            parameter("user_id", "eq.$userId")
            parameter("date", "eq.$date")
            parameter("source", "eq.manual")
        }
        resp.status.isSuccess()
    } catch (e: Exception) {
        Log.e("SleepDataHistory", "Delete failed: ${e.message}")
        false
    }
}

private suspend fun upsertSleepManualEntry(
    table: String,
    date: String,
    valueField: String,
    value: Any,
    accessToken: String
): Boolean = withContext(Dispatchers.IO) {
    try {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val body = mapOf("date" to date, "source" to "manual", valueField to value)
        val resp = client.post("$base/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            parameter("on_conflict", "user_id,source,date")
            contentType(ContentType.Application.Json)
            setBody(listOf(body))
        }
        resp.status.isSuccess()
    } catch (e: Exception) {
        Log.e("SleepDataHistory", "Upsert failed: ${e.message}")
        false
    }
}

// ─── Screen ──────────────────────────────────────────────────────────────────

@Composable
fun SleepDataHistoryScreen(onBack: () -> Unit) {
    val context = LocalContext.current
    val scrollState = rememberSaveable(saver = ScrollState.Saver) { ScrollState(0) }
    val scope = rememberCoroutineScope()

    var selectedDateStr by rememberSaveable { mutableStateOf(LocalDate.now().toString()) }
    val selectedDate = LocalDate.parse(selectedDateStr)
    val today = LocalDate.now()

    var entries by remember { mutableStateOf<List<SleepDataEntry>>(emptyList()) }
    val sleepConfig = remember { SleepCardConfigStore.load(context) }
    var isLoading by remember { mutableStateOf(true) }

    var editEntry by remember { mutableStateOf<SleepDataEntry?>(null) }
    var editValue by remember { mutableStateOf("") }

    val dateFormatter = DateTimeFormatter.ofPattern("EEEE, MMM d")

    fun loadEntries() {
        scope.launch {
            isLoading = true
            val token = SessionStore.readAccessToken(context) ?: return@launch
            val userId = SessionStore.readUserId(context) ?: return@launch
            entries = fetchSleepEntriesForDate(selectedDateStr, token, userId)
            isLoading = false
        }
    }

    LaunchedEffect(selectedDateStr) { loadEntries() }

    // Edit dialog
    if (editEntry != null) {
        val entry = editEntry!!
        AlertDialog(
            onDismissRequest = { editEntry = null },
            title = { Text("Edit ${entry.label}", color = AppTheme.TitleColor) },
            text = {
                Column {
                    Text(
                        "Current: ${entry.value}",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    Spacer(Modifier.height(12.dp))
                    Text(
                        when (entry.table) {
                            "sleep_duration_daily" -> "Enter hours (e.g. 7.5)"
                            "fell_asleep_time_daily", "woke_up_time_daily" -> "Enter time (e.g. 23:30)"
                            "sleep_score_daily", "sleep_efficiency_daily" -> "Enter percentage (e.g. 85)"
                            "sleep_disturbances_daily" -> "Enter count (e.g. 3)"
                            else -> "Enter value"
                        },
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.labelSmall
                    )
                    Spacer(Modifier.height(8.dp))
                    OutlinedTextField(
                        value = editValue,
                        onValueChange = { editValue = it },
                        singleLine = true,
                        colors = OutlinedTextFieldDefaults.colors(
                            focusedBorderColor = AppTheme.AccentPurple,
                            unfocusedBorderColor = AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                            focusedTextColor = AppTheme.TitleColor,
                            unfocusedTextColor = AppTheme.TitleColor
                        ),
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(Modifier.height(16.dp))
                    Text(
                        "Delete this entry",
                        color = Color(0xFFE57373),
                        style = MaterialTheme.typography.bodyMedium,
                        modifier = Modifier
                            .clickable {
                                scope.launch {
                                    val token = SessionStore.readAccessToken(context) ?: return@launch
                                    val userId = SessionStore.readUserId(context) ?: return@launch
                                    deleteSleepEntry(entry.table, selectedDateStr, token, userId)
                                    editEntry = null
                                    loadEntries()
                                }
                            }
                            .padding(vertical = 8.dp)
                    )
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    scope.launch {
                        val token = SessionStore.readAccessToken(context) ?: return@launch
                        val input = editValue.trim()
                        val (field, parsedValue) = when (entry.table) {
                            "sleep_duration_daily" -> "value_hours" to (input.toDoubleOrNull() ?: return@launch)
                            "fell_asleep_time_daily" -> "value_at" to "${selectedDateStr}T${input}:00"
                            "woke_up_time_daily" -> "value_at" to "${selectedDateStr}T${input}:00"
                            "sleep_score_daily" -> "value_pct" to (input.toDoubleOrNull() ?: return@launch)
                            "sleep_efficiency_daily" -> "value_pct" to (input.toDoubleOrNull() ?: return@launch)
                            "sleep_disturbances_daily" -> "value_count" to (input.toIntOrNull() ?: return@launch)
                            else -> return@launch
                        }
                        upsertSleepManualEntry(entry.table, selectedDateStr, field, parsedValue, token)
                        editEntry = null
                        loadEntries()
                    }
                }) { Text("Save", color = AppTheme.AccentPurple) }
            },
            dismissButton = {
                TextButton(onClick = { editEntry = null }) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
            },
            containerColor = Color(0xFF1E0A2E)
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(AppTheme.FadeColor)
            .verticalScroll(scrollState)
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = onBack) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White)
                }
            }

            HeroCard {
                Text(
                    "Sleep Data",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    "View and edit sleep entries",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            // Date navigation
            BaseCard {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    IconButton(onClick = { selectedDateStr = selectedDate.minusDays(1).toString() }) {
                        Icon(Icons.Default.ChevronLeft, contentDescription = "Previous day", tint = AppTheme.AccentPurple)
                    }
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            when {
                                selectedDate == today -> "Today"
                                selectedDate == today.minusDays(1) -> "Yesterday"
                                else -> selectedDate.format(dateFormatter)
                            },
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                    }
                    IconButton(
                        onClick = { selectedDateStr = selectedDate.plusDays(1).toString() },
                        enabled = selectedDate < today
                    ) {
                        Icon(
                            Icons.Default.ChevronRight,
                            contentDescription = "Next day",
                            tint = if (selectedDate < today) AppTheme.AccentPurple else AppTheme.SubtleTextColor.copy(alpha = 0.3f)
                        )
                    }
                }
            }

            // Entries
            BaseCard {
                if (isLoading) {
                    Row(
                        modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp),
                        horizontalArrangement = Arrangement.Center
                    ) {
                        CircularProgressIndicator(modifier = Modifier.size(24.dp), color = AppTheme.AccentPurple, strokeWidth = 2.dp)
                    }
                } else if (entries.isEmpty()) {
                    Text(
                        "No sleep data for this day",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth().padding(vertical = 16.dp)
                    )
                } else {
                    // Map table names to config metric keys
                    val tableToMetric = mapOf(
                        "sleep_duration_daily" to SleepCardConfig.METRIC_DURATION,
                        "fell_asleep_time_daily" to SleepCardConfig.METRIC_FELL_ASLEEP,
                        "woke_up_time_daily" to SleepCardConfig.METRIC_WOKE_UP,
                        "sleep_score_daily" to SleepCardConfig.METRIC_SCORE,
                        "sleep_efficiency_daily" to SleepCardConfig.METRIC_EFFICIENCY,
                        "sleep_disturbances_daily" to SleepCardConfig.METRIC_DISTURBANCES,
                        "sleep_stages_daily" to SleepCardConfig.METRIC_STAGES_DEEP
                    )

                    // Best value per metric (prefer non-manual first, fallback manual)
                    val bestByMetric = mutableMapOf<String, SleepDataEntry>()
                    entries.forEach { entry ->
                        val metricKey = tableToMetric[entry.table] ?: return@forEach
                        val existing = bestByMetric[metricKey]
                        if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                            bestByMetric[metricKey] = entry
                        }
                    }

                    val selectedMetrics = sleepConfig.sleepDisplayMetrics.take(3)
                    val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))

                    // Top 3 selected metrics
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly) {
                        selectedMetrics.forEachIndexed { index, metric ->
                            val entry = bestByMetric[metric]
                            val value = entry?.value ?: "—"
                            val label = SleepCardConfig.labelFor(metric)
                            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                                Text(value, color = slotColors.getOrElse(index) { slotColors.last() }, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold))
                                Text(label, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                            }
                        }
                    }

                    Spacer(Modifier.height(4.dp))
                    HorizontalDivider(color = AppTheme.SubtleTextColor.copy(alpha = 0.2f))
                    Spacer(Modifier.height(8.dp))
                    Text("All Metrics", color = AppTheme.TitleColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    Spacer(Modifier.height(4.dp))

                    // All metrics — flat list, no source headers
                    // Deduplicate: best entry per table (prefer non-manual)
                    val bestByTable = mutableMapOf<String, SleepDataEntry>()
                    entries.forEach { entry ->
                        val existing = bestByTable[entry.table]
                        if (existing == null || (existing.source == "manual" && entry.source != "manual")) {
                            bestByTable[entry.table] = entry
                        }
                    }

                    bestByTable.values.forEach { entry ->
                        val metricKey = tableToMetric[entry.table]
                        if (metricKey != null && metricKey !in selectedMetrics.toSet()) {
                            SleepDataRow(
                                entry = entry,
                                valueColor = AppTheme.SubtleTextColor,
                                onEdit = if (entry.source == "manual") {
                                    {
                                        editEntry = entry
                                        editValue = ""
                                    }
                                } else null,
                                onDelete = if (entry.source == "manual") {
                                    {
                                        scope.launch {
                                            val token = SessionStore.readAccessToken(context) ?: return@launch
                                            val userId = SessionStore.readUserId(context) ?: return@launch
                                            deleteSleepEntry(entry.table, selectedDateStr, token, userId)
                                            loadEntries()
                                        }
                                    }
                                } else null
                            )
                        }
                    }
                }
            }
        }
    }
@Composable
private fun SleepDataRow(
    entry: SleepDataEntry,
    valueColor: Color = AppTheme.SubtleTextColor,
    onEdit: (() -> Unit)?,
    onDelete: (() -> Unit)?
) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 6.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Text(entry.label, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)
            Text(entry.value, color = valueColor, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium))
        }
        if (onEdit != null) {
            Text(
                "✎", color = AppTheme.AccentPurple, style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.clickable { onEdit() }.padding(8.dp)
            )
        }
        if (onDelete != null) {
            Text(
                "✕", color = Color(0xFFE57373), style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.clickable { onDelete() }.padding(8.dp)
            )
        }
    }
}

title: SleepHistoryGraph.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.format.DateTimeFormatter

data class SleepGraphDay(
    val date: String,
    val duration: Double?,
    val score: Double?,
    val efficiency: Double?,
    val disturbances: Int?,
    val stagesDeep: Double?,
    val stagesRem: Double?,
    val stagesLight: Double?
)

data class SleepGraphResult(
    val days: List<SleepGraphDay>,
    val allTimeMin: Map<String, Float>,
    val allTimeMax: Map<String, Float>
)

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun SleepHistoryGraph(
    days: Int = 14,
    endDate: java.time.LocalDate = java.time.LocalDate.now(),
    onClick: (() -> Unit)? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    var graphResult by remember { mutableStateOf<SleepGraphResult?>(null) }
    var isLoading by remember { mutableStateOf(true) }
    var selectedMetrics by remember { mutableStateOf<Set<String>>(setOf(SleepCardConfig.METRIC_DURATION)) }
    var migraineDates by remember { mutableStateOf<Set<String>>(emptySet()) }

    LaunchedEffect(days, endDate) {
        scope.launch {
            graphResult = loadSleepGraphData(context, days, endDate)
            migraineDates = MigraineOverlayHelper.fetchMigraineDates(context, days, endDate)
            isLoading = false
        }
    }

    val historyData: List<SleepGraphDay> = graphResult?.days ?: emptyList()
    val allTimeMin: Map<String, Float> = graphResult?.allTimeMin ?: emptyMap()
    val allTimeMax: Map<String, Float> = graphResult?.allTimeMax ?: emptyMap()
    val isNormalized = selectedMetrics.size >= 2
    val daysWithData: List<SleepGraphDay> = historyData.filter { it.duration != null && it.duration > 0.0 }

    BaseCard(modifier = if (onClick != null) Modifier.clickable { onClick() } else Modifier) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "$days-Day Sleep History",
                color = AppTheme.TitleColor,
                style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
            )
            if (onClick != null) {
                Text("View Full →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall)
            }
        }

        Spacer(Modifier.height(8.dp))

        if (isLoading) {
            Row(
                modifier = Modifier.fillMaxWidth().height(150.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
            }
        } else if (historyData.isEmpty() || daysWithData.isEmpty()) {
            Text(
                text = "No sleep data available",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else if (selectedMetrics.isEmpty()) {
            Text(
                text = "Select a metric below",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else {
            // Legend
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                for (metric in selectedMetrics) {
                    val color = SleepCardConfig.colorFor(metric)
                    val label = SleepCardConfig.labelFor(metric)
                    val unit = SleepCardConfig.unitFor(metric)
                    val values: List<Float> = daysWithData.mapNotNull { getSleepDayValue(it, metric) }

                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Canvas(Modifier.size(8.dp)) { drawCircle(color) }
                        Spacer(Modifier.width(4.dp))
                        if (isNormalized) {
                            val minVal = allTimeMin[metric] ?: 0f
                            val maxVal = allTimeMax[metric] ?: 1f
                            Text(
                                text = "$label [${formatSleepValue(minVal, unit)}-${formatSleepValue(maxVal, unit)}]",
                                color = color,
                                style = MaterialTheme.typography.labelSmall
                            )
                        } else {
                            val avg = if (values.isNotEmpty()) values.average().toFloat() else 0f
                            Text(
                                text = "$label (avg: ${formatSleepValue(avg, unit)})",
                                color = color,
                                style = MaterialTheme.typography.labelSmall
                            )
                        }
                    }
                }
            }

            if (isNormalized) {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "⚠️ Normalized 0-1 scale • Dotted = $days days avg",
                    color = Color(0xFFFFB74D),
                    style = MaterialTheme.typography.labelSmall
                )
            } else if (daysWithData.isNotEmpty()) {
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Dotted line = $days-day average",
                    color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                    style = MaterialTheme.typography.labelSmall
                )
            }

            if (migraineDates.isNotEmpty()) {
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Canvas(Modifier.size(8.dp)) { drawRect(Color(0xFFE57373).copy(alpha = 0.35f)) }
                    Spacer(Modifier.width(4.dp))
                    Text(
                        text = "Red bands = migraine days",
                        color = Color(0xFFE57373),
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            }

            Spacer(Modifier.height(8.dp))

            if (daysWithData.isEmpty()) {
                Text(
                    text = "No logged days in this period",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(vertical = 16.dp)
                )
            } else {
                val yAxisWidth = 50.dp

                val yTop: String
                val yMid: String
                val yBot: String

                if (isNormalized) {
                    yTop = "1.0"
                    yMid = "0.5"
                    yBot = "0.0"
                } else {
                    val metric = selectedMetrics.first()
                    val unit = SleepCardConfig.unitFor(metric)
                    val values: List<Float> = daysWithData.mapNotNull { getSleepDayValue(it, metric) }
                    val max = values.maxOrNull() ?: 1f
                    val min = values.minOrNull() ?: 0f
                    yTop = formatSleepValue(max, unit)
                    yMid = formatSleepValue((max + min) / 2, unit)
                    yBot = formatSleepValue(min, unit)
                }

                Row(modifier = Modifier.fillMaxWidth().height(150.dp)) {
                    Column(
                        modifier = Modifier.width(yAxisWidth).fillMaxHeight(),
                        verticalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(text = yTop, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = yMid, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = yBot, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }

                    Canvas(modifier = Modifier.weight(1f).fillMaxHeight()) {
                        val padding = 8.dp.toPx()
                        val graphWidth = size.width - padding * 2
                        val graphHeight = size.height - padding * 2
                        val dashWidth = 6.dp.toPx()
                        val gapWidth = 4.dp.toPx()

                        // Draw migraine bands (behind everything)
                        with(MigraineOverlayHelper) {
                            drawMigraineBands(
                                dateList = historyData.map { it.date },
                                migraineDates = migraineDates,
                                padding = padding,
                                graphWidth = graphWidth,
                                graphHeight = graphHeight
                            )
                        }

                        for (metric in selectedMetrics) {
                            val color = SleepCardConfig.colorFor(metric)

                            val indexedValues: List<Pair<Int, Float>> = historyData.mapIndexedNotNull { i, day ->
                                val value = getSleepDayValue(day, metric)
                                if (value != null && day.duration != null && day.duration > 0.0) Pair(i, value) else null
                            }

                            if (indexedValues.isEmpty()) continue

                            val values: List<Float> = indexedValues.map { it.second }

                            val minVal: Float
                            val maxVal: Float
                            if (isNormalized) {
                                minVal = allTimeMin[metric] ?: 0f
                                maxVal = (allTimeMax[metric] ?: 1f).coerceAtLeast(minVal + 0.1f)
                            } else {
                                minVal = values.minOrNull() ?: 0f
                                maxVal = (values.maxOrNull() ?: 1f).coerceAtLeast(minVal + 0.1f)
                            }
                            val range = maxVal - minVal

                            val plotPoints: List<Pair<Int, Float>> = indexedValues.map { (idx, value) ->
                                Pair(idx, ((value - minVal) / range).coerceIn(0f, 1f))
                            }

                            // Dotted average
                            if (plotPoints.isNotEmpty()) {
                                val avgNormalized = plotPoints.map { it.second }.average().toFloat()
                                val avgY = padding + graphHeight - (avgNormalized * graphHeight)
                                var x = padding
                                while (x < size.width - padding) {
                                    drawLine(
                                        color.copy(alpha = 0.5f),
                                        Offset(x, avgY),
                                        Offset((x + dashWidth).coerceAtMost(size.width - padding), avgY),
                                        strokeWidth = 1.5.dp.toPx()
                                    )
                                    x += dashWidth + gapWidth
                                }
                            }

                            // Line
                            if (plotPoints.size > 1) {
                                val path = Path()
                                plotPoints.forEachIndexed { i, pair ->
                                    val x = padding + (pair.first.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                    val y = padding + graphHeight - (pair.second * graphHeight)
                                    if (i == 0) path.moveTo(x, y) else path.lineTo(x, y)
                                }
                                drawPath(path, color, style = Stroke(2.dp.toPx(), cap = StrokeCap.Round, join = StrokeJoin.Round))
                            }

                            // Dots
                            for (pair in plotPoints) {
                                val x = padding + (pair.first.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                val y = padding + graphHeight - (pair.second * graphHeight)
                                drawCircle(color, 4.dp.toPx(), Offset(x, y))
                            }
                        }
                    }
                }

                // Date labels
                Spacer(Modifier.height(4.dp))
                Row(
                    modifier = Modifier.fillMaxWidth().padding(start = yAxisWidth),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    val fmt = DateTimeFormatter.ofPattern("MMM d")
                    if (historyData.isNotEmpty()) {
                        val firstLabel = try { LocalDate.parse(historyData.first().date).format(fmt) } catch (_: Exception) { historyData.first().date }
                        val lastLabel = try { LocalDate.parse(historyData.last().date).format(fmt) } catch (_: Exception) { historyData.last().date }
                        Text(text = firstLabel, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(text = lastLabel, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }

        Spacer(Modifier.height(12.dp))

        Text(
            text = "Select Metrics" + if (selectedMetrics.size > 1) " (${selectedMetrics.size} selected)" else "",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )
        Spacer(Modifier.height(8.dp))

        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(6.dp),
            verticalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            for (metric in SleepCardConfig.GRAPHABLE_METRICS) {
                val isSelected = metric in selectedMetrics
                val chipColor = SleepCardConfig.colorFor(metric)
                val chipLabel = SleepCardConfig.labelFor(metric)

                FilterChip(
                    selected = isSelected,
                    onClick = {
                        selectedMetrics = if (isSelected) {
                            selectedMetrics.minus(metric)
                        } else {
                            selectedMetrics.plus(metric)
                        }
                    },
                    label = { Text(text = chipLabel, style = MaterialTheme.typography.labelSmall) },
                    colors = FilterChipDefaults.filterChipColors(
                        selectedContainerColor = chipColor.copy(alpha = 0.3f),
                        selectedLabelColor = chipColor,
                        containerColor = AppTheme.BaseCardContainer,
                        labelColor = AppTheme.SubtleTextColor
                    ),
                    border = FilterChipDefaults.filterChipBorder(
                        borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        selectedBorderColor = chipColor,
                        enabled = true,
                        selected = isSelected
                    )
                )
            }
        }
    }
}

private fun getSleepDayValue(day: SleepGraphDay, metric: String): Float? {
    return when (metric) {
        SleepCardConfig.METRIC_DURATION -> day.duration?.toFloat()
        SleepCardConfig.METRIC_SCORE -> day.score?.toFloat()
        SleepCardConfig.METRIC_EFFICIENCY -> day.efficiency?.toFloat()
        SleepCardConfig.METRIC_DISTURBANCES -> day.disturbances?.toFloat()
        SleepCardConfig.METRIC_STAGES_DEEP -> day.stagesDeep?.toFloat()
        SleepCardConfig.METRIC_STAGES_REM -> day.stagesRem?.toFloat()
        SleepCardConfig.METRIC_STAGES_LIGHT -> day.stagesLight?.toFloat()
        else -> null
    }
}

private fun formatSleepValue(value: Float, unit: String): String {
    return when (unit) {
        "h" -> String.format("%.1f%s", value, unit)
        "%" -> "${value.toInt()}%"
        else -> value.toInt().toString()
    }
}

private suspend fun loadSleepGraphData(
    ctx: android.content.Context,
    days: Int,
    endDate: java.time.LocalDate = java.time.LocalDate.now()
): SleepGraphResult = withContext(Dispatchers.IO) {
    try {
        val token = SessionStore.getValidAccessToken(ctx) ?: return@withContext SleepGraphResult(emptyList(), emptyMap(), emptyMap())
        val metrics = SupabaseMetricsService(ctx)

        val startDate = endDate.minusDays(days.toLong() - 1)

        // Fetch enough data to cover the window (fetch extra to be safe)
        val fetchLimit = days + 14
        val durations = try { metrics.fetchSleepDurationDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val scores = try { metrics.fetchSleepScoreDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val efficiencies = try { metrics.fetchSleepEfficiencyDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val disturbances = try { metrics.fetchSleepDisturbancesDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }
        val stages = try { metrics.fetchSleepStagesDaily(token, fetchLimit) } catch (_: Exception) { emptyList() }

        val scoreMap = scores.associateBy { it.date }
        val effMap = efficiencies.associateBy { it.date }
        val distMap = disturbances.associateBy { it.date }
        val stagesMap = stages.associateBy { it.date }

        // Build all days in the window, filter to date range
        val startStr = startDate.toString()
        val endStr = endDate.toString()

        val graphDays: List<SleepGraphDay> = durations
            .filter { it.date >= startStr && it.date <= endStr }
            .map { dur ->
                val score = scoreMap[dur.date]
                val eff = effMap[dur.date]
                val dist = distMap[dur.date]
                val stg = stagesMap[dur.date]
                SleepGraphDay(
                    date = dur.date,
                    duration = dur.value_hours,
                    score = score?.value_pct,
                    efficiency = eff?.value_pct,
                    disturbances = dist?.value_count,
                    stagesDeep = stg?.value_sws_hm,
                    stagesRem = stg?.value_rem_hm,
                    stagesLight = stg?.value_light_hm
                )
            }.sortedBy { it.date }

        val allTimeMin = mutableMapOf<String, Float>()
        val allTimeMax = mutableMapOf<String, Float>()

        for (metric in SleepCardConfig.GRAPHABLE_METRICS) {
            val values: List<Float> = graphDays.mapNotNull { getSleepDayValue(it, metric) }
            if (values.isNotEmpty()) {
                allTimeMin[metric] = values.minOrNull() ?: 0f
                allTimeMax[metric] = values.maxOrNull() ?: 1f
            }
        }

        SleepGraphResult(graphDays, allTimeMin, allTimeMax)
    } catch (_: Exception) {
        SleepGraphResult(emptyList(), emptyMap(), emptyMap())
    }
}


title: SleepSyncStatus.kt
text:
// FILE: C:\Users\verwe\Projects\MigraineMe\app\src\main\java\com\migraineme\SleepSyncStatus.kt
package com.migraineme

import android.content.Context
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.work.WorkInfo
import androidx.work.WorkManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId

/**
 * Renders a compact status text for WHOOP sleep sync/backfill and the 09:00 WorkManager job.
 *
 * Usage in a screen:
 *   val auth by authVm.state.collectAsState()
 *   SleepSyncStatus(accessToken = auth.accessToken)
 */
@Composable
fun SleepSyncStatus(
    accessToken: String?,
    modifier: Modifier = Modifier
) {
    val ctx = LocalContext.current.applicationContext
    var text by remember { mutableStateOf("Loading sleep sync status…") }

    LaunchedEffect(accessToken) {
        text = buildStatusText(ctx, accessToken)
    }

    Column(modifier = modifier) {
        Text(text = text, style = MaterialTheme.typography.bodyMedium)
        Spacer(Modifier.height(8.dp))
    }
}

private suspend fun buildStatusText(ctx: Context, accessToken: String?): String = withContext(Dispatchers.IO) {
    val zone = ZoneId.systemDefault()
    val today = LocalDate.now(zone)
    val yesterday = today.minusDays(1)

    val whoopConnected = (WhoopTokenStore(ctx).load() != null)

    val token = accessToken ?: SessionStore.readAccessToken(ctx)

    val metrics = SupabaseMetricsService(ctx)
    val latestDate: String? = if (!token.isNullOrBlank()) {
        runCatching { metrics.latestSleepDate(token, source = "whoop") }.getOrNull()
    } else null

    val backfillStart = latestDate?.let { runCatching { LocalDate.parse(it).plusDays(1) }.getOrNull() }
    val backfillWindow =
        if (backfillStart != null && backfillStart.isBefore(today)) {
            val end = yesterday
            val days = if (!end.isBefore(backfillStart)) (end.toEpochDay() - backfillStart.toEpochDay() + 1).toInt() else 0
            if (days > 0) "${backfillStart} → $end ($days days)" else "Up to date"
        } else {
            "Up to date"
        }

    val (jobState, jobCount) = readWorkState(ctx, "whoop_daily_sync_sleep_fields_9am")

    buildString {
        appendLine("Sleep sync status")
        appendLine("• WHOOP connected: ${if (whoopConnected) "Yes" else "No"}")
        appendLine("• Latest Supabase date (whoop): ${latestDate ?: "—"}")
        appendLine("• Backfill window: $backfillWindow")
        append("• Daily 09:00 job: $jobState${if (jobCount > 1) " ($jobCount entries)" else ""}")
    }
}

private fun readWorkState(ctx: Context, uniqueName: String): Pair<String, Int> {
    return try {
        val infos = WorkManager.getInstance(ctx).getWorkInfosForUniqueWork(uniqueName).get()
        if (infos.isNullOrEmpty()) return "Not scheduled" to 0
        val state = prioritizeWorkStates(infos.map { it.state })
        state to infos.size
    } catch (_: Throwable) {
        "Unknown" to 0
    }
}

private fun prioritizeWorkStates(states: List<WorkInfo.State>): String {
    return when {
        states.any { it == WorkInfo.State.RUNNING } -> "RUNNING"
        states.any { it == WorkInfo.State.ENQUEUED } -> "ENQUEUED"
        states.any { it == WorkInfo.State.BLOCKED } -> "BLOCKED"
        states.any { it == WorkInfo.State.SUCCEEDED } -> "SUCCEEDED"
        states.any { it == WorkInfo.State.FAILED } -> "FAILED"
        states.any { it == WorkInfo.State.CANCELLED } -> "CANCELLED"
        else -> states.firstOrNull()?.name ?: "Unknown"
    }
}

title: SpiderChartCanvas.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Fill
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import kotlin.math.PI
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.sin

/**
 * Data for one axis of the spider chart.
 * @param label  The category name shown at the tip
 * @param value  Actual count / score
 * @param maxValue  Max value for normalisation (defaults to global max if null)
 */
data class SpiderAxis(
    val label: String,
    val value: Float,
    val maxValue: Float? = null
)

/**
 * A beautiful radar / spider chart.
 *
 * @param axes        List of 3+ axes to render
 * @param accentColor Fill & stroke colour for the data polygon
 * @param gridColor   Colour of the concentric grid rings
 * @param labelColor  Colour of the axis labels
 * @param gridRings   Number of concentric rings (default 4)
 * @param size        Canvas size
 * @param fillAlpha   Alpha of the filled polygon
 */
@Composable
fun SpiderChart(
    axes: List<SpiderAxis>,
    accentColor: Color = AppTheme.AccentPurple,
    gridColor: Color = Color.White.copy(alpha = 0.35f),
    labelColor: Color = Color.White.copy(alpha = 0.85f),
    gridRings: Int = 4,
    size: Dp = 180.dp,
    fillAlpha: Float = 0.25f,
    secondAxes: List<SpiderAxis>? = null,
    secondColor: Color = Color(0xFF81C784)
) {
    if (axes.size < 3) return

    Box(modifier = Modifier.size(size), contentAlignment = Alignment.Center) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val cx = this.size.width / 2f
            val cy = this.size.height / 2f
            val radius = (minOf(this.size.width, this.size.height) / 2f) * 0.58f
            val n = axes.size
            val globalMax = axes.maxOf { it.maxValue ?: it.value }.coerceAtLeast(1f)

            // Angle per axis (start at top, -90°)
            fun angle(i: Int): Float = (2f * PI.toFloat() * i / n) - (PI.toFloat() / 2f)

            fun pointOnAxis(i: Int, fraction: Float): Offset {
                val a = angle(i)
                return Offset(cx + radius * fraction * cos(a), cy + radius * fraction * sin(a))
            }

            // Draw concentric grid rings
            for (ring in 1..gridRings) {
                val frac = ring.toFloat() / gridRings
                val path = Path().apply {
                    for (i in 0 until n) {
                        val p = pointOnAxis(i, frac)
                        if (i == 0) moveTo(p.x, p.y) else lineTo(p.x, p.y)
                    }
                    close()
                }
                drawPath(path, gridColor, style = Stroke(width = 1f))
            }

            // Draw axis lines from centre to each tip
            for (i in 0 until n) {
                val tip = pointOnAxis(i, 1f)
                drawLine(gridColor.copy(alpha = 0.5f), Offset(cx, cy), tip, strokeWidth = 1f)
            }

            // Draw primary data polygon
            val dataPath = Path().apply {
                for (i in 0 until n) {
                    val maxVal = axes[i].maxValue ?: globalMax
                    val norm = (axes[i].value / maxVal).coerceIn(0f, 1f)
                    val frac = if (axes[i].value > 0f && norm < 0.08f) 0.08f else norm
                    val p = pointOnAxis(i, frac)
                    if (i == 0) moveTo(p.x, p.y) else lineTo(p.x, p.y)
                }
                close()
            }
            drawPath(dataPath, accentColor.copy(alpha = fillAlpha), style = Fill)
            drawPath(dataPath, accentColor, style = Stroke(width = 2.5f, cap = StrokeCap.Round))

            // Draw dots on primary vertices
            for (i in 0 until n) {
                val maxVal = axes[i].maxValue ?: globalMax
                val norm = (axes[i].value / maxVal).coerceIn(0f, 1f)
                val frac = if (axes[i].value > 0f && norm < 0.08f) 0.08f else norm
                val p = pointOnAxis(i, frac)

                // Relief effectiveness circles (behind dot)
                if (secondAxes != null && secondAxes.size == n) {
                    val reliefVal = secondAxes[i].value // 0-3 scale
                    val maxRelief = secondAxes[i].maxValue ?: 3f
                    val reliefFrac = (reliefVal / maxRelief).coerceIn(0f, 1f)
                    if (reliefFrac > 0f) {
                        val maxCircleRadius = radius * 0.12f
                        val circleRadius = maxCircleRadius * reliefFrac
                        drawCircle(secondColor.copy(alpha = 0.3f), circleRadius, p)
                        drawCircle(secondColor.copy(alpha = 0.6f), circleRadius, p, style = Stroke(width = 1.5f))
                    }
                }

                drawCircle(accentColor, 4f, p)
                drawCircle(Color.White, 2f, p)
            }

            // Draw labels — pass accentColor and secondAxes for relief labels
            drawLabels(axes, cx, cy, radius, n, accentColor, secondAxes) { angle(it) }
        }
    }
}

private fun DrawScope.drawLabels(
    axes: List<SpiderAxis>,
    cx: Float, cy: Float, radius: Float, n: Int,
    accentColor: Color,
    secondAxes: List<SpiderAxis>? = null,
    angle: (Int) -> Float
) {
    val density = this.size.width / 180f
    val textSize = (11f * density).coerceIn(20f, 30f)
    val reliefTextSize = (9f * density).coerceIn(16f, 24f)

    val paint = android.graphics.Paint().apply {
        color = android.graphics.Color.argb(
            (accentColor.alpha * 255).toInt(),
            (accentColor.red * 255).toInt(),
            (accentColor.green * 255).toInt(),
            (accentColor.blue * 255).toInt()
        )
        this.textSize = textSize
        isAntiAlias = true
        typeface = android.graphics.Typeface.create("sans-serif-medium", android.graphics.Typeface.NORMAL)
    }

    for (i in 0 until n) {
        val a = angle(i)
        val labelRadius = radius * 1.38f
        val lx = cx + labelRadius * cos(a)
        val ly = cy + labelRadius * sin(a)

        // Combined label: "Category (count)"
        val fullLabel = "${axes[i].label} (${axes[i].value.toInt()})"
        val textWidth = paint.measureText(fullLabel)

        // Truncate if needed
        val maxLabelWidth = radius * 1.1f
        val displayLabel = if (textWidth > maxLabelWidth) {
            val countSuffix = " (${axes[i].value.toInt()})"
            val availableWidth = maxLabelWidth - paint.measureText(countSuffix)
            var truncated = axes[i].label
            while (paint.measureText("$truncated…") > availableWidth && truncated.length > 2) {
                truncated = truncated.dropLast(1)
            }
            "$truncated…$countSuffix"
        } else fullLabel

        val finalWidth = paint.measureText(displayLabel)

        // Horizontal alignment
        val tx = when {
            cos(a) > 0.3f -> lx + 4f
            cos(a) < -0.3f -> lx - finalWidth - 4f
            else -> lx - finalWidth / 2f
        }
        // Vertical alignment
        val ty = when {
            sin(a) > 0.3f -> ly + textSize + 4f
            sin(a) < -0.3f -> ly - 4f
            else -> ly + textSize / 3f
        }

        drawContext.canvas.nativeCanvas.drawText(displayLabel, tx, ty, paint)

        // Draw relief effectiveness label below if secondAxes provided
        if (secondAxes != null && i < secondAxes.size) {
            val reliefVal = secondAxes[i].value
            val reliefLabel = when {
                reliefVal >= 2.5f -> "High"
                reliefVal >= 1.5f -> "Mild"
                reliefVal >= 0.5f -> "Low"
                else -> "None"
            }
            val reliefColor = when {
                reliefVal >= 2.5f -> android.graphics.Color.argb(200, 129, 199, 132)  // green
                reliefVal >= 1.5f -> android.graphics.Color.argb(200, 255, 183, 77)   // orange
                reliefVal >= 0.5f -> android.graphics.Color.argb(200, 229, 115, 115)  // red
                else -> android.graphics.Color.argb(150, 150, 150, 150)               // grey
            }
            val reliefPaint = android.graphics.Paint(paint).apply {
                this.textSize = reliefTextSize
                color = reliefColor
            }
            val rw = reliefPaint.measureText(reliefLabel)
            val rx = when {
                cos(a) > 0.3f -> tx + (finalWidth - rw) / 2f
                cos(a) < -0.3f -> tx + (finalWidth - rw) / 2f
                else -> lx - rw / 2f
            }
            drawContext.canvas.nativeCanvas.drawText(reliefLabel, rx, ty + reliefTextSize + 2f, reliefPaint)
        }
    }
}

/**
 * Stacked proportional bar for 1–2 category display (fallback when < 3 axes).
 */
@Composable
fun StackedProportionalBar(
    axes: List<SpiderAxis>,
    colors: List<Color> = listOf(Color(0xFFFF8A65), Color(0xFFBA68C8), Color(0xFF4FC3F7), Color(0xFF81C784)),
    accentColor: Color = AppTheme.AccentPurple
) {
    if (axes.isEmpty()) return
    val total = axes.sumOf { it.value.toDouble() }.toFloat().coerceAtLeast(1f)

    // Single category — stat card
    if (axes.size == 1) {
        val axis = axes[0]
        val color = colors.getOrElse(0) { accentColor }
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp)
                .clip(androidx.compose.foundation.shape.RoundedCornerShape(12.dp))
                .background(Color.White.copy(alpha = 0.04f))
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(
                    "${axis.value.toInt()}",
                    color = color,
                    style = androidx.compose.material3.MaterialTheme.typography.headlineMedium.copy(
                        fontWeight = androidx.compose.ui.text.font.FontWeight.ExtraBold
                    )
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    axis.label,
                    color = AppTheme.BodyTextColor,
                    style = androidx.compose.material3.MaterialTheme.typography.bodyMedium.copy(
                        fontWeight = androidx.compose.ui.text.font.FontWeight.Medium
                    )
                )
                Text(
                    "100% of total",
                    color = AppTheme.SubtleTextColor,
                    style = androidx.compose.material3.MaterialTheme.typography.labelSmall
                )
            }
        }
        return
    }

    Column(modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp)) {
        // Labels row
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = if (axes.size == 1) Arrangement.Center else Arrangement.SpaceBetween
        ) {
            axes.forEachIndexed { i, axis ->
                val color = colors.getOrElse(i) { accentColor }
                Column(
                    horizontalAlignment = when {
                        axes.size == 1 -> Alignment.CenterHorizontally
                        i == 0 -> Alignment.Start
                        else -> Alignment.End
                    }
                ) {
                    Text(
                        axis.label,
                        color = color,
                        style = androidx.compose.material3.MaterialTheme.typography.bodySmall.copy(
                            fontWeight = androidx.compose.ui.text.font.FontWeight.SemiBold
                        )
                    )
                    Text(
                        "${axis.value.toInt()} (${((axis.value / total) * 100).toInt()}%)",
                        color = AppTheme.SubtleTextColor,
                        style = androidx.compose.material3.MaterialTheme.typography.labelSmall
                    )
                }
            }
        }

        Spacer(Modifier.height(8.dp))

        // Stacked bar
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(12.dp)
                .clip(androidx.compose.foundation.shape.RoundedCornerShape(6.dp))
                .background(Color.White.copy(alpha = 0.04f))
        ) {
            Row(modifier = Modifier.fillMaxSize()) {
                axes.forEachIndexed { i, axis ->
                    val fraction = axis.value / total
                    val color = colors.getOrElse(i) { accentColor }
                    val shape = when {
                        axes.size == 1 -> androidx.compose.foundation.shape.RoundedCornerShape(6.dp)
                        i == 0 -> androidx.compose.foundation.shape.RoundedCornerShape(topStart = 6.dp, bottomStart = 6.dp)
                        i == axes.lastIndex -> androidx.compose.foundation.shape.RoundedCornerShape(topEnd = 6.dp, bottomEnd = 6.dp)
                        else -> androidx.compose.foundation.shape.RoundedCornerShape(0.dp)
                    }
                    Box(
                        modifier = Modifier
                            .weight(fraction.coerceAtLeast(0.01f))
                            .fillMaxHeight()
                            .clip(shape)
                            .background(color)
                    )
                }
            }
        }

        Spacer(Modifier.height(4.dp))

        // Total
        Text(
            "${total.toInt()} total logged",
            color = AppTheme.SubtleTextColor,
            style = androidx.compose.material3.MaterialTheme.typography.labelSmall,
            modifier = Modifier.fillMaxWidth(),
            textAlign = androidx.compose.ui.text.style.TextAlign.Center
        )
    }
}

title: SupabaseAmbientNoiseService.kt
text:
package com.migraineme

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Writes derived ambient noise samples to:
 * - public.ambient_noise_samples
 *
 * Table (as created earlier):
 * - id uuid default gen_random_uuid()
 * - user_id uuid NOT NULL
 * - start_ts timestamptz NOT NULL
 * - duration_s int NOT NULL
 * - l_mean double precision NOT NULL
 * - l_p90 double precision NULL
 * - l_max double precision NULL
 * - quality_flags jsonb default {}
 * - created_at timestamptz default now()
 */
class SupabaseAmbientNoiseService {

    private val supabaseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true; encodeDefaults = true; explicitNulls = false })
        }
    }

    @Serializable
    private data class AmbientNoiseInsert(
        @SerialName("user_id") val userId: String,
        @SerialName("start_ts") val startTs: String,
        @SerialName("duration_s") val durationS: Int,
        @SerialName("l_mean") val lMean: Double,
        @SerialName("l_p90") val lP90: Double? = null,
        @SerialName("l_max") val lMax: Double? = null,
        @SerialName("quality_flags") val qualityFlags: Map<String, String> = emptyMap()
    )

    suspend fun insertAmbientNoiseSample(
        accessToken: String,
        userId: String,
        startTsIso: String,
        durationS: Int,
        lMean: Double,
        lP90: Double?,
        lMax: Double?,
        qualityFlags: Map<String, String>
    ) {
        val payload = AmbientNoiseInsert(
            userId = userId,
            startTs = startTsIso,
            durationS = durationS,
            lMean = lMean,
            lP90 = lP90,
            lMax = lMax,
            qualityFlags = qualityFlags
        )

        val resp: HttpResponse = client.post("$supabaseUrl/rest/v1/ambient_noise_samples") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            // No need to return rows; keeps bandwidth low.
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }

        if (!resp.status.isSuccess()) {
            error("Insert ambient_noise_samples failed: ${resp.bodyAsText()}")
        }
    }
}

title: SupabaseAuthService.kt
text:
package com.migraineme

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.put
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonObject

object SupabaseAuthService {
    private val baseUrl: String = BuildConfig.SUPABASE_URL
    private val anonKey: String = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient(Android) {
        install(ContentNegotiation) {
            json(
                Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                    encodeDefaults = true
                }
            )
        }
    }

    @Serializable
    data class PasswordGrantRequest(val email: String, val password: String)

    @Serializable
    data class SignUpRequest(val email: String, val password: String)

    @Serializable
    data class IdTokenGrantRequest(
        val provider: String,
        @SerialName("id_token") val idToken: String,
        val nonce: String? = null
    )

    @Serializable
    data class RefreshTokenGrantRequest(
        @SerialName("refresh_token") val refreshToken: String
    )

    @Serializable
    data class SessionResponse(
        @SerialName("access_token") val accessToken: String? = null,
        @SerialName("refresh_token") val refreshToken: String? = null,
        @SerialName("token_type") val tokenType: String? = null,
        @SerialName("expires_in") val expiresIn: Long? = null
    )

    @Serializable
    data class Identity(
        val provider: String? = null
    )

    @Serializable
    data class UserResponse(
        val id: String? = null,
        val email: String? = null,
        val identities: List<Identity>? = null,
        @SerialName("user_metadata") val userMetadata: JsonObject? = null
    )

    @Serializable
    data class UpdateUserRequest(
        val password: String
    )

    @Serializable
    data class RecoverRequest(
        val email: String
    )

    suspend fun signInWithEmail(email: String, password: String): SessionResponse {
        val url = "$baseUrl/auth/v1/token?grant_type=password"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(PasswordGrantRequest(email, password))
        }.body()
    }

    suspend fun signUpWithEmail(email: String, password: String): SessionResponse {
        val url = "$baseUrl/auth/v1/signup"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(SignUpRequest(email, password))
        }.body()
    }

    /**
     * Native mobile Google sign-in:
     * - You obtain a Google ID token on-device (Credential Manager)
     * - Exchange it for a Supabase session (access_token / refresh_token)
     */
    suspend fun signInWithGoogleIdToken(idToken: String, nonce: String? = null): SessionResponse {
        val url = "$baseUrl/auth/v1/token?grant_type=id_token"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(
                IdTokenGrantRequest(
                    provider = "google",
                    idToken = idToken,
                    nonce = nonce
                )
            )
        }.body()
    }

    /**
     * Refreshes a Supabase session using a refresh_token.
     * Supabase: POST /auth/v1/token?grant_type=refresh_token
     */
    suspend fun refreshSession(refreshToken: String): SessionResponse {
        val url = "$baseUrl/auth/v1/token?grant_type=refresh_token"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(RefreshTokenGrantRequest(refreshToken = refreshToken))
        }.body()
    }

    suspend fun signOut(accessToken: String) {
        val url = "$baseUrl/auth/v1/logout"
        client.post(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
        }
    }

    /**
     * Used to determine whether the current user has an email identity.
     */
    suspend fun getUser(accessToken: String): UserResponse {
        val url = "$baseUrl/auth/v1/user"
        return client.get(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
        }.body()
    }

    /**
     * Changes password for current authenticated user.
     * Supabase: PUT /auth/v1/user { "password": "..." }
     */
    suspend fun changePassword(accessToken: String, newPassword: String): UserResponse {
        val url = "$baseUrl/auth/v1/user"
        return client.put(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
            contentType(ContentType.Application.Json)
            setBody(UpdateUserRequest(password = newPassword))
        }.body()
    }

    /**
     * Sends password recovery email (reset link) for email/password accounts.
     * Supabase: POST /auth/v1/recover { "email": "..." }
     *
     * If redirectTo is provided, Supabase will redirect the recovery link to that URL
     * (it must be allowed in Supabase Auth Redirect URLs).
     */
    suspend fun requestPasswordReset(email: String, redirectTo: String? = null) {
        val url = "$baseUrl/auth/v1/recover"
        client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            if (!redirectTo.isNullOrBlank()) {
                parameter("redirect_to", redirectTo)
            }
            setBody(RecoverRequest(email = email))
        }
    }
}

title: SupabaseDbService.kt
text:
// app/src/main/java/com/migraineme/SupabaseDbService.kt
package com.migraineme

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import java.time.Instant

class SupabaseDbService(
    private val supabaseUrl: String,
    private val supabaseKey: String
) {
    @OptIn(ExperimentalSerializationApi::class)
    private val client = HttpClient {
        install(ContentNegotiation) {
            json(
                Json {
                    ignoreUnknownKeys = true
                    encodeDefaults = true
                    explicitNulls = false
                }
            )
        }
    }

    private fun HttpStatusCode.isSuccess(): Boolean = value in 200..299

    // ───────── MIGRAINES ─────────
    @Serializable
    data class MigraineRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        val severity: Int? = null,
        @SerialName("start_at") val startAt: String,
        @SerialName("ended_at") val endAt: String? = null,
        val notes: String? = null,
        @SerialName("pain_locations") val painLocations: List<String>? = null
    )
    @Serializable
    data class MigraineInsert(
        val type: String? = null,
        val severity: Int? = null,
        @SerialName("start_at") val startAt: String,
        @SerialName("ended_at") val endAt: String? = null,
        val notes: String? = null,
        @SerialName("pain_locations") val painLocations: List<String>? = null
    )
    /** Lightweight row for migraine linking. */
    @Serializable data class MigraneSummaryRow(
        val id: String,
        val type: String? = null,
        val severity: Int? = null,
        @SerialName("start_at") val startAt: String
    )

    /** Fetch migraines within a date range for linking in quick log. */
    suspend fun getNearbyMigraines(accessToken: String, fromDate: String, toDate: String): List<MigraneSummaryRow> {
        val response = client.get("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "id,type,severity,start_at")
            parameter("and", "(start_at.gte.${fromDate}T00:00:00Z,start_at.lte.${toDate}T23:59:59Z)")
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    /** All items linked to a specific migraine, for display on the journal card. */
    data class MigraineLinkedItems(
        val triggers: List<TriggerRow> = emptyList(),
        val medicines: List<MedicineRow> = emptyList(),
        val reliefs: List<ReliefRow> = emptyList(),
        val prodromes: List<ProdromeLogRow> = emptyList(),
        val activities: List<ActivityLogRow> = emptyList(),
        val locations: List<LocationLogRow> = emptyList()
    )

    suspend fun getLinkedItems(accessToken: String, migraineId: String): MigraineLinkedItems {
        suspend fun fetchTriggers(table: String): List<TriggerRow> {
            val r = client.get("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("migraine_id", "eq.$migraineId")
                parameter("order", "start_at.asc")
            }
            return if (r.status.isSuccess()) r.body() else emptyList()
        }
        suspend fun fetchMedicines(table: String): List<MedicineRow> {
            val r = client.get("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("migraine_id", "eq.$migraineId")
                parameter("order", "start_at.asc")
            }
            return if (r.status.isSuccess()) r.body() else emptyList()
        }
        suspend fun fetchReliefs(table: String): List<ReliefRow> {
            val r = client.get("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("migraine_id", "eq.$migraineId")
                parameter("order", "start_at.asc")
            }
            return if (r.status.isSuccess()) r.body() else emptyList()
        }
        suspend fun fetchProdromes(table: String): List<ProdromeLogRow> {
            val r = client.get("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("migraine_id", "eq.$migraineId")
                parameter("order", "start_at.asc")
            }
            return if (r.status.isSuccess()) r.body() else emptyList()
        }
        suspend fun fetchActivities(table: String): List<ActivityLogRow> {
            val r = client.get("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("migraine_id", "eq.$migraineId")
                parameter("order", "start_at.asc")
            }
            return if (r.status.isSuccess()) r.body() else emptyList()
        }
        suspend fun fetchLocations(table: String): List<LocationLogRow> {
            val r = client.get("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("migraine_id", "eq.$migraineId")
                parameter("order", "start_at.asc")
            }
            return if (r.status.isSuccess()) r.body() else emptyList()
        }
        return MigraineLinkedItems(
            triggers = fetchTriggers("triggers"),
            medicines = fetchMedicines("medicines"),
            reliefs = fetchReliefs("reliefs"),
            prodromes = fetchProdromes("prodromes"),
            activities = fetchActivities("time_in_high_hr_zones_daily"),
            locations = fetchLocations("locations")
        )
    }

    suspend fun insertMigraine(
        accessToken: String,
        type: String?,
        severity: Int?,
        startAt: String?,
        endAt: String?,
        notes: String?,
        painLocations: List<String>? = null
    ): MigraineRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = MigraineInsert(type, severity, safeStart, endAt, notes, painLocations)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert migraine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getMigraines(accessToken: String): List<MigraineRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch migraines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getMigraineById(accessToken: String, id: String): MigraineRow {
        val response = client.get("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get migraine by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMigraine(
        accessToken: String,
        id: String,
        type: String? = null,
        severity: Int? = null,
        startAt: String? = null,
        endAt: String? = null,
        notes: String? = null,
        painLocations: List<String>? = null
    ): MigraineRow {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            severity?.let { put("severity", it) }
            startAt?.let { put("start_at", it) }
            endAt?.let { put("ended_at", it) }
            notes?.let { put("notes", it) }
            painLocations?.let { locs ->
                put("pain_locations", kotlinx.serialization.json.JsonArray(locs.map { kotlinx.serialization.json.JsonPrimitive(it) }))
            }
        }
        val response = client.patch("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update migraine failed: ${response.bodyAsText()}")
        return response.body()
    }
    /** Set migraine_id to null on any table row, unlinking it from a migraine. */
    suspend fun unlinkFromMigraine(accessToken: String, table: String, id: String) {
        val payload = buildJsonObject { put("migraine_id", kotlinx.serialization.json.JsonNull) }
        client.patch("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
    }

    /** Set migraine_id on any table row, linking it to a migraine. */
    suspend fun linkToMigraine(accessToken: String, table: String, id: String, migraineId: String) {
        val payload = buildJsonObject { put("migraine_id", migraineId) }
        client.patch("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
    }

    suspend fun deleteMigraine(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete migraine failed: ${response.bodyAsText()}")
    }

    // ───────── TRIGGERS ─────────
    @Serializable
    data class TriggerRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual",  // ADD THIS LINE
        val active: Boolean = true       // ADD THIS LINE
    )
    @Serializable
    data class TriggerInsert(
        val type: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual",  // ADD THIS LINE
        val active: Boolean = true       // ADD THIS LINE
    )
    suspend fun insertTrigger(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        notes: String?
    ): TriggerRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = TriggerInsert(type, safeStart, notes, migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert trigger failed: ${response.bodyAsText()}")
        return response.body()
    }

    /** Lightweight row for recent trigger queries. */
    @Serializable data class RecentTriggerRow(
        val id: String,
        val type: String? = null,
        @SerialName("start_at") val startAt: String? = null
    )

    /** Fetch trigger types logged in the last [daysBack] days. */
    suspend fun getRecentTriggers(accessToken: String, daysBack: Int = 3, referenceDate: String? = null): List<RecentTriggerRow> {
        val refDate = referenceDate?.let {
            try { java.time.LocalDate.parse(it.substring(0, 10)) } catch (_: Exception) { null }
        } ?: java.time.LocalDate.now()
        val cutoffStart = refDate.minusDays(daysBack.toLong()).toString() + "T00:00:00Z"
        val cutoffEnd = refDate.plusDays(1).toString() + "T00:00:00Z"
        val response = client.get("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "id,type,start_at")
            parameter("start_at", "gte.$cutoffStart")
            parameter("start_at", "lte.$cutoffEnd")
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    suspend fun getAllTriggers(accessToken: String): List<TriggerRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch triggers failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getTriggerById(accessToken: String, id: String): TriggerRow {
        val response = client.get("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get trigger by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateTrigger(
        accessToken: String,
        id: String,
        type: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null,
        clearMigraineId: Boolean = false
    ): TriggerRow {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
            if (clearMigraineId) put("migraine_id", kotlinx.serialization.json.JsonNull)
            else migraineId?.let { put("migraine_id", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update trigger failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteTrigger(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete trigger failed: ${response.bodyAsText()}")
    }

    // ───────── MEDICINES ─────────
    @Serializable
    data class MedicineRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val name: String? = null,
        val amount: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        val category: String? = null,
        @SerialName("relief_scale") val reliefScale: String? = "NONE",
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual"
    )
    @Serializable
    data class MedicineInsert(
        val name: String? = null,
        val amount: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        val category: String? = null,
        @SerialName("relief_scale") val reliefScale: String? = "NONE",
        @SerialName("migraine_id") val migraineId: String? = null
    )
    suspend fun insertMedicine(
        accessToken: String,
        migraineId: String?,
        name: String?,
        amount: String?,
        startAt: String?,
        notes: String?,
        category: String? = null,
        reliefScale: String? = "NONE"
    ): MedicineRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = MedicineInsert(name, amount, safeStart, notes, category, reliefScale, migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert medicine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getAllMedicines(accessToken: String): List<MedicineRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch medicines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getMedicineById(accessToken: String, id: String): MedicineRow {
        val response = client.get("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get medicine by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMedicine(
        accessToken: String,
        id: String,
        name: String? = null,
        amount: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null,
        clearMigraineId: Boolean = false
    ): MedicineRow {
        val payload = buildJsonObject {
            name?.let { put("name", it) }
            if (amount != null) put("amount", amount)
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
            if (clearMigraineId) put("migraine_id", kotlinx.serialization.json.JsonNull)
            else migraineId?.let { put("migraine_id", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update medicine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMedicine(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete medicine failed: ${response.bodyAsText()}")
    }

    // ───────── RELIEFS ─────────
    @Serializable
    data class ReliefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        @SerialName("duration_minutes") val durationMinutes: Int? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        val category: String? = null,
        @SerialName("end_at") val endAt: String? = null,
        @SerialName("relief_scale") val reliefScale: String? = "NONE",
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual"
    )
    @Serializable
    data class ReliefInsert(
        val type: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val category: String? = null,
        @SerialName("end_at") val endAt: String? = null,
        @SerialName("relief_scale") val reliefScale: String? = "NONE",
    )
    suspend fun insertRelief(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        notes: String?,
        endAt: String? = null,
        reliefScale: String? = "NONE"
    ): ReliefRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val safeEnd = endAt?.takeIf { it.isNotBlank() } ?: safeStart
        val payload = ReliefInsert(type = type, startAt = safeStart, notes = notes, migraineId = migraineId, endAt = safeEnd, reliefScale = reliefScale)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert relief failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getAllReliefs(accessToken: String): List<ReliefRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch reliefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getReliefById(accessToken: String, id: String): ReliefRow {
        val response = client.get("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get relief by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateRelief(
        accessToken: String,
        id: String,
        type: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null,
        endAt: String? = null,
        clearMigraineId: Boolean = false
    ): ReliefRow {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
            if (clearMigraineId) put("migraine_id", kotlinx.serialization.json.JsonNull)
            else migraineId?.let { put("migraine_id", it) }
            endAt?.let { put("end_at", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update relief failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteRelief(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete relief failed: ${response.bodyAsText()}")
    }

    // ───────── TRIGGER POOL / PREFS ─────────
    @Serializable data class UserTriggerRow(
        val id: String,
        val label: String,
        val category: String? = null,
        @SerialName("icon_key") val iconKey: String? = null,
        @SerialName("prediction_value") val predictionValue: String? = "NONE",
        val direction: String? = null,
        @SerialName("default_threshold") val defaultThreshold: Double? = null,
        val unit: String? = null,
        @SerialName("enabled_by_default") val enabledByDefault: Boolean = false,
        @SerialName("metric_table") val metricTable: String? = null,
        @SerialName("metric_column") val metricColumn: String? = null,
        @SerialName("display_group") val displayGroup: String? = null
    )
    @Serializable
    data class TriggerPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("trigger_id") val triggerId: String,
        val position: Int,
        val status: String,
        @SerialName("user_triggers") val trigger: UserTriggerRow? = null
    )
    @Serializable private data class UserTriggerInsert(val label: String, val category: String? = null, @SerialName("prediction_value") val predictionValue: String? = "NONE")

    suspend fun getAllTriggerPool(accessToken: String): List<UserTriggerRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key,prediction_value,direction,default_threshold,unit,enabled_by_default,metric_table,metric_column,display_group"); parameter("order", "metric_table.asc.nullslast,metric_column.asc.nullslast,direction.asc.nullslast,label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_triggers failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertTriggerToPool(accessToken: String, label: String, category: String? = null, predictionValue: String? = "NONE"): UserTriggerRow {
        val response = client.post("$supabaseUrl/rest/v1/user_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserTriggerInsert(label, category, predictionValue))
        }
        if (!response.status.isSuccess()) error("Upsert user_triggers failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteTriggerFromPool(accessToken: String, triggerId: String) {
        client.delete("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("trigger_id", "eq.$triggerId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$triggerId")
        }
        if (!response.status.isSuccess()) error("Delete user_triggers failed: ${response.bodyAsText()}")
    }
    suspend fun updateTriggerPoolItem(
        accessToken: String,
        triggerId: String,
        predictionValue: String? = null,
        category: String? = null,
        defaultThreshold: Double? = null
    ) {
        val payload = buildJsonObject {
            predictionValue?.let { put("prediction_value", it) }
            category?.let { put("category", it) }
            defaultThreshold?.let { put("default_threshold", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/user_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("id", "eq.$triggerId")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update user_triggers failed: ${response.bodyAsText()}")
    }
    @Serializable private data class TriggerPrefInsert(@SerialName("trigger_id") val triggerId: String, val position: Int, val status: String)
    suspend fun getTriggerPrefs(accessToken: String): List<TriggerPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,trigger_id,position,status,user_triggers(id,label,icon_key)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch trigger prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertTriggerPref(accessToken: String, triggerId: String, position: Int, status: String = "frequent"): TriggerPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,trigger_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(TriggerPrefInsert(triggerId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert trigger pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    @Serializable private data class TriggerPrefUpdatePosition(val position: Int)
    suspend fun updateTriggerPrefPosition(accessToken: String, prefId: String, newPosition: Int) {
        val response = client.patch("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            contentType(ContentType.Application.Json); setBody(TriggerPrefUpdatePosition(newPosition))
        }
        if (!response.status.isSuccess()) error("Update trigger pref failed: ${response.bodyAsText()}")
    }
    @Serializable private data class TriggerPrefUpdateStatus(val status: String)
    suspend fun updateTriggerPrefStatus(accessToken: String, prefId: String, newStatus: String) {
        val response = client.patch("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            contentType(ContentType.Application.Json); setBody(TriggerPrefUpdateStatus(newStatus))
        }
        if (!response.status.isSuccess()) error("Update trigger status failed: ${response.bodyAsText()}")
    }
    suspend fun deleteTriggerPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete trigger pref failed: ${response.bodyAsText()}")
    }

    // ───────── MEDICINE POOL / PREFS ─────────
    @Serializable data class UserMedicineRow(val id: String, val label: String, val category: String? = null)
    @Serializable
    data class MedicinePrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("medicine_id") val medicineId: String,
        val position: Int,
        val status: String,
        @SerialName("user_medicines") val medicine: UserMedicineRow? = null
    )
    @Serializable private data class UserMedicineInsert(val label: String, val category: String? = null)

    suspend fun getAllMedicinePool(accessToken: String): List<UserMedicineRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_medicines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertMedicineToPool(accessToken: String, label: String, category: String? = null): UserMedicineRow {
        val response = client.post("$supabaseUrl/rest/v1/user_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserMedicineInsert(label, category))
        }
        if (!response.status.isSuccess()) error("Upsert user_medicines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMedicineFromPool(accessToken: String, medicineId: String) {
        client.delete("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("medicine_id", "eq.$medicineId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$medicineId")
        }
        if (!response.status.isSuccess()) error("Delete user_medicines failed: ${response.bodyAsText()}")
    }
    suspend fun setMedicineCategory(accessToken: String, medicineId: String, category: String?) {
        val payload = buildJsonObject { category?.let { put("category", it) } ?: put("category", kotlinx.serialization.json.JsonNull) }
        val response = client.patch("$supabaseUrl/rest/v1/user_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$medicineId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set medicine category failed: ${response.bodyAsText()}")
    }
    @Serializable private data class MedicinePrefInsert(@SerialName("medicine_id") val medicineId: String, val position: Int, val status: String)
    suspend fun getMedicinePrefs(accessToken: String): List<MedicinePrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,medicine_id,position,status,user_medicines(id,label,category)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch medicine prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertMedicinePref(accessToken: String, medicineId: String, position: Int, status: String = "frequent"): MedicinePrefRow {
        val response = client.post("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,medicine_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(MedicinePrefInsert(medicineId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert medicine pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMedicinePref(accessToken: String, prefId: String, position: Int? = null, status: String? = null) {
        val payload = buildJsonObject {
            position?.let { put("position", it) }
            status?.let { put("status", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update medicine pref failed: ${response.bodyAsText()}")
    }
    suspend fun deleteMedicinePref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete medicine pref failed: ${response.bodyAsText()}")
    }

    // ───────── RELIEF POOL / PREFS ─────────
    @Serializable data class UserReliefRow(val id: String, val label: String, val category: String? = null, @SerialName("icon_key") val iconKey: String? = null, @SerialName("is_automatable") val isAutomatable: Boolean = false, @SerialName("is_automated") val isAutomated: Boolean = false)
    @Serializable
    data class ReliefPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("relief_id") val reliefId: String,
        val position: Int,
        val status: String,
        @SerialName("user_reliefs") val relief: UserReliefRow? = null
    )
    @Serializable private data class UserReliefInsert(val label: String, val category: String? = null)

    suspend fun getAllReliefPool(accessToken: String): List<UserReliefRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key,is_automatable,is_automated"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_reliefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertReliefToPool(accessToken: String, label: String, category: String? = null): UserReliefRow {
        val response = client.post("$supabaseUrl/rest/v1/user_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserReliefInsert(label, category))
        }
        if (!response.status.isSuccess()) error("Upsert user_reliefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteReliefFromPool(accessToken: String, reliefId: String) {
        client.delete("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("relief_id", "eq.$reliefId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$reliefId")
        }
        if (!response.status.isSuccess()) error("Delete user_reliefs failed: ${response.bodyAsText()}")
    }
    suspend fun setReliefCategory(accessToken: String, reliefId: String, category: String?) {
        val payload = buildJsonObject { category?.let { put("category", it) } ?: put("category", kotlinx.serialization.json.JsonNull) }
        val response = client.patch("$supabaseUrl/rest/v1/user_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$reliefId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set relief category failed: ${response.bodyAsText()}")
    }
    suspend fun setReliefAutomation(accessToken: String, reliefId: String, enabled: Boolean) {
        val payload = buildJsonObject { put("is_automated", enabled) }
        val response = client.patch("$supabaseUrl/rest/v1/user_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$reliefId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set relief automation failed: ${response.bodyAsText()}")
    }
    @Serializable private data class ReliefPrefInsert(@SerialName("relief_id") val reliefId: String, val position: Int, val status: String)
    suspend fun getReliefPrefs(accessToken: String): List<ReliefPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,relief_id,position,status,user_reliefs(id,label,category,icon_key,is_automatable,is_automated)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch relief prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertReliefPref(accessToken: String, reliefId: String, position: Int, status: String = "frequent"): ReliefPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,relief_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(ReliefPrefInsert(reliefId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert relief pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateReliefPref(accessToken: String, prefId: String, position: Int? = null, status: String? = null) {
        val payload = buildJsonObject {
            position?.let { put("position", it) }
            status?.let { put("status", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update relief pref failed: ${response.bodyAsText()}")
    }
    suspend fun deleteReliefPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete relief pref failed: ${response.bodyAsText()}")
    }

    // ───────── MIGRAINE POOL / PREFS ─────────
    @Serializable data class UserMigrainePoolRow(val id: String, val label: String)
    @Serializable
    data class MigrainePrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("migraine_id") val migraineId: String,
        val position: Int,
        val status: String,
        @SerialName("user_migraines_pool") val migraine: UserMigrainePoolRow? = null
    )
    @Serializable private data class UserMigrainePoolInsert(val label: String)

    suspend fun getAllMigrainePool(accessToken: String): List<UserMigrainePoolRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_migraines_pool") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_migraines_pool failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertMigraineToPool(accessToken: String, label: String): UserMigrainePoolRow {
        val response = client.post("$supabaseUrl/rest/v1/user_migraines_pool") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserMigrainePoolInsert(label))
        }
        if (!response.status.isSuccess()) error("Upsert user_migraines_pool failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMigraineFromPool(accessToken: String, migraineId: String) {
        client.delete("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("migraine_id", "eq.$migraineId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_migraines_pool") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$migraineId")
        }
        if (!response.status.isSuccess()) error("Delete user_migraines_pool failed: ${response.bodyAsText()}")
    }
    @Serializable private data class MigrainePrefInsert(@SerialName("migraine_id") val migraineId: String, val position: Int, val status: String)
    suspend fun getMigrainePrefs(accessToken: String): List<MigrainePrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,migraine_id,position,status,user_migraines_pool(id,label)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch migraine prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertMigrainePref(accessToken: String, migraineId: String, position: Int, status: String = "frequent"): MigrainePrefRow {
        val response = client.post("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,migraine_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(MigrainePrefInsert(migraineId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert migraine pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMigrainePref(accessToken: String, prefId: String, position: Int? = null, status: String? = null) {
        val payload = buildJsonObject {
            position?.let { put("position", it) }
            status?.let { put("status", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update migraine pref failed: ${response.bodyAsText()}")
    }
    suspend fun deleteMigrainePref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete migraine pref failed: ${response.bodyAsText()}")
    }

    // ───────── WEATHER DAILY ─────────
    @Serializable
    data class WeatherDailyRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val date: String, // ISO date "YYYY-MM-DD"
        @SerialName("temp_c") val tempC: Double? = null,
        @SerialName("pressure_hpa") val pressureHpa: Double? = null,
        @SerialName("humidity_pct") val humidityPct: Double? = null,
        @SerialName("created_at") val createdAt: String,
        @SerialName("updated_at") val updatedAt: String
    )

    suspend fun getWeatherDaily(accessToken: String): List<WeatherDailyRow> {
        val response = client.get("$supabaseUrl/rest/v1/weather_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,date,temp_c,pressure_hpa,humidity_pct,created_at,updated_at")
            parameter("order", "date.asc")
        }
        if (!response.status.isSuccess()) error("Fetch weather_daily failed: ${response.bodyAsText()}")
        return response.body()
    }

    // ───────── SYMPTOM POOL ─────────
    @Serializable data class UserSymptomRow(
        val id: String,
        val label: String,
        val category: String? = null,
        @SerialName("icon_key") val iconKey: String? = null
    )
    @Serializable
    data class SymptomPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("symptom_id") val symptomId: String,
        val position: Int,
        val status: String,
        @SerialName("user_symptoms") val symptom: UserSymptomRow? = null
    )
    @Serializable private data class UserSymptomInsert(
        val label: String,
        val category: String? = null,
        @SerialName("icon_key") val iconKey: String? = null
    )

    suspend fun getAllSymptomPool(accessToken: String): List<UserSymptomRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_symptoms") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_symptoms failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertSymptomToPool(accessToken: String, label: String, category: String? = null, iconKey: String? = null): UserSymptomRow {
        val response = client.post("$supabaseUrl/rest/v1/user_symptoms") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserSymptomInsert(label, category, iconKey))
        }
        if (!response.status.isSuccess()) error("Upsert user_symptoms failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteSymptomFromPool(accessToken: String, symptomId: String) {
        client.delete("$supabaseUrl/rest/v1/symptom_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("symptom_id", "eq.$symptomId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_symptoms") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$symptomId")
        }
        if (!response.status.isSuccess()) error("Delete user_symptoms failed: ${response.bodyAsText()}")
    }
    @Serializable private data class SymptomPrefInsert(@SerialName("symptom_id") val symptomId: String, val position: Int, val status: String)
    suspend fun getSymptomPrefs(accessToken: String): List<SymptomPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/symptom_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,symptom_id,position,status,user_symptoms(id,label,category,icon_key)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch symptom prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertSymptomPref(accessToken: String, symptomId: String, position: Int, status: String = "frequent"): SymptomPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/symptom_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,symptom_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(SymptomPrefInsert(symptomId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert symptom pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteSymptomPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/symptom_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete symptom pref failed: ${response.bodyAsText()}")
    }

    // ───────── PRODROME POOL ─────────
    @Serializable data class UserProdromeRow(
        val id: String,
        val label: String,
        val category: String? = null,
        @SerialName("icon_key") val iconKey: String? = null,
        @SerialName("prediction_value") val predictionValue: String? = "NONE",
        val direction: String? = null,
        @SerialName("default_threshold") val defaultThreshold: Double? = null,
        val unit: String? = null,
        @SerialName("enabled_by_default") val enabledByDefault: Boolean = false,
        @SerialName("metric_table") val metricTable: String? = null,
        @SerialName("metric_column") val metricColumn: String? = null,
        @SerialName("display_group") val displayGroup: String? = null
    )
    @Serializable
    data class ProdromePrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("prodrome_id") val prodromeId: String,
        val position: Int,
        val status: String,
        @SerialName("user_prodromes") val prodrome: UserProdromeRow? = null
    )
    @Serializable private data class UserProdromeInsert(
        val label: String,
        val category: String? = null,
        @SerialName("prediction_value") val predictionValue: String? = "NONE"
    )

    suspend fun getAllProdromePool(accessToken: String): List<UserProdromeRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key,prediction_value,direction,default_threshold,unit,enabled_by_default,metric_table,metric_column,display_group"); parameter("order", "metric_table.asc.nullslast,metric_column.asc.nullslast,direction.asc.nullslast,label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_prodromes failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertProdromeToPool(accessToken: String, label: String, category: String? = null, predictionValue: String? = "NONE"): UserProdromeRow {
        val response = client.post("$supabaseUrl/rest/v1/user_prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserProdromeInsert(label, category, predictionValue))
        }
        if (!response.status.isSuccess()) error("Upsert user_prodromes failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteProdromeFromPool(accessToken: String, prodromeId: String) {
        client.delete("$supabaseUrl/rest/v1/prodrome_user_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("prodrome_id", "eq.$prodromeId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prodromeId")
        }
        if (!response.status.isSuccess()) error("Delete user_prodromes failed: ${response.bodyAsText()}")
    }
    suspend fun updateProdromePoolItem(
        accessToken: String,
        prodromeId: String,
        predictionValue: String? = null,
        category: String? = null,
        defaultThreshold: Double? = null
    ) {
        val payload = buildJsonObject {
            predictionValue?.let { put("prediction_value", it) }
            category?.let { put("category", it) }
            defaultThreshold?.let { put("default_threshold", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/user_prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("id", "eq.$prodromeId")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update user_prodromes failed: ${response.bodyAsText()}")
    }
    @Serializable private data class ProdromePrefInsert(@SerialName("prodrome_id") val prodromeId: String, val position: Int, val status: String)
    suspend fun getProdromePrefs(accessToken: String): List<ProdromePrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/prodrome_user_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,prodrome_id,position,status,user_prodromes(id,label,category,icon_key,prediction_value)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch prodrome prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertProdromePref(accessToken: String, prodromeId: String, position: Int, status: String = "frequent"): ProdromePrefRow {
        val response = client.post("$supabaseUrl/rest/v1/prodrome_user_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,prodrome_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(ProdromePrefInsert(prodromeId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert prodrome pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteProdromePref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/prodrome_user_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete prodrome pref failed: ${response.bodyAsText()}")
    }

    // ───────── PRODROME LOG ─────────
    @Serializable private data class ProdromeLogInsert(
        val type: String?,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String = "manual"
    )
    @Serializable data class ProdromeLogRow(
        val id: String,
        val type: String? = null,
        @SerialName("start_at") val startAt: String? = null,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual"
    )
    suspend fun insertProdrome(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        notes: String?
    ): ProdromeLogRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = ProdromeLogInsert(type, safeStart, notes, migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert prodrome failed: ${response.bodyAsText()}")
        return response.body()
    }

    /** Fetch distinct prodrome types logged in the last [daysBack] days. */
    suspend fun getRecentProdromes(accessToken: String, daysBack: Int = 3, referenceDate: String? = null): List<ProdromeLogRow> {
        val refDate = referenceDate?.let {
            try { java.time.LocalDate.parse(it.substring(0, 10)) } catch (_: Exception) { null }
        } ?: java.time.LocalDate.now()
        val cutoffStart = refDate.minusDays(daysBack.toLong()).toString() + "T00:00:00Z"
        val cutoffEnd = refDate.plusDays(1).toString() + "T00:00:00Z"
        val response = client.get("$supabaseUrl/rest/v1/prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "id,type,start_at")
            parameter("start_at", "gte.$cutoffStart")
            parameter("start_at", "lte.$cutoffEnd")
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    /** Fetch all prodrome log entries. */
    suspend fun getAllProdromeLog(accessToken: String): List<ProdromeLogRow> {
        val response = client.get("$supabaseUrl/rest/v1/prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "id,type,start_at,notes,migraine_id")
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    suspend fun deleteProdromeLog(accessToken: String, id: String) {
        client.delete("$supabaseUrl/rest/v1/prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
    }

    suspend fun updateProdromeLog(accessToken: String, id: String, type: String?, startAt: String?, notes: String?) {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
        }
        client.patch("$supabaseUrl/rest/v1/prodromes") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
    }

    // ───────── LOCATION POOL / PREFS ─────────
    @Serializable data class UserLocationRow(val id: String, val label: String, val category: String? = null, @SerialName("icon_key") val iconKey: String? = null, @SerialName("is_automatable") val isAutomatable: Boolean = false, @SerialName("is_automated") val isAutomated: Boolean = false)
    @Serializable
    data class LocationPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("location_id") val locationId: String,
        val position: Int,
        val status: String,
        @SerialName("user_locations") val location: UserLocationRow? = null
    )
    @Serializable private data class UserLocationInsert(val label: String, val category: String? = null)

    suspend fun getAllLocationPool(accessToken: String): List<UserLocationRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key,is_automatable,is_automated"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_locations failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertLocationToPool(accessToken: String, label: String, category: String? = null): UserLocationRow {
        val response = client.post("$supabaseUrl/rest/v1/user_locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserLocationInsert(label, category))
        }
        if (!response.status.isSuccess()) error("Upsert user_locations failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteLocationFromPool(accessToken: String, locationId: String) {
        client.delete("$supabaseUrl/rest/v1/location_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("location_id", "eq.$locationId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$locationId")
        }
        if (!response.status.isSuccess()) error("Delete user_locations failed: ${response.bodyAsText()}")
    }
    suspend fun setLocationCategory(accessToken: String, locationId: String, category: String?) {
        val payload = buildJsonObject { category?.let { put("category", it) } ?: put("category", kotlinx.serialization.json.JsonNull) }
        val response = client.patch("$supabaseUrl/rest/v1/user_locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$locationId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set location category failed: ${response.bodyAsText()}")
    }
    suspend fun setLocationAutomation(accessToken: String, locationId: String, enabled: Boolean) {
        val payload = buildJsonObject { put("is_automated", enabled) }
        val response = client.patch("$supabaseUrl/rest/v1/user_locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$locationId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set location automation failed: ${response.bodyAsText()}")
    }
    @Serializable private data class LocationPrefInsert(@SerialName("location_id") val locationId: String, val position: Int, val status: String)
    suspend fun getLocationPrefs(accessToken: String): List<LocationPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/location_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,location_id,position,status,user_locations(id,label,category,icon_key,is_automatable,is_automated)")
        }
        if (!response.status.isSuccess()) error("Fetch location_preferences failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertLocationPref(accessToken: String, locationId: String, position: Int, status: String = "frequent"): LocationPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/location_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(LocationPrefInsert(locationId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert location_pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteLocationPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/location_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete location_pref failed: ${response.bodyAsText()}")
    }

    // ── Location log ──
    @Serializable
    data class LocationLogRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        val category: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual"
    )
    @Serializable
    private data class LocationLogInsert(
        val type: String? = null,
        val category: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    suspend fun insertLocation(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        notes: String?
    ): LocationLogRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = LocationLogInsert(type = type, startAt = safeStart, notes = notes, migraineId = migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert location failed: ${response.bodyAsText()}")
        return response.body()
    }

    /** Fetch all location log entries. */
    suspend fun getAllLocationLog(accessToken: String): List<LocationLogRow> {
        val response = client.get("$supabaseUrl/rest/v1/locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    suspend fun deleteLocationLog(accessToken: String, id: String) {
        client.delete("$supabaseUrl/rest/v1/locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
    }

    suspend fun updateLocationLog(accessToken: String, id: String, type: String?, startAt: String?, notes: String?) {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
        }
        client.patch("$supabaseUrl/rest/v1/locations") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
    }

    // ───────── ACTIVITY POOL / PREFS ─────────
    @Serializable data class UserActivityRow(val id: String, val label: String, val category: String? = null, @SerialName("icon_key") val iconKey: String? = null, @SerialName("is_automatable") val isAutomatable: Boolean = false, @SerialName("is_automated") val isAutomated: Boolean = false)
    @Serializable
    data class ActivityPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("activity_id") val activityId: String,
        val position: Int,
        val status: String,
        @SerialName("user_activities") val activity: UserActivityRow? = null
    )
    @Serializable private data class UserActivityInsert(val label: String, val category: String? = null)

    suspend fun getAllActivityPool(accessToken: String): List<UserActivityRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key,is_automatable,is_automated"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_activities failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertActivityToPool(accessToken: String, label: String, category: String? = null): UserActivityRow {
        val response = client.post("$supabaseUrl/rest/v1/user_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserActivityInsert(label, category))
        }
        if (!response.status.isSuccess()) error("Upsert user_activities failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteActivityFromPool(accessToken: String, activityId: String) {
        client.delete("$supabaseUrl/rest/v1/activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("activity_id", "eq.$activityId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$activityId")
        }
        if (!response.status.isSuccess()) error("Delete user_activities failed: ${response.bodyAsText()}")
    }
    suspend fun setActivityCategory(accessToken: String, activityId: String, category: String?) {
        val payload = buildJsonObject { category?.let { put("category", it) } ?: put("category", kotlinx.serialization.json.JsonNull) }
        val response = client.patch("$supabaseUrl/rest/v1/user_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$activityId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set activity category failed: ${response.bodyAsText()}")
    }
    suspend fun setActivityAutomation(accessToken: String, activityId: String, enabled: Boolean) {
        val payload = buildJsonObject { put("is_automated", enabled) }
        val response = client.patch("$supabaseUrl/rest/v1/user_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$activityId")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set activity automation failed: ${response.bodyAsText()}")
    }
    @Serializable private data class ActivityPrefInsert(@SerialName("activity_id") val activityId: String, val position: Int, val status: String)
    suspend fun getActivityPrefs(accessToken: String): List<ActivityPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,activity_id,position,status,user_activities(id,label,category,icon_key,is_automatable,is_automated)")
        }
        if (!response.status.isSuccess()) error("Fetch activity_preferences failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertActivityPref(accessToken: String, activityId: String, position: Int, status: String = "frequent"): ActivityPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(ActivityPrefInsert(activityId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert activity_pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteActivityPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete activity_pref failed: ${response.bodyAsText()}")
    }

    // ── Activity log (writes to time_in_high_hr_zones_daily) ──
    @Serializable
    data class ActivityLogRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("activity_type") val type: String? = null,
        val category: String? = null,
        @SerialName("start_at") val startAt: String? = null,
        @SerialName("end_at") val endAt: String? = null,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual"
    )
    @Serializable
    private data class ActivityLogInsert(
        @SerialName("activity_type") val activityType: String? = null,
        @SerialName("start_at") val startAt: String,
        @SerialName("end_at") val endAt: String? = null,
        val date: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String = "manual",
        @SerialName("value_minutes") val valueMinutes: Int = 0
    )
    suspend fun insertActivity(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        endAt: String? = null,
        notes: String?
    ): ActivityLogRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val dateOnly = safeStart.substringBefore("T").take(10)
        val payload = ActivityLogInsert(
            activityType = type?.lowercase(),
            startAt = safeStart,
            endAt = endAt,
            date = dateOnly,
            notes = notes,
            migraineId = migraineId
        )
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/time_in_high_hr_zones_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert activity failed: ${response.bodyAsText()}")
        return response.body()
    }

    /** Lightweight row for recent activity queries. */
    @Serializable data class RecentActivityRow(
        val id: String,
        @SerialName("activity_type") val activityType: String? = null,
        @SerialName("start_at") val startAt: String? = null,
        val date: String? = null
    )

    /** Fetch activities logged in the last [daysBack] days from time_in_high_hr_zones_daily. */
    suspend fun getRecentActivities(accessToken: String, daysBack: Int = 3, referenceDate: String? = null): List<RecentActivityRow> {
        val refDate = referenceDate?.let {
            try { java.time.LocalDate.parse(it.substring(0, 10)) } catch (_: Exception) { null }
        } ?: java.time.LocalDate.now()
        val cutoffStart = refDate.minusDays(daysBack.toLong()).toString()
        val cutoffEnd = refDate.plusDays(1).toString()
        val response = client.get("$supabaseUrl/rest/v1/time_in_high_hr_zones_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "id,activity_type,start_at,date")
            parameter("date", "gte.$cutoffStart")
            parameter("date", "lte.$cutoffEnd")
            parameter("order", "date.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    /** Fetch all activity log entries. */
    suspend fun getAllActivityLog(accessToken: String): List<ActivityLogRow> {
        val response = client.get("$supabaseUrl/rest/v1/time_in_high_hr_zones_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    suspend fun deleteActivityLog(accessToken: String, id: String) {
        client.delete("$supabaseUrl/rest/v1/time_in_high_hr_zones_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
    }

    suspend fun updateActivityLog(accessToken: String, id: String, type: String?, startAt: String?, endAt: String? = null, notes: String?) {
        val payload = buildJsonObject {
            type?.let { put("activity_type", it) }
            startAt?.let { put("start_at", it) }
            endAt?.let { put("end_at", it) }
            notes?.let { put("notes", it) }
        }
        client.patch("$supabaseUrl/rest/v1/time_in_high_hr_zones_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
    }

    // ───────── MISSED ACTIVITY POOL / PREFS ─────────
    @Serializable data class UserMissedActivityRow(val id: String, val label: String, val category: String? = null, @SerialName("icon_key") val iconKey: String? = null, @SerialName("is_automatable") val isAutomatable: Boolean = false, @SerialName("is_automated") val isAutomated: Boolean = false)
    @Serializable
    data class MissedActivityPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("missed_activity_id") val missedActivityId: String,
        val position: Int,
        val status: String,
        @SerialName("user_missed_activities") val missedActivity: UserMissedActivityRow? = null
    )
    @Serializable private data class UserMissedActivityInsert(val label: String, val category: String? = null)

    suspend fun getAllMissedActivityPool(accessToken: String): List<UserMissedActivityRow> {
        val response = client.get("$supabaseUrl/rest/v1/user_missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label,category,icon_key,is_automatable,is_automated"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch user_missed_activities failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertMissedActivityToPool(accessToken: String, label: String, category: String? = null): UserMissedActivityRow {
        val response = client.post("$supabaseUrl/rest/v1/user_missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(UserMissedActivityInsert(label, category))
        }
        if (!response.status.isSuccess()) error("Upsert user_missed_activities failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMissedActivityFromPool(accessToken: String, id: String) {
        client.delete("$supabaseUrl/rest/v1/missed_activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("missed_activity_id", "eq.$id")
        }
        val response = client.delete("$supabaseUrl/rest/v1/user_missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete user_missed_activities failed: ${response.bodyAsText()}")
    }
    suspend fun setMissedActivityCategory(accessToken: String, id: String, category: String?) {
        val payload = buildJsonObject { category?.let { put("category", it) } ?: put("category", kotlinx.serialization.json.JsonNull) }
        val response = client.patch("$supabaseUrl/rest/v1/user_missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set missed activity category failed: ${response.bodyAsText()}")
    }
    suspend fun setMissedActivityAutomation(accessToken: String, id: String, enabled: Boolean) {
        val payload = buildJsonObject { put("is_automated", enabled) }
        val response = client.patch("$supabaseUrl/rest/v1/user_missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Set missed activity automation failed: ${response.bodyAsText()}")
    }
    @Serializable private data class MissedActivityPrefInsert(@SerialName("missed_activity_id") val missedActivityId: String, val position: Int, val status: String)
    suspend fun getMissedActivityPrefs(accessToken: String): List<MissedActivityPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/missed_activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,missed_activity_id,position,status,user_missed_activities(id,label,category,icon_key,is_automatable,is_automated)")
        }
        if (!response.status.isSuccess()) error("Fetch missed_activity_preferences failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertMissedActivityPref(accessToken: String, missedActivityId: String, position: Int, status: String = "frequent"): MissedActivityPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/missed_activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(MissedActivityPrefInsert(missedActivityId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert missed_activity_pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMissedActivityPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/missed_activity_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete missed_activity_pref failed: ${response.bodyAsText()}")
    }

    // ── Missed Activity log ──
    @Serializable
    data class MissedActivityLogRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        val category: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null,
        val source: String? = "manual"
    )
    @Serializable
    private data class MissedActivityLogInsert(
        val type: String? = null,
        val category: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    suspend fun insertMissedActivity(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        notes: String?
    ): MissedActivityLogRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = MissedActivityLogInsert(type = type, startAt = safeStart, notes = notes, migraineId = migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert missed_activity failed: ${response.bodyAsText()}")
        return response.body()
    }

    /** Fetch all missed activity log entries. */
    suspend fun getAllMissedActivityLog(accessToken: String): List<MissedActivityLogRow> {
        val response = client.get("$supabaseUrl/rest/v1/missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("order", "start_at.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }

    suspend fun deleteMissedActivityLog(accessToken: String, id: String) {
        client.delete("$supabaseUrl/rest/v1/missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
    }

    suspend fun updateMissedActivityLog(accessToken: String, id: String, type: String?, startAt: String?, notes: String?) {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
        }
        client.patch("$supabaseUrl/rest/v1/missed_activities") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            contentType(ContentType.Application.Json); setBody(payload)
        }
    }

    // ─────────────────────────────────────────────────────────────────
    // Risk Score — Live + Daily
    // ─────────────────────────────────────────────────────────────────

    @Serializable
    data class RiskScoreLiveRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val score: Double,
        val zone: String,
        val percent: Int,
        @SerialName("top_triggers") val topTriggers: String? = null,   // jsonb → raw string
        val forecast: String? = null,                                   // jsonb → raw string
        @SerialName("day_risks") val dayRisks: String? = null,          // jsonb → raw string
        @SerialName("updated_at") val updatedAt: String? = null,
    )

    /** Read the pre-computed live risk score for the current user. Returns null if none exists. */
    suspend fun getRiskScoreLive(accessToken: String): RiskScoreLiveRow? {
        return try {
            val response = client.get("$supabaseUrl/rest/v1/risk_score_live") {
                header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
                parameter("select", "id,user_id,score,zone,percent,top_triggers::text,forecast::text,day_risks::text,updated_at")
                parameter("limit", "1")
            }
            if (!response.status.isSuccess()) {
                android.util.Log.w("SupabaseDb", "getRiskScoreLive HTTP ${response.status}")
                return null
            }
            val raw = response.bodyAsText()
            android.util.Log.d("SupabaseDb", "getRiskScoreLive raw: ${raw.take(500)}")
            if (raw.isBlank() || raw == "[]") return null

            // Parse manually to avoid kotlinx.serialization issues with jsonb
            val arr = org.json.JSONArray(raw)
            if (arr.length() == 0) return null
            val obj = arr.getJSONObject(0)
            RiskScoreLiveRow(
                id = obj.optString("id", ""),
                userId = obj.optString("user_id", ""),
                score = obj.optDouble("score", 0.0),
                zone = obj.optString("zone", "NONE"),
                percent = obj.optInt("percent", 0),
                topTriggers = obj.optString("top_triggers", null)?.takeIf { it != "null" },
                forecast = obj.optString("forecast", null)?.takeIf { it != "null" },
                dayRisks = obj.optString("day_risks", null)?.takeIf { it != "null" },
                updatedAt = obj.optString("updated_at", null)?.takeIf { it != "null" },
            )
        } catch (e: Exception) {
            android.util.Log.e("SupabaseDb", "getRiskScoreLive error: ${e.message}", e)
            null
        }
    }

    @Serializable
    data class RiskScoreDailyRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val date: String,
        val score: Double,
        val zone: String,
        val percent: Int,
        @SerialName("top_triggers") val topTriggers: String? = null,
        @SerialName("created_at") val createdAt: String? = null,
    )

    /** Read daily risk score history. Returns most recent first. */
    suspend fun getRiskScoreDaily(accessToken: String, daysBack: Int = 30): List<RiskScoreDailyRow> {
        val cutoff = java.time.LocalDate.now().minusDays(daysBack.toLong()).toString()
        val response = client.get("$supabaseUrl/rest/v1/risk_score_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "*")
            parameter("date", "gte.$cutoff")
            parameter("order", "date.desc")
        }
        if (!response.status.isSuccess()) return emptyList()
        return response.body()
    }
}




title: SupabaseHealthConnectService.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Supabase service for uploading Health Connect data.
 * Handles all record types with source = "health_connect".
 *
 * IMPORTANT: Different tables have different unique constraints:
 * - Most tables: (user_id, source, date)
 * - time_in_high_hr_zones_daily: (user_id, source, source_measure_id) - stores individual sessions
 *
 * This service handles both patterns appropriately.
 */
class SupabaseHealthConnectService(context: Context) {

    companion object {
        private const val TAG = "SupabaseHCService"
        private const val SOURCE = "health_connect"
    }

    private val supabaseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) {
            json(Json {
                ignoreUnknownKeys = true
                encodeDefaults = true  // CRITICAL: Always include fields with defaults like 'source'
            })
        }
    }

    /**
     * Result of an upsert operation with error classification.
     */
    sealed class UpsertResult {
        object Success : UpsertResult()
        data class RetryableError(val message: String) : UpsertResult()      // Network issues, 5xx - retry later
        data class PermanentError(val message: String) : UpsertResult()      // 4xx client errors - don't retry
    }

    // ============================================================
    // Table-aware upsert helpers
    // ============================================================

    /**
     * Standard upsert for daily tables with (user_id, source, date) uniqueness.
     * Used by: sleep_duration_daily, hrv_daily, resting_hr_daily, steps_daily,
     *          weight_daily, body_fat_daily, hydration_daily, blood_pressure_daily,
     *          blood_glucose_daily, spo2_daily, respiratory_rate_daily, skin_temp_daily,
     *          fell_asleep_time_daily, woke_up_time_daily, sleep_stages_daily
     */
    private suspend inline fun <reified T> upsertDaily(
        accessToken: String,
        table: String,
        row: T
    ): UpsertResult {
        return upsertWithConflict(accessToken, table, row, "user_id,source,date")
    }

    /**
     * Upsert for session-based tables with (user_id, source, source_measure_id) uniqueness.
     * Used by: time_in_high_hr_zones_daily (stores individual exercise sessions)
     */
    private suspend inline fun <reified T> upsertSession(
        accessToken: String,
        table: String,
        row: T
    ): UpsertResult {
        return upsertWithConflict(accessToken, table, row, "user_id,source,source_measure_id")
    }

    /**
     * Generic upsert with explicit conflict resolution.
     */
    private suspend inline fun <reified T> upsertWithConflict(
        accessToken: String,
        table: String,
        row: T,
        onConflict: String
    ): UpsertResult {
        return try {
            val resp = client.post("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                header("Prefer", "resolution=merge-duplicates,return=minimal")
                parameter("on_conflict", onConflict)
                contentType(ContentType.Application.Json)
                setBody(row)
            }

            when {
                resp.status.isSuccess() -> UpsertResult.Success

                resp.status.value in 400..499 -> {
                    val body = resp.bodyAsText()
                    Log.e(TAG, "Upsert to $table failed (permanent): ${resp.status} - $body")
                    
                    // Check if it's a constraint violation we can ignore (duplicate that somehow slipped through)
                    if (body.contains("duplicate") || body.contains("unique")) {
                        Log.w(TAG, "Duplicate detected for $table, treating as success")
                        UpsertResult.Success
                    } else {
                        UpsertResult.PermanentError("${resp.status.value}: $body")
                    }
                }

                else -> {
                    // 5xx or other - retryable
                    val body = resp.bodyAsText()
                    Log.e(TAG, "Upsert to $table failed (retryable): ${resp.status} - $body")
                    UpsertResult.RetryableError("${resp.status.value}: $body")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Upsert to $table exception: ${e.message}")
            // Network errors are retryable
            UpsertResult.RetryableError(e.message ?: "Unknown error")
        }
    }

    /**
     * Legacy boolean-returning upsert for backward compatibility.
     * Converts UpsertResult to simple boolean.
     */
    private suspend inline fun <reified T> upsertDailyCompat(
        accessToken: String,
        table: String,
        row: T
    ): Boolean {
        return when (upsertDaily(accessToken, table, row)) {
            is UpsertResult.Success -> true
            is UpsertResult.RetryableError -> false
            is UpsertResult.PermanentError -> false
        }
    }

    private suspend inline fun <reified T> upsertSessionCompat(
        accessToken: String,
        table: String,
        row: T
    ): Boolean {
        return when (upsertSession(accessToken, table, row)) {
            is UpsertResult.Success -> true
            is UpsertResult.RetryableError -> false
            is UpsertResult.PermanentError -> false
        }
    }

    // ============================================================
    // Delete by source_measure_id
    // ============================================================

    suspend fun deleteBySourceMeasureId(
        accessToken: String,
        recordType: String,
        sourceMeasureId: String
    ): Boolean {
        val table = recordTypeToTable(recordType) ?: return false

        return try {
            val resp = client.delete("$supabaseUrl/rest/v1/$table") {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", supabaseKey)
                parameter("source", "eq.$SOURCE")
                parameter("source_measure_id", "eq.$sourceMeasureId")
            }
            resp.status.isSuccess()
        } catch (e: Exception) {
            Log.e(TAG, "Delete from $table failed: ${e.message}")
            false
        }
    }

    private fun recordTypeToTable(recordType: String): String? {
        return when (recordType) {
            HealthConnectRecordTypes.SLEEP -> "sleep_duration_daily"
            HealthConnectRecordTypes.HRV -> "hrv_daily"
            HealthConnectRecordTypes.RESTING_HR -> "resting_hr_daily"
            HealthConnectRecordTypes.STEPS -> "steps_daily"
            HealthConnectRecordTypes.EXERCISE -> "time_in_high_hr_zones_daily"
            HealthConnectRecordTypes.WEIGHT -> "weight_daily"
            HealthConnectRecordTypes.BODY_FAT -> "body_fat_daily"
            HealthConnectRecordTypes.HYDRATION -> "hydration_daily"
            HealthConnectRecordTypes.BLOOD_PRESSURE -> "blood_pressure_daily"
            HealthConnectRecordTypes.BLOOD_GLUCOSE -> "blood_glucose_daily"
            HealthConnectRecordTypes.SPO2 -> "spo2_daily"
            HealthConnectRecordTypes.RESPIRATORY_RATE -> "respiratory_rate_daily"
            HealthConnectRecordTypes.SKIN_TEMP -> "skin_temp_daily"
            else -> null
        }
    }

    // ============================================================
    // Sleep
    // ============================================================

    @Serializable
    private data class SleepDurationRow(
        val date: String,
        val value_hours: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    @Serializable
    private data class SleepTimeRow(
        val date: String,
        val value_at: String,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    @Serializable
    private data class SleepStagesRow(
        val date: String,
        val rem_minutes: Int,
        val deep_minutes: Int,
        val light_minutes: Int,
        val awake_minutes: Int,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertSleep(
        accessToken: String,
        date: String,
        durationHours: Double,
        startTime: String,
        endTime: String,
        remMinutes: Int,
        deepMinutes: Int,
        lightMinutes: Int,
        awakeMinutes: Int,
        sourceId: String
    ): Boolean {
        val results = mutableListOf<Boolean>()

        // Duration
        results.add(upsertDailyCompat(accessToken, "sleep_duration_daily",
            SleepDurationRow(date, durationHours, SOURCE, sourceId)))

        // Fell asleep time
        if (startTime.isNotEmpty()) {
            results.add(upsertDailyCompat(accessToken, "fell_asleep_time_daily",
                SleepTimeRow(date, startTime, SOURCE, sourceId)))
        }

        // Woke up time
        if (endTime.isNotEmpty()) {
            results.add(upsertDailyCompat(accessToken, "woke_up_time_daily",
                SleepTimeRow(date, endTime, SOURCE, sourceId)))
        }

        // Sleep stages (if available)
        if (remMinutes > 0 || deepMinutes > 0 || lightMinutes > 0) {
            results.add(upsertDailyCompat(accessToken, "sleep_stages_daily",
                SleepStagesRow(date, remMinutes, deepMinutes, lightMinutes, awakeMinutes, SOURCE, sourceId)))
        }

        return results.all { it }
    }

    // ============================================================
    // HRV
    // ============================================================

    @Serializable
    private data class HrvRow(
        val date: String,
        val value_rmssd_ms: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertHrv(accessToken: String, date: String, valueMs: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "hrv_daily", HrvRow(date, valueMs, SOURCE, sourceId))
    }

    // ============================================================
    // Resting HR
    // ============================================================

    @Serializable
    private data class RestingHrRow(
        val date: String,
        val value_bpm: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertRestingHr(accessToken: String, date: String, valueBpm: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "resting_hr_daily", RestingHrRow(date, valueBpm, SOURCE, sourceId))
    }

    // ============================================================
    // Steps
    // ============================================================

    @Serializable
    private data class StepsRow(
        val date: String,
        val value_count: Long,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertSteps(accessToken: String, date: String, count: Long, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "steps_daily", StepsRow(date, count, SOURCE, sourceId))
    }

    // ============================================================
    // Exercise (Session-based - uses source_measure_id for uniqueness)
    // ============================================================

    @Serializable
    private data class ExerciseRow(
        val date: String,
        val value_minutes: Int,
        val activity_type: String? = null,
        val source: String = SOURCE,
        val source_measure_id: String? = null,
        // Include start/end times to match WHOOP schema
        val start_at: String? = null,
        val end_at: String? = null
    )

    /**
     * Upsert exercise session.
     * 
     * IMPORTANT: time_in_high_hr_zones_daily uses (user_id, source, source_measure_id) as unique key
     * because it stores individual exercise sessions, not daily totals.
     */
    suspend fun upsertExercise(
        accessToken: String,
        date: String,
        durationMinutes: Int,
        exerciseType: Int,
        sourceId: String,
        startTime: String? = null,
        endTime: String? = null
    ): Boolean {
        val activityName = exerciseTypeToName(exerciseType)
        return upsertSessionCompat(
            accessToken,
            "time_in_high_hr_zones_daily",
            ExerciseRow(
                date = date,
                value_minutes = durationMinutes,
                activity_type = activityName,
                source = SOURCE,
                source_measure_id = sourceId,
                start_at = startTime,
                end_at = endTime
            )
        )
    }

    private fun exerciseTypeToName(type: Int): String {
        return when (type) {
            1 -> "BACK_EXTENSION"
            2 -> "BADMINTON"
            3 -> "BARBELL_SHOULDER_PRESS"
            4 -> "BASEBALL"
            5 -> "BASKETBALL"
            8 -> "BIKING"
            9 -> "BIKING_STATIONARY"
            10 -> "BOOT_CAMP"
            12 -> "BOXING"
            14 -> "BURPEE"
            16 -> "CALISTHENICS"
            17 -> "CRICKET"
            18 -> "CRUNCH"
            19 -> "DANCING"
            20 -> "DEADLIFT"
            22 -> "ELLIPTICAL"
            24 -> "FENCING"
            25 -> "FOOTBALL_AMERICAN"
            26 -> "FOOTBALL_AUSTRALIAN"
            28 -> "GOLF"
            29 -> "GUIDED_BREATHING"
            30 -> "GYMNASTICS"
            31 -> "HANDBALL"
            32 -> "HIGH_INTENSITY_INTERVAL_TRAINING"
            33 -> "HIKING"
            34 -> "ICE_HOCKEY"
            35 -> "ICE_SKATING"
            37 -> "JUMPING_JACK"
            39 -> "LAT_PULL_DOWN"
            40 -> "LUNGE"
            41 -> "MARTIAL_ARTS"
            44 -> "PADDLING"
            45 -> "PARAGLIDING"
            46 -> "PILATES"
            47 -> "PLANK"
            48 -> "RACQUETBALL"
            49 -> "ROCK_CLIMBING"
            50 -> "ROLLER_HOCKEY"
            51 -> "ROWING"
            52 -> "ROWING_MACHINE"
            53 -> "RUGBY"
            54 -> "RUNNING"
            55 -> "RUNNING_TREADMILL"
            56 -> "SAILING"
            57 -> "SCUBA_DIVING"
            58 -> "SKATING"
            59 -> "SKIING"
            60 -> "SNOWBOARDING"
            61 -> "SNOWSHOEING"
            62 -> "SOCCER"
            63 -> "SOFTBALL"
            64 -> "SQUASH"
            65 -> "SQUAT"
            66 -> "STAIR_CLIMBING"
            67 -> "STAIR_CLIMBING_MACHINE"
            68 -> "STRENGTH_TRAINING"
            69 -> "STRETCHING"
            70 -> "SURFING"
            71 -> "SWIMMING_OPEN_WATER"
            72 -> "SWIMMING_POOL"
            73 -> "TABLE_TENNIS"
            74 -> "TENNIS"
            75 -> "VOLLEYBALL"
            76 -> "WALKING"
            77 -> "WATER_POLO"
            78 -> "WEIGHTLIFTING"
            79 -> "WHEELCHAIR"
            80 -> "YOGA"
            else -> "OTHER"
        }
    }

    // ============================================================
    // Weight
    // ============================================================

    @Serializable
    private data class WeightRow(
        val date: String,
        val value_kg: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertWeight(accessToken: String, date: String, valueKg: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "weight_daily", WeightRow(date, valueKg, SOURCE, sourceId))
    }

    // ============================================================
    // Body Fat
    // ============================================================

    @Serializable
    private data class BodyFatRow(
        val date: String,
        val value_pct: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertBodyFat(accessToken: String, date: String, valuePct: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "body_fat_daily", BodyFatRow(date, valuePct, SOURCE, sourceId))
    }

    // ============================================================
    // Hydration
    // ============================================================

    @Serializable
    private data class HydrationRow(
        val date: String,
        val value_ml: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertHydration(accessToken: String, date: String, valueMl: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "hydration_daily", HydrationRow(date, valueMl, SOURCE, sourceId))
    }

    // ============================================================
    // Blood Pressure
    // ============================================================

    @Serializable
    private data class BloodPressureRow(
        val date: String,
        val systolic_mmhg: Double,
        val diastolic_mmhg: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertBloodPressure(accessToken: String, date: String, systolic: Double, diastolic: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "blood_pressure_daily", BloodPressureRow(date, systolic, diastolic, SOURCE, sourceId))
    }

    // ============================================================
    // Blood Glucose
    // ============================================================

    @Serializable
    private data class BloodGlucoseRow(
        val date: String,
        val value_mmol_l: Double,
        val meal_type: String? = null,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertBloodGlucose(accessToken: String, date: String, valueMmol: Double, mealType: String, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "blood_glucose_daily", BloodGlucoseRow(date, valueMmol, mealType, SOURCE, sourceId))
    }

    // ============================================================
    // SpO2
    // ============================================================

    @Serializable
    private data class Spo2Row(
        val date: String,
        val value_pct: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertSpo2(accessToken: String, date: String, valuePct: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "spo2_daily", Spo2Row(date, valuePct, SOURCE, sourceId))
    }

    // ============================================================
    // Respiratory Rate
    // ============================================================

    @Serializable
    private data class RespiratoryRateRow(
        val date: String,
        val value_bpm: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertRespiratoryRate(accessToken: String, date: String, valueBpm: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "respiratory_rate_daily", RespiratoryRateRow(date, valueBpm, SOURCE, sourceId))
    }

    // ============================================================
    // Skin Temperature
    // ============================================================

    @Serializable
    private data class SkinTempRow(
        val date: String,
        val value_celsius: Double,
        val source: String = SOURCE,
        val source_measure_id: String? = null
    )

    suspend fun upsertSkinTemp(accessToken: String, date: String, valueCelsius: Double, sourceId: String): Boolean {
        return upsertDailyCompat(accessToken, "skin_temp_daily", SkinTempRow(date, valueCelsius, SOURCE, sourceId))
    }
}

title: SupabaseMenstruationService.kt
text:
package com.migraineme

import android.content.Context
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.time.LocalDate

/**
 * Service for uploading/deleting menstruation data to/from Supabase
 *
 * As of Step 4, menstruation events are stored in `triggers` (type="menstruation").
 * Legacy menstruation_periods methods are kept for compatibility but forward to triggers logic.
 */
class SupabaseMenstruationService(private val context: Context) {

    companion object {
        private val SUPABASE_URL = BuildConfig.SUPABASE_URL.trimEnd('/')
        private val SUPABASE_ANON_KEY = BuildConfig.SUPABASE_ANON_KEY
    }

    private val httpClient = OkHttpClient()
    private val json = Json { ignoreUnknownKeys = true }

    /**
     * Legacy compatibility method.
     *
     * Previously wrote to `menstruation_periods`. Now forwards to triggers-based upsert.
     */
    suspend fun uploadPeriod(
        accessToken: String,
        healthConnectId: String,
        startDate: LocalDate,
        endDate: LocalDate?
    ) {
        upsertHealthConnectMenstruationTrigger(
            accessToken = accessToken,
            healthConnectId = healthConnectId,
            startDate = startDate,
            endDate = endDate
        )
    }

    /**
     * Legacy compatibility method.
     *
     * Previously deleted from `menstruation_periods`. Now forwards to triggers-based delete.
     */
    suspend fun deletePeriodsByHealthConnectIds(
        accessToken: String,
        healthConnectIds: List<String>
    ) {
        deleteHealthConnectMenstruationTriggersByIds(
            accessToken = accessToken,
            healthConnectIds = healthConnectIds
        )
    }

    @Serializable
    private data class TriggerIdDto(
        val id: String
    )

    @Serializable
    private data class TriggerMenstruationDto(
        val start_at: String,
        val notes: String? = null,
        val source: String? = null
    )

    private fun buildNotes(endDate: LocalDate?): String? {
        // Keep notes free for real notes; only store optional end_date for now.
        return endDate?.let { "end_date=$it" }
    }

    /**
     * Upsert a menstruation trigger sourced from Health Connect.
     *
     * Mapping key:
     * - source = "health_connect"
     * - source_measure_id = Health Connect record ID
     */
    suspend fun upsertHealthConnectMenstruationTrigger(
        accessToken: String,
        healthConnectId: String,
        startDate: LocalDate,
        endDate: LocalDate?
    ) {
        val userId = JwtUtils.extractUserIdFromAccessToken(accessToken)
            ?: throw Exception("Failed to extract user_id from access token")

        val baseUrl = "$SUPABASE_URL/rest/v1/triggers"
        val startAtIso = "${startDate}T09:00:00Z"
        val notes = buildNotes(endDate)

        // Find existing trigger for this Health Connect record (by source_measure_id).
        val findUrl =
            "$baseUrl?select=id&user_id=eq.$userId&type=eq.menstruation&source=eq.health_connect&source_measure_id=eq.$healthConnectId"

        val findReq = Request.Builder()
            .url(findUrl)
            .get()
            .header("apikey", SUPABASE_ANON_KEY)
            .header("Authorization", "Bearer $accessToken")
            .build()

        val existingId: String? = httpClient.newCall(findReq).execute().use { resp ->
            if (!resp.isSuccessful) {
                val err = resp.body?.string()
                throw Exception("Failed to query triggers: ${resp.code} $err")
            }
            val body = resp.body?.string().orEmpty()
            val list = runCatching { json.decodeFromString<List<TriggerIdDto>>(body) }
                .getOrDefault(emptyList())
            list.firstOrNull()?.id
        }

        val payload = buildJsonObject {
            put("user_id", userId)
            put("type", "menstruation")
            put("start_at", startAtIso)
            if (notes != null) put("notes", notes) else put("notes", JsonNull)
            put("source", "health_connect")
            put("source_measure_id", healthConnectId)
            put("active", true)
        }

        if (existingId != null) {
            val patchReq = Request.Builder()
                .url("$baseUrl?id=eq.$existingId")
                .patch(payload.toString().toRequestBody("application/json".toMediaType()))
                .header("apikey", SUPABASE_ANON_KEY)
                .header("Authorization", "Bearer $accessToken")
                .header("Content-Type", "application/json")
                .build()

            httpClient.newCall(patchReq).execute().use { resp ->
                if (!resp.isSuccessful) {
                    val err = resp.body?.string()
                    throw Exception("Failed to update trigger: ${resp.code} $err")
                }
            }
        } else {
            val postReq = Request.Builder()
                .url(baseUrl)
                .post(payload.toString().toRequestBody("application/json".toMediaType()))
                .header("apikey", SUPABASE_ANON_KEY)
                .header("Authorization", "Bearer $accessToken")
                .header("Content-Type", "application/json")
                .build()

            httpClient.newCall(postReq).execute().use { resp ->
                if (!resp.isSuccessful) {
                    val err = resp.body?.string()
                    throw Exception("Failed to insert trigger: ${resp.code} $err")
                }
            }
        }
    }

    /**
     * Delete Health Connect sourced menstruation triggers by Health Connect IDs.
     *
     * Uses source_measure_id as the mapping key.
     */
    suspend fun deleteHealthConnectMenstruationTriggersByIds(
        accessToken: String,
        healthConnectIds: List<String>
    ) {
        if (healthConnectIds.isEmpty()) return

        val userId = JwtUtils.extractUserIdFromAccessToken(accessToken)
            ?: throw Exception("Failed to extract user_id from access token")

        val baseUrl = "$SUPABASE_URL/rest/v1/triggers"

        for (id in healthConnectIds) {
            val deleteUrl =
                "$baseUrl?user_id=eq.$userId&type=eq.menstruation&source=eq.health_connect&source_measure_id=eq.$id"

            val request = Request.Builder()
                .url(deleteUrl)
                .delete()
                .header("apikey", SUPABASE_ANON_KEY)
                .header("Authorization", "Bearer $accessToken")
                .build()

            httpClient.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    val err = response.body?.string()
                    throw Exception("Failed to delete trigger(s) for source_measure_id=$id: ${response.code} $err")
                }
            }
        }
    }

    /**
     * Get user's menstruation settings
     */
    suspend fun getSettings(accessToken: String): MenstruationSettings? {
        val userId = JwtUtils.extractUserIdFromAccessToken(accessToken) ?: return null

        val url = "$SUPABASE_URL/rest/v1/menstruation_settings?user_id=eq.$userId&select=*"

        val request = Request.Builder()
            .url(url)
            .get()
            .header("apikey", SUPABASE_ANON_KEY)
            .header("Authorization", "Bearer $accessToken")
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) return null

            val body = response.body?.string() ?: return null
            val list = json.decodeFromString<List<MenstruationSettingsDto>>(body)

            return list.firstOrNull()?.let {
                MenstruationSettings(
                    lastMenstruationDate = it.last_menstruation_date?.let { date -> LocalDate.parse(date) },
                    avgCycleLength = it.avg_cycle_length ?: 28,
                    autoUpdateAverage = it.auto_update_average ?: true
                )
            }
        }
    }

    /**
     * Update user's menstruation settings
     *
     * - Upserts on user_id (on_conflict=user_id) so repeated saves update the same row.
     * - Sends last_menstruation_date explicitly (JsonNull when cleared) so clearing the date works.
     */
    suspend fun updateSettings(
        accessToken: String,
        lastMenstruationDate: LocalDate?,
        avgCycleLength: Int,
        autoUpdateAverage: Boolean
    ) {
        val userId = JwtUtils.extractUserIdFromAccessToken(accessToken)
            ?: throw Exception("Failed to extract user_id")

        val url = "$SUPABASE_URL/rest/v1/menstruation_settings"

        val body = buildJsonObject {
            put("user_id", userId)
            if (lastMenstruationDate != null) {
                put("last_menstruation_date", lastMenstruationDate.toString())
            } else {
                put("last_menstruation_date", JsonNull)
            }
            put("avg_cycle_length", avgCycleLength)
            put("auto_update_average", autoUpdateAverage)
        }

        val request = Request.Builder()
            .url("$url?on_conflict=user_id")
            .post(body.toString().toRequestBody("application/json".toMediaType()))
            .header("apikey", SUPABASE_ANON_KEY)
            .header("Authorization", "Bearer $accessToken")
            .header("Content-Type", "application/json")
            .header("Prefer", "resolution=merge-duplicates")
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                val errorBody = response.body?.string()
                throw Exception("Failed to update settings: ${response.code} $errorBody")
            }
        }
    }

    /**
     * Get menstruation history (for calculating averages).
     *
     * Reads from triggers(type="menstruation") and parses optional end_date from notes.
     */
    suspend fun getMenstruationHistory(
        accessToken: String,
        limitDays: Int = 365
    ): List<MenstruationPeriod> {
        val userId = JwtUtils.extractUserIdFromAccessToken(accessToken) ?: return emptyList()

        val cutoffDate = LocalDate.now().minusDays(limitDays.toLong())
        val cutoffIso = "${cutoffDate}T00:00:00Z"

        val url =
            "$SUPABASE_URL/rest/v1/triggers?user_id=eq.$userId&type=eq.menstruation&source=in.(manual,health_connect)&start_at=gte.$cutoffIso&order=start_at.asc&select=start_at,notes,source"

        val request = Request.Builder()
            .url(url)
            .get()
            .header("apikey", SUPABASE_ANON_KEY)
            .header("Authorization", "Bearer $accessToken")
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) return emptyList()

            val body = response.body?.string() ?: return emptyList()
            val list = runCatching { json.decodeFromString<List<TriggerMenstruationDto>>(body) }
                .getOrDefault(emptyList())

            return list.mapNotNull { row ->
                val startDate = runCatching { LocalDate.parse(row.start_at.substring(0, 10)) }.getOrNull()
                    ?: return@mapNotNull null

                val endDate = row.notes
                    ?.let { notesStr ->
                        val match = Regex("end_date=(\\d{4}-\\d{2}-\\d{2})").find(notesStr)
                        match?.groupValues?.getOrNull(1)
                    }
                    ?.let { dateStr -> runCatching { LocalDate.parse(dateStr) }.getOrNull() }

                MenstruationPeriod(
                    startDate = startDate,
                    endDate = endDate
                )
            }
        }
    }
}

// DTOs
@Serializable
data class MenstruationSettingsDto(
    val user_id: String,
    val last_menstruation_date: String?,
    val avg_cycle_length: Int?,
    val auto_update_average: Boolean?
)

@Serializable
data class MenstruationPeriodDto(
    val start_date: String,
    val end_date: String?
)

title: SupabaseMetricDataHelper.kt
text:
package com.migraineme

import android.content.Context
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

object SupabaseMetricDataHelper {

    /**
     * Returns true if at least one row exists for this metric
     * for the current user.
     *
     * Uses Edge Function (auth + RLS safe).
     */
    suspend fun hasAnyData(
        context: Context,
        metric: String
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            EdgeFunctionsService().hasAnyMetricData(
                context = context,
                metric = metric
            )
        } catch (_: Exception) {
            false
        }
    }
}


title: SupabaseMetricsServiceSleep.kt
text:
// FILE: app/src/main/java/com/migraineme/SupabaseMetricsServiceSleep.kt
package com.migraineme

import android.content.Context
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Supabase metrics writer + reader for sleep tables.
 * (Same behavior as before, plus score/efficiency.)
 *
 * Tables:
 * - sleep_duration_daily(date, value_hours, source, source_measure_id, user_id default auth.uid())
 * - fell_asleep_time_daily(date, value_at, source, source_measure_id, user_id default auth.uid())
 * - woke_up_time_daily(date, value_at, source, source_measure_id, user_id default auth.uid())
 * - sleep_disturbances_daily(date, value_count, source, source_measure_id, user_id default auth.uid())
 * - sleep_stages_daily(date, value_sws_hm, value_rem_hm, value_light_hm, source, source_measure_id, user_id default auth.uid())
 * - sleep_score_daily(date, value_pct, source, source_measure_id, user_id default auth.uid())
 * - sleep_efficiency_daily(date, value_pct, source, source_measure_id, user_id default auth.uid())
 * Unique key everywhere: (user_id, source, date)
 */
class SupabaseMetricsService(context: Context) {

    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
    }

    /* ============ READ DTOs ============ */

    @Serializable
    data class SleepDurationDailyRead(val date: String, @SerialName("value_hours") val value_hours: Double)

    @Serializable
    data class SleepDisturbancesDailyRead(val date: String, @SerialName("value_count") val value_count: Int)

    @Serializable
    data class SleepStagesDailyRead(
        val date: String,
        @SerialName("value_sws_hm") val value_sws_hm: Double,
        @SerialName("value_rem_hm") val value_rem_hm: Double,
        @SerialName("value_light_hm") val value_light_hm: Double
    )

    @Serializable
    data class SleepScoreDailyRead(val date: String, @SerialName("value_pct") val value_pct: Double)

    @Serializable
    data class SleepEfficiencyDailyRead(val date: String, @SerialName("value_pct") val value_pct: Double)

    /* ============ WRITER DTOs ============ */

    @Serializable private data class DurationRow(
        val date: String,
        val value_hours: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class FellAsleepRow(
        val date: String,
        val value_at: String,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class WakeRow(
        val date: String,
        val value_at: String,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class DisturbancesRow(
        val date: String,
        val value_count: Int,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class StagesRow(
        val date: String,
        val value_sws_hm: Double,
        val value_rem_hm: Double,
        val value_light_hm: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class PctRow(
        val date: String,
        val value_pct: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    /* ============ FETCHERS ============ */

    suspend fun fetchSleepDurationDaily(accessToken: String, limitDays: Int = 14): List<SleepDurationDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_duration_daily", accessToken, "date,value_hours", limitDays)
    }

    suspend fun fetchSleepDisturbancesDaily(accessToken: String, limitDays: Int = 14): List<SleepDisturbancesDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_disturbances_daily", accessToken, "date,value_count", limitDays)
    }

    suspend fun fetchSleepStagesDaily(accessToken: String, limitDays: Int = 14): List<SleepStagesDailyRead> {
        return getList(
            "$supabaseUrl/rest/v1/sleep_stages_daily",
            accessToken,
            "date,value_sws_hm,value_rem_hm,value_light_hm",
            limitDays
        )
    }

    suspend fun fetchSleepScoreDaily(accessToken: String, limitDays: Int = 14): List<SleepScoreDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_score_daily", accessToken, "date,value_pct", limitDays)
    }

    suspend fun fetchSleepEfficiencyDaily(accessToken: String, limitDays: Int = 14): List<SleepEfficiencyDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_efficiency_daily", accessToken, "date,value_pct", limitDays)
    }

    private suspend inline fun <reified T> getList(
        endpoint: String,
        access: String,
        select: String,
        limit: Int
    ): List<T> {
        val resp = client.get(endpoint) {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("select", select)
            parameter("order", "date.desc")
            parameter("limit", limit.toString())
        }
        if (!resp.status.isSuccess()) return emptyList()
        return runCatching { resp.body<List<T>>() }.getOrDefault(emptyList())
    }

    /** True if a sleep row already exists for date & source in sleep_duration_daily. */
    suspend fun hasSleepForDate(accessToken: String, date: String, source: String): Boolean {
        val resp = client.get("$supabaseUrl/rest/v1/sleep_duration_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("date", "eq.$date")
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return false
        val body = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return body.isNotEmpty()
    }

    /** Latest date we have for WHOOP in sleep_duration_daily (used as backfill anchor). */
    suspend fun latestSleepDate(accessToken: String, source: String): String? {
        val resp = client.get("$supabaseUrl/rest/v1/sleep_duration_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val rows = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return rows.firstOrNull()?.get("date")
    }

    /* ============ UPSERTS ============ */

    suspend fun upsertSleepDurationDaily(
        accessToken: String, date: String, valueHours: Double, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_duration_daily", DurationRow(date, valueHours, source, sourceId)) }

    suspend fun upsertFellAsleepTimeDaily(
        accessToken: String, date: String, valueAtIso: String, source: String?, sourceId: String?
    ) { upsert(accessToken, "fell_asleep_time_daily", FellAsleepRow(date, valueAtIso, source, sourceId)) }

    suspend fun upsertWokeUpTimeDaily(
        accessToken: String, date: String, valueAtIso: String, source: String?, sourceId: String?
    ) { upsert(accessToken, "woke_up_time_daily", WakeRow(date, valueAtIso, source, sourceId)) }

    suspend fun upsertSleepDisturbancesDaily(
        accessToken: String, date: String, count: Int, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_disturbances_daily", DisturbancesRow(date, count, source, sourceId)) }

    suspend fun upsertSleepStagesDaily(
        accessToken: String, date: String, swsMs: Long, remMs: Long, lightMs: Long, source: String?, sourceId: String?
    ) {
        val row = StagesRow(
            date = date,
            value_sws_hm = msToHM(swsMs),
            value_rem_hm = msToHM(remMs),
            value_light_hm = msToHM(lightMs),
            source = source,
            source_measure_id = sourceId
        )
        upsert(accessToken, "sleep_stages_daily", row)
    }

    suspend fun upsertSleepScoreDaily(
        accessToken: String, date: String, pct: Double, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_score_daily", PctRow(date, pct, source, sourceId)) }

    suspend fun upsertSleepEfficiencyDaily(
        accessToken: String, date: String, pct: Double, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_efficiency_daily", PctRow(date, pct, source, sourceId)) }

    private suspend inline fun <reified T> upsert(accessToken: String, table: String, row: T) {
        val resp = client.post("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            parameter("on_conflict", "user_id,source,date")
            contentType(ContentType.Application.Json)
            setBody(listOf(row))
        }
        if (!resp.status.isSuccess()) {
            error("Upsert $table failed: HTTP ${resp.status.value}")
        }
    }

    private fun msToHM(ms: Long): Double {
        val totalMinutes = (ms / 60000).toInt()
        val hours = totalMinutes / 60
        val minutes = totalMinutes % 60
        return hours + (minutes / 100.0)
    }
}

title: SupabaseNutritionService.kt
text:
package com.migraineme

import android.content.Context
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.time.Instant
import java.time.LocalDate

/**
 * Service for uploading/deleting nutrition data to/from Supabase
 *
 * CRITICAL FIX: Now properly sets user_id to satisfy RLS policies
 */
class SupabaseNutritionService(private val context: Context) {

    companion object {
        private const val SUPABASE_URL = BuildConfig.SUPABASE_URL
        private const val SUPABASE_ANON_KEY = BuildConfig.SUPABASE_ANON_KEY
    }

    private val httpClient = OkHttpClient.Builder()
        .connectTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
        .readTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
        .writeTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
        .build()

    /**
     * Upload a single nutrition record to Supabase
     * Includes health_connect_id for deletion tracking
     *
     * CRITICAL FIX: Now properly sets user_id to satisfy RLS policies
     */
    suspend fun uploadNutritionRecord(
        accessToken: String,
        nutrition: NutritionData,
        healthConnectId: String
    ) {
        val url = "$SUPABASE_URL/rest/v1/nutrition_records"

        // CRITICAL FIX: Extract user_id from the JWT access token
        val userId = JwtUtils.extractUserIdFromAccessToken(accessToken)
            ?: throw Exception("Failed to extract user_id from access token - cannot satisfy RLS policy")

        android.util.Log.d("SupabaseNutrition", "Uploading nutrition record for user: $userId, HC ID: ${healthConnectId.take(12)}...")

        val body = buildJsonObject {
            // CRITICAL: Set user_id for RLS policy
            put("user_id", userId)

            // Add health_connect_id for deletion tracking
            put("health_connect_id", healthConnectId)

            put("date", nutrition.date.toString())
            put("timestamp", nutrition.timestamp.toString())
            nutrition.endTimestamp?.let { put("end_timestamp", it.toString()) }

            // Food details
            nutrition.foodName?.let { put("food_name", it) }
            put("meal_type", nutrition.mealType)

            // Energy
            nutrition.calories?.let { put("calories", it) }

            // Macronutrients
            nutrition.protein?.let { put("protein", it) }
            nutrition.totalCarbohydrate?.let { put("total_carbohydrate", it) }
            nutrition.sugar?.let { put("sugar", it) }
            nutrition.dietaryFiber?.let { put("dietary_fiber", it) }
            nutrition.totalFat?.let { put("total_fat", it) }
            nutrition.saturatedFat?.let { put("saturated_fat", it) }
            nutrition.unsaturatedFat?.let { put("unsaturated_fat", it) }
            nutrition.monounsaturatedFat?.let { put("monounsaturated_fat", it) }
            nutrition.polyunsaturatedFat?.let { put("polyunsaturated_fat", it) }
            nutrition.transFat?.let { put("trans_fat", it) }
            nutrition.cholesterol?.let { put("cholesterol", it) }

            // Minerals
            nutrition.calcium?.let { put("calcium", it) }
            nutrition.chloride?.let { put("chloride", it) }
            nutrition.chromium?.let { put("chromium", it) }
            nutrition.copper?.let { put("copper", it) }
            nutrition.iodine?.let { put("iodine", it) }
            nutrition.iron?.let { put("iron", it) }
            nutrition.magnesium?.let { put("magnesium", it) }
            nutrition.manganese?.let { put("manganese", it) }
            nutrition.molybdenum?.let { put("molybdenum", it) }
            nutrition.phosphorus?.let { put("phosphorus", it) }
            nutrition.potassium?.let { put("potassium", it) }
            nutrition.selenium?.let { put("selenium", it) }
            nutrition.sodium?.let { put("sodium", it) }
            nutrition.zinc?.let { put("zinc", it) }

            // Vitamins
            nutrition.vitaminA?.let { put("vitamin_a", it) }
            nutrition.vitaminB6?.let { put("vitamin_b6", it) }
            nutrition.vitaminB12?.let { put("vitamin_b12", it) }
            nutrition.vitaminC?.let { put("vitamin_c", it) }
            nutrition.vitaminD?.let { put("vitamin_d", it) }
            nutrition.vitaminE?.let { put("vitamin_e", it) }
            nutrition.vitaminK?.let { put("vitamin_k", it) }
            nutrition.biotin?.let { put("biotin", it) }
            nutrition.folate?.let { put("folate", it) }
            nutrition.folicAcid?.let { put("folic_acid", it) }
            nutrition.niacin?.let { put("niacin", it) }
            nutrition.pantothenicAcid?.let { put("pantothenic_acid", it) }
            nutrition.riboflavin?.let { put("riboflavin", it) }
            nutrition.thiamin?.let { put("thiamin", it) }

            // Other
            nutrition.caffeine?.let { put("caffeine", it) }
            nutrition.tyramineExposure?.let { put("tyramine_exposure", it) }
            nutrition.alcoholExposure?.let { put("alcohol_exposure", it) }
            nutrition.glutenExposure?.let { put("gluten_exposure", it) }

            // Metadata
            put("source", nutrition.source)
            put("enriched", nutrition.enriched)
        }

        val request = Request.Builder()
            .url(url)
            .post(body.toString().toRequestBody("application/json".toMediaType()))
            .header("apikey", SUPABASE_ANON_KEY)
            .header("Authorization", "Bearer $accessToken")
            .header("Content-Type", "application/json")
            .header("Prefer", "resolution=merge-duplicates")
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                val errorBody = response.body?.string()
                android.util.Log.e("SupabaseNutrition", "Upload failed: ${response.code} $errorBody")
                throw Exception("Failed to upload nutrition: ${response.code} $errorBody")
            }
            android.util.Log.d("SupabaseNutrition", "✅ Successfully uploaded nutrition record")
        }
    }

    /**
     * Delete nutrition records by Health Connect IDs (batch operation)
     */
    suspend fun deleteNutritionRecordsByHealthConnectIds(
        accessToken: String,
        healthConnectIds: List<String>
    ) {
        if (healthConnectIds.isEmpty()) return

        // Build filter: health_connect_id.in.(id1,id2,id3)
        val idsFilter = healthConnectIds.joinToString(",")
        val url = "$SUPABASE_URL/rest/v1/nutrition_records?health_connect_id=in.($idsFilter)"

        val request = Request.Builder()
            .url(url)
            .delete()
            .header("apikey", SUPABASE_ANON_KEY)
            .header("Authorization", "Bearer $accessToken")
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                throw Exception("Failed to delete nutrition records: ${response.code} ${response.body?.string()}")
            }
            android.util.Log.d("SupabaseNutrition", "Deleted ${healthConnectIds.size} records from Supabase")
        }
    }
}

/**
 * Data class representing nutrition data for upload
 */
data class NutritionData(
    // Timing
    val date: LocalDate,
    val timestamp: Instant,
    val endTimestamp: Instant?,

    // Food details
    val foodName: String?,
    val mealType: String,

    // Energy
    val calories: Double?,

    // Macronutrients (grams)
    val protein: Double?,
    val totalCarbohydrate: Double?,
    val sugar: Double?,
    val dietaryFiber: Double?,
    val totalFat: Double?,
    val saturatedFat: Double?,
    val unsaturatedFat: Double?,
    val monounsaturatedFat: Double?,
    val polyunsaturatedFat: Double?,
    val transFat: Double?,
    val cholesterol: Double?, // mg

    // Minerals (mg unless noted)
    val calcium: Double?,
    val chloride: Double?,
    val chromium: Double?, // mcg
    val copper: Double?,
    val iodine: Double?, // mcg
    val iron: Double?,
    val magnesium: Double?,
    val manganese: Double?,
    val molybdenum: Double?, // mcg
    val phosphorus: Double?,
    val potassium: Double?,
    val selenium: Double?, // mcg
    val sodium: Double?,
    val zinc: Double?,

    // Vitamins
    val vitaminA: Double?, // mcg RAE
    val vitaminB6: Double?, // mg
    val vitaminB12: Double?, // mcg
    val vitaminC: Double?, // mg
    val vitaminD: Double?, // mcg
    val vitaminE: Double?, // mg
    val vitaminK: Double?, // mcg
    val biotin: Double?, // mcg (B7)
    val folate: Double?, // mcg (B9)
    val folicAcid: Double?, // mcg
    val niacin: Double?, // mg (B3)
    val pantothenicAcid: Double?, // mg (B5)
    val riboflavin: Double?, // mg (B2)
    val thiamin: Double?, // mg (B1)

    // Other
    val caffeine: Double?, // mg
    val tyramineExposure: String? = null, // "none", "low", "medium", "high"
    val alcoholExposure: String? = null,  // "none", "low", "medium", "high"
    val glutenExposure: String? = null,   // "none", "low", "medium", "high"

    // Metadata
    val source: String,
    val enriched: Boolean
)


title: SupabasePersonalService.kt
text:
package com.migraineme

import android.content.Context
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import org.json.JSONArray

class SupabasePersonalService(context: Context) {
    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
    }

    @Serializable
    private data class LocationWriteRow(
        val date: String,
        val latitude: Double,
        val longitude: Double,
        val source: String,
        val source_measure_id: String? = null,
        val timezone: String? = null,
        val altitude_m: Double? = null,
        val altitude_max_m: Double? = null,
        val altitude_min_m: Double? = null,
        val altitude_change_m: Double? = null
    )

    @Serializable
    private data class LocationHourlyWriteRow(
        val timestamp: String,
        val latitude: Double,
        val longitude: Double,
        val source: String = "device",
        val timezone: String? = null,
        val altitude_m: Double? = null
    )

    @Serializable
    data class UserLocationDailyRead(
        val date: String,
        val latitude: Double,
        val longitude: Double,
        val source: String? = null,
        val source_measure_id: String? = null,
        val timezone: String? = null,
        val altitude_m: Double? = null
    )

    @Serializable
    private data class ScreenTimeDailyWrite(
        val date: String,
        val total_hours: Double,
        val source: String,
        val quality_flags: Map<String, String>? = null
    )

    @Serializable
    private data class ScreenTimeLiveWrite(
        val date: String,
        val value_hours: Double,
        val app_count: Int?,
        val source: String,
        val timezone: String? = null
    )

    @Serializable
    private data class ScreenTimeLateNightWrite(
        val date: String,
        val value_hours: Double,
        val app_count: Int?,
        val source: String,
        val timezone: String? = null
    )

    @Serializable
    private data class PhoneSleepDurationWrite(
        val date: String,
        val value_hours: Double,
        val source: String = "phone",
        val source_measure_id: String? = null
    )

    @Serializable
    private data class PhoneSleepTimeWrite(
        val date: String,
        val value_at: String,
        val source: String = "phone",
        val source_measure_id: String? = null
    )

    @Serializable
    private data class PhoneBrightnessSampleWrite(
        val user_id: String,
        val sampled_at: String,
        val value: Int,
        val source: String = "android"
    )

    @Serializable
    private data class PhoneVolumeSampleWrite(
        val user_id: String,
        val sampled_at: String,
        val value_pct: Int,
        val stream_type: String? = "media",
        val source: String = "android"
    )

    @Serializable
    private data class PhoneDarkModeSampleWrite(
        val user_id: String,
        val sampled_at: String,
        val is_dark: Boolean,
        val source: String = "android"
    )

    @Serializable
    private data class PhoneUnlockSampleWrite(
        val user_id: String,
        val sampled_at: String,
        val value_count: Int,
        val source: String = "android"
    )

    suspend fun upsertUserLocationDaily(
        accessToken: String,
        date: String,
        latitude: Double,
        longitude: Double,
        source: String = "device",
        sourceId: String? = null,
        timezone: String? = null,
        altitudeM: Double? = null,
        altitudeMaxM: Double? = null,
        altitudeMinM: Double? = null,
        altitudeChangeM: Double? = null
    ) {
        val row = LocationWriteRow(date, latitude, longitude, source, sourceId, timezone, altitudeM, altitudeMaxM, altitudeMinM, altitudeChangeM)
        postgrestInsert(
            accessToken = accessToken,
            table = "user_location_daily",
            body = listOf(row),
            onConflict = "user_id,source,date"
        )
    }

    /**
     * Insert hourly location data.
     * Uses timestamp with timezone for precise tracking.
     */
    suspend fun insertUserLocationHourly(
        accessToken: String,
        timestamp: String,
        latitude: Double,
        longitude: Double,
        source: String = "device",
        timezone: String? = null,
        altitudeM: Double? = null
    ) {
        val row = LocationHourlyWriteRow(timestamp, latitude, longitude, source, timezone, altitudeM)
        postgrestInsert(
            accessToken = accessToken,
            table = "user_location_hourly",
            body = listOf(row),
            onConflict = "user_id,timestamp"
        )
    }

    suspend fun fetchUserLocationDaily(
        accessToken: String,
        limitDays: Int = 14
    ): List<UserLocationDailyRead> {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date,latitude,longitude,source,source_measure_id,altitude_m")
            parameter("order", "date.desc")
            parameter("limit", limitDays.toString())
        }
        if (!resp.status.isSuccess()) return emptyList()
        return runCatching { resp.body<List<UserLocationDailyRead>>() }.getOrNull() ?: emptyList()
    }

    suspend fun hasUserLocationForDate(
        accessToken: String,
        date: String,
        source: String = "device"
    ): Boolean {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("date", "eq.$date")
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return false
        val txt = resp.bodyAsText().trim()
        return txt.startsWith("[{")
    }

    /**
     * Fetch all hourly altitude readings for a given date.
     * Returns list of altitude values (non-null only).
     * Used to compute running max/min/change for daily aggregation.
     */
    suspend fun fetchHourlyAltitudesForDate(
        accessToken: String,
        date: String
    ): List<Double> {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_hourly") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "altitude_m")
            parameter("altitude_m", "not.is.null")
            // Filter by date portion of timestamp
            parameter("timestamp", "gte.${date}T00:00:00")
            parameter("timestamp", "lt.${date}T23:59:59.999")
            parameter("order", "timestamp.asc")
        }
        if (!resp.status.isSuccess()) return emptyList()
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return emptyList()
        return try {
            val arr = JSONArray(body)
            (0 until arr.length()).mapNotNull { i ->
                val obj = arr.getJSONObject(i)
                if (obj.isNull("altitude_m")) null else obj.getDouble("altitude_m")
            }
        } catch (_: Throwable) {
            emptyList()
        }
    }

    suspend fun latestUserLocationDate(
        accessToken: String,
        source: String = "device"
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.$source")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    suspend fun earliestUserLocationDate(
        accessToken: String,
        source: String = "device"
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.$source")
            parameter("order", "date.asc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    // ========== SCREEN TIME METHODS ==========

    suspend fun upsertScreenTimeDaily(
        accessToken: String,
        date: String,
        totalHours: Double,
        source: String = "android",
        qualityFlags: Map<String, String>? = null
    ) {
        val row = ScreenTimeDailyWrite(date, totalHours, source, qualityFlags)
        postgrestInsert(
            accessToken = accessToken,
            table = "screen_time_daily",
            body = listOf(row),
            onConflict = "user_id,date,source"
        )
    }

    suspend fun upsertScreenTimeLive(
        accessToken: String,
        date: String,
        totalHours: Double,
        appCount: Int? = null,
        source: String = "android",
        timezone: String? = null
    ) {
        val row = ScreenTimeLiveWrite(date, totalHours, appCount, source, timezone)
        postgrestInsert(
            accessToken = accessToken,
            table = "screen_time_live",
            body = listOf(row),
            onConflict = "user_id,date"
        )
    }

    suspend fun latestScreenTimeDate(
        accessToken: String,
        source: String = "android"
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/screen_time_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.$source")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    // ========== LATE-NIGHT SCREEN TIME METHODS ==========

    suspend fun upsertScreenTimeLateNight(
        accessToken: String,
        date: String,
        totalHours: Double,
        appCount: Int? = null,
        source: String = "android",
        timezone: String? = null
    ) {
        val row = ScreenTimeLateNightWrite(date, totalHours, appCount, source, timezone)
        postgrestInsert(
            accessToken = accessToken,
            table = "screen_time_late_night",
            body = listOf(row),
            onConflict = "user_id,date,source"
        )
    }

    suspend fun latestScreenTimeLateNightDate(
        accessToken: String,
        source: String = "android"
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/screen_time_late_night") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.$source")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    // ========== PHONE SLEEP METHODS ==========

    suspend fun upsertPhoneSleepData(
        accessToken: String,
        date: String,
        durationHours: Double,
        fellAsleepIso: String,
        wokeUpIso: String,
        timezone: String? = null
    ) {
        postgrestInsert(
            accessToken = accessToken,
            table = "sleep_duration_daily",
            body = listOf(PhoneSleepDurationWrite(date, durationHours)),
            onConflict = "user_id,source,date"
        )
        postgrestInsert(
            accessToken = accessToken,
            table = "fell_asleep_time_daily",
            body = listOf(PhoneSleepTimeWrite(date, fellAsleepIso)),
            onConflict = "user_id,source,date"
        )
        postgrestInsert(
            accessToken = accessToken,
            table = "woke_up_time_daily",
            body = listOf(PhoneSleepTimeWrite(date, wokeUpIso)),
            onConflict = "user_id,source,date"
        )
    }

    suspend fun latestPhoneSleepDate(
        accessToken: String
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/sleep_duration_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.phone")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    // ========== PHONE BEHAVIOR METHODS ==========

    suspend fun insertPhoneBrightnessSample(
        accessToken: String,
        userId: String,
        sampledAtIso: String,
        brightness: Int
    ) {
        postgrestInsert(
            accessToken = accessToken,
            table = "phone_brightness_samples",
            body = PhoneBrightnessSampleWrite(
                user_id = userId,
                sampled_at = sampledAtIso,
                value = brightness
            )
        )
    }

    suspend fun insertPhoneVolumeSample(
        accessToken: String,
        userId: String,
        sampledAtIso: String,
        volumePct: Int,
        streamType: String = "media"
    ) {
        postgrestInsert(
            accessToken = accessToken,
            table = "phone_volume_samples",
            body = PhoneVolumeSampleWrite(
                user_id = userId,
                sampled_at = sampledAtIso,
                value_pct = volumePct,
                stream_type = streamType
            )
        )
    }

    suspend fun insertPhoneDarkModeSample(
        accessToken: String,
        userId: String,
        sampledAtIso: String,
        isDark: Boolean
    ) {
        postgrestInsert(
            accessToken = accessToken,
            table = "phone_dark_mode_samples",
            body = PhoneDarkModeSampleWrite(
                user_id = userId,
                sampled_at = sampledAtIso,
                is_dark = isDark
            )
        )
    }

    suspend fun insertPhoneUnlockSample(
        accessToken: String,
        userId: String,
        sampledAtIso: String,
        unlockCount: Int
    ) {
        postgrestInsert(
            accessToken = accessToken,
            table = "phone_unlock_samples",
            body = PhoneUnlockSampleWrite(
                user_id = userId,
                sampled_at = sampledAtIso,
                value_count = unlockCount
            )
        )
    }

    private suspend inline fun <reified T> postgrestInsert(
        accessToken: String,
        table: String,
        body: T,
        onConflict: String? = null
    ) {
        val resp = client.post("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            onConflict?.let { parameter("on_conflict", it) }
            contentType(ContentType.Application.Json)
            setBody(body)
        }
        if (!resp.status.isSuccess()) {
            val msg = runCatching { resp.bodyAsText() }.getOrNull()
            error("Upsert into $table failed: HTTP ${resp.status.value} ${msg ?: ""}".trim())
        }
    }
}

title: SupabasePhysicalHealthService.kt
text:
// FILE: app/src/main/java/com/migraineme/SupabasePhysicalHealthService.kt
package com.migraineme

import android.content.Context
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Supabase service for Physical Health metrics.
 *
 * Tables:
 * - recovery_score_daily
 * - resting_hr_daily
 * - hrv_daily
 * - skin_temp_daily
 * - spo2_daily
 * - stress_index_daily
 * - time_in_high_hr_zones_daily
 *
 * NOTE:
 * - time_in_high_hr_zones_daily also carries "activities" fields:
 *   activity_type, start_at, end_at, plus zone_zero/one/two minutes when available.
 *
 * Unique key everywhere: (user_id, source, date)
 */
class SupabasePhysicalHealthService(context: Context) {

    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
    }

    /* ============================================================
     * READ DTOs
     * ============================================================
     */

    @Serializable
    data class RecoveryScoreDailyRead(
        val date: String,
        @SerialName("value_pct") val value_pct: Double
    )

    @Serializable
    data class RestingHrDailyRead(
        val date: String,
        @SerialName("value_bpm") val value_bpm: Double
    )

    @Serializable
    data class HrvDailyRead(
        val date: String,
        @SerialName("value_rmssd_ms") val value_rmssd_ms: Double
    )

    @Serializable
    data class SkinTempDailyRead(
        val date: String,
        @SerialName("value_celsius") val value_celsius: Double
    )

    @Serializable
    data class Spo2DailyRead(
        val date: String,
        @SerialName("value_pct") val value_pct: Double
    )

    @Serializable
    data class StressIndexDailyRead(
        val date: String,
        val value: Double,
        @SerialName("computed_at") val computed_at: String? = null
    )

    @Serializable
    data class HighHrZonesDailyRead(
        val date: String,
        @SerialName("value_minutes") val value_minutes: Double,

        // These are the "high HR" zones used for totals
        @SerialName("zone_three_minutes") val zone_three_minutes: Double,
        @SerialName("zone_four_minutes") val zone_four_minutes: Double,
        @SerialName("zone_five_minutes") val zone_five_minutes: Double,
        @SerialName("zone_six_minutes") val zone_six_minutes: Double,

        // Optional (present when you store full zone splits / activities)
        @SerialName("zone_zero_minutes") val zone_zero_minutes: Double? = null,
        @SerialName("zone_one_minutes") val zone_one_minutes: Double? = null,
        @SerialName("zone_two_minutes") val zone_two_minutes: Double? = null,

        @SerialName("activity_type") val activity_type: String? = null,
        @SerialName("start_at") val start_at: String? = null,
        @SerialName("end_at") val end_at: String? = null,

        @SerialName("source_measure_id") val source_measure_id: String? = null,
        @SerialName("source") val source: String? = null
    )

    /* ============================================================
     * WRITER DTOs
     * ============================================================
     */

    @Serializable private data class PctRow(
        val date: String,
        val value_pct: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class HrRow(
        val date: String,
        val value_bpm: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class HrvRow(
        val date: String,
        val value_rmssd_ms: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class TempRow(
        val date: String,
        val value_celsius: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class Spo2Row(
        val date: String,
        val value_pct: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class HighHrRow(
        val date: String,
        val value_minutes: Double,
        val zone_three_minutes: Double,
        val zone_four_minutes: Double,
        val zone_five_minutes: Double,
        val zone_six_minutes: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    /* ============================================================
     * GENERIC FETCHER
     * ============================================================
     */

    private suspend inline fun <reified T> getList(
        endpoint: String,
        access: String,
        select: String,
        limit: Int,
        order: String = "date.desc"
    ): List<T> {
        val resp = client.get(endpoint) {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("select", select)
            parameter("order", order)
            parameter("limit", limit.toString())
        }
        if (!resp.status.isSuccess()) return emptyList()
        return runCatching { resp.body<List<T>>() }.getOrDefault(emptyList())
    }

    /* ============================================================
     * PUBLIC FETCH API
     * ============================================================
     */

    suspend fun fetchRecoveryScoreDaily(access: String, days: Int = 14): List<RecoveryScoreDailyRead> =
        getList("$supabaseUrl/rest/v1/recovery_score_daily", access, "date,value_pct", days)

    suspend fun fetchRestingHrDaily(access: String, days: Int = 14): List<RestingHrDailyRead> =
        getList("$supabaseUrl/rest/v1/resting_hr_daily", access, "date,value_bpm", days)

    suspend fun fetchHrvDaily(access: String, days: Int = 14): List<HrvDailyRead> =
        getList("$supabaseUrl/rest/v1/hrv_daily", access, "date,value_rmssd_ms", days)

    suspend fun fetchSkinTempDaily(access: String, days: Int = 14): List<SkinTempDailyRead> =
        getList("$supabaseUrl/rest/v1/skin_temp_daily", access, "date,value_celsius", days)

    suspend fun fetchSpo2Daily(access: String, days: Int = 14): List<Spo2DailyRead> =
        getList("$supabaseUrl/rest/v1/spo2_daily", access, "date,value_pct", days)

    suspend fun fetchStressIndexDaily(access: String, days: Int = 14): List<StressIndexDailyRead> =
        getList("$supabaseUrl/rest/v1/stress_index_daily", access, "date,value,computed_at", days)

    suspend fun fetchHighHrDaily(access: String, days: Int = 14): List<HighHrZonesDailyRead> =
        getList(
            "$supabaseUrl/rest/v1/time_in_high_hr_zones_daily",
            access,
            "date,value_minutes,zone_zero_minutes,zone_one_minutes,zone_two_minutes,zone_three_minutes,zone_four_minutes,zone_five_minutes,zone_six_minutes,activity_type,start_at,end_at,source,source_measure_id",
            days
        )

    suspend fun fetchHighHrActivities(access: String, limitRows: Int = 50): List<HighHrZonesDailyRead> =
        getList(
            "$supabaseUrl/rest/v1/time_in_high_hr_zones_daily",
            access,
            "date,value_minutes,zone_zero_minutes,zone_one_minutes,zone_two_minutes,zone_three_minutes,zone_four_minutes,zone_five_minutes,zone_six_minutes,activity_type,start_at,end_at,source,source_measure_id",
            limitRows,
            order = "start_at.desc"
        )

    /* ============================================================
     * CONFLICT CHECKERS
     * ============================================================
     */

    suspend fun hasRecoveryForDate(access: String, date: String, source: String): Boolean {
        val resp = client.get("$supabaseUrl/rest/v1/recovery_score_daily") {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("date", "eq.$date")
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return false
        val body = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return body.isNotEmpty()
    }

    suspend fun latestPhysicalDate(access: String, source: String): String? {
        val resp = client.get("$supabaseUrl/rest/v1/recovery_score_daily") {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val rows = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return rows.firstOrNull()?.get("date")
    }

    /* ============================================================
     * UPSERTS
     * ============================================================
     */

    suspend fun upsertRecoveryScoreDaily(
        access: String, date: String, valuePct: Double, source: String?, sourceId: String?
    ) = upsert(access, "recovery_score_daily", PctRow(date, valuePct, source, sourceId))

    suspend fun upsertRestingHrDaily(
        access: String, date: String, bpm: Double, source: String?, sourceId: String?
    ) = upsert(access, "resting_hr_daily", HrRow(date, bpm, source, sourceId))

    suspend fun upsertHrvDaily(
        access: String, date: String, rmssd: Double, source: String?, sourceId: String?
    ) = upsert(access, "hrv_daily", HrvRow(date, rmssd, source, sourceId))

    suspend fun upsertSkinTempDaily(
        access: String, date: String, celsius: Double, source: String?, sourceId: String?
    ) = upsert(access, "skin_temp_daily", TempRow(date, celsius, source, sourceId))

    suspend fun upsertSpo2Daily(
        access: String, date: String, pct: Double, source: String?, sourceId: String?
    ) = upsert(access, "spo2_daily", Spo2Row(date, pct, source, sourceId))

    suspend fun upsertHighHrDaily(
        access: String,
        date: String,
        totalMinutes: Double,
        z3: Double,
        z4: Double,
        z5: Double,
        z6: Double,
        source: String?,
        sourceId: String?
    ) = upsert(
        access,
        "time_in_high_hr_zones_daily",
        HighHrRow(date, totalMinutes, z3, z4, z5, z6, source, sourceId)
    )

    private suspend inline fun <reified T> upsert(
        accessToken: String,
        table: String,
        row: T
    ) {
        val resp = client.post("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            parameter("on_conflict", "user_id,source,date")
            contentType(ContentType.Application.Json)
            setBody(listOf(row))
        }
        if (!resp.status.isSuccess()) {
            error("Upsert $table failed: HTTP ${resp.status.value}")
        }
    }
}

title: SupabaseProfileService.kt
text:
package com.migraineme

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.patch
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Source-of-truth app profile data (provider-agnostic).
 *
 * Backed by Supabase PostgREST table: profiles
 * - user_id uuid PK (RLS ensures auth.uid() can only read/write their own row)
 * - display_name text
 * - avatar_url text
 * - migraine_type migraine_type enum (nullable)
 */
object SupabaseProfileService {

    // Keep config consistent with the rest of the app: BuildConfig + anon key.
    private val baseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
    private val anonKey = BuildConfig.SUPABASE_ANON_KEY

    private val json = Json {
        ignoreUnknownKeys = true
        explicitNulls = false
        encodeDefaults = false
    }

    private val client = HttpClient(Android) {
        install(ContentNegotiation) { json(json) }
    }

    // ---- Public models (what the app uses) ----

    enum class MigraineType(val dbValue: String, val label: String) {
        MIGRAINE("migraine", "Migraine"),
        MIGRAINE_WITH_AURA("migraine_with_aura", "Migraine with aura"),
        CLUSTER("cluster", "Cluster"),
        TENSION("tension", "Tension"),
        HEMIPLEGIC("hemiplegic", "Hemiplegic"),
        VESTIBULAR("vestibular", "Vestibular"),
        OTHER("other", "Other");

        companion object {
            fun fromDbValue(value: String?): MigraineType? {
                if (value.isNullOrBlank()) return null
                return entries.firstOrNull { it.dbValue == value }
            }
        }
    }

    data class Profile(
        val userId: String,
        val displayName: String?,
        val avatarUrl: String?,
        val migraineType: MigraineType?
    )

    /**
     * Ensures a row exists for this user and optionally fills missing display_name/avatar_url
     * using provider "hints" (Google/Apple/Facebook).
     *
     * Rules:
     * - Never overwrites a user-provided value.
     * - Only sets fields if they are currently null/blank.
     */
    suspend fun ensureProfile(
        accessToken: String,
        userId: String,
        displayNameHint: String?,
        avatarUrlHint: String?
    ): Profile {
        val existing = getProfile(accessToken, userId)
        if (existing == null) {
            // No row: insert with whatever hints we have (can be null).
            return insertProfile(
                accessToken = accessToken,
                userId = userId,
                displayName = displayNameHint?.takeIf { it.isNotBlank() },
                avatarUrl = avatarUrlHint?.takeIf { it.isNotBlank() },
                migraineType = null
            )
        }

        // Row exists: only fill missing values.
        val needsDisplayName = existing.displayName.isNullOrBlank() && !displayNameHint.isNullOrBlank()
        val needsAvatarUrl = existing.avatarUrl.isNullOrBlank() && !avatarUrlHint.isNullOrBlank()

        if (!needsDisplayName && !needsAvatarUrl) return existing

        return patchProfile(
            accessToken = accessToken,
            userId = userId,
            displayName = if (needsDisplayName) displayNameHint!!.trim() else null,
            avatarUrl = if (needsAvatarUrl) avatarUrlHint!!.trim() else null,
            migraineType = null
        )
    }

    suspend fun getProfile(accessToken: String, userId: String): Profile? {
        val url =
            "$baseUrl/rest/v1/profiles?user_id=eq.$userId&select=user_id,display_name,avatar_url,migraine_type"

        val rows: List<ProfileRow> = client.get(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
        }.body()

        val row = rows.firstOrNull() ?: return null
        return row.toDomain()
    }

    /**
     * Update any combination of fields in one request (used by Profile UI).
     * Pass null for fields you don't want to change.
     */
    suspend fun updateProfile(
        accessToken: String,
        userId: String,
        displayName: String? = null,
        avatarUrl: String? = null,
        migraineType: MigraineType? = null
    ): Profile {
        return patchProfile(
            accessToken = accessToken,
            userId = userId,
            displayName = displayName?.trim(),
            avatarUrl = avatarUrl?.trim(),
            migraineType = migraineType
        )
    }

    // ---- Wire format (PostgREST JSON) ----

    @Serializable
    private data class ProfileRow(
        @SerialName("user_id") val userId: String,
        @SerialName("display_name") val displayName: String? = null,
        @SerialName("avatar_url") val avatarUrl: String? = null,
        @SerialName("migraine_type") val migraineType: String? = null
    ) {
        fun toDomain(): Profile =
            Profile(
                userId = userId,
                displayName = displayName,
                avatarUrl = avatarUrl,
                migraineType = MigraineType.fromDbValue(migraineType)
            )
    }

    @Serializable
    private data class InsertProfileBody(
        @SerialName("user_id") val userId: String,
        @SerialName("display_name") val displayName: String? = null,
        @SerialName("avatar_url") val avatarUrl: String? = null,
        @SerialName("migraine_type") val migraineType: String? = null
    )

    @Serializable
    private data class PatchProfileBody(
        @SerialName("display_name") val displayName: String? = null,
        @SerialName("avatar_url") val avatarUrl: String? = null,
        @SerialName("migraine_type") val migraineType: String? = null
    )

    private suspend fun insertProfile(
        accessToken: String,
        userId: String,
        displayName: String?,
        avatarUrl: String?,
        migraineType: MigraineType?
    ): Profile {
        val url = "$baseUrl/rest/v1/profiles?select=user_id,display_name,avatar_url,migraine_type"

        val body = InsertProfileBody(
            userId = userId,
            displayName = displayName,
            avatarUrl = avatarUrl,
            migraineType = migraineType?.dbValue
        )

        val rows: List<ProfileRow> = client.post(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
            header("Prefer", "return=representation")
            contentType(ContentType.Application.Json)
            setBody(body)
        }.body()

        return rows.first().toDomain()
    }

    private suspend fun patchProfile(
        accessToken: String,
        userId: String,
        displayName: String?,
        avatarUrl: String?,
        migraineType: MigraineType?
    ): Profile {
        val url =
            "$baseUrl/rest/v1/profiles?user_id=eq.$userId&select=user_id,display_name,avatar_url,migraine_type"

        val body = PatchProfileBody(
            displayName = displayName,
            avatarUrl = avatarUrl,
            migraineType = migraineType?.dbValue
        )

        val rows: List<ProfileRow> = client.patch(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
            header("Prefer", "return=representation")
            contentType(ContentType.Application.Json)
            setBody(body)
        }.body()

        return rows.first().toDomain()
    }
}

title: SymptomIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.PathFillType
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

/**
 * Custom symptom icons for MigraineMe.
 * Style: 24dp viewport, 2dp stroke, rounded caps/joins, no fill.
 */
object SymptomIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    // ─── PAIN CHARACTER ───────────────────────────────────────

    /** Throbbing / pulsing — heartbeat pulse wave */
    val Throbbing: ImageVector by lazy {
        ImageVector.Builder("Throbbing", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(2f, 12f)
                lineTo(6f, 12f)
                lineTo(8f, 6f)
                lineTo(10f, 18f)
                lineTo(12f, 4f)
                lineTo(14f, 16f)
                lineTo(16f, 10f)
                lineTo(18f, 12f)
                lineTo(22f, 12f)
            }
        }.build()
    }

    /** Pressure / squeezing — two arrows pressing inward on a circle */
    val Pressure: ImageVector by lazy {
        ImageVector.Builder("Pressure", W.dp, H.dp, W, H).apply {
            // Center circle
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                // Small circle
                moveTo(15f, 12f)
                arcTo(3f, 3f, 0f, true, true, 9f, 12f)
                arcTo(3f, 3f, 0f, true, true, 15f, 12f)
            }
            // Left arrow pressing in
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(2f, 12f)
                lineTo(6f, 12f)
                moveTo(4.5f, 10f)
                lineTo(6f, 12f)
                lineTo(4.5f, 14f)
            }
            // Right arrow pressing in
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(22f, 12f)
                lineTo(18f, 12f)
                moveTo(19.5f, 10f)
                lineTo(18f, 12f)
                lineTo(19.5f, 14f)
            }
        }.build()
    }

    /** Stabbing / sharp — lightning bolt */
    val Stabbing: ImageVector by lazy {
        ImageVector.Builder("Stabbing", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(13f, 2f)
                lineTo(6f, 13f)
                lineTo(12f, 13f)
                lineTo(11f, 22f)
                lineTo(18f, 11f)
                lineTo(12f, 11f)
                close()
            }
        }.build()
    }

    /** Dull ache — slow wave, gentle */
    val DullAche: ImageVector by lazy {
        ImageVector.Builder("DullAche", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(2f, 12f)
                curveTo(5f, 8f, 7f, 8f, 9f, 12f)
                curveTo(11f, 16f, 13f, 16f, 15f, 12f)
                curveTo(17f, 8f, 19f, 8f, 22f, 12f)
            }
        }.build()
    }

    /** Burning — flame */
    val Burning: ImageVector by lazy {
        ImageVector.Builder("Burning", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 22f)
                curveTo(7f, 22f, 4f, 18f, 4f, 14f)
                curveTo(4f, 10f, 8f, 6f, 12f, 2f)
                curveTo(16f, 6f, 20f, 10f, 20f, 14f)
                curveTo(20f, 18f, 17f, 22f, 12f, 22f)
            }
            // Inner flame
            path(
                stroke = stroke, strokeLineWidth = 1.5f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 20f)
                curveTo(10f, 20f, 8.5f, 18.5f, 8.5f, 16.5f)
                curveTo(8.5f, 14.5f, 10f, 13f, 12f, 11f)
                curveTo(14f, 13f, 15.5f, 14.5f, 15.5f, 16.5f)
                curveTo(15.5f, 18.5f, 14f, 20f, 12f, 20f)
            }
        }.build()
    }

    // ─── ACCOMPANYING EXPERIENCE ──────────────────────────────

    /** With aura — starburst / sparkle */
    val Aura: ImageVector by lazy {
        ImageVector.Builder("Aura", W.dp, H.dp, W, H).apply {
            // Main star
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 2f); lineTo(12f, 6f)
                moveTo(12f, 18f); lineTo(12f, 22f)
                moveTo(2f, 12f); lineTo(6f, 12f)
                moveTo(18f, 12f); lineTo(22f, 12f)
            }
            // Diagonal rays
            path(
                stroke = stroke, strokeLineWidth = 1.5f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(4.9f, 4.9f); lineTo(7.8f, 7.8f)
                moveTo(16.2f, 16.2f); lineTo(19.1f, 19.1f)
                moveTo(4.9f, 19.1f); lineTo(7.8f, 16.2f)
                moveTo(16.2f, 7.8f); lineTo(19.1f, 4.9f)
            }
        }.build()
    }

    /** Nausea — wavy stomach / queasy swirl */
    val Nausea: ImageVector by lazy {
        ImageVector.Builder("Nausea", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(4f, 8f)
                curveTo(6f, 5f, 10f, 5f, 12f, 8f)
                curveTo(14f, 11f, 18f, 11f, 20f, 8f)
            }
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(4f, 13f)
                curveTo(6f, 10f, 10f, 10f, 12f, 13f)
                curveTo(14f, 16f, 18f, 16f, 20f, 13f)
            }
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(4f, 18f)
                curveTo(6f, 15f, 10f, 15f, 12f, 18f)
                curveTo(14f, 21f, 18f, 21f, 20f, 18f)
            }
        }.build()
    }

    /** Light sensitivity — sun with rays and a slash */
    val LightSensitivity: ImageVector by lazy {
        ImageVector.Builder("LightSensitivity", W.dp, H.dp, W, H).apply {
            // Sun circle
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(16f, 12f)
                arcTo(4f, 4f, 0f, true, true, 8f, 12f)
                arcTo(4f, 4f, 0f, true, true, 16f, 12f)
            }
            // Rays
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(12f, 2f); lineTo(12f, 4f)
                moveTo(12f, 20f); lineTo(12f, 22f)
                moveTo(4f, 12f); lineTo(2f, 12f)
                moveTo(20f, 12f); lineTo(22f, 12f)
            }
            // Slash through
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(4f, 4f)
                lineTo(20f, 20f)
            }
        }.build()
    }

    /** Sound sensitivity — speaker with waves and a slash */
    val SoundSensitivity: ImageVector by lazy {
        ImageVector.Builder("SoundSensitivity", W.dp, H.dp, W, H).apply {
            // Speaker body
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(3f, 9f)
                lineTo(7f, 9f)
                lineTo(11f, 5f)
                lineTo(11f, 19f)
                lineTo(7f, 15f)
                lineTo(3f, 15f)
                close()
            }
            // Sound waves
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(15f, 9f)
                curveTo(16.5f, 10f, 16.5f, 14f, 15f, 15f)
                moveTo(18f, 7f)
                curveTo(20.5f, 9f, 20.5f, 15f, 18f, 17f)
            }
            // Slash
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(4f, 4f)
                lineTo(20f, 20f)
            }
        }.build()
    }

    /** Dizziness / vertigo — spiral */
    val Dizziness: ImageVector by lazy {
        ImageVector.Builder("Dizziness", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 12f)
                curveTo(12f, 10f, 14f, 8f, 16f, 8f)
                curveTo(19f, 8f, 20f, 10f, 20f, 12f)
                curveTo(20f, 16f, 16f, 18f, 12f, 18f)
                curveTo(7f, 18f, 4f, 15f, 4f, 12f)
                curveTo(4f, 7f, 8f, 4f, 12f, 4f)
                curveTo(18f, 4f, 22f, 8f, 22f, 12f)
            }
        }.build()
    }

    /** Neck stiffness — neck with lock/stiff indicator */
    val NeckStiffness: ImageVector by lazy {
        ImageVector.Builder("NeckStiffness", W.dp, H.dp, W, H).apply {
            // Head circle
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(16f, 7f)
                arcTo(4f, 4f, 0f, true, false, 8f, 7f)
                arcTo(4f, 4f, 0f, true, false, 16f, 7f)
            }
            // Neck
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(9.5f, 10.5f)
                lineTo(9.5f, 16f)
                lineTo(5f, 21f)
                moveTo(14.5f, 10.5f)
                lineTo(14.5f, 16f)
                lineTo(19f, 21f)
            }
            // Stiff zigzag on neck
            path(
                stroke = stroke, strokeLineWidth = 1.5f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(10.5f, 12f)
                lineTo(11.5f, 13f)
                lineTo(12.5f, 12f)
                lineTo(13.5f, 13f)
            }
        }.build()
    }

    /** Brain fog — cloud */
    val BrainFog: ImageVector by lazy {
        ImageVector.Builder("BrainFog", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(6f, 18f)
                curveTo(3f, 18f, 2f, 16f, 2f, 14f)
                curveTo(2f, 12f, 3.5f, 10.5f, 5.5f, 10.5f)
                curveTo(5.5f, 7.5f, 8f, 5f, 11f, 5f)
                curveTo(13.5f, 5f, 15.5f, 6.5f, 16.5f, 8.5f)
                curveTo(17f, 8.2f, 17.5f, 8f, 18f, 8f)
                curveTo(20.2f, 8f, 22f, 9.8f, 22f, 12f)
                curveTo(22f, 14.2f, 20.2f, 16f, 18f, 16f)
                lineTo(18f, 18f)
                close()
            }
            // Fog lines
            path(
                stroke = stroke, strokeLineWidth = 1.5f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(8f, 14f); lineTo(10f, 14f)
                moveTo(12f, 14f); lineTo(16f, 14f)
            }
        }.build()
    }

    /** Fatigue — drooping eyelid / heavy eye */
    val Fatigue: ImageVector by lazy {
        ImageVector.Builder("Fatigue", W.dp, H.dp, W, H).apply {
            // Open eye shape
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(2f, 12f)
                curveTo(5f, 7f, 9f, 5f, 12f, 5f)
                curveTo(15f, 5f, 19f, 7f, 22f, 12f)
            }
            // Drooping lid
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(2f, 12f)
                curveTo(5f, 15f, 9f, 16f, 12f, 14f)
                curveTo(15f, 12f, 19f, 13f, 22f, 12f)
            }
            // Z Z
            path(
                stroke = stroke, strokeLineWidth = 1.5f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(17f, 3f); lineTo(20f, 3f); lineTo(17f, 6f); lineTo(20f, 6f)
            }
        }.build()
    }

    /** Blurred vision — eye with blur lines */
    val BlurredVision: ImageVector by lazy {
        ImageVector.Builder("BlurredVision", W.dp, H.dp, W, H).apply {
            // Eye outline
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(2f, 12f)
                curveTo(5f, 7f, 9f, 5f, 12f, 5f)
                curveTo(15f, 5f, 19f, 7f, 22f, 12f)
                curveTo(19f, 17f, 15f, 19f, 12f, 19f)
                curveTo(9f, 19f, 5f, 17f, 2f, 12f)
            }
            // Pupil
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(14.5f, 12f)
                arcTo(2.5f, 2.5f, 0f, true, true, 9.5f, 12f)
                arcTo(2.5f, 2.5f, 0f, true, true, 14.5f, 12f)
            }
            // Blur streaks
            path(
                stroke = stroke, strokeLineWidth = 1.5f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(1f, 9f); lineTo(4f, 9f)
                moveTo(20f, 15f); lineTo(23f, 15f)
                moveTo(1f, 15f); lineTo(4f, 15f)
            }
        }.build()
    }

    /** Tingling / numbness — dots radiating from fingertips */
    val Tingling: ImageVector by lazy {
        ImageVector.Builder("Tingling", W.dp, H.dp, W, H).apply {
            // Hand outline (simplified)
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(8f, 22f)
                lineTo(8f, 14f)
                curveTo(8f, 13f, 6f, 13f, 6f, 14f)
                lineTo(6f, 16f)
                moveTo(8f, 14f)
                lineTo(8f, 8f)
                moveTo(8f, 9f)
                lineTo(12f, 9f)
                lineTo(12f, 14f)
                moveTo(12f, 10f)
                lineTo(16f, 10f)
                lineTo(16f, 14f)
                lineTo(12f, 14f)
                lineTo(12f, 22f)
            }
            // Tingle dots
            path(
                fill = SolidColor(Color.White),
                stroke = null
            ) {
                // Small circles as dots
                moveTo(19f, 6f); arcTo(1f, 1f, 0f, true, true, 17f, 6f); arcTo(1f, 1f, 0f, true, true, 19f, 6f)
                moveTo(21f, 9f); arcTo(1f, 1f, 0f, true, true, 19f, 9f); arcTo(1f, 1f, 0f, true, true, 21f, 9f)
                moveTo(20f, 3f); arcTo(0.8f, 0.8f, 0f, true, true, 18.4f, 3f); arcTo(0.8f, 0.8f, 0f, true, true, 20f, 3f)
                moveTo(22f, 6f); arcTo(0.8f, 0.8f, 0f, true, true, 20.4f, 6f); arcTo(0.8f, 0.8f, 0f, true, true, 22f, 6f)
            }
        }.build()
    }

    // ─── GENERIC / PICKER ICONS ─────────────────────────────

    /** Generic circle — default for custom symptoms */
    val GenericCircle: ImageVector by lazy {
        ImageVector.Builder("GenericCircle", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(19f, 12f)
                arcTo(7f, 7f, 0f, true, true, 5f, 12f)
                arcTo(7f, 7f, 0f, true, true, 19f, 12f)
            }
        }.build()
    }

    /** Diamond */
    val Diamond: ImageVector by lazy {
        ImageVector.Builder("Diamond", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 2f)
                lineTo(22f, 12f)
                lineTo(12f, 22f)
                lineTo(2f, 12f)
                close()
            }
        }.build()
    }

    /** Triangle */
    val Triangle: ImageVector by lazy {
        ImageVector.Builder("Triangle", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 3f)
                lineTo(21f, 21f)
                lineTo(3f, 21f)
                close()
            }
        }.build()
    }

    /** Cross / plus */
    val Cross: ImageVector by lazy {
        ImageVector.Builder("Cross", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round
            ) {
                moveTo(12f, 4f); lineTo(12f, 20f)
                moveTo(4f, 12f); lineTo(20f, 12f)
            }
        }.build()
    }

    /** Droplet */
    val Droplet: ImageVector by lazy {
        ImageVector.Builder("Droplet", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 3f)
                curveTo(8f, 8f, 5f, 12f, 5f, 15f)
                curveTo(5f, 19f, 8f, 22f, 12f, 22f)
                curveTo(16f, 22f, 19f, 19f, 19f, 15f)
                curveTo(19f, 12f, 16f, 8f, 12f, 3f)
            }
        }.build()
    }

    /** Heart */
    val Heart: ImageVector by lazy {
        ImageVector.Builder("Heart", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 21f)
                curveTo(6f, 16f, 2f, 12f, 2f, 8.5f)
                curveTo(2f, 5.4f, 4.4f, 3f, 7f, 3f)
                curveTo(9f, 3f, 11f, 4f, 12f, 6f)
                curveTo(13f, 4f, 15f, 3f, 17f, 3f)
                curveTo(19.6f, 3f, 22f, 5.4f, 22f, 8.5f)
                curveTo(22f, 12f, 18f, 16f, 12f, 21f)
            }
        }.build()
    }

    /** Hexagon */
    val Hexagon: ImageVector by lazy {
        ImageVector.Builder("Hexagon", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(12f, 2f)
                lineTo(20f, 7f)
                lineTo(20f, 17f)
                lineTo(12f, 22f)
                lineTo(4f, 17f)
                lineTo(4f, 7f)
                close()
            }
        }.build()
    }

    /** Moon / crescent */
    val Moon: ImageVector by lazy {
        ImageVector.Builder("Moon", W.dp, H.dp, W, H).apply {
            path(
                stroke = stroke, strokeLineWidth = 2f,
                strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round
            ) {
                moveTo(20f, 12f)
                curveTo(20f, 16.4f, 16.4f, 20f, 12f, 20f)
                curveTo(7.6f, 20f, 4f, 16.4f, 4f, 12f)
                curveTo(4f, 7.6f, 7.6f, 4f, 12f, 4f)
                curveTo(10f, 6f, 9f, 9f, 9f, 12f)
                curveTo(9f, 15f, 10f, 18f, 12f, 20f)
            }
        }.build()
    }

    /** All icons available for the picker */
    data class PickerIcon(val key: String, val label: String, val icon: ImageVector)

    val PICKER_ICONS: List<PickerIcon> by lazy { listOf(
        PickerIcon("circle", "Circle", GenericCircle),
        PickerIcon("diamond", "Diamond", Diamond),
        PickerIcon("triangle", "Triangle", Triangle),
        PickerIcon("cross", "Cross", Cross),
        PickerIcon("droplet", "Droplet", Droplet),
        PickerIcon("heart", "Heart", Heart),
        PickerIcon("hexagon", "Hexagon", Hexagon),
        PickerIcon("moon", "Moon", Moon),
        PickerIcon("throbbing", "Pulse", Throbbing),
        PickerIcon("pressure", "Pressure", Pressure),
        PickerIcon("stabbing", "Bolt", Stabbing),
        PickerIcon("dullache", "Wave", DullAche),
        PickerIcon("burning", "Flame", Burning),
        PickerIcon("aura", "Sparkle", Aura),
        PickerIcon("nausea", "Nausea", Nausea),
        PickerIcon("light", "Light", LightSensitivity),
        PickerIcon("sound", "Sound", SoundSensitivity),
        PickerIcon("dizziness", "Spiral", Dizziness),
        PickerIcon("neck", "Neck", NeckStiffness),
        PickerIcon("brainfog", "Cloud", BrainFog),
        PickerIcon("fatigue", "Fatigue", Fatigue),
        PickerIcon("blur", "Blur", BlurredVision),
        PickerIcon("tingling", "Tingle", Tingling),
    ) }

    /** Look up icon by key (for DB-stored custom icon choices) */
    fun forKey(key: String?): ImageVector? = PICKER_ICONS.find { it.key == key }?.icon

    // ─── LOOKUP ───────────────────────────────────────────────

    /** Map symptom label → icon. Checks iconKey first, then fuzzy-matches label. Returns null for unknown. */
    fun forLabel(label: String, iconKey: String? = null): ImageVector? {
        // Check explicit icon key first (from DB)
        if (iconKey != null) return forKey(iconKey)
        // Fuzzy match by label
        return when {
        label.contains("Throb", ignoreCase = true) || label.contains("puls", ignoreCase = true) -> Throbbing
        label.contains("Pressure", ignoreCase = true) || label.contains("squeez", ignoreCase = true) -> Pressure
        label.contains("Stab", ignoreCase = true) || label.contains("sharp", ignoreCase = true) -> Stabbing
        label.contains("Dull", ignoreCase = true) || label.contains("ache", ignoreCase = true) -> DullAche
        label.contains("Burn", ignoreCase = true) -> Burning
        label.contains("aura", ignoreCase = true) -> Aura
        label.contains("Nausea", ignoreCase = true) -> Nausea
        label.contains("Light", ignoreCase = true) -> LightSensitivity
        label.contains("Sound", ignoreCase = true) -> SoundSensitivity
        label.contains("Dizz", ignoreCase = true) || label.contains("vertigo", ignoreCase = true) -> Dizziness
        label.contains("Neck", ignoreCase = true) || label.contains("stiff", ignoreCase = true) -> NeckStiffness
        label.contains("fog", ignoreCase = true) || label.contains("Brain", ignoreCase = true) -> BrainFog
        label.contains("Fatigue", ignoreCase = true) -> Fatigue
        label.contains("Blur", ignoreCase = true) || label.contains("vision", ignoreCase = true) -> BlurredVision
        label.contains("Tingl", ignoreCase = true) || label.contains("numb", ignoreCase = true) -> Tingling
        else -> null
        }
    }
}

title: SymptomViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class SymptomViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _painCharacter = MutableStateFlow<List<SupabaseDbService.UserSymptomRow>>(emptyList())
    val painCharacter: StateFlow<List<SupabaseDbService.UserSymptomRow>> = _painCharacter

    private val _accompanying = MutableStateFlow<List<SupabaseDbService.UserSymptomRow>>(emptyList())
    val accompanying: StateFlow<List<SupabaseDbService.UserSymptomRow>> = _accompanying

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserSymptomRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserSymptomRow>> = _pool

    private val _favorites = MutableStateFlow<List<SupabaseDbService.SymptomPrefRow>>(emptyList())
    val favorites: StateFlow<List<SupabaseDbService.SymptomPrefRow>> = _favorites

    /** Set of symptom IDs that are favorited, for quick lookup */
    private val _favoriteIds = MutableStateFlow<Set<String>>(emptySet())
    val favoriteIds: StateFlow<Set<String>> = _favoriteIds

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val all = db.getAllSymptomPool(accessToken)
                val prefs = db.getSymptomPrefs(accessToken)
                _pool.value = all
                _painCharacter.value = all.filter { it.category == "pain_character" }
                _accompanying.value = all.filter { it.category != "pain_character" }
                _favorites.value = prefs.filter { it.status == "frequent" }.sortedBy { it.position }
                _favoriteIds.value = _favorites.value.map { it.symptomId }.toSet()
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _painCharacter.value = emptyList()
                _accompanying.value = emptyList()
                _favorites.value = emptyList()
                _favoriteIds.value = emptySet()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String, iconKey: String? = null) {
        viewModelScope.launch {
            try {
                db.upsertSymptomToPool(accessToken, label.trim(), category, iconKey)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, symptomId: String) {
        viewModelScope.launch {
            try {
                db.deleteSymptomFromPool(accessToken, symptomId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFavorites(accessToken: String, symptomId: String) {
        viewModelScope.launch {
            try {
                val pos = _favorites.value.size
                db.insertSymptomPref(accessToken, symptomId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFavorites(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteSymptomPref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


title: SyncStateEntity.kt
text:
package com.migraineme

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "sync_state")
data class SyncStateEntity(
    @PrimaryKey val id: Int = 1,
    val nutritionChangesToken: String? = null,
    val lastHourlyRunAtEpochMs: Long? = null,
    val lastPushRunAtEpochMs: Long? = null
)

title: TestingScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId

@Composable
fun TestingScreen(authVm: AuthViewModel, onNavigateToOnboarding: () -> Unit = {}, onNavigateToHome: () -> Unit = {}, onNavigateToCheckIn: () -> Unit = {}) {
    val auth by authVm.state.collectAsState()
    val ctx = LocalContext.current
    val scrollState = rememberScrollState()

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            Row(
                Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    "Testing",
                    color = Color.White,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
            }

            DataStatusCard(accessToken = auth.accessToken)

            // Evening Check-in
            BaseCard {
                Text(
                    "Evening Check-in",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Text(
                    "Test the daily evening check-in flow",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
                Spacer(Modifier.height(4.dp))
                Button(
                    onClick = onNavigateToCheckIn,
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                    shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
                ) {
                    Text("Open Evening Check-in")
                }
            }

            // Onboarding reset
            BaseCard {
                Text(
                    "Onboarding",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )

                Text(
                    "Completed: ${OnboardingPrefs.isCompleted(ctx)}",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )

                Button(
                    onClick = {
                        OnboardingPrefs.reset(ctx)
                        onNavigateToOnboarding()
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple),
                    shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
                ) {
                    Text("Restart Onboarding")
                }

                Spacer(Modifier.height(8.dp))

                Button(
                    onClick = {
                        TourManager.startTour()
                        onNavigateToHome()
                    },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPink),
                    shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
                ) {
                    Text("Start Feature Tour Only")
                }
            }
        }
    }
}

@Composable
private fun DataStatusCard(accessToken: String?) {
    val ctx = LocalContext.current.applicationContext
    val zone = ZoneId.systemDefault()
    val today = LocalDate.now(zone).toString()
    val afterNine = LocalTime.now(zone) >= LocalTime.of(9, 0)

    var whoopConnected by remember(accessToken, today) { mutableStateOf(false) }
    var metricSettings by remember { mutableStateOf<List<EdgeFunctionsService.MetricSettingResponse>>(emptyList()) }
    var settingsLoaded by remember { mutableStateOf(false) }

    LaunchedEffect(accessToken, today) {
        whoopConnected = runCatching { WhoopTokenStore(ctx).load() != null }.getOrDefault(false)

        if (!accessToken.isNullOrBlank()) {
            withContext(Dispatchers.IO) {
                metricSettings = try {
                    EdgeFunctionsService().getMetricSettings(ctx)
                } catch (e: Exception) {
                    emptyList()
                }
            }
        }
        settingsLoaded = true
    }

    val isWhoopMetricEnabled: (String) -> Boolean = { metric ->
        val setting = metricSettings.find { it.metric == metric }
        setting != null && setting.enabled && setting.preferredSource == "whoop"
    }

    val isMetricEnabled: (String) -> Boolean = { metric ->
        val setting = metricSettings.find { it.metric == metric }
        setting != null && setting.enabled
    }

    val sleepAnchorsAll = listOf("sleep_duration_daily", "sleep_score_daily")
    val sleepOptionalsAll = listOf(
        "sleep_efficiency_daily", "sleep_stages_daily", "sleep_disturbances_daily",
        "fell_asleep_time_daily", "woke_up_time_daily"
    )
    val physicalAnchorsAll = listOf("recovery_score_daily", "resting_hr_daily", "hrv_daily")
    val physicalOptionalsAll = listOf("spo2_daily", "skin_temp_daily", "time_in_high_hr_zones_daily")

    val enabledSleepAnchors = sleepAnchorsAll.filter { isWhoopMetricEnabled(it) }
    val enabledSleepOptionals = sleepOptionalsAll.filter { isWhoopMetricEnabled(it) }
    val enabledPhysicalAnchors = physicalAnchorsAll.filter { isWhoopMetricEnabled(it) }
    val enabledPhysicalOptionals = physicalOptionalsAll.filter { isWhoopMetricEnabled(it) }
    val locationEnabled = isMetricEnabled("user_location_daily")

    var sleepAnchorLoaded by remember(today, accessToken) { mutableStateOf<Boolean?>(null) }
    var physicalAnchorLoaded by remember(today, accessToken) { mutableStateOf<Boolean?>(null) }
    var locationLoaded by remember(today, accessToken) { mutableStateOf<Boolean?>(null) }

    LaunchedEffect(today, accessToken, whoopConnected, settingsLoaded, metricSettings) {
        if (accessToken.isNullOrBlank() || !settingsLoaded) {
            sleepAnchorLoaded = null
            physicalAnchorLoaded = null
            locationLoaded = null
            return@LaunchedEffect
        }

        withContext(Dispatchers.IO) {
            sleepAnchorLoaded = if (enabledSleepAnchors.isEmpty() && enabledSleepOptionals.isEmpty()) {
                null
            } else if (!whoopConnected) {
                false
            } else {
                runCatching { SupabaseMetricsService(ctx).hasSleepForDate(accessToken, today, "whoop") }.getOrDefault(false)
            }

            physicalAnchorLoaded = if (enabledPhysicalAnchors.isEmpty() && enabledPhysicalOptionals.isEmpty()) {
                null
            } else if (!whoopConnected) {
                false
            } else {
                runCatching { SupabasePhysicalHealthService(ctx).hasRecoveryForDate(accessToken, today, "whoop") }.getOrDefault(false)
            }

            locationLoaded = if (!locationEnabled) {
                null
            } else {
                runCatching { SupabasePersonalService(ctx).hasUserLocationForDate(accessToken, today, source = "device") }.getOrDefault(false)
            }
        }
    }

    BaseCard {
        Text(
            "Data status",
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        Text(
            text = "WHOOP: " + if (whoopConnected) "Connected" else "Not connected",
            color = Color.White,
            style = MaterialTheme.typography.bodyLarge
        )

        val sleepText = when (sleepAnchorLoaded) {
            null -> "Sleep: Disabled"
            true -> "Sleep: Loaded for $today"
            false -> "Sleep: Missing for $today"
        }
        Text(sleepText, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)

        val physicalText = when (physicalAnchorLoaded) {
            null -> "Recovery: Disabled"
            true -> "Recovery: Loaded for $today"
            false -> "Recovery: Missing for $today"
        }
        Text(physicalText, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)

        val locationText = when (locationLoaded) {
            null -> "Location: Disabled"
            true -> "Location: Loaded for $today"
            false -> "Location: Missing for $today"
        }
        Text(locationText, color = AppTheme.BodyTextColor, style = MaterialTheme.typography.bodyMedium)

        if (afterNine) {
            Spacer(Modifier.height(6.dp))
            Text(
                "Tip: After 9:00, today's WHOOP sleep/recovery should usually be available.",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall
            )
        }
    }
}

title: ThirdPartyConnectionsScreen.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.health.connect.client.HealthConnectClient
import androidx.health.connect.client.PermissionController
import androidx.health.connect.client.permission.HealthPermission
import androidx.health.connect.client.records.BloodGlucoseRecord
import androidx.health.connect.client.records.BloodPressureRecord
import androidx.health.connect.client.records.BodyFatRecord
import androidx.health.connect.client.records.BodyTemperatureRecord
import androidx.health.connect.client.records.ExerciseSessionRecord
import androidx.health.connect.client.records.HeartRateVariabilityRmssdRecord
import androidx.health.connect.client.records.HydrationRecord
import androidx.health.connect.client.records.MenstruationPeriodRecord
import androidx.health.connect.client.records.NutritionRecord
import androidx.health.connect.client.records.OxygenSaturationRecord
import androidx.health.connect.client.records.RespiratoryRateRecord
import androidx.health.connect.client.records.RestingHeartRateRecord
import androidx.health.connect.client.records.SleepSessionRecord
import androidx.health.connect.client.records.StepsRecord
import androidx.health.connect.client.records.WeightRecord
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.compose.LocalLifecycleOwner
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ThirdPartyConnectionsScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val activity = context as? Activity
    val lifecycleOwner = LocalLifecycleOwner.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    // WHOOP state
    val tokenStore = remember { WhoopTokenStore(context) }
    val hasWhoop = remember { mutableStateOf(tokenStore.load() != null) }
    val whoopErrorDialog = remember { mutableStateOf<String?>(null) }
    val showWhoopDisconnectDialog = remember { mutableStateOf(false) }

    // Health Connect state
    val healthConnectChecking = remember { mutableStateOf(true) }
    val healthConnectAvailable = remember { mutableStateOf(true) }
    val showHealthConnectDisconnectDialog = remember { mutableStateOf(false) }
    val nutritionDataAvailable = remember { mutableStateOf(false) }
    val checkingNutritionData = remember { mutableStateOf(false) }

    // Metric enabled flags from Supabase
    val nutritionEnabled = remember { mutableStateOf(false) }
    val menstruationEnabled = remember { mutableStateOf(false) }

    // Permission flags from Health Connect
    val nutritionPermissionGranted = remember { mutableStateOf(false) }
    val menstruationPermissionGranted = remember { mutableStateOf(false) }
    val sleepPermissionGranted = remember { mutableStateOf(false) }
    val hrvPermissionGranted = remember { mutableStateOf(false) }
    val stepsPermissionGranted = remember { mutableStateOf(false) }
    val restingHrPermissionGranted = remember { mutableStateOf(false) }
    val weightPermissionGranted = remember { mutableStateOf(false) }
    val spo2PermissionGranted = remember { mutableStateOf(false) }

    // Permission definitions
    val nutritionPermission = HealthPermission.getReadPermission(NutritionRecord::class)
    val menstruationPermission = HealthPermission.getReadPermission(MenstruationPeriodRecord::class)
    val sleepPermission = HealthPermission.getReadPermission(SleepSessionRecord::class)
    val hrvPermission = HealthPermission.getReadPermission(HeartRateVariabilityRmssdRecord::class)
    val stepsPermission = HealthPermission.getReadPermission(StepsRecord::class)
    val restingHrPermission = HealthPermission.getReadPermission(RestingHeartRateRecord::class)
    val weightPermission = HealthPermission.getReadPermission(WeightRecord::class)
    val spo2Permission = HealthPermission.getReadPermission(OxygenSaturationRecord::class)
    val exercisePermission = HealthPermission.getReadPermission(ExerciseSessionRecord::class)
    val bodyFatPermission = HealthPermission.getReadPermission(BodyFatRecord::class)
    val hydrationPermission = HealthPermission.getReadPermission(HydrationRecord::class)
    val bloodPressurePermission = HealthPermission.getReadPermission(BloodPressureRecord::class)
    val bloodGlucosePermission = HealthPermission.getReadPermission(BloodGlucoseRecord::class)
    val respiratoryRatePermission = HealthPermission.getReadPermission(RespiratoryRateRecord::class)
    val bodyTempPermission = HealthPermission.getReadPermission(BodyTemperatureRecord::class)

    val allHealthConnectPermissions = setOf(
        nutritionPermission, menstruationPermission, sleepPermission, hrvPermission,
        stepsPermission, restingHrPermission, weightPermission, spo2Permission,
        exercisePermission, bodyFatPermission, hydrationPermission,
        bloodPressurePermission, bloodGlucosePermission, respiratoryRatePermission, bodyTempPermission
    )

    val anyWearablePermissionGranted = remember {
        derivedStateOf {
            sleepPermissionGranted.value || hrvPermissionGranted.value ||
                    stepsPermissionGranted.value || restingHrPermissionGranted.value ||
                    weightPermissionGranted.value || spo2PermissionGranted.value
        }
    }

    val anyHCConnected by remember {
        derivedStateOf {
            nutritionPermissionGranted.value || menstruationPermissionGranted.value || anyWearablePermissionGranted.value
        }
    }

    // Helper functions
    suspend fun refreshMetricEnabledFlags() {
        withContext(Dispatchers.IO) {
            val settings = EdgeFunctionsService().getMetricSettings(context.applicationContext)
            val map = settings.associateBy { it.metric }
            withContext(Dispatchers.Main) {
                nutritionEnabled.value = map["nutrition"]?.enabled == true
                menstruationEnabled.value = map["menstruation"]?.enabled == true
            }
        }
    }

    suspend fun refreshHealthConnectPermissions() {
        withContext(Dispatchers.IO) {
            try {
                val availability = HealthConnectClient.getSdkStatus(context)
                if (availability == HealthConnectClient.SDK_AVAILABLE) {
                    val hc = HealthConnectClient.getOrCreate(context)
                    val granted = hc.permissionController.getGrantedPermissions()
                    withContext(Dispatchers.Main) {
                        nutritionPermissionGranted.value = nutritionPermission in granted
                        menstruationPermissionGranted.value = menstruationPermission in granted
                        sleepPermissionGranted.value = sleepPermission in granted
                        hrvPermissionGranted.value = hrvPermission in granted
                        stepsPermissionGranted.value = stepsPermission in granted
                        restingHrPermissionGranted.value = restingHrPermission in granted
                        weightPermissionGranted.value = weightPermission in granted
                        spo2PermissionGranted.value = spo2Permission in granted
                    }
                }
            } catch (_: Exception) { }
        }
    }

    /**
     * Switch phone sleep metrics (duration, fell_asleep, woke_up) to a new source.
     * Called when wearable connects (switch away from phone) or disconnects (switch back to phone).
     * Does NOT auto-enable disabled metrics — only switches preferred_source.
     */
    suspend fun switchPhoneSleepSource(newSource: String) {
        withContext(Dispatchers.IO) {
            val edge = EdgeFunctionsService()
            val sleepMetrics = listOf(
                "sleep_duration_daily",
                "fell_asleep_time_daily",
                "woke_up_time_daily"
            )
            val settings = edge.getMetricSettings(context.applicationContext)
            val settingsMap = settings.associateBy { it.metric }

            for (metric in sleepMetrics) {
                val current = settingsMap[metric]
                val isEnabled = current?.enabled ?: false
                runCatching {
                    edge.upsertMetricSetting(
                        context = context.applicationContext,
                        metric = metric,
                        enabled = isEnabled,
                        preferredSource = newSource
                    )
                }
            }
            Log.d("ThirdPartyConnections", "Switched phone sleep metrics to source: $newSource")

            // If switching back to phone and metrics are enabled, trigger sync
            if (newSource == "phone") {
                PhoneSleepSyncWorker.runOnce(context.applicationContext)
            }
        }
    }

    suspend fun enableNutritionWorkersAndBackfillIfNeeded(showToast: Boolean) {
        if (!nutritionPermissionGranted.value) return
        withContext(Dispatchers.Main) {
            MetricToggleHelper.toggle(context.applicationContext, "nutrition", true)
            if (showToast) {
                android.widget.Toast.makeText(context, "Nutrition connected.", android.widget.Toast.LENGTH_LONG).show()
            }
        }
        scope.launch(Dispatchers.IO) {
            checkingNutritionData.value = true
            nutritionDataAvailable.value = HealthConnectDataAvailability.hasNutritionData(context)
            checkingNutritionData.value = false
            try {
                NutritionBackfillUtility.forceReBackfill(context)
                delay(30_000)
                val wm = androidx.work.WorkManager.getInstance(context)
                val immediatePush = androidx.work.OneTimeWorkRequestBuilder<NutritionOutboxPushWorker>()
                    .addTag("immediate_nutrition_push").build()
                wm.enqueue(immediatePush)
            } catch (e: Exception) {
                android.util.Log.e("HealthConnect", "Failed to backfill: ${e.message}", e)
            }
        }
    }

    suspend fun enableMenstruationWorkersIfNeeded(showToast: Boolean) {
        if (!menstruationPermissionGranted.value) return
        withContext(Dispatchers.Main) {
            MetricToggleHelper.toggle(context.applicationContext, "menstruation", true)
            if (showToast) {
                android.widget.Toast.makeText(context, "Menstruation connected.", android.widget.Toast.LENGTH_LONG).show()
            }
        }
    }

    suspend fun enableHealthConnectWearablesIfNeeded() {
        if (!anyWearablePermissionGranted.value) return
        withContext(Dispatchers.IO) {
            val edge = EdgeFunctionsService()
            runCatching { edge.enableDefaultHealthConnectMetricSettings(context.applicationContext) }
            // Use SyncManager instead of scheduling periodic workers
            HealthConnectSyncManager.markAsConnected(context.applicationContext)
            // Switch phone sleep metrics to Health Connect source
            runCatching { switchPhoneSleepSource("health_connect") }
        }
        withContext(Dispatchers.Main) {
            android.widget.Toast.makeText(context, "Health Connect wearables connected!", android.widget.Toast.LENGTH_LONG).show()
        }
    }

    // Health Connect permission launcher
    val healthConnectLauncher = rememberLauncherForActivityResult(
        contract = PermissionController.createRequestPermissionResultContract()
    ) { granted ->
        nutritionPermissionGranted.value = granted.contains(nutritionPermission)
        menstruationPermissionGranted.value = granted.contains(menstruationPermission)
        sleepPermissionGranted.value = granted.contains(sleepPermission)
        hrvPermissionGranted.value = granted.contains(hrvPermission)
        stepsPermissionGranted.value = granted.contains(stepsPermission)
        restingHrPermissionGranted.value = granted.contains(restingHrPermission)
        weightPermissionGranted.value = granted.contains(weightPermission)
        spo2PermissionGranted.value = granted.contains(spo2Permission)

        scope.launch {
            runCatching { refreshMetricEnabledFlags() }
            if (nutritionEnabled.value && nutritionPermissionGranted.value) {
                enableNutritionWorkersAndBackfillIfNeeded(showToast = false)
            }
            if (menstruationEnabled.value && menstruationPermissionGranted.value) {
                enableMenstruationWorkersIfNeeded(showToast = false)
            }
            if (anyWearablePermissionGranted.value) {
                enableHealthConnectWearablesIfNeeded()
            }
        }
    }

    // Check Health Connect availability on launch
    LaunchedEffect(Unit) {
        withContext(Dispatchers.IO) {
            try {
                val availability = HealthConnectClient.getSdkStatus(context)
                healthConnectAvailable.value = availability == HealthConnectClient.SDK_AVAILABLE
            } catch (_: Exception) {
                healthConnectAvailable.value = false
            }
            healthConnectChecking.value = false
        }
        runCatching { refreshHealthConnectPermissions() }
        runCatching { refreshMetricEnabledFlags() }
    }

    // WHOOP callback handling
    val lastProcessedUri = remember { mutableStateOf<String?>(null) }
    val whoopLogoResId = remember {
        context.resources.getIdentifier("whoop_logo", "drawable", context.packageName)
            .takeIf { it != 0 } ?: context.resources.getIdentifier("whoop_logo", "mipmap", context.packageName)
    }

    suspend fun tryCompleteWhoopIfCallbackPresent() {
        val prefs = context.getSharedPreferences("whoop_oauth", Context.MODE_PRIVATE)
        val lastUri = prefs.getString("last_uri", null)
        if (lastUri.isNullOrBlank() || lastProcessedUri.value == lastUri) return
        lastProcessedUri.value = lastUri

        val ok = withContext(Dispatchers.IO) { WhoopAuthService().completeAuth(context) }
        val localToken = tokenStore.load()

        if (ok && localToken != null) {
            hasWhoop.value = true
            withContext(Dispatchers.IO) {
                val edge = EdgeFunctionsService()
                val stored = edge.upsertWhoopTokenToSupabase(context.applicationContext, localToken)
                if (stored) {
                    runCatching { edge.enableDefaultWhoopMetricSettings(context.applicationContext) }
                    // Switch phone sleep metrics to WHOOP source
                    runCatching { switchPhoneSleepSource("whoop") }
                    edge.enqueueLoginBackfill(context.applicationContext)
                }
            }
        } else {
            hasWhoop.value = false
            whoopErrorDialog.value = prefs.getString("token_error", "WHOOP authentication failed")
        }
    }

    val resumeTick = remember { mutableStateOf(0) }
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_RESUME) resumeTick.value++
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
    }

    LaunchedEffect(resumeTick.value) {
        tryCompleteWhoopIfCallbackPresent()
        runCatching { refreshHealthConnectPermissions() }
        runCatching { refreshMetricEnabledFlags() }
    }

    // Dialogs
    whoopErrorDialog.value?.let { msg ->
        AlertDialog(
            onDismissRequest = { whoopErrorDialog.value = null },
            title = { Text("WHOOP connection failed") },
            text = { Text(msg) },
            confirmButton = { TextButton(onClick = { whoopErrorDialog.value = null }) { Text("OK") } }
        )
    }

    if (showWhoopDisconnectDialog.value) {
        AlertDialog(
            onDismissRequest = { showWhoopDisconnectDialog.value = false },
            title = { Text("Disconnect WHOOP?") },
            text = { Text("Are you sure you want to disconnect WHOOP?") },
            confirmButton = {
                TextButton(onClick = {
                    showWhoopDisconnectDialog.value = false
                    scope.launch(Dispatchers.IO) {
                        WhoopAuthService().disconnectWithDebug(context.applicationContext)

                        // Check if HC wearables still connected; if not, fall back to phone
                        val hcStillConnected = try {
                            val hc = HealthConnectClient.getOrCreate(context)
                            val granted = hc.permissionController.getGrantedPermissions()
                            granted.contains(sleepPermission)
                        } catch (_: Exception) { false }

                        if (hcStillConnected) {
                            runCatching { switchPhoneSleepSource("health_connect") }
                        } else {
                            runCatching { switchPhoneSleepSource("phone") }
                        }

                        withContext(Dispatchers.Main) {
                            hasWhoop.value = false
                            lastProcessedUri.value = null
                            android.widget.Toast.makeText(context, "WHOOP disconnected.", android.widget.Toast.LENGTH_LONG).show()
                        }
                    }
                }) { Text("Disconnect") }
            },
            dismissButton = { TextButton(onClick = { showWhoopDisconnectDialog.value = false }) { Text("Cancel") } }
        )
    }

    if (showHealthConnectDisconnectDialog.value) {
        AlertDialog(
            onDismissRequest = { showHealthConnectDisconnectDialog.value = false },
            title = { Text("Disconnect?") },
            text = { Text("This will stop syncing Health Connect data. To fully disconnect, revoke permissions in Health Connect settings.") },
            confirmButton = {
                TextButton(onClick = {
                    NutritionSyncScheduler.cancel(context)
                    // Use SyncManager instead of cancelling workers directly
                    HealthConnectSyncManager.markAsDisconnected(context.applicationContext)

                    scope.launch(Dispatchers.IO) {
                        try { NutritionSyncDatabase.get(context).clearAllTables() } catch (_: Exception) {}
                        try {
                            val hcDb = HealthConnectSyncDatabase.get(context)
                            hcDb.dao().clearSyncState()
                            hcDb.dao().clearOutbox()
                        } catch (_: Exception) {}

                        val edge = EdgeFunctionsService()
                        edge.upsertMetricSetting(context.applicationContext, "nutrition", false, null)
                        edge.upsertMetricSetting(context.applicationContext, "menstruation", false, null)
                        edge.disableHealthConnectMetricSettings(context.applicationContext)

                        // Check if WHOOP still connected; if not, fall back to phone
                        val whoopStillConnected = WhoopTokenStore(context.applicationContext).load() != null
                        if (whoopStillConnected) {
                            runCatching { switchPhoneSleepSource("whoop") }
                        } else {
                            runCatching { switchPhoneSleepSource("phone") }
                        }
                    }

                    try {
                        context.startActivity(Intent("androidx.health.ACTION_HEALTH_CONNECT_SETTINGS"))
                    } catch (_: Exception) {}

                    showHealthConnectDisconnectDialog.value = false
                    nutritionPermissionGranted.value = false
                    menstruationPermissionGranted.value = false
                    sleepPermissionGranted.value = false
                    hrvPermissionGranted.value = false
                    stepsPermissionGranted.value = false
                    restingHrPermissionGranted.value = false
                    weightPermissionGranted.value = false
                    spo2PermissionGranted.value = false
                    nutritionEnabled.value = false
                    menstruationEnabled.value = false

                    android.widget.Toast.makeText(context, "Disconnected.", android.widget.Toast.LENGTH_LONG).show()
                }) { Text("Disconnect") }
            },
            dismissButton = { TextButton(onClick = { showHealthConnectDisconnectDialog.value = false }) { Text("Cancel") } }
        )
    }

    // Check if all HC permissions granted
    val allHCConnected by remember {
        derivedStateOf {
            nutritionPermissionGranted.value && menstruationPermissionGranted.value &&
                    sleepPermissionGranted.value && hrvPermissionGranted.value &&
                    stepsPermissionGranted.value && restingHrPermissionGranted.value &&
                    weightPermissionGranted.value && spo2PermissionGranted.value
        }
    }

    // UI
    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(scroll)
                .padding(horizontal = 16.dp)
        ) {
            // Spacer for background reveal
            Spacer(Modifier.height(AppTheme.LogoRevealHeight))

            // Connected Services section
            Text(
                "Connected Services",
                color = AppTheme.AccentPurple,
                style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold),
                modifier = Modifier.padding(bottom = 16.dp)
            )

            // WHOOP Row
            Box(Modifier.spotlightTarget("whoop_card")) {
                ConnectionRowLogoOnly(
                    logoResId = whoopLogoResId,
                    fallbackLetter = "W",
                    isConnected = hasWhoop.value,
                    onClick = {
                        if (!hasWhoop.value) {
                            // Flag to return here after OAuth if setup coach is active
                            if (TourManager.isActive() && TourManager.currentPhase() == CoachPhase.SETUP) {
                                context.getSharedPreferences("whoop_oauth", Context.MODE_PRIVATE)
                                    .edit().putBoolean("return_to_setup", true).apply()
                            }
                            activity?.let { WhoopAuthService().startAuth(it) }
                        }
                    },
                    onLongClick = {
                        if (hasWhoop.value) showWhoopDisconnectDialog.value = true
                    }
                )
            }

            Spacer(Modifier.height(12.dp))

            // Health Connect Row
            Box(Modifier.spotlightTarget("health_connect_card")) {
                ConnectionRow(
                    logoResId = R.drawable.ic_health_connect,
                    fallbackLetter = "H",
                    title = "Health Connect",
                    isConnected = anyHCConnected,
                    warningText = if (anyHCConnected && !allHCConnected) "Some permissions missing. Tap to enable all." else null,
                    onClick = {
                        if (!healthConnectAvailable.value) {
                            android.widget.Toast.makeText(context, "Health Connect not available.", android.widget.Toast.LENGTH_LONG).show()
                            return@ConnectionRow
                        }
                        scope.launch { runCatching { healthConnectLauncher.launch(allHealthConnectPermissions) } }
                    },
                    onLongClick = {
                        if (anyHCConnected) showHealthConnectDisconnectDialog.value = true
                    }
                )
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun ConnectionRowLogoOnly(
    logoResId: Int,
    fallbackLetter: String,
    isConnected: Boolean,
    onClick: () -> Unit,
    onLongClick: () -> Unit
) {
    BaseCard {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .combinedClickable(
                    onClick = onClick,
                    onLongClick = onLongClick
                )
                .padding(start = 24.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Logo - 100dp
            if (logoResId != 0) {
                Image(
                    painter = painterResource(id = logoResId),
                    contentDescription = null,
                    contentScale = ContentScale.Fit,
                    modifier = Modifier.size(100.dp)
                )
            } else {
                Box(
                    modifier = Modifier.size(100.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        fallbackLetter,
                        color = Color.White,
                        fontWeight = FontWeight.Bold,
                        fontSize = 40.sp
                    )
                }
            }

            Spacer(Modifier.weight(1f))

            // Connect/Connected Button
            Button(
                onClick = onClick,
                shape = RoundedCornerShape(24.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = if (isConnected) AppTheme.AccentPurple.copy(alpha = 0.3f) else AppTheme.AccentPurple
                ),
                contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp)
            ) {
                Text(
                    if (isConnected) "Connected" else "Connect",
                    color = Color.White,
                    style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold)
                )
            }
        }
    }
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun ConnectionRow(
    logoResId: Int,
    fallbackLetter: String,
    title: String,
    isConnected: Boolean,
    warningText: String?,
    onClick: () -> Unit,
    onLongClick: () -> Unit
) {
    BaseCard {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .combinedClickable(
                    onClick = onClick,
                    onLongClick = onLongClick
                )
                .padding(start = 24.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Logo - 100dp
            if (logoResId != 0) {
                Image(
                    painter = painterResource(id = logoResId),
                    contentDescription = null,
                    contentScale = ContentScale.Fit,
                    modifier = Modifier.size(100.dp)
                )
            } else {
                Box(
                    modifier = Modifier.size(100.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        fallbackLetter,
                        color = Color.White,
                        fontWeight = FontWeight.Bold,
                        fontSize = 40.sp
                    )
                }
            }

            Spacer(Modifier.width(16.dp))

            // Title only
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    title,
                    color = Color.White,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                if (warningText != null) {
                    Spacer(Modifier.height(4.dp))
                    Text(
                        warningText,
                        color = Color(0xFFFFB74D),
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }

            Spacer(Modifier.width(12.dp))

            // Connect/Connected Button
            Button(
                onClick = onClick,
                shape = RoundedCornerShape(24.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = if (isConnected) AppTheme.AccentPurple.copy(alpha = 0.3f) else AppTheme.AccentPurple
                ),
                contentPadding = PaddingValues(horizontal = 20.dp, vertical = 8.dp)
            ) {
                Text(
                    if (isConnected) "Connected" else "Connect",
                    color = Color.White,
                    style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold)
                )
            }
        }
    }
}


title: TimingScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.AccessTime
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun TimingScreen(
    navController: NavController,
    vm: LogViewModel,
    onClose: () -> Unit = {}
) {
    val draft by vm.draft.collectAsState()
    val scrollState = rememberScrollState()

    var beganAt by rememberSaveable { mutableStateOf(draft.migraine?.beganAtIso) }
    var endedAt by rememberSaveable { mutableStateOf(draft.migraine?.endedAtIso) }

    // Sync from draft when it changes
    LaunchedEffect(draft.migraine?.beganAtIso, draft.migraine?.endedAtIso) {
        draft.migraine?.let { m ->
            if (m.beganAtIso != null && beganAt == null) beganAt = m.beganAtIso
            if (m.endedAtIso != null && endedAt == null) endedAt = m.endedAtIso
        }
    }

    fun syncDraft() {
        vm.setMigraineDraft(beganAtIso = beganAt, endedAtIso = endedAt)
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                    Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(4.dp))
                    Text("Log", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                }
                Text("Timing", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                IconButton(onClick = onClose) {
                    Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                }
            }

            // Hero
            HeroCard {
                Icon(
                    imageVector = Icons.Outlined.AccessTime,
                    contentDescription = "Timing",
                    tint = AppTheme.AccentPink,
                    modifier = Modifier.size(40.dp)
                )
                Text(
                    "When did it happen?",
                    color = Color.White,
                    style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold),
                    textAlign = TextAlign.Center
                )
                Text(
                    "Set when the migraine started and ended",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }

            // Start time
            BaseCard {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.AccessTime, contentDescription = null, tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(8.dp))
                    Text("Started", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                }
                AppDateTimePicker(
                    label = beganAt?.let { "Started: ${formatIsoDdMmYyHm(it)}" } ?: "Set start time"
                ) { beganAt = it; syncDraft() }
            }

            // End time
            BaseCard {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Icon(Icons.Outlined.AccessTime, contentDescription = null, tint = AppTheme.AccentPurple, modifier = Modifier.size(20.dp))
                    Spacer(Modifier.width(8.dp))
                    Text("Ended", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                }
                AppDateTimePicker(
                    label = endedAt?.let { "Ended: ${formatIsoDdMmYyHm(it)}" } ?: "Set end time (optional)"
                ) { endedAt = it; syncDraft() }
            }

            // Duration hint
            if (beganAt != null && endedAt != null) {
                val duration = computeDurationText(beganAt!!, endedAt!!)
                if (duration != null) {
                    BaseCard {
                        Text("Duration: $duration", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodyMedium, textAlign = TextAlign.Center, modifier = Modifier.fillMaxWidth())
                    }
                }
            }

            // Navigation
            Row(
                Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text("Back") }
                Button(
                    onClick = { navController.navigate(Routes.PAIN_LOCATION) },
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text("Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

private fun formatIsoDdMmYyHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "-"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) { "-" }
}

private fun computeDurationText(startIso: String, endIso: String): String? {
    return try {
        val s = runCatching { OffsetDateTime.parse(startIso).toLocalDateTime() }.getOrNull() ?: LocalDateTime.parse(startIso)
        val e = runCatching { OffsetDateTime.parse(endIso).toLocalDateTime() }.getOrNull() ?: LocalDateTime.parse(endIso)
        val dur = java.time.Duration.between(s, e)
        if (dur.isNegative) return null
        val h = dur.toHours()
        val m = dur.toMinutes() % 60
        when {
            h > 0 && m > 0 -> "${h}h ${m}m"
            h > 0 -> "${h}h"
            else -> "${m}m"
        }
    } catch (_: Exception) { null }
}


title: TriggerIcons.kt
text:
package com.migraineme

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

/**
 * Custom trigger icons for MigraineMe.
 * Style: 24dp viewport, 2dp stroke, rounded caps/joins, no fill.
 * Each trigger's icon_key maps to one ImageVector.
 * The trigger-worker now checks both fixed threshold AND ±2 SD from
 * the user's personal baseline automatically for every trigger.
 */
object TriggerIcons {

    private val stroke = SolidColor(Color.White)
    private const val W = 24f
    private const val H = 24f

    // ─── SLEEP ───────────────────────────────────────────────

    /** duration — hourglass */
    val Duration: ImageVector by lazy {
        ImageVector.Builder("Duration", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 2f); lineTo(18f, 2f)
                moveTo(6f, 22f); lineTo(18f, 22f)
                moveTo(7f, 2f); curveTo(7f, 8f, 12f, 10f, 12f, 12f)
                curveTo(12f, 14f, 7f, 16f, 7f, 22f)
                moveTo(17f, 2f); curveTo(17f, 8f, 12f, 10f, 12f, 12f)
                curveTo(12f, 14f, 17f, 16f, 17f, 22f)
            }
        }.build()
    }

    /** score — star */
    val Score: ImageVector by lazy {
        ImageVector.Builder("Score", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(14.5f, 9f); lineTo(22f, 9f); lineTo(16f, 13.5f)
                lineTo(18f, 21f); lineTo(12f, 16.5f); lineTo(6f, 21f); lineTo(8f, 13.5f)
                lineTo(2f, 9f); lineTo(9.5f, 9f); close()
            }
        }.build()
    }

    /** efficiency — gauge/speedometer */
    val Efficiency: ImageVector by lazy {
        ImageVector.Builder("Efficiency", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Arc
                moveTo(4f, 18f)
                arcTo(10f, 10f, 0f, isMoreThanHalf = true, isPositiveArc = true, 20f, 18f)
                // Needle
                moveTo(12f, 12f); lineTo(16f, 7f)
                // Center dot
                moveTo(13f, 12f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 11f, 12f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 13f, 12f)
            }
        }.build()
    }

    /** disturbances — zigzag crack */
    val Disturbances: ImageVector by lazy {
        ImageVector.Builder("Disturbances", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(4f, 4f); lineTo(10f, 10f); lineTo(6f, 14f); lineTo(12f, 20f)
                moveTo(14f, 4f); lineTo(20f, 10f); lineTo(16f, 14f); lineTo(20f, 20f)
            }
        }.build()
    }

    /** bedtime — moon with zzz */
    val Bedtime: ImageVector by lazy {
        ImageVector.Builder("Bedtime", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Crescent moon
                moveTo(18f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 8f, 4f)
                curveTo(14f, 4f, 18f, 7f, 18f, 12f)
            }
            // Z
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(17f, 6f); lineTo(21f, 6f); lineTo(17f, 10f); lineTo(21f, 10f)
            }
        }.build()
    }

    /** wake_time — sunrise */
    val WakeTime: ImageVector by lazy {
        ImageVector.Builder("WakeTime", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Horizon line
                moveTo(2f, 18f); lineTo(22f, 18f)
                // Half sun
                moveTo(17f, 18f)
                arcTo(5f, 5f, 0f, isMoreThanHalf = false, isPositiveArc = false, 7f, 18f)
                // Rays
                moveTo(12f, 8f); lineTo(12f, 5f)
                moveTo(5.6f, 12.4f); lineTo(3.5f, 10.3f)
                moveTo(18.4f, 12.4f); lineTo(20.5f, 10.3f)
            }
        }.build()
    }

    /** deep_sleep — layered waves (deep) */
    val DeepSleep: ImageVector by lazy {
        ImageVector.Builder("DeepSleep", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 8f); curveTo(6f, 4f, 10f, 4f, 12f, 8f); curveTo(14f, 12f, 18f, 12f, 22f, 8f)
                moveTo(2f, 14f); curveTo(6f, 10f, 10f, 10f, 12f, 14f); curveTo(14f, 18f, 18f, 18f, 22f, 14f)
                moveTo(2f, 20f); curveTo(6f, 16f, 10f, 16f, 12f, 20f); curveTo(14f, 24f, 18f, 24f, 22f, 20f)
            }
        }.build()
    }

    /** rem_sleep — closed eye with movement lines */
    val RemSleep: ImageVector by lazy {
        ImageVector.Builder("RemSleep", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Closed eye
                moveTo(2f, 12f); curveTo(6f, 16f, 18f, 16f, 22f, 12f)
                // Lashes
                moveTo(12f, 16f); lineTo(12f, 19f)
                moveTo(8f, 15.5f); lineTo(7f, 18f)
                moveTo(16f, 15.5f); lineTo(17f, 18f)
            }
        }.build()
    }

    /** light_sleep — single gentle wave */
    val LightSleep: ImageVector by lazy {
        ImageVector.Builder("LightSleep", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 12f); curveTo(6f, 8f, 10f, 8f, 12f, 12f); curveTo(14f, 16f, 18f, 16f, 22f, 12f)
            }
            // Zzz small
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(16f, 4f); lineTo(20f, 4f); lineTo(16f, 8f); lineTo(20f, 8f)
            }
        }.build()
    }

    /** jet_lag — airplane + clock */
    val JetLag: ImageVector by lazy {
        ImageVector.Builder("JetLag", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Simple plane shape
                moveTo(2f, 14f); lineTo(8f, 12f); lineTo(12f, 4f); lineTo(14f, 12f); lineTo(22f, 10f)
                moveTo(12f, 12f); lineTo(12f, 18f)
                moveTo(9f, 18f); lineTo(15f, 18f)
            }
        }.build()
    }

    /** sleep_apnea — lungs with pause */
    val SleepApnea: ImageVector by lazy {
        ImageVector.Builder("SleepApnea", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Nose/airway
                moveTo(12f, 2f); lineTo(12f, 8f)
                // Left lung
                moveTo(12f, 8f); curveTo(8f, 8f, 4f, 12f, 4f, 16f); curveTo(4f, 20f, 8f, 20f, 12f, 18f)
                // Right lung
                moveTo(12f, 8f); curveTo(16f, 8f, 20f, 12f, 20f, 16f); curveTo(20f, 20f, 16f, 20f, 12f, 18f)
            }
            // X mark (blocked)
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(10f, 5f); lineTo(14f, 9f)
                moveTo(14f, 5f); lineTo(10f, 9f)
            }
        }.build()
    }

    // ─── PHYSICAL ────────────────────────────────────────────

    /** recovery — battery with plus */
    val Recovery: ImageVector by lazy {
        ImageVector.Builder("Recovery", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Battery body
                moveTo(4f, 6f); lineTo(18f, 6f); lineTo(18f, 18f); lineTo(4f, 18f); close()
                // Battery nub
                moveTo(18f, 10f); lineTo(20f, 10f); lineTo(20f, 14f); lineTo(18f, 14f)
                // Plus
                moveTo(11f, 9f); lineTo(11f, 15f)
                moveTo(8f, 12f); lineTo(14f, 12f)
            }
        }.build()
    }

    /** spo2 — O2 molecule */
    val SpO2: ImageVector by lazy {
        ImageVector.Builder("SpO2", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // O
                moveTo(10f, 8f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 2f, 8f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 8f)
            }
            // 2 subscript
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 16f); curveTo(12f, 14f, 16f, 14f, 16f, 16f); curveTo(16f, 18f, 12f, 20f, 12f, 20f); lineTo(16f, 20f)
            }
            // Droplet
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(18f, 4f); curveTo(18f, 4f, 14f, 8f, 18f, 11f); curveTo(22f, 8f, 18f, 4f, 18f, 4f)
            }
        }.build()
    }

    /** skin_temp — thermometer */
    val SkinTemp: ImageVector by lazy {
        ImageVector.Builder("SkinTemp", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Thermometer body
                moveTo(10f, 3f); lineTo(14f, 3f); lineTo(14f, 14f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 14f)
                lineTo(10f, 3f)
                // Bulb
                moveTo(13f, 17f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 11f, 17f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 13f, 17f)
                // Mercury line
                moveTo(12f, 15f); lineTo(12f, 7f)
            }
        }.build()
    }

    /** resp_rate — lungs breathing */
    val RespRate: ImageVector by lazy {
        ImageVector.Builder("RespRate", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 2f); lineTo(12f, 8f)
                moveTo(12f, 8f); curveTo(8f, 8f, 4f, 12f, 4f, 16f); curveTo(4f, 20f, 8f, 20f, 12f, 18f)
                moveTo(12f, 8f); curveTo(16f, 8f, 20f, 12f, 20f, 16f); curveTo(20f, 20f, 16f, 20f, 12f, 18f)
            }
        }.build()
    }

    /** hr_zones — heart with pulse */
    val HrZones: ImageVector by lazy {
        ImageVector.Builder("HrZones", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Heart
                moveTo(12f, 20f)
                curveTo(4f, 14f, 2f, 10f, 2f, 7f); curveTo(2f, 4f, 4.5f, 2f, 7f, 2f); curveTo(9f, 2f, 11f, 3f, 12f, 5f)
                curveTo(13f, 3f, 15f, 2f, 17f, 2f); curveTo(19.5f, 2f, 22f, 4f, 22f, 7f); curveTo(22f, 10f, 20f, 14f, 12f, 20f)
            }
            // Pulse inside
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(6f, 11f); lineTo(9f, 11f); lineTo(10.5f, 8f); lineTo(13f, 14f); lineTo(14.5f, 11f); lineTo(18f, 11f)
            }
        }.build()
    }

    /** steps — footprint */
    val Steps: ImageVector by lazy {
        ImageVector.Builder("Steps", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Left foot
                moveTo(8f, 4f); curveTo(6f, 4f, 5f, 6f, 5f, 8f); curveTo(5f, 10f, 6f, 11f, 8f, 11f); curveTo(10f, 11f, 11f, 10f, 11f, 8f); curveTo(11f, 6f, 10f, 4f, 8f, 4f)
                // Right foot
                moveTo(16f, 13f); curveTo(14f, 13f, 13f, 15f, 13f, 17f); curveTo(13f, 19f, 14f, 20f, 16f, 20f); curveTo(18f, 20f, 19f, 19f, 19f, 17f); curveTo(19f, 15f, 18f, 13f, 16f, 13f)
            }
        }.build()
    }

    /** body_fat — scale */
    val BodyFat: ImageVector by lazy {
        ImageVector.Builder("BodyFat", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Scale platform
                moveTo(4f, 6f); lineTo(20f, 6f); lineTo(20f, 20f); lineTo(4f, 20f); close()
                // Display circle
                moveTo(16f, 13f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 8f, 13f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 16f, 13f)
                // Needle
                moveTo(12f, 13f); lineTo(14.5f, 10.5f)
            }
        }.build()
    }

    /** weight — dumbbell */
    val Weight: ImageVector by lazy {
        ImageVector.Builder("Weight", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Bar
                moveTo(7f, 12f); lineTo(17f, 12f)
                // Left weight
                moveTo(3f, 8f); lineTo(7f, 8f); lineTo(7f, 16f); lineTo(3f, 16f); close()
                // Right weight
                moveTo(17f, 8f); lineTo(21f, 8f); lineTo(21f, 16f); lineTo(17f, 16f); close()
            }
        }.build()
    }

    /** bp — blood pressure cuff arm */
    val Bp: ImageVector by lazy {
        ImageVector.Builder("Bp", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Heart
                moveTo(12f, 18f)
                curveTo(7f, 14f, 5f, 11f, 5f, 8.5f); curveTo(5f, 6f, 7f, 4f, 8.5f, 4f); curveTo(10f, 4f, 11f, 5f, 12f, 6.5f)
                curveTo(13f, 5f, 14f, 4f, 15.5f, 4f); curveTo(17f, 4f, 19f, 6f, 19f, 8.5f); curveTo(19f, 11f, 17f, 14f, 12f, 18f)
            }
            // Arrow up
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(19f, 14f); lineTo(19f, 21f)
                moveTo(17f, 16f); lineTo(19f, 14f); lineTo(21f, 16f)
            }
        }.build()
    }

    /** blood_glucose — droplet with wave */
    val BloodGlucose: ImageVector by lazy {
        ImageVector.Builder("BloodGlucose", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Droplet
                moveTo(12f, 3f); curveTo(12f, 3f, 5f, 11f, 5f, 15f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = false, isPositiveArc = false, 19f, 15f)
                curveTo(19f, 11f, 12f, 3f, 12f, 3f)
            }
            // Wave inside
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(8f, 15f); curveTo(9f, 13f, 11f, 13f, 12f, 15f); curveTo(13f, 17f, 15f, 17f, 16f, 15f)
            }
        }.build()
    }

    /** strain — flexed arm / exertion */
    val Strain: ImageVector by lazy {
        ImageVector.Builder("Strain", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Flexed bicep
                moveTo(4f, 18f); lineTo(4f, 12f); curveTo(4f, 8f, 8f, 4f, 12f, 4f)
                curveTo(14f, 4f, 16f, 6f, 16f, 8f); curveTo(16f, 10f, 14f, 10f, 14f, 12f)
                lineTo(20f, 12f); lineTo(20f, 18f)
            }
            // Effort lines
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 2f); lineTo(8f, 4f)
                moveTo(11f, 1f); lineTo(11f, 3f)
            }
        }.build()
    }

    /** hydration — water glass */
    val Hydration: ImageVector by lazy {
        ImageVector.Builder("Hydration", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Glass shape
                moveTo(6f, 2f); lineTo(18f, 2f); lineTo(16f, 22f); lineTo(8f, 22f); close()
                // Water level
                moveTo(7.5f, 10f); lineTo(16.5f, 10f)
                // Wave
                moveTo(8f, 14f); curveTo(9.5f, 12.5f, 10.5f, 12.5f, 12f, 14f); curveTo(13.5f, 15.5f, 14.5f, 15.5f, 16f, 14f)
            }
        }.build()
    }

    /** allergies — flower pollen */
    val Allergies: ImageVector by lazy {
        ImageVector.Builder("Allergies", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Center
                moveTo(14f, 12f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 12f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 14f, 12f)
                // Petals
                moveTo(12f, 6f); curveTo(10f, 8f, 10f, 10f, 12f, 10f); curveTo(14f, 10f, 14f, 8f, 12f, 6f)
                moveTo(12f, 18f); curveTo(10f, 16f, 10f, 14f, 12f, 14f); curveTo(14f, 14f, 14f, 16f, 12f, 18f)
                moveTo(6f, 12f); curveTo(8f, 10f, 10f, 10f, 10f, 12f); curveTo(10f, 14f, 8f, 14f, 6f, 12f)
                moveTo(18f, 12f); curveTo(16f, 10f, 14f, 10f, 14f, 12f); curveTo(14f, 14f, 16f, 14f, 18f, 12f)
            }
            // Sneeze dots
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 4f); lineTo(3.1f, 4f)
                moveTo(5f, 2f); lineTo(5.1f, 2f)
                moveTo(20f, 19f); lineTo(20.1f, 19f)
            }
        }.build()
    }

    /** illness — thermometer with cross */
    val Illness: ImageVector by lazy {
        ImageVector.Builder("Illness", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Thermometer
                moveTo(9f, 3f); lineTo(13f, 3f); lineTo(13f, 14f)
                arcTo(4f, 4f, 0f, isMoreThanHalf = true, isPositiveArc = true, 9f, 14f)
                lineTo(9f, 3f)
                moveTo(11f, 15f); lineTo(11f, 8f)
            }
            // Cross
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(18f, 6f); lineTo(18f, 14f)
                moveTo(14f, 10f); lineTo(22f, 10f)
            }
        }.build()
    }

    /** medication — pill capsule */
    val Medication: ImageVector by lazy {
        ImageVector.Builder("Medication", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Capsule
                moveTo(8.5f, 4f); curveTo(6f, 4f, 4f, 6f, 4f, 8.5f)
                lineTo(4f, 11.5f); lineTo(12.5f, 20f)
                lineTo(15.5f, 20f); curveTo(18f, 20f, 20f, 18f, 20f, 15.5f)
                lineTo(20f, 12.5f); lineTo(11.5f, 4f); close()
                // Divider
                moveTo(8f, 16f); lineTo(16f, 8f)
            }
        }.build()
    }

    /** motion_sickness — spiral */
    val MotionSickness: ImageVector by lazy {
        ImageVector.Builder("MotionSickness", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 12f)
                curveTo(12f, 10f, 14f, 9f, 15f, 10f)
                curveTo(17f, 12f, 15f, 16f, 12f, 16f)
                curveTo(8f, 16f, 6f, 12f, 6f, 10f)
                curveTo(6f, 5f, 10f, 2f, 14f, 2f)
                curveTo(20f, 2f, 22f, 7f, 22f, 12f)
                curveTo(22f, 18f, 17.5f, 22f, 12f, 22f)
                curveTo(6f, 22f, 2f, 17.5f, 2f, 12f)
            }
        }.build()
    }

    /** sexual_activity — two hearts */
    val SexualActivity: ImageVector by lazy {
        ImageVector.Builder("SexualActivity", W.dp, H.dp, W, H).apply {
            // Small heart
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(8f, 14f)
                curveTo(4f, 11f, 3f, 9f, 3f, 7.5f); curveTo(3f, 6f, 4f, 5f, 5.5f, 5f); curveTo(6.5f, 5f, 7.5f, 5.5f, 8f, 6.5f)
                curveTo(8.5f, 5.5f, 9.5f, 5f, 10.5f, 5f); curveTo(12f, 5f, 13f, 6f, 13f, 7.5f); curveTo(13f, 9f, 12f, 11f, 8f, 14f)
            }
            // Big heart
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(16f, 21f)
                curveTo(11f, 17f, 10f, 15f, 10f, 13f); curveTo(10f, 11f, 11.5f, 10f, 13f, 10f); curveTo(14f, 10f, 15f, 11f, 16f, 12f)
                curveTo(17f, 11f, 18f, 10f, 19f, 10f); curveTo(20.5f, 10f, 22f, 11f, 22f, 13f); curveTo(22f, 15f, 21f, 17f, 16f, 21f)
            }
        }.build()
    }

    /** tobacco — cigarette */
    val Tobacco: ImageVector by lazy {
        ImageVector.Builder("Tobacco", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cigarette body
                moveTo(2f, 14f); lineTo(18f, 14f); lineTo(18f, 18f); lineTo(2f, 18f); close()
                // Filter
                moveTo(14f, 14f); lineTo(14f, 18f)
                // Smoke wisps
                moveTo(19f, 12f); curveTo(19f, 10f, 21f, 10f, 21f, 8f)
                moveTo(21f, 12f); curveTo(21f, 10f, 23f, 10f, 23f, 8f)
            }
        }.build()
    }

    /** low_blood_sugar — droplet with arrow down */
    val LowBloodSugar: ImageVector by lazy {
        ImageVector.Builder("LowBloodSugar", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Droplet
                moveTo(12f, 3f); curveTo(12f, 3f, 6f, 10f, 6f, 14f)
                arcTo(6f, 6f, 0f, isMoreThanHalf = false, isPositiveArc = false, 18f, 14f)
                curveTo(18f, 10f, 12f, 3f, 12f, 3f)
            }
            // Arrow down inside
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 11f); lineTo(12f, 18f)
                moveTo(10f, 16f); lineTo(12f, 18f); lineTo(14f, 16f)
            }
        }.build()
    }

    // ─── MENTAL ──────────────────────────────────────────────

    /** screen_time — phone/monitor */
    val ScreenTime: ImageVector by lazy {
        ImageVector.Builder("ScreenTime", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Monitor
                moveTo(3f, 4f); lineTo(21f, 4f); lineTo(21f, 16f); lineTo(3f, 16f); close()
                // Stand
                moveTo(8f, 20f); lineTo(16f, 20f)
                moveTo(12f, 16f); lineTo(12f, 20f)
            }
        }.build()
    }

    /** late_screen — phone with moon */
    val LateScreen: ImageVector by lazy {
        ImageVector.Builder("LateScreen", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Phone
                moveTo(7f, 2f); lineTo(17f, 2f); lineTo(17f, 22f); lineTo(7f, 22f); close()
                moveTo(10f, 19f); lineTo(14f, 19f)
            }
            // Moon inside screen
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(15f, 10f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 7f)
                curveTo(12.5f, 7f, 15f, 8.5f, 15f, 10f)
            }
        }.build()
    }

    /** noise — sound waves */
    val Noise: ImageVector by lazy {
        ImageVector.Builder("Noise", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Speaker
                moveTo(3f, 9f); lineTo(7f, 9f); lineTo(11f, 5f); lineTo(11f, 19f); lineTo(7f, 15f); lineTo(3f, 15f); close()
                // Sound waves
                moveTo(14f, 8f); curveTo(16f, 9.5f, 16f, 14.5f, 14f, 16f)
                moveTo(17f, 5f); curveTo(20f, 8f, 20f, 16f, 17f, 19f)
            }
        }.build()
    }

    /** stress — head with lightning */
    val Stress: ImageVector by lazy {
        ImageVector.Builder("Stress", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Head circle
                moveTo(19f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 5f, 12f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 19f, 12f)
            }
            // Lightning inside
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(13f, 7f); lineTo(10f, 12f); lineTo(13f, 12f); lineTo(11f, 17f)
            }
        }.build()
    }

    /** anxiety — swirl/spiral in head */
    val Anxiety: ImageVector by lazy {
        ImageVector.Builder("Anxiety", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Head outline
                moveTo(19f, 13f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = true, isPositiveArc = true, 5f, 13f)
                lineTo(5f, 20f)
                moveTo(19f, 13f); lineTo(19f, 20f)
            }
            // Spiral inside
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 11f)
                curveTo(12f, 10f, 13.5f, 9.5f, 14f, 10.5f)
                curveTo(15f, 12f, 13f, 14f, 11f, 13f)
                curveTo(9f, 12f, 9.5f, 8f, 12f, 7f)
            }
        }.build()
    }

    /** depression — rain cloud */
    val Depression: ImageVector by lazy {
        ImageVector.Builder("Depression", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cloud
                moveTo(6f, 14f); lineTo(18f, 14f)
                curveTo(20f, 14f, 21f, 12f, 21f, 10f); curveTo(21f, 8f, 19f, 6f, 17f, 6f)
                curveTo(17f, 4f, 15f, 2f, 12f, 2f); curveTo(9f, 2f, 7f, 4f, 7f, 6f)
                curveTo(5f, 6f, 3f, 8f, 3f, 10f); curveTo(3f, 12f, 4f, 14f, 6f, 14f)
            }
            // Rain drops
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 17f); lineTo(8f, 20f)
                moveTo(12f, 17f); lineTo(12f, 22f)
                moveTo(16f, 17f); lineTo(16f, 20f)
            }
        }.build()
    }

    /** anger — explosion/bang */
    val Anger: ImageVector by lazy {
        ImageVector.Builder("Anger", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Jagged star/burst
                moveTo(12f, 2f); lineTo(14f, 8f); lineTo(20f, 6f); lineTo(16f, 12f)
                lineTo(22f, 14f); lineTo(16f, 16f); lineTo(18f, 22f); lineTo(12f, 18f)
                lineTo(6f, 22f); lineTo(8f, 16f); lineTo(2f, 14f); lineTo(8f, 12f)
                lineTo(4f, 6f); lineTo(10f, 8f); close()
            }
        }.build()
    }

    /** letdown — downward trend arrow */
    val Letdown: ImageVector by lazy {
        ImageVector.Builder("Letdown", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Trend down then relief
                moveTo(2f, 6f); lineTo(8f, 6f); lineTo(14f, 16f); lineTo(22f, 10f)
                // Arrow head
                moveTo(18f, 10f); lineTo(22f, 10f); lineTo(22f, 14f)
            }
        }.build()
    }

    /** computer — laptop */
    val Computer: ImageVector by lazy {
        ImageVector.Builder("Computer", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Screen
                moveTo(4f, 4f); lineTo(20f, 4f); lineTo(20f, 16f); lineTo(4f, 16f); close()
                // Base
                moveTo(2f, 20f); lineTo(22f, 20f)
                moveTo(8f, 16f); lineTo(6f, 20f)
                moveTo(16f, 16f); lineTo(18f, 20f)
            }
        }.build()
    }

    /** travel — suitcase */
    val Travel: ImageVector by lazy {
        ImageVector.Builder("Travel", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Suitcase body
                moveTo(3f, 8f); lineTo(21f, 8f); lineTo(21f, 20f); lineTo(3f, 20f); close()
                // Handle
                moveTo(8f, 8f); lineTo(8f, 5f); curveTo(8f, 4f, 9f, 3f, 10f, 3f)
                lineTo(14f, 3f); curveTo(15f, 3f, 16f, 4f, 16f, 5f); lineTo(16f, 8f)
                // Strap
                moveTo(12f, 12f); lineTo(12f, 16f)
            }
        }.build()
    }

    // ─── ENVIRONMENT ─────────────────────────────────────────

    /** pressure — barometer */
    val Pressure: ImageVector by lazy {
        ImageVector.Builder("Pressure", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Gauge circle
                moveTo(21f, 12f)
                arcTo(9f, 9f, 0f, isMoreThanHalf = true, isPositiveArc = true, 3f, 12f)
                arcTo(9f, 9f, 0f, isMoreThanHalf = true, isPositiveArc = true, 21f, 12f)
                // Needle
                moveTo(12f, 12f); lineTo(8f, 8f)
                // Center dot
                moveTo(13f, 12f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 11f, 12f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 13f, 12f)
            }
        }.build()
    }

    /** humidity — water droplets */
    val Humidity: ImageVector by lazy {
        ImageVector.Builder("Humidity", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Big drop
                moveTo(12f, 3f); curveTo(12f, 3f, 7f, 9f, 7f, 13f)
                arcTo(5f, 5f, 0f, isMoreThanHalf = false, isPositiveArc = false, 17f, 13f)
                curveTo(17f, 9f, 12f, 3f, 12f, 3f)
            }
            // Small drop
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(18f, 14f); curveTo(18f, 14f, 16f, 17f, 18f, 19f); curveTo(20f, 17f, 18f, 14f, 18f, 14f)
            }
        }.build()
    }

    /** temperature — sun thermometer */
    val Temperature: ImageVector by lazy {
        ImageVector.Builder("Temperature", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Sun
                moveTo(18f, 6f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 12f, 6f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 18f, 6f)
                // Rays
                moveTo(15f, 1f); lineTo(15f, 2f)
                moveTo(15f, 10f); lineTo(15f, 11f)
                moveTo(20f, 6f); lineTo(21f, 6f)
                moveTo(9f, 6f); lineTo(10f, 6f)
            }
            // Small thermometer
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(5f, 10f); lineTo(7f, 10f); lineTo(7f, 18f)
                arcTo(2f, 2f, 0f, isMoreThanHalf = true, isPositiveArc = true, 5f, 18f)
                lineTo(5f, 10f)
            }
        }.build()
    }

    /** uv — sun with UV label */
    val Uv: ImageVector by lazy {
        ImageVector.Builder("Uv", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Sun circle
                moveTo(17f, 10f)
                arcTo(5f, 5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 7f, 10f)
                arcTo(5f, 5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 17f, 10f)
                // Rays
                moveTo(12f, 2f); lineTo(12f, 3f)
                moveTo(12f, 17f); lineTo(12f, 18f)
                moveTo(4f, 10f); lineTo(3f, 10f)
                moveTo(21f, 10f); lineTo(20f, 10f)
                moveTo(6.3f, 4.3f); lineTo(7f, 5f)
                moveTo(17f, 15f); lineTo(17.7f, 15.7f)
                moveTo(17.7f, 4.3f); lineTo(17f, 5f)
                moveTo(7f, 15f); lineTo(6.3f, 15.7f)
            }
            // UV text hint - small line under
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 21f); lineTo(16f, 21f)
            }
        }.build()
    }

    /** wind — wind lines */
    val Wind: ImageVector by lazy {
        ImageVector.Builder("Wind", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 8f); lineTo(16f, 8f); curveTo(19f, 8f, 19f, 4f, 16f, 4f)
                moveTo(2f, 12f); lineTo(19f, 12f); curveTo(22f, 12f, 22f, 16f, 19f, 16f)
                moveTo(2f, 16f); lineTo(12f, 16f); curveTo(14f, 16f, 14f, 20f, 12f, 20f)
            }
        }.build()
    }

    /** altitude — mountain */
    val Altitude: ImageVector by lazy {
        ImageVector.Builder("Altitude", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(2f, 20f); lineTo(9f, 6f); lineTo(14f, 14f); lineTo(17f, 10f); lineTo(22f, 20f); close()
            }
        }.build()
    }

    /** fluorescent — tube light */
    val Fluorescent: ImageVector by lazy {
        ImageVector.Builder("Fluorescent", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Tube
                moveTo(4f, 10f); lineTo(20f, 10f); lineTo(20f, 14f); lineTo(4f, 14f); close()
                // Mounting lines
                moveTo(8f, 6f); lineTo(8f, 10f)
                moveTo(16f, 6f); lineTo(16f, 10f)
                // Glow rays
                moveTo(6f, 17f); lineTo(6f, 19f)
                moveTo(12f, 17f); lineTo(12f, 20f)
                moveTo(18f, 17f); lineTo(18f, 19f)
            }
        }.build()
    }

    /** smoke — cloud with particles */
    val Smoke: ImageVector by lazy {
        ImageVector.Builder("Smoke", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Smoke cloud
                moveTo(5f, 18f); lineTo(19f, 18f)
                curveTo(21f, 18f, 22f, 16f, 22f, 14f); curveTo(22f, 12f, 20f, 10f, 18f, 10f)
                curveTo(18f, 7f, 15f, 5f, 12f, 5f); curveTo(9f, 5f, 6f, 7f, 6f, 10f)
                curveTo(4f, 10f, 2f, 12f, 2f, 14f); curveTo(2f, 16f, 3f, 18f, 5f, 18f)
            }
            // Particles
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round) {
                moveTo(8f, 21f); lineTo(8.1f, 21f)
                moveTo(12f, 21f); lineTo(12.1f, 21f)
                moveTo(16f, 21f); lineTo(16.1f, 21f)
            }
        }.build()
    }

    /** strong_smell — nose with waves */
    val StrongSmell: ImageVector by lazy {
        ImageVector.Builder("StrongSmell", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Nose
                moveTo(12f, 3f); lineTo(12f, 12f); curveTo(12f, 16f, 8f, 17f, 7f, 15f)
            }
            // Smell waves
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(16f, 10f); curveTo(16f, 8f, 18f, 8f, 18f, 10f); curveTo(18f, 12f, 16f, 12f, 16f, 14f)
                moveTo(19f, 8f); curveTo(19f, 6f, 21f, 6f, 21f, 8f); curveTo(21f, 10f, 19f, 10f, 19f, 12f)
            }
        }.build()
    }

    // ─── MENSTRUAL ───────────────────────────────────────────

    /** menstruation — droplet */
    val Menstruation: ImageVector by lazy {
        ImageVector.Builder("Menstruation", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 3f); curveTo(12f, 3f, 5f, 11f, 5f, 15f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = false, isPositiveArc = false, 19f, 15f)
                curveTo(19f, 11f, 12f, 3f, 12f, 3f)
            }
        }.build()
    }

    /** ovulation — egg cell */
    val Ovulation: ImageVector by lazy {
        ImageVector.Builder("Ovulation", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Outer circle
                moveTo(20f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 4f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 20f, 12f)
                // Inner nucleus
                moveTo(15f, 11f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 9f, 11f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 15f, 11f)
            }
        }.build()
    }

    /** contraceptive — pill pack */
    val Contraceptive: ImageVector by lazy {
        ImageVector.Builder("Contraceptive", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Pack outline
                moveTo(4f, 4f); lineTo(20f, 4f); lineTo(20f, 20f); lineTo(4f, 20f); close()
                // Pill dots (grid)
                moveTo(8f, 8f); lineTo(8.1f, 8f)
                moveTo(12f, 8f); lineTo(12.1f, 8f)
                moveTo(16f, 8f); lineTo(16.1f, 8f)
                moveTo(8f, 12f); lineTo(8.1f, 12f)
                moveTo(12f, 12f); lineTo(12.1f, 12f)
                moveTo(16f, 12f); lineTo(16.1f, 12f)
                moveTo(8f, 16f); lineTo(8.1f, 16f)
                moveTo(12f, 16f); lineTo(12.1f, 16f)
                moveTo(16f, 16f); lineTo(16.1f, 16f)
            }
        }.build()
    }

    // ─── DIET ────────────────────────────────────────────────

    /** calories — flame */
    val Calories: ImageVector by lazy {
        ImageVector.Builder("Calories", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f)
                curveTo(7f, 22f, 4f, 18f, 4f, 14f)
                curveTo(4f, 10f, 8f, 6f, 12f, 2f)
                curveTo(16f, 6f, 20f, 10f, 20f, 14f)
                curveTo(20f, 18f, 17f, 22f, 12f, 22f)
            }
            path(stroke = stroke, strokeLineWidth = 1.5f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 20f)
                curveTo(10f, 20f, 8.5f, 18.5f, 8.5f, 16.5f)
                curveTo(8.5f, 14.5f, 10f, 13f, 12f, 11f)
                curveTo(14f, 13f, 15.5f, 14.5f, 15.5f, 16.5f)
                curveTo(15.5f, 18.5f, 14f, 20f, 12f, 20f)
            }
        }.build()
    }

    /** caffeine — coffee cup */
    val Caffeine: ImageVector by lazy {
        ImageVector.Builder("Caffeine", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cup
                moveTo(4f, 8f); lineTo(16f, 8f); lineTo(15f, 20f); lineTo(5f, 20f); close()
                // Handle
                moveTo(16f, 10f); curveTo(19f, 10f, 19f, 16f, 16f, 16f)
                // Steam
                moveTo(8f, 4f); curveTo(8f, 3f, 9f, 3f, 9f, 4f); curveTo(9f, 5f, 10f, 5f, 10f, 4f)
                moveTo(12f, 4f); curveTo(12f, 3f, 13f, 3f, 13f, 4f); curveTo(13f, 5f, 14f, 5f, 14f, 4f)
            }
        }.build()
    }

    /** alcohol — wine glass */
    val Alcohol: ImageVector by lazy {
        ImageVector.Builder("Alcohol", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Glass bowl
                moveTo(6f, 2f); lineTo(18f, 2f); curveTo(18f, 10f, 14f, 12f, 12f, 12f)
                curveTo(10f, 12f, 6f, 10f, 6f, 2f)
                // Stem
                moveTo(12f, 12f); lineTo(12f, 19f)
                // Base
                moveTo(8f, 19f); lineTo(16f, 19f)
                // Wine level
                moveTo(7f, 6f); lineTo(17f, 6f)
            }
        }.build()
    }

    /** sugar — cube with S */
    val Sugar: ImageVector by lazy {
        ImageVector.Builder("Sugar", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cube
                moveTo(4f, 6f); lineTo(12f, 2f); lineTo(20f, 6f); lineTo(20f, 18f); lineTo(12f, 22f); lineTo(4f, 18f); close()
                moveTo(12f, 2f); lineTo(12f, 22f)
                moveTo(4f, 6f); lineTo(20f, 18f)
            }
        }.build()
    }

    /** sodium — salt shaker */
    val Sodium: ImageVector by lazy {
        ImageVector.Builder("Sodium", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Shaker body
                moveTo(7f, 8f); lineTo(17f, 8f); lineTo(16f, 22f); lineTo(8f, 22f); close()
                // Cap
                moveTo(8f, 8f); curveTo(8f, 5f, 10f, 3f, 12f, 3f); curveTo(14f, 3f, 16f, 5f, 16f, 8f)
                // Holes
                moveTo(10f, 5f); lineTo(10.1f, 5f)
                moveTo(12f, 4f); lineTo(12.1f, 4f)
                moveTo(14f, 5f); lineTo(14.1f, 5f)
            }
        }.build()
    }

    /** cholesterol — droplet with cross */
    val Cholesterol: ImageVector by lazy {
        ImageVector.Builder("Cholesterol", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 3f); curveTo(12f, 3f, 5f, 11f, 5f, 15f)
                arcTo(7f, 7f, 0f, isMoreThanHalf = false, isPositiveArc = false, 19f, 15f)
                curveTo(19f, 11f, 12f, 3f, 12f, 3f)
                // Blocked sign
                moveTo(8f, 13f); lineTo(16f, 17f)
            }
        }.build()
    }

    /** protein — meat/drumstick */
    val Protein: ImageVector by lazy {
        ImageVector.Builder("Protein", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Drumstick
                moveTo(16f, 4f); curveTo(20f, 4f, 22f, 8f, 19f, 12f)
                curveTo(16f, 16f, 12f, 14f, 12f, 14f)
                lineTo(6f, 20f); curveTo(4f, 22f, 2f, 20f, 4f, 18f)
                lineTo(10f, 12f); curveTo(10f, 12f, 8f, 8f, 12f, 5f)
                curveTo(14f, 3f, 16f, 4f, 16f, 4f)
            }
        }.build()
    }

    /** carbs — bread slice */
    val Carbs: ImageVector by lazy {
        ImageVector.Builder("Carbs", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Bread shape
                moveTo(5f, 10f); curveTo(5f, 5f, 8f, 3f, 12f, 3f); curveTo(16f, 3f, 19f, 5f, 19f, 10f)
                lineTo(19f, 20f); lineTo(5f, 20f); close()
            }
        }.build()
    }

    /** fat — oil drop */
    val Fat: ImageVector by lazy {
        ImageVector.Builder("Fat", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 3f); curveTo(12f, 3f, 6f, 10f, 6f, 14f)
                arcTo(6f, 6f, 0f, isMoreThanHalf = false, isPositiveArc = false, 18f, 14f)
                curveTo(18f, 10f, 12f, 3f, 12f, 3f)
                // Shine
                moveTo(10f, 14f); curveTo(9f, 12f, 10f, 10f, 12f, 9f)
            }
        }.build()
    }

    /** fibre — wheat stalk */
    val Fibre: ImageVector by lazy {
        ImageVector.Builder("Fibre", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Stem
                moveTo(12f, 22f); lineTo(12f, 6f)
                // Leaves
                moveTo(12f, 8f); curveTo(8f, 6f, 7f, 3f, 7f, 3f)
                moveTo(12f, 8f); curveTo(16f, 6f, 17f, 3f, 17f, 3f)
                moveTo(12f, 12f); curveTo(8f, 10f, 6f, 8f, 6f, 8f)
                moveTo(12f, 12f); curveTo(16f, 10f, 18f, 8f, 18f, 8f)
                moveTo(12f, 16f); curveTo(8f, 14f, 6f, 12f, 6f, 12f)
                moveTo(12f, 16f); curveTo(16f, 14f, 18f, 12f, 18f, 12f)
            }
        }.build()
    }

    /** gluten — wheat with X */
    val Gluten: ImageVector by lazy {
        ImageVector.Builder("Gluten", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                moveTo(12f, 22f); lineTo(12f, 8f)
                moveTo(12f, 10f); curveTo(8f, 8f, 7f, 5f, 7f, 5f)
                moveTo(12f, 10f); curveTo(16f, 8f, 17f, 5f, 17f, 5f)
                moveTo(12f, 14f); curveTo(8f, 12f, 6f, 10f, 6f, 10f)
                moveTo(12f, 14f); curveTo(16f, 12f, 18f, 10f, 18f, 10f)
            }
            // X over it
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(3f, 3f); lineTo(21f, 21f)
                moveTo(21f, 3f); lineTo(3f, 21f)
            }
        }.build()
    }

    /** tyramine — cheese wedge */
    val Tyramine: ImageVector by lazy {
        ImageVector.Builder("Tyramine", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Cheese wedge
                moveTo(2f, 18f); lineTo(22f, 18f); lineTo(22f, 8f); close()
                // Holes
                moveTo(10f, 15f)
                arcTo(1.5f, 1.5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 7f, 15f)
                arcTo(1.5f, 1.5f, 0f, isMoreThanHalf = true, isPositiveArc = true, 10f, 15f)
                moveTo(18f, 13f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 16f, 13f)
                arcTo(1f, 1f, 0f, isMoreThanHalf = true, isPositiveArc = true, 18f, 13f)
            }
        }.build()
    }

    /** iron — magnet shape */
    val Iron: ImageVector by lazy {
        ImageVector.Builder("Iron", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Horseshoe magnet
                moveTo(6f, 4f); lineTo(6f, 14f)
                arcTo(6f, 6f, 0f, isMoreThanHalf = false, isPositiveArc = false, 18f, 14f)
                lineTo(18f, 4f)
                // Pole caps
                moveTo(3f, 4f); lineTo(9f, 4f)
                moveTo(15f, 4f); lineTo(21f, 4f)
            }
        }.build()
    }

    /** magnesium — Mg atom */
    val Magnesium: ImageVector by lazy {
        ImageVector.Builder("Magnesium", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Atom circle
                moveTo(20f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 4f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 20f, 12f)
                // Electron orbits
                moveTo(12f, 5f); curveTo(16f, 5f, 20f, 8f, 18f, 12f)
                moveTo(12f, 19f); curveTo(8f, 19f, 4f, 16f, 6f, 12f)
            }
        }.build()
    }

    /** skipped_meals — plate with X */
    val SkippedMeals: ImageVector by lazy {
        ImageVector.Builder("SkippedMeals", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Plate circle
                moveTo(20f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 4f, 12f)
                arcTo(8f, 8f, 0f, isMoreThanHalf = true, isPositiveArc = true, 20f, 12f)
            }
            // X
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round) {
                moveTo(9f, 9f); lineTo(15f, 15f)
                moveTo(15f, 9f); lineTo(9f, 15f)
            }
        }.build()
    }

    /** mineral — gemstone/crystal */
    val Mineral: ImageVector by lazy {
        ImageVector.Builder("Mineral", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Diamond/gem shape
                moveTo(6f, 3f); lineTo(18f, 3f); lineTo(22f, 9f); lineTo(12f, 21f); lineTo(2f, 9f); close()
                // Facet lines
                moveTo(2f, 9f); lineTo(22f, 9f)
                moveTo(6f, 3f); lineTo(12f, 9f); lineTo(18f, 3f)
            }
        }.build()
    }

    /** vitamin — capsule pill */
    val Vitamin: ImageVector by lazy {
        ImageVector.Builder("Vitamin", W.dp, H.dp, W, H).apply {
            path(stroke = stroke, strokeLineWidth = 2f, strokeLineCap = StrokeCap.Round, strokeLineJoin = StrokeJoin.Round) {
                // Capsule vertical
                moveTo(9f, 6f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 15f, 6f)
                lineTo(15f, 18f)
                arcTo(3f, 3f, 0f, isMoreThanHalf = true, isPositiveArc = true, 9f, 18f)
                close()
                // Divider
                moveTo(9f, 12f); lineTo(15f, 12f)
            }
        }.build()
    }

    // ─── LOOKUP ──────────────────────────────────────────────

    data class TriggerPickerIcon(val key: String, val label: String, val icon: ImageVector)

    val ALL_ICONS: List<TriggerPickerIcon> by lazy { listOf(
        TriggerPickerIcon("duration", "Duration", Duration),
        TriggerPickerIcon("score", "Score", Score),
        TriggerPickerIcon("efficiency", "Efficiency", Efficiency),
        TriggerPickerIcon("disturbances", "Disturbances", Disturbances),
        TriggerPickerIcon("bedtime", "Bedtime", Bedtime),
        TriggerPickerIcon("wake_time", "Wake time", WakeTime),
        TriggerPickerIcon("deep_sleep", "Deep sleep", DeepSleep),
        TriggerPickerIcon("rem_sleep", "REM sleep", RemSleep),
        TriggerPickerIcon("light_sleep", "Light sleep", LightSleep),
        TriggerPickerIcon("jet_lag", "Jet lag", JetLag),
        TriggerPickerIcon("sleep_apnea", "Sleep apnea", SleepApnea),
        TriggerPickerIcon("recovery", "Recovery", Recovery),
        TriggerPickerIcon("spo2", "SpO2", SpO2),
        TriggerPickerIcon("skin_temp", "Skin temp", SkinTemp),
        TriggerPickerIcon("resp_rate", "Resp rate", RespRate),
        TriggerPickerIcon("hr_zones", "HR zones", HrZones),
        TriggerPickerIcon("steps", "Steps", Steps),
        TriggerPickerIcon("body_fat", "Body fat", BodyFat),
        TriggerPickerIcon("weight", "Weight", Weight),
        TriggerPickerIcon("bp", "Blood pressure", Bp),
        TriggerPickerIcon("blood_glucose", "Blood glucose", BloodGlucose),
        TriggerPickerIcon("strain", "Strain", Strain),
        TriggerPickerIcon("hydration", "Hydration", Hydration),
        TriggerPickerIcon("allergies", "Allergies", Allergies),
        TriggerPickerIcon("illness", "Illness", Illness),
        TriggerPickerIcon("medication", "Medication", Medication),
        TriggerPickerIcon("motion_sickness", "Motion sickness", MotionSickness),
        TriggerPickerIcon("sexual_activity", "Sexual activity", SexualActivity),
        TriggerPickerIcon("tobacco", "Tobacco", Tobacco),
        TriggerPickerIcon("low_blood_sugar", "Low blood sugar", LowBloodSugar),
        TriggerPickerIcon("screen_time", "Screen time", ScreenTime),
        TriggerPickerIcon("late_screen", "Late screen", LateScreen),
        TriggerPickerIcon("noise", "Noise", Noise),
        TriggerPickerIcon("stress", "Stress", Stress),
        TriggerPickerIcon("anxiety", "Anxiety", Anxiety),
        TriggerPickerIcon("depression", "Depression", Depression),
        TriggerPickerIcon("anger", "Anger", Anger),
        TriggerPickerIcon("letdown", "Let-down", Letdown),
        TriggerPickerIcon("computer", "Computer", Computer),
        TriggerPickerIcon("travel", "Travel", Travel),
        TriggerPickerIcon("pressure", "Pressure", Pressure),
        TriggerPickerIcon("humidity", "Humidity", Humidity),
        TriggerPickerIcon("temperature", "Temperature", Temperature),
        TriggerPickerIcon("uv", "UV", Uv),
        TriggerPickerIcon("wind", "Wind", Wind),
        TriggerPickerIcon("altitude", "Altitude", Altitude),
        TriggerPickerIcon("fluorescent", "Fluorescent", Fluorescent),
        TriggerPickerIcon("smoke", "Smoke", Smoke),
        TriggerPickerIcon("strong_smell", "Strong smell", StrongSmell),
        TriggerPickerIcon("menstruation", "Menstruation", Menstruation),
        TriggerPickerIcon("ovulation", "Ovulation", Ovulation),
        TriggerPickerIcon("contraceptive", "Contraceptive", Contraceptive),
        TriggerPickerIcon("calories", "Calories", Calories),
        TriggerPickerIcon("caffeine", "Caffeine", Caffeine),
        TriggerPickerIcon("alcohol", "Alcohol", Alcohol),
        TriggerPickerIcon("sugar", "Sugar", Sugar),
        TriggerPickerIcon("sodium", "Sodium", Sodium),
        TriggerPickerIcon("cholesterol", "Cholesterol", Cholesterol),
        TriggerPickerIcon("protein", "Protein", Protein),
        TriggerPickerIcon("carbs", "Carbs", Carbs),
        TriggerPickerIcon("fat", "Fat", Fat),
        TriggerPickerIcon("fibre", "Fibre", Fibre),
        TriggerPickerIcon("gluten", "Gluten", Gluten),
        TriggerPickerIcon("tyramine", "Tyramine", Tyramine),
        TriggerPickerIcon("iron", "Iron", Iron),
        TriggerPickerIcon("magnesium", "Magnesium", Magnesium),
        TriggerPickerIcon("skipped_meals", "Skipped meals", SkippedMeals),
        TriggerPickerIcon("mineral", "Mineral", Mineral),
        TriggerPickerIcon("vitamin", "Vitamin", Vitamin),
    ) }

    fun forKey(key: String?): ImageVector? = ALL_ICONS.find { it.key == key }?.icon
}

title: TriggersScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun TriggersScreen(
    navController: NavController,
    vm: TriggerViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel,
    onClose: () -> Unit = {},
    quickLogMode: Boolean = false,
    onSave: (() -> Unit)? = null,
    linkedMigraineId: String? = null,
    onMigraineSelect: ((String?) -> Unit)? = null
) {
    val rawPool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    // Show all triggers in the logging wizard (including NONE prediction)
    // so system-detected anomalies are surfaced. Collapse display_group items
    // into a single entry so user sees "Poor sleep" instead of 8 individual sleep metrics
    val pool = remember(rawPool) {
        val visible = rawPool
        val standalone = visible.filter { it.displayGroup == null }
        val grouped = visible.filter { it.displayGroup != null }
            .groupBy { it.displayGroup!! }
            .map { (groupName, members) ->
                val first = members.first()
                // Use highest severity among members as group severity
                val severityOrder = listOf("HIGH", "MILD", "LOW", "NONE")
                val bestSeverity = members.map { it.predictionValue?.uppercase() ?: "NONE" }
                    .minByOrNull { sev -> severityOrder.indexOf(sev) } ?: "NONE"
                SupabaseDbService.UserTriggerRow(
                    id = "group_${groupName}",
                    label = groupName,
                    iconKey = first.iconKey,
                    category = first.category,
                    predictionValue = bestSeverity,
                    displayGroup = groupName
                )
            }
        standalone + grouped
    }
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(authState.accessToken, draft.migraine?.beganAtIso) {
        authState.accessToken?.let { token ->
            vm.loadAll(token)
            vm.loadRecent(token, draft.migraine?.beganAtIso)
        }
    }

    // Recent triggers: type → days ago
    val recentDaysAgo by vm.recentDaysAgo.collectAsState()
    val recentStartAts by vm.recentStartAts.collectAsState()
    var hasAutoSelected by remember { mutableStateOf(false) }

    // Reset auto-select when migraine date changes
    LaunchedEffect(draft.migraine?.beganAtIso) {
        hasAutoSelected = false
    }

    // ── Rebuild helpers ──
    fun rebuildDraftWithTriggers(triggers: List<TriggerDraft>) {
        logVm.replaceTriggers(triggers)
    }

    // ── Auto-select recent triggers (once, on first load — wizard only) ──
    // Only auto-select when user has explicitly set a migraine date
    LaunchedEffect(recentDaysAgo, pool) {
        if (!quickLogMode && !hasAutoSelected && recentDaysAgo.isNotEmpty() && pool.isNotEmpty() && draft.migraine?.beganAtIso != null) {
            val currentLabels = draft.triggers.map { it.type }.toSet()
            val poolLabelsSet = pool.map { it.label }.toSet()
            val toAdd = recentDaysAgo.keys
                .filter { it in poolLabelsSet && it !in currentLabels }
            if (toAdd.isNotEmpty()) {
                val newTriggers = draft.triggers + toAdd.map { TriggerDraft(it, startAtIso = recentStartAts[it]) }
                rebuildDraftWithTriggers(newTriggers)
            }
            hasAutoSelected = true
        }
    }

    // ── Time dialog: add new ──
    var showAddTimeDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }

    // ── Time dialog: edit existing ──
    var showEditTimeDialog by remember { mutableStateOf(false) }
    var editIndex by remember { mutableStateOf<Int?>(null) }

    fun onTriggerTap(label: String) {
        val existingIdx = draft.triggers.indexOfFirst { it.type == label }
        if (existingIdx >= 0) {
            // Deselect
            val updated = draft.triggers.toMutableList().apply { removeAt(existingIdx) }
            rebuildDraftWithTriggers(updated)
        } else {
            pendingLabel = label
            showAddTimeDialog = true
        }
    }

    // Add dialog
    if (showAddTimeDialog && pendingLabel != null) {
        TriggerTimeDialog(
            title = pendingLabel!!,
            initialIso = null,
            onDismiss = { showAddTimeDialog = false },
            onSkip = {
                val updated = draft.triggers + TriggerDraft(pendingLabel!!, startAtIso = null)
                rebuildDraftWithTriggers(updated)
                showAddTimeDialog = false
            },
            onConfirm = { iso ->
                val updated = draft.triggers + TriggerDraft(pendingLabel!!, startAtIso = iso)
                rebuildDraftWithTriggers(updated)
                showAddTimeDialog = false
            }
        )
    }

    // Edit dialog
    if (showEditTimeDialog && editIndex != null && editIndex!! in draft.triggers.indices) {
        val editing = draft.triggers[editIndex!!]
        TriggerTimeDialog(
            title = editing.type,
            initialIso = editing.startAtIso,
            onDismiss = { showEditTimeDialog = false },
            onSkip = {
                val updated = draft.triggers.toMutableList().apply {
                    set(editIndex!!, editing.copy(startAtIso = null))
                }
                rebuildDraftWithTriggers(updated)
                showEditTimeDialog = false
            },
            onConfirm = { iso ->
                val updated = draft.triggers.toMutableList().apply {
                    set(editIndex!!, editing.copy(startAtIso = iso))
                }
                rebuildDraftWithTriggers(updated)
                showEditTimeDialog = false
            }
        )
    }

    // Frequent labels
    val poolLabels = remember(pool) { pool.map { it.label }.toSet() }
    val frequentLabels = remember(frequent, poolLabels) {
        frequent.mapNotNull { it.trigger?.label }.filter { it in poolLabels }.toSet()
    }
    val selectedLabels = remember(draft.triggers) { draft.triggers.map { it.type }.toSet() }

    // Group pool by category
    val grouped = remember(pool) {
        pool.groupBy { it.category ?: "Other" }.toSortedMap()
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll, logoRevealHeight = 60.dp) {

            // Top bar: ← Previous | Title | X Close
            Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                if (!quickLogMode) {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                        Spacer(Modifier.width(4.dp))
                        Text("Prodromes", color = Color.White.copy(alpha = 0.7f), style = MaterialTheme.typography.bodySmall)
                    }
                } else {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.clickable { navController.popBackStack() }) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back", tint = Color.White, modifier = Modifier.size(20.dp))
                    }
                }
                Text("Triggers", color = Color.White, style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold))
                if (!quickLogMode) {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Outlined.Close, contentDescription = "Close", tint = Color.White, modifier = Modifier.size(28.dp))
                    }
                } else {
                    Spacer(Modifier.size(28.dp))
                }
            }

            // ── HeroCard: icon + title + subtitle + selected list ──
            HeroCard {
                Box(
                    modifier = Modifier
                        .size(40.dp)
                        .drawBehind { HubIcons.run { drawTriggerBolt(Color(0xFFFFB74D)) } }
                )
                Text("Triggers", color = Color.White, style = MaterialTheme.typography.titleLarge.copy(fontWeight = FontWeight.Bold))
                Text(
                    if (draft.triggers.isEmpty()) "Select triggers that may have contributed"
                    else "${draft.triggers.size} trigger${if (draft.triggers.size > 1) "s" else ""} selected",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
                if (draft.triggers.isNotEmpty()) {
                    Spacer(Modifier.height(8.dp))
                    draft.triggers.forEachIndexed { index, t ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 3.dp)
                                .clip(RoundedCornerShape(8.dp))
                                .background(Color.White.copy(alpha = 0.06f))
                                .padding(horizontal = 12.dp, vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.SpaceBetween
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    t.type,
                                    color = AppTheme.BodyTextColor,
                                    style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Medium)
                                )
                                Text(
                                    if (t.startAtIso == null) "Same as migraine start"
                                    else formatTriggerTime(t.startAtIso),
                                    color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                                    style = MaterialTheme.typography.labelSmall
                                )
                            }
                            Icon(
                                Icons.Outlined.Edit,
                                contentDescription = "Edit time",
                                tint = AppTheme.AccentPurple.copy(alpha = 0.7f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        editIndex = index
                                        showEditTimeDialog = true
                                    }
                            )
                            Spacer(Modifier.width(8.dp))
                            Icon(
                                Icons.Outlined.Close,
                                contentDescription = "Remove",
                                tint = AppTheme.AccentPink.copy(alpha = 0.6f),
                                modifier = Modifier
                                    .size(18.dp)
                                    .clickable {
                                        val updated = draft.triggers.toMutableList().apply { removeAt(index) }
                                        rebuildDraftWithTriggers(updated)
                                    }
                            )
                        }
                    }
                }
            }

            // Manage card (own card)
            BaseCard {
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
                    Text("Triggers", color = AppTheme.TitleColor, style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold))
                    Text("Manage →", color = AppTheme.AccentPurple, style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.SemiBold),
                        modifier = Modifier.clickable { navController.navigate(Routes.MANAGE_TRIGGERS) })
                }
            }

            // ── Migraine picker (quick log only) ──
            if (quickLogMode && onMigraineSelect != null) {
                val firstIso = draft.triggers.firstOrNull()?.startAtIso
                MigrainePickerCard(itemStartAtIso = firstIso, authVm = authVm, selectedMigraineId = linkedMigraineId, onSelect = onMigraineSelect)
            }

            // ── Single triggers card: Frequent → divider → categories with dividers ──
            BaseCard {
                // Frequent section
                if (frequentLabels.isNotEmpty()) {
                    Text("Frequent", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                    FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        pool.filter { it.label in frequentLabels }.forEach { trig ->
                            TriggerButton(trig.label, trig.iconKey, trig.label in selectedLabels, daysAgo = recentDaysAgo[trig.label]) {
                                onTriggerTap(trig.label)
                            }
                        }
                    }
                    HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                }

                // Category sections with dividers
                val categoryEntries = grouped.entries.toList()
                categoryEntries.forEachIndexed { catIndex, (category, items) ->
                    val nonFreqItems = items.filter { it.label !in frequentLabels }
                    if (nonFreqItems.isNotEmpty()) {
                        Text(category, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelMedium.copy(fontWeight = FontWeight.SemiBold))
                        FlowRow(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalArrangement = Arrangement.spacedBy(16.dp)) {
                            nonFreqItems.forEach { trig ->
                                TriggerButton(trig.label, trig.iconKey, trig.label in selectedLabels, daysAgo = recentDaysAgo[trig.label]) {
                                    onTriggerTap(trig.label)
                                }
                            }
                        }
                        val hasMore = categoryEntries.drop(catIndex + 1).any { (_, its) -> its.any { it.label !in frequentLabels } }
                        if (hasMore) {
                            HorizontalDivider(color = Color.White.copy(alpha = 0.08f))
                        }
                    }
                }

                if (pool.isEmpty()) {
                    Text("Loading…", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.bodySmall)
                }
            }

            // Navigation
            Row(
                Modifier.fillMaxWidth().padding(vertical = 8.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    border = BorderStroke(1.dp, AppTheme.AccentPurple.copy(alpha = 0.5f)),
                    colors = ButtonDefaults.outlinedButtonColors(contentColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Cancel" else "Back") }
                Button(
                    onClick = { if (quickLogMode) onSave?.invoke() else navController.navigate(Routes.MEDICINES) },
                    enabled = !quickLogMode || draft.triggers.isNotEmpty(),
                    colors = ButtonDefaults.buttonColors(containerColor = AppTheme.AccentPurple)
                ) { Text(if (quickLogMode) "Save" else "Next") }
            }

            Spacer(Modifier.height(32.dp))
        }
    }
}

/* ────────────────────────────────────────────────
 *  Time dialog — Skip (use migraine start) or pick
 * ──────────────────────────────────────────────── */

@Composable
private fun TriggerTimeDialog(
    title: String,
    initialIso: String?,
    onDismiss: () -> Unit,
    onSkip: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf(initialIso) }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E0A2E),
        titleContentColor = Color.White,
        textContentColor = AppTheme.BodyTextColor,
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text(
                    "When did this start?",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
                Text(
                    "Time: ${formatTriggerTime(pickedIso)}",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
                AppDateTimePicker(
                    label = "Select time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        },
        confirmButton = {
            TextButton(onClick = { onConfirm(pickedIso) }) {
                Text("Set time", color = AppTheme.AccentPurple)
            }
        },
        dismissButton = {
            Row {
                TextButton(onClick = onDismiss) {
                    Text("Cancel", color = AppTheme.SubtleTextColor)
                }
                TextButton(onClick = onSkip) {
                    Text("Skip", color = Color(0xFFFFB74D))
                }
            }
        }
    )
}

/* ────────────────────────────────────────────────
 *  Trigger circle button
 * ──────────────────────────────────────────────── */

@Composable
private fun TriggerButton(label: String, iconKey: String? = null, isSelected: Boolean, daysAgo: Int? = null, onClick: () -> Unit) {
    val accent = Color(0xFFFFB74D)

    val (circleColor, borderColor) = when {
        isSelected && daysAgo == null -> accent.copy(alpha = 0.40f) to accent.copy(alpha = 0.7f)
        isSelected && daysAgo == 0   -> accent.copy(alpha = 0.50f) to accent.copy(alpha = 0.85f)
        isSelected && daysAgo == 1   -> Color(0xFFFF8A65).copy(alpha = 0.35f) to Color(0xFFFF8A65).copy(alpha = 0.65f) // deeper orange
        isSelected && daysAgo == 2   -> Color(0xFFE57373).copy(alpha = 0.30f) to Color(0xFFE57373).copy(alpha = 0.55f) // salmon
        isSelected && daysAgo == 3   -> Color(0xFFEF9A9A).copy(alpha = 0.25f) to Color(0xFFEF9A9A).copy(alpha = 0.45f) // faded red
        else -> Color.White.copy(alpha = 0.08f) to Color.White.copy(alpha = 0.12f)
    }
    val iconTint = if (isSelected) Color.White else AppTheme.SubtleTextColor
    val textColor = if (isSelected) Color.White else AppTheme.BodyTextColor
    val icon = TriggerIcons.forKey(iconKey)

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .width(72.dp)
            .clickable(
                interactionSource = remember { MutableInteractionSource() },
                indication = null,
                onClick = onClick
            )
    ) {
        Box(
            modifier = Modifier
                .size(52.dp)
                .clip(CircleShape)
                .background(circleColor)
                .border(width = 1.5.dp, color = borderColor, shape = CircleShape),
            contentAlignment = Alignment.Center
        ) {
            if (icon != null) {
                Icon(
                    imageVector = icon,
                    contentDescription = label,
                    tint = iconTint,
                    modifier = Modifier.size(24.dp)
                )
            } else {
                Text(
                    label.take(2).uppercase(),
                    color = iconTint,
                    style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Bold)
                )
            }
        }
        Spacer(Modifier.height(4.dp))
        Text(
            label,
            color = textColor,
            style = MaterialTheme.typography.labelSmall,
            textAlign = TextAlign.Center,
            maxLines = 2,
            modifier = Modifier.fillMaxWidth()
        )
        if (isSelected && daysAgo != null && daysAgo > 0) {
            Text(
                when (daysAgo) {
                    1 -> "yesterday"
                    2 -> "2d ago"
                    3 -> "3d ago"
                    else -> ""
                },
                color = Color.White.copy(alpha = 0.5f),
                style = MaterialTheme.typography.labelSmall.copy(fontSize = 9.sp),
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

/* ────────────────────────────────────────────────
 *  Format helper
 * ──────────────────────────────────────────────── */

private fun formatTriggerTime(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime()
            ?: runCatching { LocalDateTime.parse(iso) }.getOrNull()
            ?: runCatching { Instant.parse(iso).atZone(ZoneId.systemDefault()).toLocalDateTime() }.getOrNull()
            ?: return "Not set"
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}





title: TriggersSettingsScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Tune
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

@Composable
fun TriggersSettingsScreen(
    navController: NavController,
    authVm: AuthViewModel = viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val authState by authVm.state.collectAsState()
    val scrollState = rememberScrollState()

    // Load trigger stats
    var triggerCount by remember { mutableStateOf(0) }
    var autoTriggersEnabled by remember { mutableStateOf(0) }

    LaunchedEffect(authState.accessToken) {
        val token = authState.accessToken
        if (token.isNullOrBlank()) return@LaunchedEffect

        withContext(Dispatchers.IO) {
            // Count user's triggers
            try {
                val edge = EdgeFunctionsService()
                val triggerSettings = edge.getTriggerSettings(ctx)
                autoTriggersEnabled = triggerSettings.count { it.enabled }
            } catch (_: Exception) {}
        }
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            // Customize Triggers Card (similar to Configure Monitor in MonitorScreen)
            HeroCard(
                modifier = Modifier.clickable { navController.navigate(Routes.CUSTOMIZE_TRIGGERS) }
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Outlined.Tune,
                        contentDescription = "Customize",
                        tint = AppTheme.AccentPurple,
                        modifier = Modifier.size(28.dp)
                    )
                    Spacer(Modifier.width(12.dp))
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            "Customize Triggers",
                            color = AppTheme.TitleColor,
                            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                        )
                        Text(
                            "Configure automatic trigger detection",
                            color = AppTheme.SubtleTextColor,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                    Text(
                        "→",
                        color = AppTheme.AccentPurple,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            }

            // Summary Card
            HeroCard {
                Text(
                    "About Triggers",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(8.dp))
                Text(
                    "Triggers are events or conditions that may contribute to your migraines. " +
                    "You can log triggers manually when recording a migraine, or enable automatic " +
                    "trigger detection based on your health data.",
                    color = AppTheme.BodyTextColor,
                    style = MaterialTheme.typography.bodyMedium
                )
                Spacer(Modifier.height(12.dp))
                Text(
                    "Automatic triggers are checked daily at 9 AM your local time and will " +
                    "be added to your journal when conditions are met.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

title: TriggerViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class TriggerViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.UserTriggerRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.UserTriggerRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.TriggerPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.TriggerPrefRow>> = _frequent

    private val _hidden = MutableStateFlow<List<SupabaseDbService.TriggerPrefRow>>(emptyList())
    val hidden: StateFlow<List<SupabaseDbService.TriggerPrefRow>> = _hidden

    /** Map of trigger type → days ago (0=today, 1=yesterday, 2=two days, 3=three days). Lowest value wins. */
    private val _recentDaysAgo = MutableStateFlow<Map<String, Int>>(emptyMap())
    val recentDaysAgo: StateFlow<Map<String, Int>> = _recentDaysAgo

    /** Map of trigger type → most recent start_at ISO string. */
    private val _recentStartAts = MutableStateFlow<Map<String, String>>(emptyMap())
    val recentStartAts: StateFlow<Map<String, String>> = _recentStartAts

    private fun safeSortPrefs(prefs: List<SupabaseDbService.TriggerPrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllTriggerPool(accessToken)
                val prefs = db.getTriggerPrefs(accessToken)
                _pool.value = p
                _frequent.value = safeSortPrefs(prefs.filter { it.status == "frequent" })
                _hidden.value = prefs.filter { it.status == "hidden" }
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
                _hidden.value = emptyList()
            }
        }
    }

    fun loadRecent(accessToken: String, referenceDate: String? = null) {
        viewModelScope.launch {
            try {
                val refDate = referenceDate?.let {
                    try { java.time.LocalDate.parse(it.substring(0, 10)) } catch (_: Exception) { null }
                } ?: java.time.LocalDate.now()
                val rows = db.getRecentTriggers(accessToken, daysBack = 3, referenceDate = refDate.toString())
                val map = mutableMapOf<String, Int>()
                val isoMap = mutableMapOf<String, String>()
                for (row in rows) {
                    val type = row.type ?: continue
                    val startAt = row.startAt ?: continue
                    val date = try {
                        java.time.LocalDate.parse(startAt.substring(0, 10))
                    } catch (_: Exception) { continue }
                    val daysAgo = kotlin.math.abs(java.time.temporal.ChronoUnit.DAYS.between(date, refDate).toInt())
                    if (daysAgo in 0..3) {
                        val existing = map[type]
                        if (existing == null || daysAgo < existing) {
                            map[type] = daysAgo
                            isoMap[type] = startAt
                        }
                    }
                }
                _recentDaysAgo.value = map
                _recentStartAts.value = isoMap
            } catch (e: Exception) {
                e.printStackTrace()
                _recentDaysAgo.value = emptyMap()
                _recentStartAts.value = emptyMap()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String, category: String? = null, predictionValue: String? = "NONE") {
        viewModelScope.launch {
            try {
                db.upsertTriggerToPool(accessToken, label.trim(), category, predictionValue)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, triggerId: String) {
        viewModelScope.launch {
            try {
                db.deleteTriggerFromPool(accessToken, triggerId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, triggerId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertTriggerPref(accessToken, triggerId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteTriggerPref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun setPrediction(accessToken: String, triggerId: String, value: String) {
        viewModelScope.launch {
            try {
                db.updateTriggerPoolItem(accessToken, triggerId, predictionValue = value)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun setCategory(accessToken: String, triggerId: String, category: String?) {
        viewModelScope.launch {
            try {
                db.updateTriggerPoolItem(accessToken, triggerId, category = category)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}


title: trigger_templates_rows.json
text:
[{"id":"0280fa88-0d37-41da-93ad-823be26bfd23","label":"Pantothenic acid low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":1,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_pantothenic_acid_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"03dbe45b-b42f-4713-bb8c-c1d94f178105","label":"Wake time early","category":"Sleep","icon_key":"wake_time","prediction_value":"NONE","direction":"low","default_threshold":5,"unit":"time","enabled_by_default":true,"metric_table":"woke_up_time_daily","metric_column":"value_at","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Irregular sleep"},{"id":"0759da77-2a77-4bc1-a87a-e9ebe20888a7","label":"Riboflavin high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":3,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_riboflavin_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"09bb0579-9f8d-4e3d-81de-c97a17e32881","label":"Steps high","category":"Body","icon_key":"steps","prediction_value":"NONE","direction":"high","default_threshold":25000,"unit":"count","enabled_by_default":true,"metric_table":"steps_daily","metric_column":"value_count","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"0a1b6074-6c44-41ae-b8a5-bc5b40c37b03","label":"Wake time late","category":"Sleep","icon_key":"wake_time","prediction_value":"NONE","direction":"high","default_threshold":10,"unit":"time","enabled_by_default":true,"metric_table":"woke_up_time_daily","metric_column":"value_at","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Irregular sleep"},{"id":"0c293c4e-b5a8-4f55-9968-fbe6511d5581","label":"Sexual activity","category":"Physical","icon_key":"sexual_activity","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"0cb1d2ca-489a-46b9-8c69-585cea557022","label":"Altitude change low","category":"Environment","icon_key":"altitude","prediction_value":"NONE","direction":"low","default_threshold":0,"unit":"m","enabled_by_default":true,"metric_table":"user_location_daily","metric_column":"altitude_change_m","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Altitude low"},{"id":"0d1cd70e-f5fe-4e90-a29b-955c8475b898","label":"Light sleep low","category":"Sleep","icon_key":"light_sleep","prediction_value":"NONE","direction":"low","default_threshold":1,"unit":"hours","enabled_by_default":true,"metric_table":"sleep_stages_daily","metric_column":"value_light_hm","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"0e991be8-51bb-4fe0-aeaf-fa8f6810897a","label":"Strong smell","category":"Environment","icon_key":"strong_smell","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"0f1ba3c7-820f-41c5-a898-3d9f29690f05","label":"Stress low","category":"Body","icon_key":"strain","prediction_value":"NONE","direction":"low","default_threshold":10,"unit":"","enabled_by_default":true,"metric_table":"stress_index_daily","metric_column":"value","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"10c1c7db-6df0-4788-af76-efcd3b5c8ec3","label":"REM sleep high","category":"Sleep","icon_key":"rem_sleep","prediction_value":"NONE","direction":"high","default_threshold":3.5,"unit":"hours","enabled_by_default":true,"metric_table":"sleep_stages_daily","metric_column":"value_rem_hm","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Oversleep"},{"id":"110bb759-0527-4fac-8b7f-81f36ac67410","label":"Riboflavin low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":0.3,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_riboflavin_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"110fec46-0f10-42a7-9e76-c8a86548015f","label":"Phosphorus low","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"low","default_threshold":300,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_phosphorus_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"13b7cbc6-4228-4443-96a9-2c13ba033036","label":"Pressure low","category":"Environment","icon_key":"pressure","prediction_value":"NONE","direction":"low","default_threshold":990,"unit":"hPa","enabled_by_default":true,"metric_table":"user_weather_daily","metric_column":"pressure_hpa_mean","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"21e8ba36-9b5d-4813-a91e-e4321b79122f","label":"Skipped meals","category":"Diet","icon_key":"skipped_meals","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"224e33cf-496d-454d-9e17-0c5da9a2cae8","label":"Anger","category":"Cognitive","icon_key":"anger","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"2549d2c2-eca1-40d7-82af-b56b31985021","label":"Blood pressure low","category":"Body","icon_key":"bp","prediction_value":"NONE","direction":"low","default_threshold":90,"unit":"mmHg","enabled_by_default":true,"metric_table":"blood_pressure_daily","metric_column":"systolic_mmhg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"27bc5e2a-7699-4c42-bfd9-f64c95c8a015","label":"Sleep disturbances high","category":"Sleep","icon_key":"disturbances","prediction_value":"NONE","direction":"high","default_threshold":5,"unit":"count","enabled_by_default":true,"metric_table":"sleep_disturbances_daily","metric_column":"value_count","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Poor sleep"},{"id":"28059cea-fca6-4bb9-99b5-781bcd6b69e5","label":"Body fat high","category":"Body","icon_key":"body_fat","prediction_value":"NONE","direction":"high","default_threshold":35,"unit":"%","enabled_by_default":true,"metric_table":"body_fat_daily","metric_column":"value_pct","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"2ac2e1f6-15a9-430e-93e7-4af7fb899b9b","label":"Iron high","category":"Diet","icon_key":"iron","prediction_value":"NONE","direction":"high","default_threshold":25,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_iron_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"2ac378f9-f776-4daa-93e2-13efc7d6e827","label":"Altitude change high","category":"Environment","icon_key":"altitude","prediction_value":"NONE","direction":"high","default_threshold":500,"unit":"m","enabled_by_default":true,"metric_table":"user_location_daily","metric_column":"altitude_change_m","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Altitude high"},{"id":"2c0bf1a3-67e5-4c6a-ad96-045f8872af37","label":"Noise low","category":"Cognitive","icon_key":"noise","prediction_value":"NONE","direction":"low","default_threshold":30,"unit":"dB","enabled_by_default":true,"metric_table":"ambient_noise_index_daily","metric_column":"day_mean_lmean","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"2ca996e1-14c8-40ca-93c9-b9d0e981dc86","label":"Anxiety","category":"Cognitive","icon_key":"anxiety","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"2d23ca80-ebce-4e70-87c6-f00f43b925bb","label":"Gluten exposure high","category":"Diet","icon_key":"gluten","prediction_value":"NONE","direction":"high","default_threshold":1,"unit":"","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"max_gluten_exposure","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"2dc003f1-29eb-4943-a616-2c078680f0ae","label":"Travel","category":"Environment","icon_key":"travel","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"2de31ada-55b0-4b8d-9abd-985b38f0075d","label":"Vitamin D high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":50,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_d_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"2e60b43c-1817-4775-9479-c57f3844edfe","label":"UV index low","category":"Environment","icon_key":"uv","prediction_value":"NONE","direction":"low","default_threshold":1,"unit":"","enabled_by_default":true,"metric_table":"user_weather_daily","metric_column":"uv_index_max","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"31b8ad39-a346-4b6c-a7bf-abc3de14073d","label":"Sugar high","category":"Diet","icon_key":"sugar","prediction_value":"NONE","direction":"high","default_threshold":80,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_sugar_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"331c4ccd-f2ab-43e8-add2-7d08ac59a69d","label":"Carbs high","category":"Diet","icon_key":"carbs","prediction_value":"NONE","direction":"high","default_threshold":400,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_carbs_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"346d58f9-f7b7-4667-9473-80877fefc12c","label":"Caffeine high","category":"Diet","icon_key":"caffeine","prediction_value":"NONE","direction":"high","default_threshold":400,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_caffeine_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"349f5ee4-4adf-4c96-a87b-ed1cdb5ae0ab","label":"Humidity low","category":"Environment","icon_key":"humidity","prediction_value":"NONE","direction":"low","default_threshold":20,"unit":"%","enabled_by_default":true,"metric_table":"user_weather_daily","metric_column":"humidity_pct_mean","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"34e7ad58-a41d-4132-98ca-e9db6bbaa862","label":"Copper low","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"low","default_threshold":0.3,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_copper_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"34f0631d-de0e-44e6-ab69-c90556958894","label":"Niacin high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":30,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_niacin_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"390f9b20-eb11-4afd-8ebd-8615670302c9","label":"Humidity high","category":"Environment","icon_key":"humidity","prediction_value":"NONE","direction":"high","default_threshold":80,"unit":"%","enabled_by_default":true,"metric_table":"user_weather_daily","metric_column":"humidity_pct_mean","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"3a653f98-b865-42f7-9b8a-017b52a13972","label":"Pressure high","category":"Environment","icon_key":"pressure","prediction_value":"NONE","direction":"high","default_threshold":1030,"unit":"hPa","enabled_by_default":true,"metric_table":"user_weather_daily","metric_column":"pressure_hpa_mean","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"3d90402e-bce7-4060-9052-bf754d6cb9aa","label":"Vitamin C high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":200,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_c_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"3e9968bd-8804-4d3a-9409-7f3d14e2eefd","label":"Body fat low","category":"Body","icon_key":"body_fat","prediction_value":"NONE","direction":"low","default_threshold":8,"unit":"%","enabled_by_default":true,"metric_table":"body_fat_daily","metric_column":"value_pct","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"40af8180-3b87-48d0-9e3b-a30b73fa3948","label":"Biotin high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":100,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_biotin_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"4319d7d9-3c0d-4cb9-b4c0-4454396b250b","label":"Screen time low","category":"Cognitive","icon_key":"screen_time","prediction_value":"NONE","direction":"low","default_threshold":0.5,"unit":"hours","enabled_by_default":true,"metric_table":"screen_time_daily","metric_column":"total_hours","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"4548426b-dd1b-4dd7-9ff6-3dd6c9d6ec12","label":"Carbs low","category":"Diet","icon_key":"carbs","prediction_value":"NONE","direction":"low","default_threshold":100,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_carbs_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"456e30b3-ab50-422d-b2b2-2d206b864e02","label":"Steps low","category":"Body","icon_key":"steps","prediction_value":"NONE","direction":"low","default_threshold":3000,"unit":"count","enabled_by_default":true,"metric_table":"steps_daily","metric_column":"value_count","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"46fe8e09-b595-4107-acbf-6be04b4e381a","label":"Ovulation","category":"Menstrual Cycle","icon_key":"ovulation","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"47c5afa8-2f09-45d5-868d-bcf8db0c53d6","label":"Iron low","category":"Diet","icon_key":"iron","prediction_value":"NONE","direction":"low","default_threshold":5,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_iron_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"47f7ac3c-d7db-4941-ae99-5eeb84d8988d","label":"Blood glucose high","category":"Body","icon_key":"blood_glucose","prediction_value":"NONE","direction":"high","default_threshold":180,"unit":"mg/dL","enabled_by_default":true,"metric_table":"blood_glucose_daily","metric_column":"value_mgdl","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"47ff6444-19c2-4bd0-b738-cf322aac3d59","label":"Phosphorus high","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"high","default_threshold":1500,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_phosphorus_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"4864618e-9d28-4c17-9d22-5a5e86fa0d62","label":"Blood pressure high","category":"Body","icon_key":"bp","prediction_value":"NONE","direction":"high","default_threshold":140,"unit":"mmHg","enabled_by_default":true,"metric_table":"blood_pressure_daily","metric_column":"systolic_mmhg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"4958acbf-cf28-444f-ae7c-426b938cfb34","label":"Bedtime late","category":"Sleep","icon_key":"bedtime","prediction_value":"NONE","direction":"high","default_threshold":1,"unit":"time","enabled_by_default":true,"metric_table":"fell_asleep_time_daily","metric_column":"value_at","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Irregular sleep"},{"id":"4cc55ec6-f0ee-4006-8bb4-0a9c7799d17d","label":"Caffeine low","category":"Diet","icon_key":"caffeine","prediction_value":"NONE","direction":"low","default_threshold":50,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_caffeine_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"500448c1-dfa0-4a5b-967f-3392acf9de83","label":"Fluorescent light","category":"Environment","icon_key":"fluorescent","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"5230f26d-3abe-4af9-99cc-cde1396097ac","label":"Zinc low","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"low","default_threshold":3,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_zinc_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"532030b5-ab52-4d68-b1b4-814fc8d66a04","label":"Calcium high","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"high","default_threshold":1500,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_calcium_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"53bb186e-12da-489e-8a86-b57c5a15424b","label":"Let-down","category":"Cognitive","icon_key":"letdown","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"57b46eb0-09f6-4cd4-b428-c6a4320c379b","label":"Sodium high","category":"Diet","icon_key":"sodium","prediction_value":"NONE","direction":"high","default_threshold":3000,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_sodium_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"58490ebf-690e-4050-9143-40ef3fb24dfe","label":"Cholesterol high","category":"Diet","icon_key":"cholesterol","prediction_value":"NONE","direction":"high","default_threshold":400,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_cholesterol_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"5a34c165-5906-4032-9332-686b547c6c24","label":"Cholesterol low","category":"Diet","icon_key":"cholesterol","prediction_value":"NONE","direction":"low","default_threshold":100,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_cholesterol_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"5a836b07-a828-4577-ba9e-a54cbfa96641","label":"Vitamin C low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":20,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_c_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"5cbbf2c6-e12e-4177-b3b1-d6c91655928d","label":"Vitamin B12 high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":5,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_b12_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"5eea39e6-0ac4-45c8-a78f-a82879a311f1","label":"Folate low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":100,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_folate_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"620b8e80-fe50-43c1-af4c-63803abc8606","label":"Stress","category":"Cognitive","icon_key":"stress","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"6255091a-902e-4702-8a49-79414777ba7d","label":"Computer / screen","category":"Environment","icon_key":"computer","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"62c6d4dc-e72c-40f9-82e1-570637c779f0","label":"Manganese low","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"low","default_threshold":0.5,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_manganese_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"62e5eae7-eb68-47ea-8f91-6eb3edc35ca5","label":"Vitamin B12 low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":0.5,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_b12_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"647a65f0-3c6b-43ac-ab23-ec64399afdaa","label":"Vitamin B6 low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":0.5,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_b6_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"651805c0-9d7f-41b3-891e-ca784ff82771","label":"Potassium high","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"high","default_threshold":5000,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_potassium_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"6548ae42-a280-4cdf-b8ce-190e8608aa17","label":"Sugar low","category":"Diet","icon_key":"sugar","prediction_value":"NONE","direction":"low","default_threshold":10,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_sugar_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"65cb0dab-96fb-4dc5-b7c7-a3b557a7f2c7","label":"Calories low","category":"Diet","icon_key":"calories","prediction_value":"NONE","direction":"low","default_threshold":1200,"unit":"kcal","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_calories","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"6638dbeb-ec5c-4be8-b6c5-e35eb417f094","label":"Menstruation","category":"Menstrual Cycle","icon_key":"menstruation","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"66b3e8c5-f99e-42cc-9b12-f0802d5a91cf","label":"Stress high","category":"Body","icon_key":"strain","prediction_value":"NONE","direction":"high","default_threshold":75,"unit":"","enabled_by_default":true,"metric_table":"stress_index_daily","metric_column":"value","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"68a26929-6b92-45aa-a9c5-69c341be4f76","label":"Tyramine exposure high","category":"Diet","icon_key":"tyramine","prediction_value":"NONE","direction":"high","default_threshold":1,"unit":"","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"max_tyramine_exposure","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"6b7882d2-147e-4180-b5d4-a0ddac625c00","label":"Temperature high","category":"Environment","icon_key":"temperature","prediction_value":"NONE","direction":"high","default_threshold":35,"unit":"°C","enabled_by_default":true,"metric_table":"user_weather_daily","metric_column":"temp_c_mean","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"6c492c5a-0018-4155-9d8e-deaf0ec36361","label":"Vitamin B6 high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":5,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_b6_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"6d0aec24-4239-41d8-b7fd-5ab608cb39a6","label":"Vitamin K low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":20,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_k_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"6f6c5280-c6d4-4842-bbfa-7d8468958dc6","label":"Sleep disturbances low","category":"Sleep","icon_key":"disturbances","prediction_value":"NONE","direction":"low","default_threshold":1,"unit":"count","enabled_by_default":true,"metric_table":"sleep_disturbances_daily","metric_column":"value_count","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Oversleep"},{"id":"6fd9ef3b-8543-4ae6-808c-f2e6dadfda1e","label":"Jet lag","category":"Sleep","icon_key":"jet_lag","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"71136e68-ce9f-43fc-85f9-68da2da6c939","label":"Protein low","category":"Diet","icon_key":"protein","prediction_value":"NONE","direction":"low","default_threshold":30,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_protein_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"722a0fe7-1a47-46d3-902a-5bd28c5f6546","label":"Screen time high","category":"Cognitive","icon_key":"screen_time","prediction_value":"NONE","direction":"high","default_threshold":8,"unit":"hours","enabled_by_default":true,"metric_table":"screen_time_daily","metric_column":"total_hours","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"729d06d9-3076-4ccb-9f78-7a2546eaac31","label":"REM sleep low","category":"Sleep","icon_key":"rem_sleep","prediction_value":"NONE","direction":"low","default_threshold":0.5,"unit":"hours","enabled_by_default":true,"metric_table":"sleep_stages_daily","metric_column":"value_rem_hm","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Poor sleep"},{"id":"76018c31-23aa-4991-9ed6-c4d35af46403","label":"Sleep duration high","category":"Sleep","icon_key":"duration","prediction_value":"NONE","direction":"high","default_threshold":10,"unit":"hours","enabled_by_default":true,"metric_table":"sleep_duration_daily","metric_column":"value_hours","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Oversleep"},{"id":"77d5d11a-6471-4216-8c94-ae71630564a9","label":"Vitamin E low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":3,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_e_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"7a4018eb-4e6a-4259-a018-14218b4d7b49","label":"Light sleep high","category":"Sleep","icon_key":"light_sleep","prediction_value":"NONE","direction":"high","default_threshold":5,"unit":"hours","enabled_by_default":true,"metric_table":"sleep_stages_daily","metric_column":"value_light_hm","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Poor sleep"},{"id":"7a514506-1841-48b7-abd2-0fb1c32d12fc","label":"Magnesium low","category":"Diet","icon_key":"magnesium","prediction_value":"NONE","direction":"low","default_threshold":100,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_magnesium_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"7e8809dc-d035-406d-9ab3-b553c22805a7","label":"Calories high","category":"Diet","icon_key":"calories","prediction_value":"NONE","direction":"high","default_threshold":3000,"unit":"kcal","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_calories","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"7f5918c8-3527-4d1b-8465-73b7e38451bf","label":"Altitude high","category":"Environment","icon_key":"altitude","prediction_value":"NONE","direction":"high","default_threshold":2500,"unit":"m","enabled_by_default":true,"metric_table":"user_location_daily","metric_column":"altitude_max_m","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Altitude high"},{"id":"861bff1f-0afd-46dd-9cb2-ede86e49249d","label":"Trans fat low","category":"Diet","icon_key":"fat","prediction_value":"NONE","direction":"low","default_threshold":0,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_trans_fat_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"872a481e-5740-4028-a3ae-529bb8891d9a","label":"Vitamin A high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":1500,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_a_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"8779edc4-8318-4a1c-9a8b-42fc00e2c63d","label":"High HR zones low","category":"Body","icon_key":"hr_zones","prediction_value":"NONE","direction":"low","default_threshold":5,"unit":"min","enabled_by_default":true,"metric_table":"time_in_high_hr_zones_daily","metric_column":"value_minutes","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"8933ad5d-1d01-42d4-96ad-325245c2fce6","label":"Copper high","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"high","default_threshold":2,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_copper_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"896898ec-9e6b-47ce-8617-04a8955e0060","label":"Deep sleep high","category":"Sleep","icon_key":"deep_sleep","prediction_value":"NONE","direction":"high","default_threshold":3,"unit":"hours","enabled_by_default":true,"metric_table":"sleep_stages_daily","metric_column":"value_sws_hm","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Oversleep"},{"id":"8c8aa08a-42a3-451e-8585-562b5a86c985","label":"Manganese high","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"high","default_threshold":5,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_manganese_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"8da861bb-702d-4beb-8223-7ec98a691f7f","label":"Allergies","category":"Physical","icon_key":"allergies","prediction_value":"NONE","direction":null,"default_threshold":null,"unit":null,"enabled_by_default":false,"metric_table":null,"metric_column":null,"created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":null,"display_group":null},{"id":"904714f0-0a95-4278-b9a7-8849b05f593c","label":"Vitamin K high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":200,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_vitamin_k_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"90c9bb66-9aa3-43a4-b771-68e6c5c84c5c","label":"Recovery high","category":"Body","icon_key":"recovery","prediction_value":"NONE","direction":"high","default_threshold":85,"unit":"%","enabled_by_default":true,"metric_table":"recovery_score_daily","metric_column":"value_pct","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"915d308f-03de-492f-b6fd-f4b773b0e3de","label":"Zinc high","category":"Diet","icon_key":"mineral","prediction_value":"NONE","direction":"high","default_threshold":15,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_zinc_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"92e17ab1-24a9-4bfe-81d2-dec3f7f01aff","label":"Thiamin low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":0.3,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_thiamin_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"934607d2-868b-48d7-ad2f-f13426512338","label":"Altitude low","category":"Environment","icon_key":"altitude","prediction_value":"NONE","direction":"low","default_threshold":0,"unit":"m","enabled_by_default":true,"metric_table":"user_location_daily","metric_column":"altitude_max_m","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":"Altitude low"},{"id":"93dfef9d-54c6-4528-acac-869b336edb32","label":"Biotin low","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"low","default_threshold":10,"unit":"mcg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_biotin_mcg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"975d7449-96c6-4ea9-b55e-3211a4a984df","label":"Recovery low","category":"Body","icon_key":"recovery","prediction_value":"NONE","direction":"low","default_threshold":33,"unit":"%","enabled_by_default":true,"metric_table":"recovery_score_daily","metric_column":"value_pct","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"9b46188f-2fd8-4364-b298-dc33e47c76eb","label":"Late screen time high","category":"Cognitive","icon_key":"late_screen","prediction_value":"NONE","direction":"high","default_threshold":2,"unit":"hours","enabled_by_default":true,"metric_table":"screen_time_late_night","metric_column":"value_hours","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"nightly","display_group":null},{"id":"9bd236cc-8276-4c66-8bfb-0101c4a38a33","label":"Fibre low","category":"Diet","icon_key":"fibre","prediction_value":"NONE","direction":"low","default_threshold":10,"unit":"g","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_fiber_g","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null},{"id":"9bd6fef1-fd2a-48de-a520-7abf00f3ee1f","label":"Pantothenic acid high","category":"Diet","icon_key":"vitamin","prediction_value":"NONE","direction":"high","default_threshold":10,"unit":"mg","enabled_by_default":true,"metric_table":"nutrition_daily","metric_column":"total_pantothenic_acid_mg","created_at":"2026-02-11 21:46:56.060526+00","baseline_days":14,"metric_type":"cumulative","display_group":null}]

title: TyramineClassifierService.kt
text:
package com.migraineme

import android.util.Log
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.util.concurrent.TimeUnit

/**
 * Classifies tyramine exposure risk for a food item.
 * 
 * Calls the classify-tyramine edge function, which:
 * 1. Checks a shared cache table first
 * 2. On miss, calls GPT-4o-mini for classification
 * 3. Caches the result for all future lookups
 * 
 * Returns: "none", "low", "medium", or "high"
 */
class TyramineClassifierService {

    companion object {
        private const val TAG = "TyramineClassifier"
        private const val BASE_URL = BuildConfig.SUPABASE_URL
        private const val ANON_KEY = BuildConfig.SUPABASE_ANON_KEY
    }

    private val httpClient = OkHttpClient.Builder()
        .connectTimeout(15, TimeUnit.SECONDS)
        .readTimeout(15, TimeUnit.SECONDS)
        .build()

    /**
     * Classify tyramine exposure for a food item.
     * 
     * @param accessToken User's Supabase access token (for edge function auth)
     * @param foodName The food name to classify
     * @return Risk level: "none", "low", "medium", or "high"
     */
    fun classify(accessToken: String, foodName: String): String {
        if (foodName.isBlank()) {
            Log.w(TAG, "Empty food name, returning none")
            return "none"
        }

        return try {
            val url = "${BASE_URL.trimEnd('/')}/functions/v1/classify-tyramine"

            val body = JSONObject().apply {
                put("food_name", foodName)
            }

            val request = Request.Builder()
                .url(url)
                .post(body.toString().toRequestBody("application/json".toMediaType()))
                .header("Authorization", "Bearer $accessToken")
                .header("apikey", ANON_KEY)
                .header("Content-Type", "application/json")
                .build()

            httpClient.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    Log.e(TAG, "Edge function failed: ${response.code}")
                    return "none"
                }

                val responseBody = response.body?.string() ?: return "none"
                val json = JSONObject(responseBody)
                val risk = json.optString("risk", "none")
                val cached = json.optBoolean("cached", false)

                Log.d(TAG, "✅ $foodName → $risk (cached=$cached)")
                risk
            }
        } catch (e: Exception) {
            Log.e(TAG, "Classification failed for '$foodName': ${e.message}", e)
            "none" // Fail safe — don't block nutrition sync
        }
    }
}

title: UiKit.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

/** Simple centered top bar made from primitives. */
@Composable
fun SimpleTopBar(title: String) {
    Surface(tonalElevation = 3.dp) {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 16.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(text = title, style = MaterialTheme.typography.titleLarge)
        }
    }
}

@Composable
fun AppFormCard(title: String, content: @Composable ColumnScope.() -> Unit) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        ElevatedCard(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.elevatedCardElevation(defaultElevation = 2.dp)
        ) {
            Column(Modifier.padding(16.dp)) {
                Text(title, style = MaterialTheme.typography.titleMedium)
                Spacer(Modifier.height(12.dp))
                content()
            }
        }
    }
}

/** Public reusable dropdown (index-based) */
@Composable
fun AppDropdown(
    options: List<String>,
    selectedIndex: Int,
    onSelected: (Int) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val label = options.getOrNull(selectedIndex) ?: "None"

    Box {
        OutlinedButton(
            onClick = { expanded = true },
            modifier = Modifier.fillMaxWidth()
        ) { Text(label) }

        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
            options.forEachIndexed { idx, text ->
                DropdownMenuItem(
                    text = { Text(text) },
                    onClick = {
                        onSelected(idx)
                        expanded = false
                    }
                )
            }
        }
    }
}

// DateTimePickerField, AppDateTimePicker, and AppDatePicker
// have been moved to AppDateTimePickers.kt with Material3 purple theming.

title: USDAEnrichmentService.kt
text:
package com.migraineme

import android.util.Log
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import okhttp3.OkHttpClient
import okhttp3.Request
import java.util.concurrent.TimeUnit

/**
 * Service to enrich nutrition data using USDA FoodData Central API
 * 
 * Takes incomplete nutrition data (e.g. from MyFitnessPal via Health Connect)
 * and fills in missing nutrients by searching the USDA database.
 */
class USDAEnrichmentService {

    companion object {
        private const val TAG = "USDAEnrichment"
        private const val API_KEY = BuildConfig.USDA_API_KEY
        private const val BASE_URL = "https://api.nal.usda.gov/fdc/v1"
    }

    private val httpClient = OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .build()

    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }

    /**
     * Enrich nutrition data by searching USDA database
     * 
     * @param nutrition The incomplete nutrition data from Health Connect
     * @return Enriched nutrition data with filled nutrients, or original if enrichment fails
     */
    suspend fun enrichNutrition(nutrition: NutritionData): NutritionData {
        val foodName = nutrition.foodName
        if (foodName.isNullOrBlank()) {
            Log.w(TAG, "No food name provided, cannot enrich")
            return nutrition.copy(enriched = true) // Mark as enriched even though we couldn't
        }

        return try {
            Log.d(TAG, "Searching USDA for: $foodName")
            
            // Search for the food
            val searchResults = searchFood(foodName)
            if (searchResults.foods.isEmpty()) {
                Log.w(TAG, "No USDA results for: $foodName")
                return nutrition.copy(enriched = true)
            }

            // Get the first result (best match)
            val fdcId = searchResults.foods.first().fdcId
            Log.d(TAG, "Found FDC ID: $fdcId")

            // Get detailed nutrient data
            val foodDetails = getFoodDetails(fdcId)
            
            // Merge USDA nutrients with existing data
            val enriched = mergeNutrients(nutrition, foodDetails)
            
            Log.d(TAG, "✅ Successfully enriched: $foodName")
            enriched.copy(enriched = true)
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to enrich $foodName: ${e.message}", e)
            // Return original data marked as enriched (best effort)
            nutrition.copy(enriched = true)
        }
    }

    /**
     * Search USDA database for a food by name
     */
    private fun searchFood(query: String): USDASearchResponse {
        val url = "$BASE_URL/foods/search?api_key=$API_KEY&query=${query.replace(" ", "%20")}&pageSize=1"
        
        val request = Request.Builder()
            .url(url)
            .get()
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                throw Exception("USDA search failed: ${response.code}")
            }
            
            val body = response.body?.string() ?: throw Exception("Empty response")
            return json.decodeFromString(body)
        }
    }

    /**
     * Get detailed nutrient information for a food by FDC ID
     */
    private fun getFoodDetails(fdcId: Int): USDAFoodDetails {
        val url = "$BASE_URL/food/$fdcId?api_key=$API_KEY"
        
        val request = Request.Builder()
            .url(url)
            .get()
            .build()

        httpClient.newCall(request).execute().use { response ->
            if (!response.isSuccessful) {
                throw Exception("USDA details failed: ${response.code}")
            }
            
            val body = response.body?.string() ?: throw Exception("Empty response")
            return json.decodeFromString(body)
        }
    }

    /**
     * Merge USDA nutrients with existing nutrition data
     * Only fills in missing fields, preserves existing data
     */
    private fun mergeNutrients(original: NutritionData, usda: USDAFoodDetails): NutritionData {
        // Create a map of nutrient ID to value from USDA
        val nutrients = usda.foodNutrients.associate { 
            it.nutrient.id to it.amount 
        }

        return original.copy(
            // Only fill in if missing (use original if present)
            calories = original.calories ?: getNutrient(nutrients, 1008),
            
            // Macronutrients
            protein = original.protein ?: getNutrient(nutrients, 1003),
            totalCarbohydrate = original.totalCarbohydrate ?: getNutrient(nutrients, 1005),
            sugar = original.sugar ?: getNutrient(nutrients, 2000),
            dietaryFiber = original.dietaryFiber ?: getNutrient(nutrients, 1079),
            totalFat = original.totalFat ?: getNutrient(nutrients, 1004),
            saturatedFat = original.saturatedFat ?: getNutrient(nutrients, 1258),
            monounsaturatedFat = original.monounsaturatedFat ?: getNutrient(nutrients, 1292),
            polyunsaturatedFat = original.polyunsaturatedFat ?: getNutrient(nutrients, 1293),
            transFat = original.transFat ?: getNutrient(nutrients, 1257),
            cholesterol = original.cholesterol ?: getNutrient(nutrients, 1253),
            
            // Minerals (mg)
            calcium = original.calcium ?: getNutrient(nutrients, 1087),
            iron = original.iron ?: getNutrient(nutrients, 1089),
            magnesium = original.magnesium ?: getNutrient(nutrients, 1090),
            phosphorus = original.phosphorus ?: getNutrient(nutrients, 1091),
            potassium = original.potassium ?: getNutrient(nutrients, 1092),
            sodium = original.sodium ?: getNutrient(nutrients, 1093),
            zinc = original.zinc ?: getNutrient(nutrients, 1095),
            copper = original.copper ?: getNutrient(nutrients, 1098),
            manganese = original.manganese ?: getNutrient(nutrients, 1101),
            selenium = original.selenium ?: getNutrient(nutrients, 1103)?.div(1000), // Convert mcg to mg
            
            // Vitamins
            vitaminA = original.vitaminA ?: getNutrient(nutrients, 1106),
            vitaminC = original.vitaminC ?: getNutrient(nutrients, 1162),
            vitaminD = original.vitaminD ?: getNutrient(nutrients, 1114),
            vitaminE = original.vitaminE ?: getNutrient(nutrients, 1109),
            vitaminK = original.vitaminK ?: getNutrient(nutrients, 1185),
            thiamin = original.thiamin ?: getNutrient(nutrients, 1165),
            riboflavin = original.riboflavin ?: getNutrient(nutrients, 1166),
            niacin = original.niacin ?: getNutrient(nutrients, 1167),
            vitaminB6 = original.vitaminB6 ?: getNutrient(nutrients, 1175),
            folate = original.folate ?: getNutrient(nutrients, 1177),
            vitaminB12 = original.vitaminB12 ?: getNutrient(nutrients, 1178),
            pantothenicAcid = original.pantothenicAcid ?: getNutrient(nutrients, 1170),
            
            // Other
            caffeine = original.caffeine ?: getNutrient(nutrients, 1057)
        )
    }

    /**
     * Helper to safely get a nutrient value by ID
     */
    private fun getNutrient(nutrients: Map<Int, Double>, nutrientId: Int): Double? {
        return nutrients[nutrientId]?.takeIf { it > 0 }
    }

    /**
     * Check if nutrition data needs enrichment
     * Returns true if critical nutrients are missing
     */
    fun needsEnrichment(nutrition: NutritionData): Boolean {
        // If already enriched, skip
        if (nutrition.enriched) return false
        
        // If no food name, can't enrich
        if (nutrition.foodName.isNullOrBlank()) return false
        
        // Check if missing key micronutrients (vitamins/minerals)
        val missingMicronutrients = nutrition.vitaminA == null &&
                nutrition.vitaminC == null &&
                nutrition.calcium == null &&
                nutrition.iron == null
        
        return missingMicronutrients
    }
}

// USDA API Response Models

@Serializable
data class USDASearchResponse(
    val foods: List<USDASearchFood>
)

@Serializable
data class USDASearchFood(
    val fdcId: Int,
    val description: String
)

@Serializable
data class USDAFoodDetails(
    val fdcId: Int,
    val description: String,
    val foodNutrients: List<USDAFoodNutrient>
)

@Serializable
data class USDAFoodNutrient(
    val nutrient: USDANutrient,
    val amount: Double
)

@Serializable
data class USDANutrient(
    val id: Int,
    val name: String,
    val unitName: String
)

title: USDAFoodSearchService.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.time.Instant
import java.util.UUID
import java.util.concurrent.TimeUnit

/**
 * Service for searching USDA FoodData Central and adding foods to nutrition_records
 */
class USDAFoodSearchService(private val context: Context) {

    companion object {
        private const val TAG = "USDAFoodSearch"
        private const val API_KEY = BuildConfig.USDA_API_KEY
        private const val BASE_URL = "https://api.nal.usda.gov/fdc/v1"

        private fun dbl(obj: org.json.JSONObject, key: String): Double? =
            obj.optDouble(key).takeIf { !it.isNaN() }

        fun parseNutritionLogItem(obj: org.json.JSONObject): NutritionLogItem = NutritionLogItem(
            id = obj.getString("id"),
            foodName = obj.optString("food_name", "Unknown"),
            mealType = obj.optString("meal_type", "unknown"),
            calories = dbl(obj, "calories"),
            protein = dbl(obj, "protein"),
            totalCarbohydrate = dbl(obj, "total_carbohydrate"),
            totalFat = dbl(obj, "total_fat"),
            sugar = dbl(obj, "sugar"),
            sodium = dbl(obj, "sodium"),
            caffeine = dbl(obj, "caffeine"),
            dietaryFiber = dbl(obj, "dietary_fiber"),
            cholesterol = dbl(obj, "cholesterol"),
            saturatedFat = dbl(obj, "saturated_fat"),
            unsaturatedFat = dbl(obj, "unsaturated_fat"),
            transFat = dbl(obj, "trans_fat"),
            potassium = dbl(obj, "potassium"),
            calcium = dbl(obj, "calcium"),
            iron = dbl(obj, "iron"),
            magnesium = dbl(obj, "magnesium"),
            zinc = dbl(obj, "zinc"),
            selenium = dbl(obj, "selenium"),
            phosphorus = dbl(obj, "phosphorus"),
            copper = dbl(obj, "copper"),
            manganese = dbl(obj, "manganese"),
            vitaminA = dbl(obj, "vitamin_a"),
            vitaminC = dbl(obj, "vitamin_c"),
            vitaminD = dbl(obj, "vitamin_d"),
            vitaminE = dbl(obj, "vitamin_e"),
            vitaminK = dbl(obj, "vitamin_k"),
            vitaminB6 = dbl(obj, "vitamin_b6"),
            vitaminB12 = dbl(obj, "vitamin_b12"),
            thiamin = dbl(obj, "thiamin"),
            riboflavin = dbl(obj, "riboflavin"),
            niacin = dbl(obj, "niacin"),
            folate = dbl(obj, "folate"),
            biotin = dbl(obj, "biotin"),
            pantothenicAcid = dbl(obj, "pantothenic_acid"),
            tyramineExposure = if (!obj.has("tyramine_exposure") || obj.isNull("tyramine_exposure")) null else obj.optString("tyramine_exposure"),
            alcoholExposure = if (!obj.has("alcohol_exposure") || obj.isNull("alcohol_exposure")) null else obj.optString("alcohol_exposure"),
            glutenExposure = if (!obj.has("gluten_exposure") || obj.isNull("gluten_exposure")) null else obj.optString("gluten_exposure"),
            timestamp = obj.getString("timestamp"),
            source = obj.optString("source", "")
        )
    }

    private val httpClient = OkHttpClient.Builder()
        .connectTimeout(15, TimeUnit.SECONDS)
        .readTimeout(15, TimeUnit.SECONDS)
        .build()

    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }

    /**
     * Search for foods — USDA API primary, local Supabase DB fallback on rate limit.
     */
    suspend fun searchFoods(query: String): List<USDAFoodSearchResult> = withContext(Dispatchers.IO) {
        if (query.isBlank()) return@withContext emptyList()

        val result: List<USDAFoodSearchResult> = try {
            val url = "$BASE_URL/foods/search?api_key=$API_KEY" +
                "&query=${query.replace(" ", "%20")}" +
                "&pageSize=25" +
                "&dataType=Foundation,SR%20Legacy,Survey%20(FNDDS)"

            val request = Request.Builder().url(url).get().build()
            val response = httpClient.newCall(request).execute()

            if (response.code == 429 || response.code == 403) {
                response.close()
                Log.w(TAG, "USDA rate limited (${response.code}), falling back to local DB")
                searchLocalFoods(query)
            } else if (!response.isSuccessful) {
                response.close()
                Log.e(TAG, "USDA search failed: ${response.code}, trying local DB")
                searchLocalFoods(query)
            } else {
                val body = response.body?.string()
                response.close()
                if (body == null) {
                    searchLocalFoods(query)
                } else {
                    val searchResponse = json.decodeFromString<USDASearchResponseFull>(body)
                    if (searchResponse.foods.isEmpty()) {
                        emptyList()
                    } else {
                        val sortedFoods = searchResponse.foods.sortedBy { food ->
                            when (food.dataType) {
                                "Foundation" -> 0; "SR Legacy" -> 1; "Survey (FNDDS)" -> 2; else -> 3
                            }
                        }
                        sortedFoods.take(20).map { food ->
                            USDAFoodSearchResult(
                                fdcId = food.fdcId,
                                description = food.description,
                                brandName = food.brandName,
                                servingSize = food.servingSize,
                                servingSizeUnit = food.servingSizeUnit,
                                calories = food.foodNutrients.find { it.nutrientId == 1008 }?.value
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "USDA search failed: ${e.message}, trying local DB", e)
            searchLocalFoods(query)
        }
        result
    }

    /**
     * Fallback: search local Supabase usda_foods table using RPC.
     */
    private fun searchLocalFoods(query: String): List<USDAFoodSearchResult> {
        try {
            val token = SessionStore.readAccessToken(context) ?: return emptyList()
            val rpcUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/rpc/search_usda_foods"
            val body = org.json.JSONObject().apply {
                put("search_query", query)
                put("result_limit", 20)
            }

            val request = Request.Builder()
                .url(rpcUrl)
                .post(body.toString().toRequestBody("application/json".toMediaType()))
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            val response = httpClient.newCall(request).execute()
            if (!response.isSuccessful) {
                response.close()
                Log.e(TAG, "Local search failed: ${response.code}")
                return emptyList()
            }

            val respBody = response.body?.string()
            response.close()
            if (respBody == null) return emptyList()

            val arr = org.json.JSONArray(respBody)
            val results = mutableListOf<USDAFoodSearchResult>()

            for (i in 0 until arr.length()) {
                val obj = arr.getJSONObject(i)
                results.add(
                    USDAFoodSearchResult(
                        fdcId = obj.getInt("fdc_id"),
                        description = obj.getString("description"),
                        brandName = null,
                        servingSize = if (obj.isNull("serving_size")) null else obj.optDouble("serving_size").takeIf { !it.isNaN() },
                        servingSizeUnit = if (obj.isNull("serving_size_unit")) null else obj.optString("serving_size_unit"),
                        calories = null
                    )
                )
            }

            Log.d(TAG, "Local DB search '$query': ${results.size} results")
            return results
        } catch (e: Exception) {
            Log.e(TAG, "Local search failed: ${e.message}", e)
            return emptyList()
        }
    }

    /**
     * Get full nutrient details — USDA API primary, local DB fallback.
     */
    suspend fun getFoodDetails(fdcId: Int): USDAFoodDetailsFull? = withContext(Dispatchers.IO) {
        val result: USDAFoodDetailsFull? = try {
            val url = "$BASE_URL/food/$fdcId?api_key=$API_KEY"
            val request = Request.Builder().url(url).get().build()
            val response = httpClient.newCall(request).execute()

            if (response.code == 429 || response.code == 403) {
                response.close()
                Log.w(TAG, "USDA rate limited (${response.code}), falling back to local DB")
                getLocalFoodDetails(fdcId)
            } else if (!response.isSuccessful) {
                response.close()
                Log.e(TAG, "USDA details failed: ${response.code}, trying local DB")
                getLocalFoodDetails(fdcId)
            } else {
                val body = response.body?.string()
                response.close()
                if (body == null) {
                    getLocalFoodDetails(fdcId)
                } else {
                    json.decodeFromString<USDAFoodDetailsFull>(body)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "USDA details failed: ${e.message}, trying local DB", e)
            getLocalFoodDetails(fdcId)
        }
        result
    }

    /**
     * Fallback: get nutrients from local Supabase usda_nutrients table.
     */
    private fun getLocalFoodDetails(fdcId: Int): USDAFoodDetailsFull? {
        try {
            val token = SessionStore.readAccessToken(context) ?: return null

            // Get food info
            val foodUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/usda_foods?fdc_id=eq.$fdcId&select=*"
            val foodReq = Request.Builder()
                .url(foodUrl).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            val foodResp = httpClient.newCall(foodReq).execute()
            if (!foodResp.isSuccessful) { foodResp.close(); return null }
            val foodBody = foodResp.body?.string()
            foodResp.close()
            if (foodBody == null) return null
            val foodArr = org.json.JSONArray(foodBody)
            if (foodArr.length() == 0) return null
            val foodObj = foodArr.getJSONObject(0)

            // Get nutrients
            val nutUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/usda_nutrients?fdc_id=eq.$fdcId&select=nutrient_id,amount"
            val nutReq = Request.Builder()
                .url(nutUrl).get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            val nutResp = httpClient.newCall(nutReq).execute()
            if (!nutResp.isSuccessful) { nutResp.close(); return null }
            val nutBody = nutResp.body?.string()
            nutResp.close()
            if (nutBody == null) return null
            val nutArr = org.json.JSONArray(nutBody)

            val nutrients = mutableListOf<USDAFoodNutrientFull>()
            for (i in 0 until nutArr.length()) {
                val n = nutArr.getJSONObject(i)
                nutrients.add(
                    USDAFoodNutrientFull(
                        nutrient = USDANutrientInfo(
                            id = n.getInt("nutrient_id"),
                            name = "",
                            unitName = ""
                        ),
                        amount = n.getDouble("amount")
                    )
                )
            }

            Log.d(TAG, "Local DB details for $fdcId: ${nutrients.size} nutrients")
            return USDAFoodDetailsFull(
                fdcId = fdcId,
                description = foodObj.getString("description"),
                servingSize = if (foodObj.isNull("serving_size")) null else foodObj.optDouble("serving_size").takeIf { !it.isNaN() },
                servingSizeUnit = if (foodObj.isNull("serving_size_unit")) null else foodObj.optString("serving_size_unit"),
                foodNutrients = nutrients
            )
        } catch (e: Exception) {
            Log.e(TAG, "Local details failed for $fdcId: ${e.message}", e)
            return null
        }
    }

    /**
     * Add food to nutrition_records using already-loaded details (no USDA call needed)
     */
    suspend fun addFoodFromDetails(
        foodDetails: USDAFoodDetailsFull,
        foodName: String,
        mealType: String,
        servings: Double = 1.0
    ): Pair<Boolean, String?> = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.readAccessToken(context) ?: run {
                Log.e(TAG, "No access token")
                return@withContext Pair(false, "Not logged in")
            }
            val userId = SessionStore.readUserId(context) ?: run {
                Log.e(TAG, "No user ID")
                return@withContext Pair(false, "No user ID")
            }

            Log.d(TAG, "Adding food: $foodName for user: $userId")

            // Build nutrients map from already-loaded USDA data
            val nutrients = foodDetails.foodNutrients.associate {
                it.nutrient.id to (it.amount ?: 0.0)
            }

            Log.d(TAG, "Found ${nutrients.size} nutrients")

            // Helper to get nutrient value multiplied by servings
            fun getNutrient(id: Int): Double? = nutrients[id]?.takeIf { it > 0 }?.times(servings)

            // Create nutrition record JSON
            val today = java.time.LocalDate.now().toString()
            val nutritionRecord = buildString {
                append("{")
                append("\"id\":\"${UUID.randomUUID()}\",")
                append("\"user_id\":\"$userId\",")
                append("\"date\":\"$today\",")
                append("\"timestamp\":\"${Instant.now()}\",")
                append("\"food_name\":\"${foodName.replace("\"", "\\\"").replace("\n", " ")}\",")
                append("\"meal_type\":\"$mealType\",")
                append("\"source\":\"manual_usda\",")

                // Macros
                getNutrient(1008)?.let { append("\"calories\":$it,") }
                getNutrient(1003)?.let { append("\"protein\":$it,") }
                getNutrient(1005)?.let { append("\"total_carbohydrate\":$it,") }
                getNutrient(1004)?.let { append("\"total_fat\":$it,") }
                getNutrient(1079)?.let { append("\"dietary_fiber\":$it,") }
                getNutrient(2000)?.let { append("\"sugar\":$it,") }
                getNutrient(1258)?.let { append("\"saturated_fat\":$it,") }
                getNutrient(1292)?.let { append("\"monounsaturated_fat\":$it,") }
                getNutrient(1293)?.let { append("\"polyunsaturated_fat\":$it,") }
                getNutrient(1257)?.let { append("\"trans_fat\":$it,") }
                getNutrient(1253)?.let { append("\"cholesterol\":$it,") }

                // Minerals
                getNutrient(1087)?.let { append("\"calcium\":$it,") }
                getNutrient(1089)?.let { append("\"iron\":$it,") }
                getNutrient(1090)?.let { append("\"magnesium\":$it,") }
                getNutrient(1091)?.let { append("\"phosphorus\":$it,") }
                getNutrient(1092)?.let { append("\"potassium\":$it,") }
                getNutrient(1093)?.let { append("\"sodium\":$it,") }
                getNutrient(1095)?.let { append("\"zinc\":$it,") }
                getNutrient(1098)?.let { append("\"copper\":$it,") }
                getNutrient(1101)?.let { append("\"manganese\":$it,") }
                getNutrient(1103)?.let { append("\"selenium\":$it,") }

                // Vitamins
                getNutrient(1106)?.let { append("\"vitamin_a\":$it,") }
                getNutrient(1162)?.let { append("\"vitamin_c\":$it,") }
                getNutrient(1114)?.let { append("\"vitamin_d\":$it,") }
                getNutrient(1109)?.let { append("\"vitamin_e\":$it,") }
                getNutrient(1185)?.let { append("\"vitamin_k\":$it,") }
                getNutrient(1165)?.let { append("\"thiamin\":$it,") }
                getNutrient(1166)?.let { append("\"riboflavin\":$it,") }
                getNutrient(1167)?.let { append("\"niacin\":$it,") }
                getNutrient(1175)?.let { append("\"vitamin_b6\":$it,") }
                getNutrient(1177)?.let { append("\"folate\":$it,") }
                getNutrient(1178)?.let { append("\"vitamin_b12\":$it,") }
                getNutrient(1170)?.let { append("\"pantothenic_acid\":$it,") }
                getNutrient(1176)?.let { append("\"biotin\":$it,") }

                // Caffeine
                getNutrient(1057)?.let { append("\"caffeine\":$it,") }

                // Food risk classification (tyramine, alcohol, gluten)
                try {
                    val risks = FoodRiskClassifierService().classify(token, foodName)
                    if (risks.tyramine != "none") append("\"tyramine_exposure\":\"${risks.tyramine}\",")
                    if (risks.alcohol != "none") append("\"alcohol_exposure\":\"${risks.alcohol}\",")
                    if (risks.gluten != "none") append("\"gluten_exposure\":\"${risks.gluten}\",")
                } catch (_: Exception) {}

                // Remove trailing comma and close
                if (endsWith(",")) deleteCharAt(length - 1)
                append("}")
            }

            Log.d(TAG, "Inserting nutrition record: $nutritionRecord")

            // Insert to Supabase
            val supabaseUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records"

            Log.d(TAG, "Posting to: $supabaseUrl")

            val insertRequest = Request.Builder()
                .url(supabaseUrl)
                .post(nutritionRecord.toRequestBody("application/json".toMediaType()))
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .addHeader("Content-Type", "application/json")
                .addHeader("Prefer", "return=minimal")
                .build()

            httpClient.newCall(insertRequest).execute().use { response ->
                val responseBody = response.body?.string()
                if (response.isSuccessful) {
                    Log.d(TAG, "✅ Food added successfully: $foodName")
                    return@withContext Pair(true, null)
                } else {
                    Log.e(TAG, "Failed to insert: ${response.code} - $responseBody")
                    return@withContext Pair(false, "Error ${response.code}: $responseBody")
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Failed to add food: ${e.message}", e)
            Pair(false, e.message ?: "Unknown error")
        }
    }

    /**
     * Get full nutrient details for a food and add to nutrition_records
     */
    suspend fun addFoodToNutrition(
        fdcId: Int,
        foodName: String,
        mealType: String,
        servings: Double = 1.0
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.readAccessToken(context) ?: return@withContext false
            val userId = SessionStore.readUserId(context) ?: return@withContext false

            // Get detailed nutrient data from USDA
            val url = "$BASE_URL/food/$fdcId?api_key=$API_KEY"

            val request = Request.Builder()
                .url(url)
                .get()
                .build()

            val foodDetails = httpClient.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    Log.e(TAG, "USDA details failed: ${response.code}")
                    return@withContext false
                }

                val body = response.body?.string() ?: return@withContext false
                json.decodeFromString<USDAFoodDetailsFull>(body)
            }

            // Build nutrients map from USDA data
            val nutrients = foodDetails.foodNutrients.associate {
                it.nutrient.id to (it.amount ?: 0.0)
            }

            // Helper to get nutrient value multiplied by servings
            fun getNutrient(id: Int): Double? = nutrients[id]?.takeIf { it > 0 }?.times(servings)

            // Create nutrition record JSON
            val nutritionRecord = buildString {
                append("{")
                append("\"id\":\"${UUID.randomUUID()}\",")
                append("\"user_id\":\"$userId\",")
                append("\"timestamp\":\"${Instant.now()}\",")
                append("\"food_name\":\"${foodName.replace("\"", "\\\"")}\",")
                append("\"meal_type\":\"$mealType\",")
                append("\"source\":\"manual_usda\",")

                // Macros
                getNutrient(1008)?.let { append("\"calories\":$it,") }
                getNutrient(1003)?.let { append("\"protein\":$it,") }
                getNutrient(1005)?.let { append("\"total_carbohydrate\":$it,") }
                getNutrient(1004)?.let { append("\"total_fat\":$it,") }
                getNutrient(1079)?.let { append("\"dietary_fiber\":$it,") }
                getNutrient(2000)?.let { append("\"sugar\":$it,") }
                getNutrient(1258)?.let { append("\"saturated_fat\":$it,") }
                getNutrient(1292)?.let { append("\"monounsaturated_fat\":$it,") }
                getNutrient(1293)?.let { append("\"polyunsaturated_fat\":$it,") }
                getNutrient(1257)?.let { append("\"trans_fat\":$it,") }
                getNutrient(1253)?.let { append("\"cholesterol\":$it,") }

                // Minerals
                getNutrient(1087)?.let { append("\"calcium\":$it,") }
                getNutrient(1089)?.let { append("\"iron\":$it,") }
                getNutrient(1090)?.let { append("\"magnesium\":$it,") }
                getNutrient(1091)?.let { append("\"phosphorus\":$it,") }
                getNutrient(1092)?.let { append("\"potassium\":$it,") }
                getNutrient(1093)?.let { append("\"sodium\":$it,") }
                getNutrient(1095)?.let { append("\"zinc\":$it,") }
                getNutrient(1098)?.let { append("\"copper\":$it,") }
                getNutrient(1101)?.let { append("\"manganese\":$it,") }
                getNutrient(1103)?.let { append("\"selenium\":$it,") }

                // Vitamins
                getNutrient(1106)?.let { append("\"vitamin_a\":$it,") }
                getNutrient(1162)?.let { append("\"vitamin_c\":$it,") }
                getNutrient(1114)?.let { append("\"vitamin_d\":$it,") }
                getNutrient(1109)?.let { append("\"vitamin_e\":$it,") }
                getNutrient(1185)?.let { append("\"vitamin_k\":$it,") }
                getNutrient(1165)?.let { append("\"thiamin\":$it,") }
                getNutrient(1166)?.let { append("\"riboflavin\":$it,") }
                getNutrient(1167)?.let { append("\"niacin\":$it,") }
                getNutrient(1175)?.let { append("\"vitamin_b6\":$it,") }
                getNutrient(1177)?.let { append("\"folate\":$it,") }
                getNutrient(1178)?.let { append("\"vitamin_b12\":$it,") }
                getNutrient(1170)?.let { append("\"pantothenic_acid\":$it,") }
                getNutrient(1176)?.let { append("\"biotin\":$it,") }

                // Caffeine
                getNutrient(1057)?.let { append("\"caffeine\":$it,") }

                // Food risk classification (tyramine, alcohol, gluten)
                try {
                    val risks = FoodRiskClassifierService().classify(token, foodName)
                    if (risks.tyramine != "none") append("\"tyramine_exposure\":\"${risks.tyramine}\",")
                    if (risks.alcohol != "none") append("\"alcohol_exposure\":\"${risks.alcohol}\",")
                    if (risks.gluten != "none") append("\"gluten_exposure\":\"${risks.gluten}\",")
                } catch (_: Exception) {}

                // Remove trailing comma and close
                if (endsWith(",")) deleteCharAt(length - 1)
                append("}")
            }

            Log.d(TAG, "Inserting nutrition record: $nutritionRecord")

            // Upsert to Supabase
            val supabaseUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records"

            val upsertRequest = Request.Builder()
                .url(supabaseUrl)
                .post(nutritionRecord.toRequestBody("application/json".toMediaType()))
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .addHeader("Content-Type", "application/json")
                .addHeader("Prefer", "return=minimal")
                .build()

            httpClient.newCall(upsertRequest).execute().use { response ->
                if (response.isSuccessful) {
                    Log.d(TAG, "✅ Food added successfully: $foodName")
                    return@withContext true
                } else {
                    Log.e(TAG, "Failed to insert: ${response.code} - ${response.body?.string()}")
                    return@withContext false
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Failed to add food: ${e.message}", e)
            false
        }
    }
    /**
     * Get today's nutrition items
     */
    suspend fun getTodayNutritionItems(): List<NutritionLogItem> = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.readAccessToken(context) ?: return@withContext emptyList()
            val userId = SessionStore.readUserId(context) ?: return@withContext emptyList()

            val today = java.time.LocalDate.now().toString()
            val todayStart = "${today}T00:00:00Z"
            val todayEnd = "${today}T23:59:59Z"

            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?" +
                "user_id=eq.$userId&timestamp=gte.$todayStart&timestamp=lte.$todayEnd" +
                "&select=*&order=timestamp.desc"

            val request = Request.Builder()
                .url(url)
                .get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            httpClient.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    Log.e(TAG, "Failed to get today's items: ${response.code}")
                    return@withContext emptyList()
                }

                val body = response.body?.string() ?: return@withContext emptyList()
                val arr = org.json.JSONArray(body)

                val items = mutableListOf<NutritionLogItem>()
                for (i in 0 until arr.length()) {
                    items.add(parseNutritionLogItem(arr.getJSONObject(i)))
                }
                items
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get today's items: ${e.message}", e)
            emptyList()
        }
    }

    /**
     * Get nutrition items for a specific date
     */
    suspend fun getNutritionItemsForDate(date: String): List<NutritionLogItem> = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.readAccessToken(context) ?: return@withContext emptyList()
            val userId = SessionStore.readUserId(context) ?: return@withContext emptyList()

            val dateStart = "${date}T00:00:00Z"
            val dateEnd = "${date}T23:59:59Z"

            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?" +
                "user_id=eq.$userId&timestamp=gte.$dateStart&timestamp=lte.$dateEnd" +
                "&select=*&order=timestamp.desc"

            val request = Request.Builder()
                .url(url)
                .get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            httpClient.newCall(request).execute().use { response ->
                if (!response.isSuccessful) {
                    Log.e(TAG, "Failed to get items for date: ${response.code}")
                    return@withContext emptyList()
                }

                val body = response.body?.string() ?: return@withContext emptyList()
                val arr = org.json.JSONArray(body)

                val items = mutableListOf<NutritionLogItem>()
                for (i in 0 until arr.length()) {
                    items.add(parseNutritionLogItem(arr.getJSONObject(i)))
                }
                items
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get items for date: ${e.message}", e)
            emptyList()
        }
    }

    /**
     * Delete a nutrition item (only manual entries)
     */
    suspend fun deleteNutritionItem(id: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.readAccessToken(context) ?: return@withContext false
            val userId = SessionStore.readUserId(context) ?: return@withContext false

            val url = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?" +
                "id=eq.$id&user_id=eq.$userId&source=eq.manual_usda"

            val request = Request.Builder()
                .url(url)
                .delete()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            httpClient.newCall(request).execute().use { response ->
                if (response.isSuccessful) {
                    Log.d(TAG, "✅ Deleted nutrition item: $id")
                    return@withContext true
                } else {
                    Log.e(TAG, "Failed to delete: ${response.code}")
                    return@withContext false
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to delete item: ${e.message}", e)
            false
        }
    }

    /**
     * Update a nutrition item (only manual entries) - meal type and servings
     * When servings changes, we scale all nutrient values proportionally
     */
    suspend fun updateNutritionItem(
        id: String,
        mealType: String,
        servingsMultiplier: Double? = null // e.g., 2.0 means double all values
    ): Boolean = withContext(Dispatchers.IO) {
        // ... existing code
        try {
            val token = SessionStore.readAccessToken(context) ?: return@withContext false
            val userId = SessionStore.readUserId(context) ?: return@withContext false

            // If just updating meal type
            if (servingsMultiplier == null || servingsMultiplier == 1.0) {
                val updateJson = """{"meal_type":"$mealType"}"""

                val url = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?" +
                    "id=eq.$id&user_id=eq.$userId&source=eq.manual_usda"

                val request = Request.Builder()
                    .url(url)
                    .patch(updateJson.toRequestBody("application/json".toMediaType()))
                    .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    .addHeader("Authorization", "Bearer $token")
                    .addHeader("Content-Type", "application/json")
                    .build()

                httpClient.newCall(request).execute().use { response ->
                    if (response.isSuccessful) {
                        Log.d(TAG, "✅ Updated nutrition item: $id")
                        return@withContext true
                    } else {
                        Log.e(TAG, "Failed to update: ${response.code} - ${response.body?.string()}")
                        return@withContext false
                    }
                }
            } else {
                // Need to fetch current values and scale them
                val getUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?id=eq.$id&user_id=eq.$userId"

                val getRequest = Request.Builder()
                    .url(getUrl)
                    .get()
                    .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    .addHeader("Authorization", "Bearer $token")
                    .build()

                val currentData = httpClient.newCall(getRequest).execute().use { response ->
                    if (!response.isSuccessful) return@withContext false
                    val body = response.body?.string() ?: return@withContext false
                    val arr = org.json.JSONArray(body)
                    if (arr.length() == 0) return@withContext false
                    arr.getJSONObject(0)
                }

                // Build update JSON with scaled values
                val updateJson = buildString {
                    append("{")
                    append("\"meal_type\":\"$mealType\"")

                    // Scale all nutrient columns
                    val nutrientColumns = listOf(
                        "calories", "protein", "total_carbohydrate", "total_fat",
                        "dietary_fiber", "sugar", "saturated_fat", "monounsaturated_fat",
                        "polyunsaturated_fat", "trans_fat", "cholesterol",
                        "calcium", "iron", "magnesium", "phosphorus", "potassium",
                        "sodium", "zinc", "copper", "manganese", "selenium",
                        "vitamin_a", "vitamin_c", "vitamin_d", "vitamin_e", "vitamin_k",
                        "thiamin", "riboflavin", "niacin", "vitamin_b6", "folate",
                        "vitamin_b12", "pantothenic_acid", "biotin", "caffeine"
                    )

                    nutrientColumns.forEach { col ->
                        val currentValue = currentData.optDouble(col, Double.NaN)
                        if (!currentValue.isNaN()) {
                            val newValue = currentValue * servingsMultiplier
                            append(",\"$col\":$newValue")
                        }
                    }

                    append("}")
                }

                val url = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?" +
                    "id=eq.$id&user_id=eq.$userId&source=eq.manual_usda"

                val request = Request.Builder()
                    .url(url)
                    .patch(updateJson.toRequestBody("application/json".toMediaType()))
                    .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    .addHeader("Authorization", "Bearer $token")
                    .addHeader("Content-Type", "application/json")
                    .build()

                httpClient.newCall(request).execute().use { response ->
                    if (response.isSuccessful) {
                        Log.d(TAG, "✅ Updated nutrition item with scaled values: $id")
                        return@withContext true
                    } else {
                        Log.e(TAG, "Failed to update: ${response.code} - ${response.body?.string()}")
                        return@withContext false
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to update item: ${e.message}", e)
            false
        }
    }

    /**
     * Get ALL nutrition history and calculate normalization in memory
     */
    suspend fun getNutritionHistory(days: Int = 14, endDateOverride: java.time.LocalDate? = null): NutritionHistoryResult = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.readAccessToken(context) ?: return@withContext NutritionHistoryResult()
            val userId = SessionStore.readUserId(context) ?: return@withContext NutritionHistoryResult()

            // Get ALL data from nutrition_daily - one query, store everything
            val allDataUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_daily?" +
                "user_id=eq.$userId&order=date.asc"

            val allDataRequest = Request.Builder()
                .url(allDataUrl)
                .get()
                .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                .addHeader("Authorization", "Bearer $token")
                .build()

            val allDays = mutableListOf<NutritionDayData>()

            httpClient.newCall(allDataRequest).execute().use { response ->
                if (response.isSuccessful) {
                    val body = response.body?.string() ?: return@use
                    val arr = org.json.JSONArray(body)

                    for (i in 0 until arr.length()) {
                        val obj = arr.getJSONObject(i)
                        allDays.add(NutritionDayData(
                            date = obj.getString("date"),
                            calories = obj.optDouble("total_calories", 0.0).toInt(),
                            protein = obj.optDouble("total_protein_g", 0.0).toInt(),
                            carbs = obj.optDouble("total_carbs_g", 0.0).toInt(),
                            fat = obj.optDouble("total_fat_g", 0.0).toInt(),
                            fiber = obj.optDouble("total_fiber_g", 0.0).toInt(),
                            sugar = obj.optDouble("total_sugar_g", 0.0).toInt(),
                            sodium = obj.optDouble("total_sodium_mg", 0.0).toInt(),
                            caffeine = obj.optDouble("total_caffeine_mg", 0.0).toInt()
                        ))
                    }
                }
            }

            // Also get today's data from nutrition_records (not yet aggregated)
            val today = java.time.LocalDate.now().toString()
            val hasToday = allDays.any { it.date == today }

            if (!hasToday) {
                val todayUrl = "${BuildConfig.SUPABASE_URL}/rest/v1/nutrition_records?" +
                    "user_id=eq.$userId&date=eq.$today&select=calories,protein,total_carbohydrate,total_fat,dietary_fiber,sugar,sodium,caffeine"

                val todayRequest = Request.Builder()
                    .url(todayUrl)
                    .get()
                    .addHeader("apikey", BuildConfig.SUPABASE_ANON_KEY)
                    .addHeader("Authorization", "Bearer $token")
                    .build()

                httpClient.newCall(todayRequest).execute().use { response ->
                    if (response.isSuccessful) {
                        val body = response.body?.string() ?: return@use
                        val arr = org.json.JSONArray(body)

                        if (arr.length() > 0) {
                            var calories = 0; var protein = 0; var carbs = 0; var fat = 0
                            var fiber = 0; var sugar = 0; var sodium = 0; var caffeine = 0

                            for (i in 0 until arr.length()) {
                                val obj = arr.getJSONObject(i)
                                calories += obj.optDouble("calories", 0.0).toInt()
                                protein += obj.optDouble("protein", 0.0).toInt()
                                carbs += obj.optDouble("total_carbohydrate", 0.0).toInt()
                                fat += obj.optDouble("total_fat", 0.0).toInt()
                                fiber += obj.optDouble("dietary_fiber", 0.0).toInt()
                                sugar += obj.optDouble("sugar", 0.0).toInt()
                                sodium += obj.optDouble("sodium", 0.0).toInt()
                                caffeine += obj.optDouble("caffeine", 0.0).toInt()
                            }

                            allDays.add(NutritionDayData(
                                date = today,
                                calories = calories, protein = protein, carbs = carbs, fat = fat,
                                fiber = fiber, sugar = sugar, sodium = sodium, caffeine = caffeine
                            ))
                        }
                    }
                }
            }

            // Calculate min/max from ALL data
            val allTimeMin = mutableMapOf<String, Float>()
            val allTimeMax = mutableMapOf<String, Float>()

            if (allDays.isNotEmpty()) {
                allTimeMin["calories"] = allDays.minOf { it.calories }.toFloat()
                allTimeMax["calories"] = allDays.maxOf { it.calories }.toFloat()
                allTimeMin["protein"] = allDays.minOf { it.protein }.toFloat()
                allTimeMax["protein"] = allDays.maxOf { it.protein }.toFloat()
                allTimeMin["carbs"] = allDays.minOf { it.carbs }.toFloat()
                allTimeMax["carbs"] = allDays.maxOf { it.carbs }.toFloat()
                allTimeMin["fat"] = allDays.minOf { it.fat }.toFloat()
                allTimeMax["fat"] = allDays.maxOf { it.fat }.toFloat()
                allTimeMin["fiber"] = allDays.minOf { it.fiber }.toFloat()
                allTimeMax["fiber"] = allDays.maxOf { it.fiber }.toFloat()
                allTimeMin["sugar"] = allDays.minOf { it.sugar }.toFloat()
                allTimeMax["sugar"] = allDays.maxOf { it.sugar }.toFloat()
                allTimeMin["sodium"] = allDays.minOf { it.sodium }.toFloat()
                allTimeMax["sodium"] = allDays.maxOf { it.sodium }.toFloat()
                allTimeMin["caffeine"] = allDays.minOf { it.caffeine }.toFloat()
                allTimeMax["caffeine"] = allDays.maxOf { it.caffeine }.toFloat()
            }

            // Ensure min != max
            listOf("calories", "protein", "carbs", "fat", "fiber", "sugar", "sodium", "caffeine").forEach { metric ->
                if (allTimeMin[metric] == null) allTimeMin[metric] = 0f
                if (allTimeMax[metric] == null) allTimeMax[metric] = 1f
                if (allTimeMin[metric] == allTimeMax[metric]) {
                    allTimeMax[metric] = allTimeMin[metric]!! + 1f
                }
            }

            // Get last N days for display
            val endDate = endDateOverride ?: java.time.LocalDate.now()
            val startDate = endDate.minusDays(days.toLong() - 1)

            val displayDays = mutableListOf<NutritionDayData>()
            var currentDate = startDate
            while (!currentDate.isAfter(endDate)) {
                val dateStr = currentDate.toString()
                val dayData = allDays.find { it.date == dateStr } ?: NutritionDayData(date = dateStr)
                displayDays.add(dayData)
                currentDate = currentDate.plusDays(1)
            }

            Log.d(TAG, "Nutrition history: ${allDays.size} total days, ${displayDays.size} display days")
            Log.d(TAG, "Calories min/max: ${allTimeMin["calories"]} - ${allTimeMax["calories"]}")

            NutritionHistoryResult(
                days = displayDays,
                allDays = allDays,
                allTimeMin = allTimeMin,
                allTimeMax = allTimeMax
            )
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get nutrition history: ${e.message}", e)
            NutritionHistoryResult()
        }
    }
}

// Result containing history data and all-time min/max for normalization
data class NutritionHistoryResult(
    val days: List<NutritionDayData> = emptyList(),
    val allDays: List<NutritionDayData> = emptyList(),
    val allTimeMin: Map<String, Float> = emptyMap(),
    val allTimeMax: Map<String, Float> = emptyMap()
)

// Daily nutrition data for graph
data class NutritionDayData(
    val date: String = "",
    val calories: Int = 0,
    val protein: Int = 0,
    val carbs: Int = 0,
    val fat: Int = 0,
    val fiber: Int = 0,
    val sugar: Int = 0,
    val sodium: Int = 0,
    val caffeine: Int = 0
)

// Search result for display
data class USDAFoodSearchResult(
    val fdcId: Int,
    val description: String,
    val brandName: String?,
    val servingSize: Double?,
    val servingSizeUnit: String?,
    val calories: Double?
)

// Logged nutrition item
data class NutritionLogItem(
    val id: String,
    val foodName: String,
    val mealType: String,
    val calories: Double?,
    val protein: Double?,
    val totalCarbohydrate: Double?,
    val totalFat: Double?,
    val sugar: Double?,
    val sodium: Double?,
    val caffeine: Double?,
    val dietaryFiber: Double?,
    val cholesterol: Double?,
    val saturatedFat: Double?,
    val unsaturatedFat: Double?,
    val transFat: Double?,
    val potassium: Double?,
    val calcium: Double?,
    val iron: Double?,
    val magnesium: Double?,
    val zinc: Double?,
    val selenium: Double?,
    val phosphorus: Double?,
    val copper: Double?,
    val manganese: Double?,
    val vitaminA: Double?,
    val vitaminC: Double?,
    val vitaminD: Double?,
    val vitaminE: Double?,
    val vitaminK: Double?,
    val vitaminB6: Double?,
    val vitaminB12: Double?,
    val thiamin: Double?,
    val riboflavin: Double?,
    val niacin: Double?,
    val folate: Double?,
    val biotin: Double?,
    val pantothenicAcid: Double?,
    val tyramineExposure: String?,
    val alcoholExposure: String?,
    val glutenExposure: String?,
    val timestamp: String,
    val source: String
)

// USDA API response models for search
@Serializable
data class USDASearchResponseFull(
    val foods: List<USDASearchFoodFull> = emptyList()
)

@Serializable
data class USDASearchFoodFull(
    val fdcId: Int,
    val description: String,
    val dataType: String? = null,
    val brandName: String? = null,
    val servingSize: Double? = null,
    val servingSizeUnit: String? = null,
    val foodNutrients: List<USDASearchNutrient> = emptyList()
)

@Serializable
data class USDASearchNutrient(
    val nutrientId: Int,
    val value: Double? = null
)

// USDA API response models for food details
@Serializable
data class USDAFoodDetailsFull(
    val fdcId: Int,
    val description: String,
    val servingSize: Double? = null,
    val servingSizeUnit: String? = null,
    val foodNutrients: List<USDAFoodNutrientFull> = emptyList()
)

@Serializable
data class USDAFoodNutrientFull(
    val nutrient: USDANutrientInfo,
    val amount: Double? = null
)

@Serializable
data class USDANutrientInfo(
    val id: Int,
    val name: String,
    val unitName: String = ""
)


fun NutritionLogItem.metricValue(metric: String): Double? = when (metric) {
    MonitorCardConfig.METRIC_CALORIES -> calories
    MonitorCardConfig.METRIC_PROTEIN -> protein
    MonitorCardConfig.METRIC_CARBS -> totalCarbohydrate
    MonitorCardConfig.METRIC_FAT -> totalFat
    MonitorCardConfig.METRIC_SUGAR -> sugar
    MonitorCardConfig.METRIC_SODIUM -> sodium
    MonitorCardConfig.METRIC_CAFFEINE -> caffeine
    MonitorCardConfig.METRIC_FIBER -> dietaryFiber
    MonitorCardConfig.METRIC_CHOLESTEROL -> cholesterol
    MonitorCardConfig.METRIC_SATURATED_FAT -> saturatedFat
    MonitorCardConfig.METRIC_UNSATURATED_FAT -> unsaturatedFat
    MonitorCardConfig.METRIC_TRANS_FAT -> transFat
    MonitorCardConfig.METRIC_POTASSIUM -> potassium
    MonitorCardConfig.METRIC_CALCIUM -> calcium
    MonitorCardConfig.METRIC_IRON -> iron
    MonitorCardConfig.METRIC_MAGNESIUM -> magnesium
    MonitorCardConfig.METRIC_ZINC -> zinc
    MonitorCardConfig.METRIC_SELENIUM -> selenium
    MonitorCardConfig.METRIC_PHOSPHORUS -> phosphorus
    MonitorCardConfig.METRIC_COPPER -> copper
    MonitorCardConfig.METRIC_MANGANESE -> manganese
    MonitorCardConfig.METRIC_VITAMIN_A -> vitaminA
    MonitorCardConfig.METRIC_VITAMIN_C -> vitaminC
    MonitorCardConfig.METRIC_VITAMIN_D -> vitaminD
    MonitorCardConfig.METRIC_VITAMIN_E -> vitaminE
    MonitorCardConfig.METRIC_VITAMIN_K -> vitaminK
    MonitorCardConfig.METRIC_VITAMIN_B6 -> vitaminB6
    MonitorCardConfig.METRIC_VITAMIN_B12 -> vitaminB12
    MonitorCardConfig.METRIC_THIAMIN -> thiamin
    MonitorCardConfig.METRIC_RIBOFLAVIN -> riboflavin
    MonitorCardConfig.METRIC_NIACIN -> niacin
    MonitorCardConfig.METRIC_FOLATE -> folate
    MonitorCardConfig.METRIC_BIOTIN -> biotin
    MonitorCardConfig.METRIC_PANTOTHENIC_ACID -> pantothenicAcid
    MonitorCardConfig.METRIC_TYRAMINE_EXPOSURE -> when (tyramineExposure) {
        "high" -> 3.0; "medium" -> 2.0; "low" -> 1.0; else -> 0.0
    }
    MonitorCardConfig.METRIC_ALCOHOL_EXPOSURE -> when (alcoholExposure) {
        "high" -> 3.0; "medium" -> 2.0; "low" -> 1.0; else -> 0.0
    }
    MonitorCardConfig.METRIC_GLUTEN_EXPOSURE -> when (glutenExposure) {
        "high" -> 3.0; "medium" -> 2.0; "low" -> 1.0; else -> 0.0
    }
    else -> null
}


title: WeatherCardConfig.kt
text:
package com.migraineme

/**
 * Weather metric constants and labels.
 * Mirrors MonitorCardConfig structure for consistency.
 */
object WeatherCardConfig {
    // Metric keys
    const val METRIC_TEMPERATURE = "temp_c_mean"
    const val METRIC_PRESSURE = "pressure_hpa_mean"
    const val METRIC_HUMIDITY = "humidity_pct_mean"
    const val METRIC_WIND_SPEED = "wind_speed_mps_mean"
    const val METRIC_UV_INDEX = "uv_index_max"
    const val METRIC_ALTITUDE = "altitude_m"
    const val METRIC_ALTITUDE_CHANGE = "altitude_change_m"

    // All available weather metrics
    val ALL_WEATHER_METRICS = listOf(
        METRIC_TEMPERATURE,
        METRIC_PRESSURE,
        METRIC_HUMIDITY,
        METRIC_WIND_SPEED,
        METRIC_UV_INDEX,
        METRIC_ALTITUDE,
        METRIC_ALTITUDE_CHANGE
    )

    // Default metrics to display
    val DEFAULT_DISPLAY_METRICS = listOf(
        METRIC_TEMPERATURE,
        METRIC_PRESSURE,
        METRIC_HUMIDITY
    )

    // Human-readable labels
    val WEATHER_METRIC_LABELS = mapOf(
        METRIC_TEMPERATURE to "Temperature",
        METRIC_PRESSURE to "Pressure",
        METRIC_HUMIDITY to "Humidity",
        METRIC_WIND_SPEED to "Wind Speed",
        METRIC_UV_INDEX to "UV Index",
        METRIC_ALTITUDE to "Altitude",
        METRIC_ALTITUDE_CHANGE to "Altitude Change"
    )

    // Units for each metric
    val WEATHER_METRIC_UNITS = mapOf(
        METRIC_TEMPERATURE to "°C",
        METRIC_PRESSURE to "hPa",
        METRIC_HUMIDITY to "%",
        METRIC_WIND_SPEED to "m/s",
        METRIC_UV_INDEX to "",
        METRIC_ALTITUDE to "m",
        METRIC_ALTITUDE_CHANGE to "m"
    )
}

title: WeatherCardConfigStore.kt
text:
package com.migraineme

import android.content.Context

/**
 * SharedPreferences store for weather display configuration.
 * Stores which weather metrics user wants to see on Monitor screen.
 */
data class WeatherCardConfigData(
    val weatherDisplayMetrics: List<String>
)

object WeatherCardConfigStore {
    private const val PREFS_NAME = "weather_card_config"
    private const val KEY_DISPLAY_METRICS = "weather_display_metrics"

    fun load(context: Context): WeatherCardConfigData {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        val metricsStr = prefs.getString(KEY_DISPLAY_METRICS, null)
        val metrics = if (metricsStr.isNullOrBlank()) {
            WeatherCardConfig.DEFAULT_DISPLAY_METRICS
        } else {
            metricsStr.split(",").filter { it.isNotBlank() }
        }

        return WeatherCardConfigData(weatherDisplayMetrics = metrics)
    }

    fun save(context: Context, config: WeatherCardConfigData) {
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit()
            .putString(KEY_DISPLAY_METRICS, config.weatherDisplayMetrics.joinToString(","))
            .apply()
    }
}

title: WeatherComponents.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

/**
 * Row displaying a weather metric with label and value.
 */
@Composable
fun WeatherMetricRow(label: String, value: Double?, unit: String) {
    Row(
        modifier = Modifier.fillMaxWidth().padding(vertical = 2.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(label, color = AppTheme.TitleColor, style = MaterialTheme.typography.bodySmall)
        Text(
            if (value != null && value != 0.0) {
                if (unit == "hPa") String.format("%.0f%s", value, unit)
                else String.format("%.1f%s", value, unit)
            } else "—",
            color = AppTheme.AccentPurple,
            style = MaterialTheme.typography.bodySmall.copy(fontWeight = FontWeight.Medium)
        )
    }
}

/**
 * Today's weather summary card content.
 */
@Composable
fun TodayWeatherSummary(
    weather: WeatherDayData?,
    displayMetrics: List<String>
) {
    if (weather == null) {
        Text(
            "No weather data for today",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.bodySmall
        )
        return
    }

    Column {
        // Weather condition
        val condition = weatherCodeToCondition(weather.weatherCode)
        Text(
            condition,
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
        )

        if (weather.isThunderstormDay) {
            Text(
                "⚡ Thunderstorm detected",
                color = Color(0xFFFFB74D),
                style = MaterialTheme.typography.bodySmall
            )
        }

        // Display selected metrics
        displayMetrics.forEach { metric ->
            val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
            val unit = WeatherCardConfig.WEATHER_METRIC_UNITS[metric] ?: ""
            val value = getWeatherValue(weather, metric)
            WeatherMetricRow(label, value, unit)
        }
    }
}

/**
 * Helper to get value from WeatherDayData by metric key.
 */
private fun getWeatherValue(day: WeatherDayData, metric: String): Double? {
    return when (metric) {
        WeatherCardConfig.METRIC_TEMPERATURE -> day.tempMean
        WeatherCardConfig.METRIC_PRESSURE -> day.pressureMean
        WeatherCardConfig.METRIC_HUMIDITY -> day.humidityMean
        WeatherCardConfig.METRIC_WIND_SPEED -> day.windSpeedMean
        WeatherCardConfig.METRIC_UV_INDEX -> day.uvIndexMax
        else -> null
    }
}

/**
 * Convert WMO weather code to human-readable condition.
 */
private fun weatherCodeToCondition(code: Int): String {
    return when (code) {
        0 -> "Clear sky"
        1 -> "Mainly clear"
        2 -> "Partly cloudy"
        3 -> "Overcast"
        45, 48 -> "Foggy"
        51, 53, 55 -> "Drizzle"
        56, 57 -> "Freezing drizzle"
        61, 63, 65 -> "Rain"
        66, 67 -> "Freezing rain"
        71, 73, 75 -> "Snow"
        77 -> "Snow grains"
        80, 81, 82 -> "Rain showers"
        85, 86 -> "Snow showers"
        95 -> "Thunderstorm"
        96, 99 -> "Thunderstorm with hail"
        else -> "Unknown"
    }
}

title: WeatherConfigScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.PhoneAndroid
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

@OptIn(ExperimentalLayoutApi::class, ExperimentalMaterial3Api::class)
@Composable
fun WeatherConfigScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    val initialConfig = remember { WeatherCardConfigStore.load(context) }
    var selectedMetrics by remember { mutableStateOf(initialConfig.weatherDisplayMetrics.toSet()) }

    // Check if any weather metric is enabled in data settings
    var anyWeatherEnabled by remember { mutableStateOf(true) } // default true until loaded
    var settingsLoaded by remember { mutableStateOf(false) }

    val weatherTables = setOf(
        "temperature_daily", "pressure_daily", "humidity_daily",
        "wind_daily", "uv_daily", "thunderstorm_daily"
    )

    LaunchedEffect(Unit) {
        scope.launch {
            try {
                val edge = EdgeFunctionsService()
                val settings = edge.getMetricSettings(context)
                val map = settings.associateBy { it.metric }
                // Only hide if there are settings and ALL weather metrics are explicitly disabled
                val hasAnySettings = weatherTables.any { map.containsKey(it) }
                anyWeatherEnabled = !hasAnySettings || weatherTables.any { map[it]?.enabled != false }
            } catch (_: Exception) { }
            settingsLoaded = true
        }
    }

    fun saveConfig() {
        WeatherCardConfigStore.save(
            context,
            WeatherCardConfigData(weatherDisplayMetrics = selectedMetrics.toList())
        )
    }

    ScrollFadeContainer(scrollState = scrollState) { scroll ->
        ScrollableScreenContent(scrollState = scroll) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Start
            ) {
                IconButton(onClick = {
                    saveConfig()
                    onBack()
                }) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        tint = Color.White
                    )
                }
            }

            HeroCard {
                Text(
                    text = "Customize Environment",
                    color = AppTheme.TitleColor,
                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = "Choose which environment metrics to display on the Monitor screen.",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall
                )
            }

            if (settingsLoaded && !anyWeatherEnabled) {
                BaseCard {
                    Text(
                        text = "No environment source enabled",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    Spacer(Modifier.height(4.dp))
                    Text(
                        text = "Enable environment tracking in Data Settings to customize metrics.",
                        color = AppTheme.SubtleTextColor.copy(alpha = 0.7f),
                        style = MaterialTheme.typography.labelSmall
                    )
                }
            } else {
                BaseCard {
                    Text(
                        text = "Display Metrics (${selectedMetrics.size}/3)",
                        color = AppTheme.TitleColor,
                        style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
                    )
                    Spacer(Modifier.height(4.dp))
                    Text(
                        text = "Select up to 3 environment metrics to show on the Monitor card.",
                        color = AppTheme.SubtleTextColor,
                        style = MaterialTheme.typography.bodySmall
                    )
                    Spacer(Modifier.height(12.dp))

                    FlowRow(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        val slotColors = listOf(Color(0xFFFFB74D), Color(0xFF4FC3F7), Color(0xFF81C784))
                        for (metric in WeatherCardConfig.ALL_WEATHER_METRICS) {
                            val isSelected = metric in selectedMetrics
                            val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                            val canSelect = isSelected || selectedMetrics.size < 3
                            val slotIndex = if (isSelected) selectedMetrics.toList().indexOf(metric) else -1
                            val slotColor = if (slotIndex in slotColors.indices) slotColors[slotIndex] else AppTheme.AccentPurple

                            FilterChip(
                                selected = isSelected,
                                onClick = {
                                    selectedMetrics = if (isSelected) {
                                        selectedMetrics.minus(metric)
                                    } else if (selectedMetrics.size < 3) {
                                        selectedMetrics.plus(metric)
                                    } else {
                                        selectedMetrics
                                    }
                                    saveConfig()
                                },
                                enabled = true,
                                label = {
                                    Text(
                                        text = label,
                                        style = MaterialTheme.typography.labelSmall
                                    )
                                },
                                leadingIcon = if (isSelected) {
                                    {
                                        Icon(
                                            Icons.Default.Check,
                                            contentDescription = null,
                                            modifier = Modifier.size(18.dp)
                                        )
                                    }
                                } else null,
                                trailingIcon = {
                                    Icon(
                                        Icons.Default.PhoneAndroid,
                                        contentDescription = "Phone",
                                        modifier = Modifier.size(14.dp),
                                        tint = if (isSelected) slotColor else AppTheme.SubtleTextColor
                                    )
                                },
                                colors = FilterChipDefaults.filterChipColors(
                                    selectedContainerColor = slotColor.copy(alpha = 0.3f),
                                    selectedLabelColor = AppTheme.TitleColor,
                                    selectedLeadingIconColor = slotColor,
                                    containerColor = AppTheme.BaseCardContainer,
                                    labelColor = AppTheme.BodyTextColor
                                ),
                                border = FilterChipDefaults.filterChipBorder(
                                    borderColor = AppTheme.SubtleTextColor.copy(alpha = 0.5f),
                                    selectedBorderColor = slotColor,
                                    enabled = true,
                                    selected = isSelected
                                )
                            )
                        }
                    }

                    Spacer(Modifier.height(12.dp))
                    Row(horizontalArrangement = Arrangement.spacedBy(4.dp)) {
                        Icon(Icons.Default.PhoneAndroid, contentDescription = null, modifier = Modifier.size(14.dp), tint = AppTheme.SubtleTextColor)
                        Text(text = "Phone (API)", color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }
                }
            }
        }
    }
}

title: WeatherGraph.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.FilterChip
import androidx.compose.material3.FilterChipDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.time.format.DateTimeFormatter

// Metric colors
private val metricColors = mapOf(
    WeatherCardConfig.METRIC_TEMPERATURE to Color(0xFFFF7043),
    WeatherCardConfig.METRIC_PRESSURE to Color(0xFF42A5F5),
    WeatherCardConfig.METRIC_HUMIDITY to Color(0xFF26C6DA),
    WeatherCardConfig.METRIC_WIND_SPEED to Color(0xFF66BB6A),
    WeatherCardConfig.METRIC_UV_INDEX to Color(0xFFFFCA28),
    WeatherCardConfig.METRIC_ALTITUDE to Color(0xFFCE93D8),
    WeatherCardConfig.METRIC_ALTITUDE_CHANGE to Color(0xFFBA68C8)
)

// Get metric value from day data
private fun getDayValue(day: WeatherDayData, metric: String): Float {
    return when (metric) {
        WeatherCardConfig.METRIC_TEMPERATURE -> day.tempMean.toFloat()
        WeatherCardConfig.METRIC_PRESSURE -> day.pressureMean.toFloat()
        WeatherCardConfig.METRIC_HUMIDITY -> day.humidityMean.toFloat()
        WeatherCardConfig.METRIC_WIND_SPEED -> day.windSpeedMean.toFloat()
        WeatherCardConfig.METRIC_UV_INDEX -> day.uvIndexMax.toFloat()
        WeatherCardConfig.METRIC_ALTITUDE -> (day.altitudeMaxM ?: 0.0).toFloat()
        WeatherCardConfig.METRIC_ALTITUDE_CHANGE -> (day.altitudeChangeM ?: 0.0).toFloat()
        else -> 0f
    }
}

// Check if day has data (at least one metric is non-zero)
private fun hasData(day: WeatherDayData): Boolean {
    return day.tempMean != 0.0 || day.pressureMean != 0.0 || day.humidityMean != 0.0
}

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun WeatherHistoryGraph(
    days: Int = 14,
    endDate: java.time.LocalDate = java.time.LocalDate.now(),
    forecastStartDate: String? = null,
    onClick: (() -> Unit)? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    val weatherService = remember { WeatherHistoryService(context) }

    var historyData by remember { mutableStateOf<List<WeatherDayData>>(emptyList()) }
    var allTimeMin by remember { mutableStateOf<Map<String, Float>>(emptyMap()) }
    var allTimeMax by remember { mutableStateOf<Map<String, Float>>(emptyMap()) }
    var isLoading by remember { mutableStateOf(true) }
    var selectedMetrics by remember { mutableStateOf(setOf(WeatherCardConfig.METRIC_TEMPERATURE)) }
    var migraineDates by remember { mutableStateOf<Set<String>>(emptySet()) }

    // Load history data
    LaunchedEffect(days, endDate) {
        scope.launch {
            val result = weatherService.getWeatherHistory(days, endDate)
            historyData = result.days
            allTimeMin = result.allTimeMin
            allTimeMax = result.allTimeMax
            migraineDates = MigraineOverlayHelper.fetchMigraineDates(context, days, endDate)
            isLoading = false
        }
    }

    val isNormalized = selectedMetrics.size >= 2
    val daysWithData = historyData.filter { hasData(it) }

    val title = if (forecastStartDate != null) "History + Forecast" else "$days-Day History"

    BaseCard(modifier = if (onClick != null) Modifier.clickable { onClick() } else Modifier) {
        Text(
            title,
            color = AppTheme.TitleColor,
            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold)
        )

        Spacer(Modifier.height(8.dp))

        if (isLoading) {
            Row(
                modifier = Modifier.fillMaxWidth().height(150.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(Modifier.size(24.dp), AppTheme.AccentPurple, strokeWidth = 2.dp)
            }
        } else if (historyData.isEmpty()) {
            Text(
                "No data available",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else if (selectedMetrics.isEmpty()) {
            Text(
                "Select a metric below",
                color = AppTheme.SubtleTextColor,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.fillMaxWidth().height(150.dp).padding(vertical = 60.dp),
                textAlign = TextAlign.Center
            )
        } else {
            // Legend
            FlowRow(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                selectedMetrics.forEach { metric ->
                    val color = metricColors[metric] ?: AppTheme.AccentPurple
                    val label = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric
                    val unit = WeatherCardConfig.WEATHER_METRIC_UNITS[metric] ?: ""
                    val values = daysWithData.map { getDayValue(it, metric) }

                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Canvas(Modifier.size(8.dp)) { drawCircle(color) }
                        Spacer(Modifier.width(4.dp))
                        if (isNormalized) {
                            val minVal = allTimeMin[metric] ?: 0f
                            val maxVal = allTimeMax[metric] ?: 1f
                            Text("$label [${formatValue(minVal, unit)}-${formatValue(maxVal, unit)}]", color = color, style = MaterialTheme.typography.labelSmall)
                        } else {
                            val avg = if (values.isNotEmpty()) values.average().toFloat() else 0f
                            Text("$label (avg: ${formatValue(avg, unit)})", color = color, style = MaterialTheme.typography.labelSmall)
                        }
                    }
                }
            }

            val avgLabel = if (forecastStartDate != null) "Dotted = history average" else "Dotted line = $days-day average"
            if (isNormalized) {
                Spacer(Modifier.height(4.dp))
                Text("⚠️ Normalized 0-1 scale • $avgLabel", color = Color(0xFFFFB74D), style = MaterialTheme.typography.labelSmall)
            } else if (daysWithData.isNotEmpty()) {
                Spacer(Modifier.height(4.dp))
                Text(avgLabel, color = AppTheme.SubtleTextColor.copy(alpha = 0.7f), style = MaterialTheme.typography.labelSmall)
            }

            if (migraineDates.isNotEmpty()) {
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Canvas(Modifier.size(8.dp)) { drawRect(Color(0xFFE57373).copy(alpha = 0.35f)) }
                    Spacer(Modifier.width(4.dp))
                    Text("Red bands = migraine days", color = Color(0xFFE57373), style = MaterialTheme.typography.labelSmall)
                }
            }

            if (forecastStartDate != null) {
                Spacer(Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Canvas(Modifier.size(8.dp)) { drawRect(Color(0xFF4FC3F7).copy(alpha = 0.15f)) }
                    Spacer(Modifier.width(4.dp))
                    Text("Blue zone = forecast", color = Color(0xFF4FC3F7), style = MaterialTheme.typography.labelSmall)
                }
            }

            Spacer(Modifier.height(8.dp))

            if (daysWithData.isEmpty()) {
                Text(
                    "No logged days in this period",
                    color = AppTheme.SubtleTextColor,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(vertical = 16.dp)
                )
            } else {
                val yAxisWidth = 50.dp

                // Y-axis values depend on normalization
                val yTop: String
                val yMid: String
                val yBot: String

                if (isNormalized) {
                    yTop = "1.0"
                    yMid = "0.5"
                    yBot = "0.0"
                } else {
                    val metric = selectedMetrics.first()
                    val unit = WeatherCardConfig.WEATHER_METRIC_UNITS[metric] ?: ""
                    val values = daysWithData.map { getDayValue(it, metric) }
                    val max = values.maxOrNull() ?: 1f
                    val min = values.minOrNull() ?: 0f
                    yTop = formatValue(max, unit)
                    yMid = formatValue((max + min) / 2, unit)
                    yBot = formatValue(min, unit)
                }

                Row(modifier = Modifier.fillMaxWidth().height(150.dp)) {
                    // Y-axis labels
                    Column(
                        modifier = Modifier.width(yAxisWidth).fillMaxHeight(),
                        verticalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(yTop, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(yMid, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                        Text(yBot, color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    }

                    // Graph canvas
                    Canvas(modifier = Modifier.weight(1f).fillMaxHeight()) {
                        val padding = 8.dp.toPx()
                        val graphWidth = size.width - padding * 2
                        val graphHeight = size.height - padding * 2
                        val dashWidth = 6.dp.toPx()
                        val gapWidth = 4.dp.toPx()

                        // Draw migraine bands (behind everything)
                        with(MigraineOverlayHelper) {
                            drawMigraineBands(
                                dateList = historyData.map { it.date },
                                migraineDates = migraineDates,
                                padding = padding,
                                graphWidth = graphWidth,
                                graphHeight = graphHeight
                            )
                        }

                        // Draw forecast divider line
                        if (forecastStartDate != null && historyData.isNotEmpty()) {
                            val forecastIdx = historyData.indexOfFirst { it.date >= forecastStartDate }
                            if (forecastIdx > 0) {
                                // Position between the last history day and first forecast day
                                val divX = padding + ((forecastIdx - 0.5f) / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                // Dashed vertical line
                                var yPos = padding
                                while (yPos < padding + graphHeight) {
                                    drawLine(
                                        Color.White.copy(alpha = 0.4f),
                                        Offset(divX, yPos),
                                        Offset(divX, (yPos + dashWidth).coerceAtMost(padding + graphHeight)),
                                        strokeWidth = 1.5.dp.toPx()
                                    )
                                    yPos += dashWidth + gapWidth
                                }
                                // "Forecast →" label background
                                drawRect(
                                    Color(0xFF4FC3F7).copy(alpha = 0.08f),
                                    topLeft = Offset(divX, padding),
                                    size = androidx.compose.ui.geometry.Size(size.width - padding - divX, graphHeight)
                                )
                            }
                        }

                        selectedMetrics.forEach { metric ->
                            val color = metricColors[metric] ?: Color.White

                            // Get indexed values for X positioning
                            val indexedValues = historyData.mapIndexedNotNull { i, day ->
                                if (hasData(day)) i to getDayValue(day, metric) else null
                            }

                            if (indexedValues.isEmpty()) return@forEach

                            val values = indexedValues.map { it.second }

                            // For single metric: use window min/max (actual values)
                            // For multi metric: use all-time min/max (normalized)
                            val minVal: Float
                            val maxVal: Float
                            if (isNormalized) {
                                minVal = allTimeMin[metric] ?: 0f
                                maxVal = (allTimeMax[metric] ?: 1f).coerceAtLeast(minVal + 0.1f)
                            } else {
                                minVal = values.minOrNull() ?: 0f
                                maxVal = (values.maxOrNull() ?: 1f).coerceAtLeast(minVal + 0.1f)
                            }
                            val range = maxVal - minVal

                            // Normalize values to 0-1 scale for plotting
                            val plotPoints = indexedValues.map { (idx, value) ->
                                idx to ((value - minVal) / range).coerceIn(0f, 1f)
                            }

                            // Draw dotted average line (always show)
                            // When forecast is shown, only average history points (not forecast)
                            if (plotPoints.isNotEmpty()) {
                                val avgPoints = if (forecastStartDate != null) {
                                    val forecastIdx = historyData.indexOfFirst { it.date >= forecastStartDate }
                                    if (forecastIdx > 0) plotPoints.filter { it.first < forecastIdx }
                                    else plotPoints
                                } else plotPoints
                                val avgNormalized = (if (avgPoints.isNotEmpty()) avgPoints else plotPoints).map { it.second }.average().toFloat()
                                val avgY = padding + graphHeight - (avgNormalized * graphHeight)

                                var x = padding
                                while (x < size.width - padding) {
                                    drawLine(
                                        color.copy(alpha = 0.5f),
                                        Offset(x, avgY),
                                        Offset((x + dashWidth).coerceAtMost(size.width - padding), avgY),
                                        strokeWidth = 1.5.dp.toPx()
                                    )
                                    x += dashWidth + gapWidth
                                }
                            }

                            // Draw line
                            if (plotPoints.size > 1) {
                                val path = Path()
                                plotPoints.forEachIndexed { i, (dayIdx, normalizedValue) ->
                                    val x = padding + (dayIdx.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                    val y = padding + graphHeight - (normalizedValue * graphHeight)
                                    if (i == 0) path.moveTo(x, y) else path.lineTo(x, y)
                                }
                                drawPath(path, color, style = Stroke(2.dp.toPx(), cap = StrokeCap.Round, join = StrokeJoin.Round))
                            }

                            // Draw dots
                            plotPoints.forEach { (dayIdx, normalizedValue) ->
                                val x = padding + (dayIdx.toFloat() / (historyData.size - 1).coerceAtLeast(1)) * graphWidth
                                val y = padding + graphHeight - (normalizedValue * graphHeight)
                                drawCircle(color, 4.dp.toPx(), Offset(x, y))
                            }
                        }
                    }
                }

                // Date labels
                Spacer(Modifier.height(4.dp))
                Row(
                    modifier = Modifier.fillMaxWidth().padding(start = yAxisWidth),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    val fmt = DateTimeFormatter.ofPattern("MMM d")
                    Text(LocalDate.parse(historyData.first().date).format(fmt), color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                    Text(LocalDate.parse(historyData.last().date).format(fmt), color = AppTheme.SubtleTextColor, style = MaterialTheme.typography.labelSmall)
                }
            }
        }

        Spacer(Modifier.height(12.dp))

        // Metric selector - multi-select
        Text(
            "Select Metrics${if (selectedMetrics.size > 1) " (${selectedMetrics.size} selected)" else ""}",
            color = AppTheme.SubtleTextColor,
            style = MaterialTheme.typography.labelMedium
        )
        Spacer(Modifier.height(8.dp))

        FlowRow(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(6.dp),
            verticalArrangement = Arrangement.spacedBy(6.dp)
        ) {
            WeatherCardConfig.ALL_WEATHER_METRICS.forEach { metric ->
                val isSelected = metric in selectedMetrics
                val chipColor = metricColors[metric] ?: AppTheme.AccentPurple
                val chipLabel = WeatherCardConfig.WEATHER_METRIC_LABELS[metric] ?: metric

                FilterChip(
                    selected = isSelected,
                    onClick = {
                        selectedMetrics = if (isSelected) {
                            selectedMetrics - metric
                        } else {
                            selectedMetrics + metric
                        }
                    },
                    label = { Text(chipLabel, style = MaterialTheme.typography.labelSmall) },
                    colors = FilterChipDefaults.filterChipColors(
                        selectedContainerColor = chipColor.copy(alpha = 0.3f),
                        selectedLabelColor = chipColor,
                        containerColor = AppTheme.BaseCardContainer,
                        labelColor = AppTheme.SubtleTextColor
                    ),
                    border = FilterChipDefaults.filterChipBorder(
                        borderColor = if (isSelected) chipColor else AppTheme.SubtleTextColor.copy(alpha = 0.3f),
                        selectedBorderColor = chipColor,
                        enabled = true,
                        selected = isSelected
                    )
                )
            }
        }
    }
}

private fun formatValue(value: Float, unit: String): String {
    return when (unit) {
        "hPa" -> "${value.toInt()}$unit"
        "%" -> "${value.toInt()}$unit"
        else -> String.format("%.1f%s", value, unit)
    }
}



title: WeatherHistoryService.kt
text:
package com.migraineme

import android.content.Context
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.LocalDate

/**
 * Data class representing a single day's weather data.
 */
data class WeatherDayData(
    val date: String,
    val tempMean: Double,
    val pressureMean: Double,
    val humidityMean: Double,
    val windSpeedMean: Double,
    val uvIndexMax: Double,
    val weatherCode: Int,
    val isThunderstormDay: Boolean,
    val altitudeMaxM: Double? = null,
    val altitudeChangeM: Double? = null
)

/**
 * Result from getWeatherHistory() containing days + all-time min/max for normalization.
 */
data class WeatherHistoryResult(
    val days: List<WeatherDayData>,
    val allTimeMin: Map<String, Float>,
    val allTimeMax: Map<String, Float>
)

/**
 * Service for fetching weather history from user_weather_daily table.
 */
class WeatherHistoryService(context: Context) {
    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }
    }

    private val appContext = context.applicationContext

    @Serializable
    private data class WeatherRow(
        val date: String? = null,
        @SerialName("temp_c_mean") val tempMean: Double? = null,
        @SerialName("pressure_hpa_mean") val pressureMean: Double? = null,
        @SerialName("humidity_pct_mean") val humidityMean: Double? = null,
        @SerialName("wind_speed_mps_mean") val windSpeedMean: Double? = null,
        @SerialName("uv_index_max") val uvIndexMax: Double? = null,
        @SerialName("weather_code") val weatherCode: Int? = null,
        @SerialName("is_thunderstorm_day") val isThunderstormDay: Boolean? = null
    )

    @Serializable
    private data class LocationAltitudeRow(
        val date: String? = null,
        val altitude_max_m: Double? = null,
        val altitude_change_m: Double? = null
    )

    /**
     * Fetches weather history for the last N days.
     * Also calculates all-time min/max for normalization.
     */
    suspend fun getWeatherHistory(days: Int): WeatherHistoryResult = getWeatherHistory(days, LocalDate.now())

    /**
     * Fetches weather history for the given window.
     * endDate is the last date to include; startDate = endDate - days + 1.
     */
    suspend fun getWeatherHistory(days: Int, endDate: LocalDate): WeatherHistoryResult = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.getValidAccessToken(appContext)
                ?: return@withContext WeatherHistoryResult(emptyList(), emptyMap(), emptyMap())

            val userId = SessionStore.readUserId(appContext)
                ?: return@withContext WeatherHistoryResult(emptyList(), emptyMap(), emptyMap())

            val startDate = endDate.minusDays(days.toLong() - 1)

            // Fetch data for the requested window
            val response = client.get("$supabaseUrl/rest/v1/user_weather_daily") {
                header(HttpHeaders.Authorization, "Bearer $token")
                header("apikey", supabaseKey)
                parameter("user_id", "eq.$userId")
                parameter("date", "gte.${startDate}")
                parameter("date", "lte.${endDate}")
                parameter("select", "date,temp_c_mean,pressure_hpa_mean,humidity_pct_mean,wind_speed_mps_mean,uv_index_max,weather_code,is_thunderstorm_day")
                parameter("order", "date.asc")
            }

            if (!response.status.isSuccess()) {
                return@withContext WeatherHistoryResult(emptyList(), emptyMap(), emptyMap())
            }

            val rows: List<WeatherRow> = response.body()

            // Fetch altitude for the same date range
            val altitudeMap = fetchAltitudeMap(token, userId, startDate, endDate)

            // Fetch ALL data for all-time min/max calculation
            val allResponse = client.get("$supabaseUrl/rest/v1/user_weather_daily") {
                header(HttpHeaders.Authorization, "Bearer $token")
                header("apikey", supabaseKey)
                parameter("user_id", "eq.$userId")
                parameter("select", "temp_c_mean,pressure_hpa_mean,humidity_pct_mean,wind_speed_mps_mean,uv_index_max")
                parameter("order", "date.asc")
            }

            val allRows: List<WeatherRow> = if (allResponse.status.isSuccess()) {
                allResponse.body()
            } else {
                rows
            }

            // Fetch all-time altitude for min/max
            val allAltResponse = client.get("$supabaseUrl/rest/v1/user_location_daily") {
                header(HttpHeaders.Authorization, "Bearer $token")
                header("apikey", supabaseKey)
                parameter("user_id", "eq.$userId")
                parameter("select", "altitude_max_m,altitude_change_m")
                parameter("altitude_max_m", "not.is.null")
                parameter("order", "date.asc")
            }
            val allAltRows: List<LocationAltitudeRow> = if (allAltResponse.status.isSuccess()) {
                runCatching { allAltResponse.body<List<LocationAltitudeRow>>() }.getOrDefault(emptyList())
            } else emptyList()

            // Calculate all-time min/max
            val allTimeMin = mutableMapOf<String, Float>()
            val allTimeMax = mutableMapOf<String, Float>()

            val tempValues = allRows.mapNotNull { it.tempMean?.toFloat() }
            val pressureValues = allRows.mapNotNull { it.pressureMean?.toFloat() }
            val humidityValues = allRows.mapNotNull { it.humidityMean?.toFloat() }
            val windValues = allRows.mapNotNull { it.windSpeedMean?.toFloat() }
            val uvValues = allRows.mapNotNull { it.uvIndexMax?.toFloat() }
            val altMaxValues = allAltRows.mapNotNull { it.altitude_max_m?.toFloat() }
            val altChangeValues = allAltRows.mapNotNull { it.altitude_change_m?.toFloat() }

            if (tempValues.isNotEmpty()) {
                allTimeMin["temp_c_mean"] = tempValues.minOrNull() ?: 0f
                allTimeMax["temp_c_mean"] = tempValues.maxOrNull() ?: 1f
            }
            if (pressureValues.isNotEmpty()) {
                allTimeMin["pressure_hpa_mean"] = pressureValues.minOrNull() ?: 0f
                allTimeMax["pressure_hpa_mean"] = pressureValues.maxOrNull() ?: 1f
            }
            if (humidityValues.isNotEmpty()) {
                allTimeMin["humidity_pct_mean"] = humidityValues.minOrNull() ?: 0f
                allTimeMax["humidity_pct_mean"] = humidityValues.maxOrNull() ?: 1f
            }
            if (windValues.isNotEmpty()) {
                allTimeMin["wind_speed_mps_mean"] = windValues.minOrNull() ?: 0f
                allTimeMax["wind_speed_mps_mean"] = windValues.maxOrNull() ?: 1f
            }
            if (uvValues.isNotEmpty()) {
                allTimeMin["uv_index_max"] = uvValues.minOrNull() ?: 0f
                allTimeMax["uv_index_max"] = uvValues.maxOrNull() ?: 1f
            }
            if (altMaxValues.isNotEmpty()) {
                allTimeMin["altitude_m"] = altMaxValues.minOrNull() ?: 0f
                allTimeMax["altitude_m"] = altMaxValues.maxOrNull() ?: 1f
            }
            if (altChangeValues.isNotEmpty()) {
                allTimeMin["altitude_change_m"] = altChangeValues.minOrNull() ?: 0f
                allTimeMax["altitude_change_m"] = altChangeValues.maxOrNull() ?: 1f
            }

            // Convert to WeatherDayData (filter out rows without date)
            val dayData = rows.filter { it.date != null }.map { row ->
                WeatherDayData(
                    date = row.date!!,
                    tempMean = row.tempMean ?: 0.0,
                    pressureMean = row.pressureMean ?: 0.0,
                    humidityMean = row.humidityMean ?: 0.0,
                    windSpeedMean = row.windSpeedMean ?: 0.0,
                    uvIndexMax = row.uvIndexMax ?: 0.0,
                    weatherCode = row.weatherCode ?: 0,
                    isThunderstormDay = row.isThunderstormDay ?: false,
                    altitudeMaxM = altitudeMap[row.date]?.maxM,
                    altitudeChangeM = altitudeMap[row.date]?.changeM
                )
            }

            WeatherHistoryResult(
                days = dayData,
                allTimeMin = allTimeMin,
                allTimeMax = allTimeMax
            )
        } catch (e: Exception) {
            android.util.Log.e("WeatherHistoryService", "Error fetching weather history", e)
            WeatherHistoryResult(emptyList(), emptyMap(), emptyMap())
        }
    }

    /**
     * Get today's weather summary including altitude.
     */
    suspend fun getTodayWeather(): WeatherDayData? = withContext(Dispatchers.IO) {
        try {
            val token = SessionStore.getValidAccessToken(appContext) ?: return@withContext null
            val userId = SessionStore.readUserId(appContext) ?: return@withContext null
            val today = LocalDate.now().toString()

            val response = client.get("$supabaseUrl/rest/v1/user_weather_daily") {
                header(HttpHeaders.Authorization, "Bearer $token")
                header("apikey", supabaseKey)
                parameter("user_id", "eq.$userId")
                parameter("date", "eq.$today")
                parameter("select", "date,temp_c_mean,pressure_hpa_mean,humidity_pct_mean,wind_speed_mps_mean,uv_index_max,weather_code,is_thunderstorm_day")
                parameter("limit", "1")
            }

            if (!response.status.isSuccess()) return@withContext null

            val rows: List<WeatherRow> = response.body()
            val row = rows.firstOrNull() ?: return@withContext null
            if (row.date == null) return@withContext null

            // Fetch today's altitude
            val altAgg = fetchAltitudeForDate(token, userId, today)

            WeatherDayData(
                date = row.date,
                tempMean = row.tempMean ?: 0.0,
                pressureMean = row.pressureMean ?: 0.0,
                humidityMean = row.humidityMean ?: 0.0,
                windSpeedMean = row.windSpeedMean ?: 0.0,
                uvIndexMax = row.uvIndexMax ?: 0.0,
                weatherCode = row.weatherCode ?: 0,
                isThunderstormDay = row.isThunderstormDay ?: false,
                altitudeMaxM = altAgg?.maxM,
                altitudeChangeM = altAgg?.changeM
            )
        } catch (e: Exception) {
            android.util.Log.e("WeatherHistoryService", "Error fetching today's weather", e)
            null
        }
    }

    private data class AltitudeAggData(val maxM: Double?, val changeM: Double?)

    /**
     * Fetch altitude aggregation for a date range from user_location_daily.
     */
    private suspend fun fetchAltitudeMap(
        token: String,
        userId: String,
        startDate: LocalDate,
        endDate: LocalDate
    ): Map<String, AltitudeAggData> {
        return try {
            val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
                header(HttpHeaders.Authorization, "Bearer $token")
                header("apikey", supabaseKey)
                parameter("user_id", "eq.$userId")
                parameter("date", "gte.$startDate")
                parameter("date", "lte.$endDate")
                parameter("select", "date,altitude_max_m,altitude_change_m")
                parameter("order", "date.asc")
            }
            if (!resp.status.isSuccess()) return emptyMap()
            val rows: List<LocationAltitudeRow> = resp.body()
            rows.filter { it.date != null }
                .associate { it.date!! to AltitudeAggData(it.altitude_max_m, it.altitude_change_m) }
        } catch (_: Exception) {
            emptyMap()
        }
    }

    /**
     * Fetch altitude for a single date.
     */
    private suspend fun fetchAltitudeForDate(
        token: String,
        userId: String,
        date: String
    ): AltitudeAggData? {
        return try {
            val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
                header(HttpHeaders.Authorization, "Bearer $token")
                header("apikey", supabaseKey)
                parameter("user_id", "eq.$userId")
                parameter("date", "eq.$date")
                parameter("select", "altitude_max_m,altitude_change_m")
                parameter("limit", "1")
            }
            if (!resp.status.isSuccess()) return null
            val rows: List<LocationAltitudeRow> = resp.body()
            val row = rows.firstOrNull() ?: return null
            AltitudeAggData(row.altitude_max_m, row.altitude_change_m)
        } catch (_: Exception) {
            null
        }
    }
}

title: WhoopAuthService.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.util.Base64
import android.util.Log
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.net.URLEncoder
import java.security.MessageDigest
import java.security.SecureRandom
import kotlin.math.max

class WhoopAuthService {

    companion object {
        private const val TAG = "WHOOP"

        private const val CLIENT_ID = "354e4d44-3780-4e99-a655-a306776879ee"
        private const val CLIENT_SECRET =
            "ce7314f4cdfab97a16467747a174a0ba8f1a8c561bc1dcc149674171ccd85d00"

        private const val REDIRECT_URI = "whoop://migraineme/callback"

        private const val AUTH_URL = "https://api.prod.whoop.com/oauth/oauth2/auth"
        private const val TOKEN_URL = "https://api.prod.whoop.com/oauth/oauth2/token"
        private const val REVOKE_URL = "https://api.prod.whoop.com/developer/v2/user/access"

        private const val PREFS = "whoop_oauth"
        private const val KEY_STATE = "state"
        private const val KEY_VERIFIER = "code_verifier"
        private const val KEY_LAST_URI = "last_uri"
        private const val KEY_TOKEN_ERROR = "token_error"

        private const val EXPIRY_SKEW_MS = 60_000L

        private const val SCOPE =
            "offline read:recovery read:sleep read:workout read:cycles read:body_measurement read:profile"
    }

    fun startAuth(activity: Activity) {
        val uri = buildAuthUri(activity.applicationContext)
        Log.e(TAG, "Opening WHOOP auth URL: $uri")
        val intent = Intent(Intent.ACTION_VIEW, uri).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        activity.startActivity(intent)
    }

    fun buildAuthUri(context: Context): Uri {
        val appCtx = context.applicationContext
        val prefs = appCtx.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

        val state = randomUrlSafe(24)
        val verifier = randomUrlSafe(64)
        val challenge = pkceChallengeS256(verifier)

        prefs.edit()
            .putString(KEY_STATE, state)
            .putString(KEY_VERIFIER, verifier)
            .putString(KEY_TOKEN_ERROR, "")
            .apply()

        return Uri.parse(AUTH_URL).buildUpon()
            .appendQueryParameter("response_type", "code")
            .appendQueryParameter("client_id", CLIENT_ID)
            .appendQueryParameter("redirect_uri", REDIRECT_URI)
            .appendQueryParameter("scope", SCOPE.replace("+", " "))
            .appendQueryParameter("state", state)
            .appendQueryParameter("code_challenge", challenge)
            .appendQueryParameter("code_challenge_method", "S256")
            .build()
    }

    fun completeAuth(context: Context): Boolean {
        val appCtx = context.applicationContext
        val prefs = appCtx.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

        val last = prefs.getString(KEY_LAST_URI, null)
        if (last.isNullOrBlank()) return false

        val uri = Uri.parse(last)

        val error = uri.getQueryParameter("error")
        if (!error.isNullOrBlank()) {
            prefs.edit().putString(KEY_TOKEN_ERROR, error).apply()
            return false
        }

        val code = uri.getQueryParameter("code")
        if (code.isNullOrBlank()) {
            prefs.edit().putString(KEY_TOKEN_ERROR, "Missing authorization code").apply()
            return false
        }

        val returnedState = uri.getQueryParameter("state").orEmpty()
        val expectedState = prefs.getString(KEY_STATE, "").orEmpty()
        val verifier = prefs.getString(KEY_VERIFIER, "").orEmpty()

        if (expectedState.isBlank() || verifier.isBlank()) {
            prefs.edit().putString(KEY_TOKEN_ERROR, "Missing PKCE state/verifier. Reconnect WHOOP.").apply()
            return false
        }
        if (returnedState != expectedState) {
            prefs.edit().putString(KEY_TOKEN_ERROR, "State mismatch. Reconnect WHOOP.").apply()
            return false
        }

        val res = postForm(
            TOKEN_URL,
            mapOf(
                "grant_type" to "authorization_code",
                "client_id" to CLIENT_ID,
                "client_secret" to CLIENT_SECRET,
                "redirect_uri" to REDIRECT_URI,
                "code" to code,
                "code_verifier" to verifier
            )
        )

        return if (res.isSuccess) {
            val tok = res.getOrThrow()

            val currentUserId = SessionStore.readUserId(appCtx)
            if (currentUserId.isNullOrBlank()) {
                val access = SessionStore.readAccessToken(appCtx)
                if (!access.isNullOrBlank()) {
                    val derived = JwtUtils.extractUserIdFromAccessToken(access)
                    if (!derived.isNullOrBlank()) {
                        SessionStore.saveUserId(appCtx, derived)
                    }
                }
            }

            val store = WhoopTokenStore(appCtx)
            val existing = store.load()

            val merged = when {
                tok.refreshToken.isNotBlank() -> tok
                existing?.refreshToken?.isNotBlank() == true -> tok.copy(refreshToken = existing.refreshToken)
                else -> {
                    prefs.edit().putString(
                        KEY_TOKEN_ERROR,
                        "WHOOP did not return refresh_token. Reconnect and ensure offline scope is granted."
                    ).apply()
                    return false
                }
            }

            store.save(merged)

            prefs.edit()
                .remove(KEY_STATE)
                .remove(KEY_VERIFIER)
                .remove(KEY_LAST_URI)
                .putString(KEY_TOKEN_ERROR, "")
                .apply()

            WhoopTokenUploadWorker.enqueueNow(appCtx)
            true
        } else {
            prefs.edit().putString(KEY_TOKEN_ERROR, res.exceptionOrNull()?.message ?: "WHOOP authentication failed").apply()
            false
        }
    }

    /**
     * Server (sync-worker) handles all WHOOP token refreshes.
     * App must never refresh locally to avoid racing with the server
     * and burning the refresh token.
     */
    fun refresh(context: Context): Boolean {
        return true
    }

    /**
     * Server handles all WHOOP token refreshes.
     * Just return whatever we have locally.
     */
    suspend fun refreshIfNeeded(context: Context): WhoopToken? {
        return WhoopTokenStore(context.applicationContext).load()
    }

    suspend fun revokeAccessWithDebug(context: Context): Pair<Boolean, String> {
        val appCtx = context.applicationContext
        val tok = refreshIfNeeded(appCtx)

        if (tok == null || tok.accessToken.isBlank()) {
            return false to "No local WHOOP access token available to revoke."
        }

        val conn = (URL(REVOKE_URL).openConnection() as HttpURLConnection).apply {
            requestMethod = "DELETE"
            setRequestProperty("Authorization", "${tok.tokenType} ${tok.accessToken}")
            setRequestProperty("Accept", "application/json")
        }

        return try {
            val code = conn.responseCode
            val stream = if (code in 200..299) conn.inputStream else conn.errorStream
            val body = stream?.use { s ->
                BufferedReader(InputStreamReader(s)).readText()
            }.orEmpty()

            val ok = (code == 204) || (code in 200..299)
            if (!ok) {
                Log.w(TAG, "WHOOP revoke failed HTTP $code: $body")
            }

            ok to "HTTP $code${if (body.isNotBlank()) ": $body" else ""}"
        } catch (t: Throwable) {
            Log.w(TAG, "WHOOP revoke exception: ${t.message}", t)
            false to "Exception: ${t.javaClass.simpleName}: ${t.message ?: "unknown"}"
        } finally {
            runCatching { conn.disconnect() }
        }
    }

    suspend fun disconnectWithDebug(context: Context): Pair<Boolean, String> {
        val appCtx = context.applicationContext

        val (revoked, debug) = runCatching { revokeAccessWithDebug(appCtx) }
            .getOrElse { false to "Exception: ${it.javaClass.simpleName}: ${it.message ?: "unknown"}" }

        runCatching { WhoopTokenStore(appCtx).clear() }
        runCatching {
            appCtx.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
                .edit().clear().apply()
        }

        return revoked to debug
    }

    private fun postForm(url: String, form: Map<String, String>): Result<WhoopToken> {
        val body = form.entries.joinToString("&") { (k, v) ->
            "${URLEncoder.encode(k, "UTF-8")}=${URLEncoder.encode(v, "UTF-8")}"
        }

        val conn = (URL(url).openConnection() as HttpURLConnection).apply {
            requestMethod = "POST"
            doOutput = true
            setRequestProperty("Content-Type", "application/x-www-form-urlencoded")
            setRequestProperty("Accept", "application/json")
        }

        return try {
            conn.outputStream.use { os ->
                os.write(body.toByteArray(Charsets.UTF_8))
            }

            val code = conn.responseCode
            val stream = if (code in 200..299) conn.inputStream else conn.errorStream
            val text = stream?.use { s ->
                BufferedReader(InputStreamReader(s)).readText()
            }.orEmpty()

            if (code !in 200..299) {
                Log.e(TAG, "token endpoint error $code: $text")
                val msg = runCatching {
                    val jo = JSONObject(text)
                    val err = jo.optString("error")
                    val desc = jo.optString("error_description")
                    if (err.isNotBlank()) "$err: $desc" else text
                }.getOrDefault(text)
                Result.failure(IllegalStateException(msg))
            } else {
                val jo = JSONObject(text)
                Result.success(WhoopToken.fromTokenResponse(jo))
            }
        } catch (t: Throwable) {
            Result.failure(t)
        } finally {
            runCatching { conn.disconnect() }
        }
    }

    private fun pkceChallengeS256(verifier: String): String {
        val md = MessageDigest.getInstance("SHA-256")
        val digest = md.digest(verifier.toByteArray(Charsets.UTF_8))
        return Base64.encodeToString(digest, Base64.URL_SAFE or Base64.NO_WRAP or Base64.NO_PADDING)
    }

    private fun randomUrlSafe(lenBytes: Int): String {
        val b = ByteArray(max(16, lenBytes))
        SecureRandom().nextBytes(b)
        return Base64.encodeToString(b, Base64.URL_SAFE or Base64.NO_WRAP or Base64.NO_PADDING)
            .take(lenBytes * 2)
    }
}

data class WhoopToken(
    val accessToken: String,
    val refreshToken: String,
    val tokenType: String = "Bearer",
    val expiresAtMillis: Long = 0L
) {
    fun isExpiredSoon(skewMs: Long = 60_000L): Boolean {
        if (expiresAtMillis <= 0L) return false
        return System.currentTimeMillis() + skewMs >= expiresAtMillis
    }

    companion object {
        fun fromTokenResponse(jo: JSONObject): WhoopToken {
            val access = jo.optString("access_token", "")
            val refresh = jo.optString("refresh_token", "")
            val type = jo.optString("token_type", "Bearer")

            val nowMs = System.currentTimeMillis()

            val expiresInSecRaw = jo.optLong("expires_in", 0L)
            val expiresInSec = if (expiresInSecRaw > 0L) expiresInSecRaw else 3600L
            val expiresAt = nowMs + expiresInSec * 1000L

            return WhoopToken(
                accessToken = access,
                refreshToken = refresh,
                tokenType = type,
                expiresAtMillis = expiresAt
            )
        }
    }
}

title: WhoopLateDataReminderWorker.kt
text:
package com.migraineme

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.ZonedDateTime
import java.util.concurrent.TimeUnit

/**
 * Single daily "late cutoff" reminder:
 * - Runs at 11:00 local time
 * - Checks whether today's WHOOP sleep + recovery exist in Supabase
 * - If still missing, posts ONE notification (no repeats)
 *
 * This worker does NOT call WHOOP. It only checks Supabase (cheap).
 */
class WhoopLateDataReminderWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        val ctx = applicationContext
        try {
            val access = SessionStore.getValidAccessToken(ctx) ?: return Result.success()

            val whoopConnected = runCatching { WhoopTokenStore(ctx).load() != null }.getOrDefault(false)
            if (!whoopConnected) return Result.success()

            val zone = ZoneId.systemDefault()
            val todaySql = LocalDate.now(zone).toString()

            val sleepLoaded = runCatching { SupabaseMetricsService(ctx).hasSleepForDate(access, todaySql, "whoop") }
                .getOrDefault(false)

            val recoveryLoaded = runCatching { SupabasePhysicalHealthService(ctx).hasRecoveryForDate(access, todaySql, "whoop") }
                .getOrDefault(false)

            if (!(sleepLoaded && recoveryLoaded)) {
                postNotification(ctx)
            }

            return Result.success()
        } finally {
            // Always schedule the next run, even if today failed.
            scheduleNext(ctx)
        }
    }

    private fun postNotification(context: Context) {
        val channelId = CHANNEL_ID

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            val ch = NotificationChannel(
                channelId,
                "MigraineMe data reminders",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            nm.createNotificationChannel(ch)
        }

        val notif = NotificationCompat.Builder(context, channelId)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentTitle("Whoop data still missing")
            .setContentText("We haven’t received today’s Whoop data yet. Open MigraineMe to retry.")
            .setAutoCancel(true)
            .build()

        NotificationManagerCompat.from(context).notify(NOTIF_ID, notif)
    }

    companion object {
        private const val UNIQUE = "whoop_late_data_reminder_11am"
        private const val CHANNEL_ID = "migraineme_data_reminders"
        private const val NOTIF_ID = 91011

        fun scheduleNext(context: Context) {
            val zone = ZoneId.systemDefault()
            val now = ZonedDateTime.now(zone)
            val targetTime = LocalTime.of(11, 0)

            var target = now.withHour(targetTime.hour).withMinute(targetTime.minute).withSecond(0).withNano(0)
            if (!target.isAfter(now)) {
                target = target.plusDays(1)
            }

            val delayMs = java.time.Duration.between(now, target).toMillis().coerceAtLeast(0)

            val req = OneTimeWorkRequestBuilder<WhoopLateDataReminderWorker>()
                .setInitialDelay(delayMs, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE,
                ExistingWorkPolicy.REPLACE,
                req
            )
        }
    }
}

title: WhoopSyncLogStore.kt
text:
package com.migraineme

import android.content.Context
import org.json.JSONObject
import java.time.Instant

/**
 * Rolling log + per-table daily sync outcomes for WHOOP.
 *
 * Rolling log:
 * - append(), get(), clear() operate on a single text blob (capped)
 *
 * Per-table outcomes (NEW):
 * - Stored per day ("YYYY-MM-DD") as JSON in SharedPreferences
 * - Allows UI to distinguish: couldn't fetch vs no data vs stored, per table
 */
class WhoopSyncLogStore(context: Context) {
    private val app = context.applicationContext
    private val prefs = app.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

    // -------------------------
    // Rolling log (existing)
    // -------------------------

    fun append(line: String) {
        val ts = Instant.now().toString()
        val entry = "$ts | $line\n"
        val cur = prefs.getString(KEY_LOG, "") ?: ""
        var out = cur + entry
        if (out.length > MAX_CHARS) {
            out = out.substring(out.length - MAX_CHARS)
            val idx = out.indexOf('\n')
            if (idx >= 0) out = out.substring(idx + 1)
        }
        prefs.edit().putString(KEY_LOG, out).apply()
    }

    fun get(): String? = prefs.getString(KEY_LOG, null)

    /**
     * Clears ONLY the rolling log. Outcomes are kept.
     */
    fun clear() {
        prefs.edit().remove(KEY_LOG).apply()
    }

    // -------------------------
    // Per-table outcomes (NEW)
    // -------------------------

    enum class TableOutcomeType {
        FETCH_OK_STORED,
        FETCH_OK_NO_DATA,
        FETCH_FAILED
    }

    data class TableOutcome(
        val type: TableOutcomeType,
        val atIso: String,
        val note: String?
    )

    /**
     * Record an outcome for a specific table + date.
     *
     * date: "YYYY-MM-DD"
     * table: e.g. "spo2_daily"
     */
    fun setOutcome(
        date: String,
        table: String,
        type: TableOutcomeType,
        note: String? = null
    ) {
        val key = outcomesKey(date)
        val root = loadOutcomesJson(date)

        val entry = JSONObject()
            .put("type", type.name)
            .put("at", Instant.now().toString())

        if (!note.isNullOrBlank()) entry.put("note", note)

        root.put(table, entry)
        prefs.edit().putString(key, root.toString()).apply()
    }

    /**
     * Read outcome for one table on a given date.
     * Returns null if we never recorded an attempt (NOT_TRIED is implicit).
     */
    fun getOutcome(date: String, table: String): TableOutcome? {
        val root = loadOutcomesJson(date)
        if (!root.has(table)) return null

        val entry = root.optJSONObject(table) ?: return null
        val typeStr = entry.optString("type", "")
        val atIso = entry.optString("at", "")
        val note = entry.optString("note", null)

        val type = runCatching { TableOutcomeType.valueOf(typeStr) }.getOrNull() ?: return null
        if (atIso.isBlank()) return null

        return TableOutcome(type = type, atIso = atIso, note = note)
    }

    /**
     * Get all recorded outcomes for a date.
     * Tables never attempted won't appear in the map.
     */
    fun getOutcomesForDate(date: String): Map<String, TableOutcome> {
        val root = loadOutcomesJson(date)
        val out = mutableMapOf<String, TableOutcome>()

        val keys = root.keys()
        while (keys.hasNext()) {
            val table = keys.next()
            val entry = root.optJSONObject(table) ?: continue

            val typeStr = entry.optString("type", "")
            val atIso = entry.optString("at", "")
            val note = entry.optString("note", null)

            val type = runCatching { TableOutcomeType.valueOf(typeStr) }.getOrNull() ?: continue
            if (atIso.isBlank()) continue

            out[table] = TableOutcome(type = type, atIso = atIso, note = note)
        }

        return out
    }

    fun clearOutcomesForDate(date: String) {
        prefs.edit().remove(outcomesKey(date)).apply()
    }

    fun clearAllOutcomes() {
        val editor = prefs.edit()
        for (k in prefs.all.keys) {
            if (k.startsWith(KEY_OUTCOMES_PREFIX)) editor.remove(k)
        }
        editor.apply()
    }

    private fun outcomesKey(date: String): String = "$KEY_OUTCOMES_PREFIX$date"

    private fun loadOutcomesJson(date: String): JSONObject {
        val raw = prefs.getString(outcomesKey(date), null) ?: return JSONObject()
        return runCatching { JSONObject(raw) }.getOrElse { JSONObject() }
    }

    companion object {
        private const val PREFS = "whoop_sync_log_prefs"
        private const val KEY_LOG = "log"
        private const val MAX_CHARS = 8000
        private const val KEY_OUTCOMES_PREFIX = "outcomes_"
    }
}

title: WhoopTokenStore.kt
text:
// FILE: app/src/main/java/com/migraineme/WhoopTokenStore.kt
package com.migraineme

import android.content.Context

/**
 * Stores WHOOP tokens privately.
 *
 * Tokens are bound to the currently logged-in Supabase userId.
 * - On save(): record owner_user_id
 * - On load(): only return tokens if owner_user_id matches current SessionStore userId
 *   Otherwise clear and return null
 */
class WhoopTokenStore(private val context: Context) {
    private val app = context.applicationContext
    private val prefs = app.getSharedPreferences("whoop_tokens", Context.MODE_PRIVATE)

    private companion object {
        private const val KEY_OWNER_USER_ID = "owner_user_id"
        private const val KEY_ACCESS = "access_token"
        private const val KEY_REFRESH = "refresh_token"
        private const val KEY_TYPE = "token_type"
        private const val KEY_EXPIRES = "expires_at"
    }

    fun save(t: WhoopToken) {
        val currentUserId = SessionStore.readUserId(app).orEmpty()

        prefs.edit()
            .putString(KEY_OWNER_USER_ID, currentUserId)
            .putString(KEY_ACCESS, t.accessToken)
            .putString(KEY_REFRESH, t.refreshToken)
            .putString(KEY_TYPE, t.tokenType)
            .putLong(KEY_EXPIRES, t.expiresAtMillis)
            .apply()
    }

    fun load(): WhoopToken? {
        val currentUserId = SessionStore.readUserId(app).orEmpty()
        val ownerUserId = prefs.getString(KEY_OWNER_USER_ID, "") ?: ""

        if (currentUserId.isBlank()) return null

        if (ownerUserId.isNotBlank() && ownerUserId != currentUserId) {
            clear()
            return null
        }

        val access = prefs.getString(KEY_ACCESS, null) ?: return null
        val refresh = prefs.getString(KEY_REFRESH, "") ?: ""
        val type = prefs.getString(KEY_TYPE, "Bearer") ?: "Bearer"
        val exp = prefs.getLong(KEY_EXPIRES, 0L)

        return WhoopToken(
            accessToken = access,
            refreshToken = refresh,
            tokenType = type,
            expiresAtMillis = exp
        )
    }

    fun clear() {
        prefs.edit().clear().apply()
    }
}

title: WhoopTokenUploadWorker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.BackoffPolicy
import androidx.work.Constraints
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import java.util.concurrent.TimeUnit

class WhoopTokenUploadWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result {
        val ctx = applicationContext

        val supaAccessToken = SessionStore.getValidAccessToken(ctx)
            ?.takeIf { it.isNotBlank() }
            ?: return Result.retry()

        val existingUserId = SessionStore.readUserId(ctx)
        if (existingUserId.isNullOrBlank()) {
            val derived = JwtUtils.extractUserIdFromAccessToken(supaAccessToken)
            if (!derived.isNullOrBlank()) {
                SessionStore.saveUserId(ctx, derived)
            }
        }

        val whoopToken = runCatching { WhoopTokenStore(ctx).load() }.getOrNull()
            ?: return Result.success()

        val edge = EdgeFunctionsService()

        val uploaded = runCatching { edge.upsertWhoopTokenToSupabase(ctx, whoopToken) }
            .getOrDefault(false)

        if (!uploaded) {
            Log.w(TAG, "upsert-whoop-token failed; retrying")
            return Result.retry()
        }

        // Best-effort backfill — do NOT retry the whole worker if this fails.
        // The server will handle backfill via cron regardless.
        runCatching { edge.enqueueLoginBackfillGuaranteed(ctx) }
            .onFailure { Log.w(TAG, "enqueue-login-backfill failed (non-fatal): ${it.message}") }

        Log.d(TAG, "WHOOP token uploaded successfully")
        return Result.success()
    }

    companion object {
        private const val TAG = "WhoopTokenUploadWorker"
        private const val UNIQUE_WORK_NAME = "whoop_token_upload_and_backfill"

        fun enqueueNow(context: Context) {
            val appCtx = context.applicationContext

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()

            val req = OneTimeWorkRequestBuilder<WhoopTokenUploadWorker>()
                .setConstraints(constraints)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30, TimeUnit.SECONDS)
                .build()

            WorkManager.getInstance(appCtx)
                .enqueueUniqueWork(UNIQUE_WORK_NAME, ExistingWorkPolicy.REPLACE, req)
        }
    }
}

title: Color.kt
text:
package com.migraineme.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

title: Theme.kt
text:
package com.migraineme.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun MigraineMeTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

title: Type.kt
text:
package com.migraineme.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

