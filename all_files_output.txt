title: AdjustMedicinesScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.material3.rememberSwipeToDismissBoxState
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustMedicinesScreen(
    navController: NavController,
    vm: MedicineViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        Log.d("AdjustMedicines", "token present? ${authState.accessToken != null}")
        authState.accessToken?.let { vm.loadAll(it) }
    }

    LazyColumn(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.background)
            .padding(horizontal = 16.dp),
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Back
        item {
            ElevatedCard(
                onClick = { navController.popBackStack() },
                shape = MaterialTheme.shapes.medium,
                colors = CardDefaults.elevatedCardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Row(
                    modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    Spacer(Modifier.width(8.dp))
                    Text("Back")
                }
            }
        }

        // Add new to pool
        item {
            Column {
                OutlinedTextField(
                    value = newLabel,
                    onValueChange = { newLabel = it },
                    label = { Text("New medicine label") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )
                Spacer(Modifier.height(8.dp))
                Button(
                    onClick = {
                        val token = authState.accessToken ?: return@Button
                        val label = newLabel.trim()
                        if (label.isNotEmpty()) {
                            vm.addNewToPool(token, label)
                            newLabel = ""
                        }
                    },
                    enabled = newLabel.isNotBlank()
                ) {
                    Icon(Icons.Default.Add, contentDescription = "Add to Pool")
                    Spacer(Modifier.width(8.dp))
                    Text("Add to list")
                }
            }
        }

        // Frequent
        item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }
        items(frequent, key = { it.id }) { pref ->
            ElevatedCard(
                shape = MaterialTheme.shapes.medium,
                colors = CardDefaults.elevatedCardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                ),
                modifier = Modifier.fillMaxWidth()
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp, horizontal = 8.dp),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(pref.medicine?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                    IconButton(onClick = {
                        val token = authState.accessToken ?: return@IconButton
                        vm.removeFromFrequent(token, pref.id)
                    }) {
                        Icon(Icons.Default.Delete, contentDescription = "Remove from Frequent")
                    }
                }
            }
        }

        // All medicines
        item { Text("All Medicines", style = MaterialTheme.typography.titleMedium) }

        val frequentIds = frequent.map { it.medicineId }.toSet()
        val remaining = pool.filter { it.id !in frequentIds }

        items(remaining, key = { it.id }) { med ->
            val dismissState = rememberSwipeToDismissBoxState(
                initialValue = Settled,
                confirmValueChange = { value ->
                    if (value == EndToStart) {
                        val token = authState.accessToken
                            ?: return@rememberSwipeToDismissBoxState false
                        vm.removeFromPool(token, med.id)
                        true
                    } else false
                }
            )
            SwipeToDismissBox(
                state = dismissState,
                enableDismissFromStartToEnd = false,
                enableDismissFromEndToStart = true,
                backgroundContent = { }
            ) {
                ElevatedCard(
                    shape = MaterialTheme.shapes.medium,
                    colors = CardDefaults.elevatedCardColors(
                        containerColor = MaterialTheme.colorScheme.surface
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(med.label, style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: run {
                                Log.d("AdjustMedicines", "token null on + click")
                                return@IconButton
                            }
                            Log.d("AdjustMedicines", "addToFrequent id=${med.id}")
                            vm.addToFrequent(token, med.id)
                        }) {
                            Icon(Icons.Default.Add, contentDescription = "Add to Frequent")
                        }
                    }
                }
            }
        }

        item { Spacer(Modifier.height(24.dp)) }
    }
}

title: AdjustMigrainesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustMigrainesScreen(
    navController: NavController,
    vm: MigraineViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    Scaffold { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Back arrow card
            item {
                Card(
                    onClick = { navController.popBackStack() },
                    shape = MaterialTheme.shapes.medium,
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                ) {
                    Row(
                        modifier = Modifier
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.ArrowBack,
                            contentDescription = "Back"
                        )
                        Spacer(Modifier.width(8.dp))
                        Text("Back")
                    }
                }
            }

            // New migraine input
            item {
                Column {
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        label = { Text("New migraine label") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                    Spacer(Modifier.height(8.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        Button(
                            onClick = {
                                val token = authState.accessToken ?: return@Button
                                val label = newLabel.trim()
                                if (label.isNotEmpty()) {
                                    vm.addNewToPool(token, label)
                                    newLabel = ""
                                }
                            },
                            enabled = newLabel.isNotBlank()
                        ) {
                            Icon(Icons.Default.Add, contentDescription = null)
                            Spacer(Modifier.width(8.dp))
                            Text("Add to list")
                        }
                    }
                }
            }

            // Frequent header
            item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }

            // Frequent items
            items(frequent, key = { it.id }) { pref ->
                Surface(
                    color = MaterialTheme.colorScheme.surface,
                    tonalElevation = 0.dp,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(pref.migraine?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: return@IconButton
                            vm.removeFromFrequent(token, pref.id)
                        }) {
                            Icon(Icons.Default.Delete, contentDescription = "Remove from Frequent")
                        }
                    }
                }
            }

            // All Migraines header
            item { Text("All Migraines", style = MaterialTheme.typography.titleMedium) }

            // All Migraines with swipe-to-delete
            val frequentIds = frequent.map { it.migraineId }.toSet()
            val remaining = pool.filter { it.id !in frequentIds }

            items(remaining, key = { it.id }) { mg ->
                val dismissState = rememberSwipeToDismissBoxState(
                    initialValue = Settled,
                    confirmValueChange = { value ->
                        if (value == EndToStart) {
                            val token = authState.accessToken ?: return@rememberSwipeToDismissBoxState false
                            vm.removeFromPool(token, mg.id)
                            true
                        } else false
                    }
                )

                SwipeToDismissBox(
                    state = dismissState,
                    enableDismissFromStartToEnd = false,
                    enableDismissFromEndToStart = true,
                    backgroundContent = {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(
                                    if (dismissState.targetValue == EndToStart)
                                        MaterialTheme.colorScheme.error
                                    else
                                        MaterialTheme.colorScheme.error.copy(alpha = 0.25f)
                                )
                                .padding(horizontal = 16.dp),
                            contentAlignment = Alignment.CenterEnd
                        ) {
                            Icon(
                                Icons.Default.Delete,
                                contentDescription = "Delete",
                                tint = Color.White
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Surface(
                        color = MaterialTheme.colorScheme.surface,
                        tonalElevation = 0.dp,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp, horizontal = 8.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(mg.label, style = MaterialTheme.typography.bodyLarge)
                            IconButton(onClick = {
                                val token = authState.accessToken ?: return@IconButton
                                vm.addToFrequent(token, mg.id)
                            }) {
                                Icon(Icons.Default.Add, contentDescription = "Add to Frequent")
                            }
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(24.dp)) }
        }
    }
}

title: AdjustReliefsScreen.kt
text:
package com.migraineme

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.material3.rememberSwipeToDismissBoxState
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustReliefsScreen(
    navController: NavController,
    vm: ReliefViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    val snackbar = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        Log.d("AdjustReliefs", "token=${authState.accessToken != null}")
        authState.accessToken?.let { vm.loadAll(it) }
    }

    Scaffold(snackbarHost = { SnackbarHost(snackbar) }) { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                ElevatedCard(
                    onClick = { navController.popBackStack() },
                    shape = MaterialTheme.shapes.medium
                ) {
                    Row(
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                        Spacer(Modifier.width(8.dp))
                        Text("Back")
                    }
                }
            }

            item {
                Column {
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        label = { Text("New relief label") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                    Spacer(Modifier.height(8.dp))
                    Button(
                        onClick = {
                            val token = authState.accessToken
                            val label = newLabel.trim()
                            if (token.isNullOrBlank() || label.isEmpty()) return@Button
                            runCatching {
                                vm.addNewToPool(token, label)
                                newLabel = ""
                            }.onFailure { e ->
                                e.printStackTrace()
                                scope.launch { snackbar.showSnackbar("Failed to add: ${e.message ?: "error"}") }
                            }
                        },
                        enabled = newLabel.isNotBlank()
                    ) {
                        Icon(Icons.Filled.Add, contentDescription = "Add to Pool")
                        Spacer(Modifier.width(8.dp))
                        Text("Add to list")
                    }
                }
            }

            item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }
            items(frequent, key = { it.id }) { pref ->
                ElevatedCard(
                    shape = MaterialTheme.shapes.medium,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(pref.relief?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: return@IconButton
                            runCatching { vm.removeFromFrequent(token, pref.id) }
                                .onFailure { e ->
                                    e.printStackTrace()
                                    scope.launch { snackbar.showSnackbar("Failed to remove: ${e.message ?: "error"}") }
                                }
                        }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Remove from Frequent")
                        }
                    }
                }
            }

            item { Text("All Reliefs", style = MaterialTheme.typography.titleMedium) }

            val frequentIds = frequent.map { it.reliefId }.toSet()
            val remaining = pool.filter { it.id !in frequentIds }

            items(remaining, key = { it.id }) { rel ->
                val dismissState = rememberSwipeToDismissBoxState(
                    initialValue = Settled,
                    confirmValueChange = { value ->
                        if (value == EndToStart) {
                            val token = authState.accessToken ?: return@rememberSwipeToDismissBoxState false
                            runCatching {
                                vm.removeFromPool(token, rel.id)
                                true
                            }.onFailure { e ->
                                e.printStackTrace()
                                scope.launch { snackbar.showSnackbar("Delete failed: ${e.message ?: "error"}") }
                            }.getOrDefault(false)
                        } else false
                    }
                )
                SwipeToDismissBox(
                    state = dismissState,
                    enableDismissFromStartToEnd = false,
                    enableDismissFromEndToStart = true,
                    backgroundContent = { }
                ) {
                    ElevatedCard(
                        shape = MaterialTheme.shapes.medium,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp, horizontal = 8.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(rel.label, style = MaterialTheme.typography.bodyLarge)
                            IconButton(onClick = {
                                val token = authState.accessToken ?: return@IconButton
                                runCatching { vm.addToFrequent(token, rel.id) }
                                    .onFailure { e ->
                                        e.printStackTrace()
                                        scope.launch { snackbar.showSnackbar("Add failed: ${e.message ?: "error"}") }
                                    }
                            }) {
                                Icon(Icons.Filled.Add, contentDescription = "Add to Frequent")
                            }
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(24.dp)) }
        }
    }
}

title: AdjustTriggersScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.material3.SwipeToDismissBoxValue.EndToStart
import androidx.compose.material3.SwipeToDismissBoxValue.Settled
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdjustTriggersScreen(
    navController: NavController,
    vm: TriggerViewModel,
    authVm: AuthViewModel
) {
    val authState by authVm.state.collectAsState()
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()

    var newLabel by remember { mutableStateOf("") }

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    Scaffold { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .background(MaterialTheme.colorScheme.background)
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Back arrow card
            item {
                Card(
                    onClick = { navController.popBackStack() },
                    shape = MaterialTheme.shapes.medium,
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                ) {
                    Row(
                        modifier = Modifier
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            Icons.Default.ArrowBack,
                            contentDescription = "Back"
                        )
                        Spacer(Modifier.width(8.dp))
                        Text("Back")
                    }
                }
            }

            // New trigger input
            item {
                Column {
                    OutlinedTextField(
                        value = newLabel,
                        onValueChange = { newLabel = it },
                        label = { Text("New trigger label") },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )
                    Spacer(Modifier.height(8.dp))
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        Button(
                            onClick = {
                                val token = authState.accessToken ?: return@Button
                                val label = newLabel.trim()
                                if (label.isNotEmpty()) {
                                    vm.addNewToPool(token, label)
                                    newLabel = ""
                                }
                            },
                            enabled = newLabel.isNotBlank()
                        ) {
                            Icon(Icons.Default.Add, contentDescription = null)
                            Spacer(Modifier.width(8.dp))
                            Text("Add to list")
                        }
                    }
                }
            }

            // Frequent header
            item { Text("Frequent", style = MaterialTheme.typography.titleMedium) }

            // Frequent items
            items(frequent, key = { it.id }) { pref ->
                Surface(
                    color = MaterialTheme.colorScheme.surface,
                    tonalElevation = 0.dp,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 8.dp, horizontal = 8.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(pref.trigger?.label ?: "", style = MaterialTheme.typography.bodyLarge)
                        IconButton(onClick = {
                            val token = authState.accessToken ?: return@IconButton
                            vm.removeFromFrequent(token, pref.id)
                        }) {
                            Icon(Icons.Default.Delete, contentDescription = "Remove from Frequent")
                        }
                    }
                }
            }

            // All Triggers header
            item { Text("All Triggers", style = MaterialTheme.typography.titleMedium) }

            // All Triggers with swipe-to-delete
            val frequentIds = frequent.map { it.triggerId }.toSet()
            val remaining = pool.filter { it.id !in frequentIds }

            items(remaining, key = { it.id }) { trig ->
                val dismissState = rememberSwipeToDismissBoxState(
                    initialValue = Settled,
                    confirmValueChange = { value ->
                        if (value == EndToStart) {
                            val token = authState.accessToken ?: return@rememberSwipeToDismissBoxState false
                            vm.removeFromPool(token, trig.id)
                            true
                        } else false
                    }
                )

                SwipeToDismissBox(
                    state = dismissState,
                    enableDismissFromStartToEnd = false,
                    enableDismissFromEndToStart = true,
                    backgroundContent = {
                        Box(
                            modifier = Modifier
                                .fillMaxSize()
                                .background(
                                    if (dismissState.targetValue == EndToStart)
                                        MaterialTheme.colorScheme.error
                                    else
                                        MaterialTheme.colorScheme.error.copy(alpha = 0.25f)
                                )
                                .padding(horizontal = 16.dp),
                            contentAlignment = Alignment.CenterEnd
                        ) {
                            Icon(
                                Icons.Default.Delete,
                                contentDescription = "Delete",
                                tint = Color.White
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Surface(
                        color = MaterialTheme.colorScheme.surface,
                        tonalElevation = 0.dp,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 8.dp, horizontal = 8.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(trig.label, style = MaterialTheme.typography.bodyLarge)
                            IconButton(onClick = {
                                val token = authState.accessToken ?: return@IconButton
                                vm.addToFrequent(token, trig.id)
                            }) {
                                Icon(Icons.Default.Add, contentDescription = "Add to Frequent")
                            }
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(24.dp)) }
        }
    }
}

title: AppContext.kt
text:
// app/src/main/java/com/migraineme/AppContext.kt
package com.migraineme

import android.content.Context

object AppContext {
    lateinit var app: Context
        private set

    fun init(context: Context) {
        app = context.applicationContext
    }
}

title: AuthViewModel.kt
text:
// FILE: app/src/main/java/com/migraineme/AuthViewModel.kt
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

data class AuthState(
    val accessToken: String? = null,
    val userId: String? = null,
    val error: String? = null
)

class AuthViewModel : ViewModel() {
    private val _state = MutableStateFlow(AuthState())
    val state: StateFlow<AuthState> = _state

    fun setSession(accessToken: String?, userId: String?) {
        _state.update { it.copy(accessToken = accessToken, userId = userId, error = null) }
    }

    fun clearSession() {
        _state.update { AuthState() }
    }

    /**
     * Fixes "needs two taps" logout:
     * - Clear local session immediately so UI updates / navigation guards stop treating user as signed in
     * - Perform remote signout in background (best-effort)
     */
    fun signOut() {
        val token = _state.value.accessToken

        // Clear local session immediately (prevents Login screen from auto-routing back to Home)
        clearSession()

        // Best-effort remote sign-out (does not block UI)
        if (!token.isNullOrBlank()) {
            viewModelScope.launch {
                try {
                    SupabaseAuthService.signOut(token)
                } catch (_: Exception) {
                    // ignore remote signout errors
                }
            }
        }
    }
}

title: ChangePasswordScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@Composable
fun ChangePasswordScreen(
    authVm: AuthViewModel,
    onDone: () -> Unit
) {
    val auth by authVm.state.collectAsState()
    val scope = rememberCoroutineScope()

    val loading = remember { mutableStateOf(false) }
    val canUse = remember { mutableStateOf(false) }

    val currentPassword = remember { mutableStateOf("") }
    val newPassword = remember { mutableStateOf("") }
    val confirmPassword = remember { mutableStateOf("") }

    val errorDialog = remember { mutableStateOf<String?>(null) }
    val successDialog = remember { mutableStateOf(false) }

    LaunchedEffect(auth.accessToken) {
        val token = auth.accessToken
        if (token.isNullOrBlank()) {
            canUse.value = false
            return@LaunchedEffect
        }

        loading.value = true
        try {
            val user = withContext(Dispatchers.IO) { SupabaseAuthService.getUser(token) }
            canUse.value = user.identities?.any { it.provider == "email" } == true
        } catch (_: Throwable) {
            canUse.value = false
        } finally {
            loading.value = false
        }
    }

    fun validate(): String? {
        if (currentPassword.value.isBlank()) return "Please enter your current password."
        if (newPassword.value.isBlank() || confirmPassword.value.isBlank())
            return "Please fill in all password fields."
        if (newPassword.value != confirmPassword.value)
            return "New passwords do not match."
        if (newPassword.value.length < 8)
            return "Password must be at least 8 characters."
        return null
    }

    fun submit() {
        val token = auth.accessToken
        val userId = auth.userId

        if (token.isNullOrBlank() || userId.isNullOrBlank()) {
            errorDialog.value = "Not signed in."
            return
        }

        if (!canUse.value) {
            errorDialog.value = "Password changes are only available for email accounts."
            return
        }

        val v = validate()
        if (v != null) {
            errorDialog.value = v
            return
        }

        loading.value = true
        scope.launch {
            try {
                // 1) fetch email (authoritative)
                val email = withContext(Dispatchers.IO) {
                    SupabaseAuthService.getUser(token).email
                } ?: throw IllegalStateException("Could not determine email.")

                // 2) re-authenticate with current password
                val session = withContext(Dispatchers.IO) {
                    SupabaseAuthService.signInWithEmail(email, currentPassword.value)
                }

                val newAccessToken = session.accessToken
                    ?: throw IllegalStateException("Re-authentication failed.")

                // 3) change password using fresh token
                withContext(Dispatchers.IO) {
                    SupabaseAuthService.changePassword(newAccessToken, newPassword.value)
                }

                successDialog.value = true
            } catch (t: Throwable) {
                errorDialog.value = t.message ?: "Failed to change password."
            } finally {
                loading.value = false
            }
        }
    }

    errorDialog.value?.let { msg ->
        AlertDialog(
            onDismissRequest = { errorDialog.value = null },
            title = { Text("Error") },
            text = { Text(msg) },
            confirmButton = {
                TextButton(onClick = { errorDialog.value = null }) { Text("OK") }
            }
        )
    }

    if (successDialog.value) {
        AlertDialog(
            onDismissRequest = { },
            title = { Text("Password updated") },
            text = { Text("Your password has been changed.") },
            confirmButton = {
                TextButton(onClick = {
                    successDialog.value = false
                    onDone()
                }) { Text("Done") }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Change password", style = MaterialTheme.typography.titleLarge)
        Divider()

        OutlinedTextField(
            value = currentPassword.value,
            onValueChange = { currentPassword.value = it },
            label = { Text("Current password") },
            singleLine = true,
            enabled = !loading.value && canUse.value,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = newPassword.value,
            onValueChange = { newPassword.value = it },
            label = { Text("New password") },
            singleLine = true,
            enabled = !loading.value && canUse.value,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = confirmPassword.value,
            onValueChange = { confirmPassword.value = it },
            label = { Text("Confirm new password") },
            singleLine = true,
            enabled = !loading.value && canUse.value,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(Modifier.height(4.dp))

        Button(
            onClick = { submit() },
            enabled = !loading.value && canUse.value,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(if (loading.value) "Updating..." else "Update password")
        }
    }
}

title: CityWeatherViewModel.kt
text:
// FILE: C:\Users\verwe\Projects\MigraineMe\app\src\main\java\com\migraineme\CityWeatherViewModel.kt
package com.migraineme

import android.app.Application
import android.location.Location
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.json.JSONArray
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

data class CityRow(
    val id: Long,
    val label: String,
    val lat: Double,
    val lon: Double,
    val timezone: String?
)

data class DailyRow(
    val day: String,
    val tempMeanC: Double?,
    val pressureMeanHpa: Double?,
    val humidityMeanPct: Double?
)

data class CityWeatherState(
    val loading: Boolean = false,
    val error: String? = null,
    val nearestCity: CityRow? = null,
    val days: List<DailyRow> = emptyList()
)

class CityWeatherViewModel(app: Application) : AndroidViewModel(app) {

    private val _state = MutableStateFlow(CityWeatherState(loading = false))
    val state: StateFlow<CityWeatherState> = _state

    private val supabaseUrl: String = BuildConfig.SUPABASE_URL
    private val supabaseKey: String = BuildConfig.SUPABASE_ANON_KEY

    /** Existing entry (kept): pulls around today (T−2..T+6, fallback to recent). */
    fun loadNearestAndDaily(location: Location?) {
        if (_state.value.loading) return
        _state.value = _state.value.copy(loading = true, error = null)
        viewModelScope.launch {
            try {
                val (refLat, refLon) = extractRefLatLonOrFallback(location)
                Log.d("CityWX", "Ref location lat=$refLat lon=$refLon")

                val cities: List<CityRow> = withContext(Dispatchers.IO) {
                    val nearby = fetchCitiesNear(refLat, refLon, 2.0)
                    if (nearby.isNotEmpty()) {
                        if (nearby.size < 5) mergeUnique(nearby, fetchAllCities()) else nearby
                    } else {
                        fetchAllCities()
                    }
                }
                if (cities.isEmpty()) {
                    _state.value = _state.value.copy(loading = false, error = "No cities available")
                    return@launch
                }

                val nearest = pickNearest(refLat, refLon, cities)
                val days = withContext(Dispatchers.IO) { fetchDaily(nearest.id) }

                _state.value = CityWeatherState(loading = false, error = null, nearestCity = nearest, days = days)
            } catch (e: Exception) {
                _state.value = _state.value.copy(loading = false, error = e.message ?: "Error")
            }
        }
    }

    /**
     * NEW: Range-aware loader.
     * Start = max( earliest user_location_daily (source=device), today−30d )
     * End   = today
     * If the ranged query is empty, fall back to the original window logic.
     */
    fun loadNearestAndDailyByUserHistory(
        accessToken: String,
        location: Location?
    ) {
        if (_state.value.loading) return
        _state.value = _state.value.copy(loading = true, error = null)
        viewModelScope.launch {
            try {
                val (refLat, refLon) = extractRefLatLonOrFallback(location)

                val personal = SupabasePersonalService(getApplication())
                val earliestStr = withContext(Dispatchers.IO) {
                    runCatching { personal.earliestUserLocationDate(accessToken, source = "device") }.getOrNull()
                }

                val today = LocalDate.now()
                val start = runCatching { earliestStr?.let { LocalDate.parse(it) } }.getOrNull()
                    ?.let { if (it.isAfter(today.minusDays(30))) it else today.minusDays(30) }
                    ?: today.minusDays(30)
                val fromIso = start.format(DateTimeFormatter.ISO_DATE)
                val toIso = today.format(DateTimeFormatter.ISO_DATE)

                Log.d("CityWX", "History range from=$fromIso to=$toIso (earliest=$earliestStr)")

                val cities: List<CityRow> = withContext(Dispatchers.IO) {
                    val nearby = fetchCitiesNear(refLat, refLon, 2.0)
                    if (nearby.isNotEmpty()) {
                        if (nearby.size < 5) mergeUnique(nearby, fetchAllCities()) else nearby
                    } else {
                        fetchAllCities()
                    }
                }
                if (cities.isEmpty()) {
                    _state.value = _state.value.copy(loading = false, error = "No cities available")
                    return@launch
                }

                val nearest = pickNearest(refLat, refLon, cities)
                val days = withContext(Dispatchers.IO) {
                    val ranged = fetchDailyRange(nearest.id, fromIso, toIso)
                    if (ranged.isNotEmpty()) ranged else fetchDaily(nearest.id)
                }

                _state.value = CityWeatherState(loading = false, error = null, nearestCity = nearest, days = days)
            } catch (e: Exception) {
                _state.value = _state.value.copy(loading = false, error = e.message ?: "Error")
            }
        }
    }

    /* ---------------- Internals ---------------- */

    private fun extractRefLatLonOrFallback(location: Location?): Pair<Double, Double> {
        return if (location != null) location.latitude to location.longitude else 51.5074 to -0.1278 // London fallback
    }

    /** GET /rest/v1/city?select=id,label:name,lat,lon,timezone&limit=5000 */
    private fun fetchAllCities(): List<CityRow> {
        val qp = "select=id,label:name,lat,lon,timezone&limit=5000"
        val (code, body) = httpGet("$supabaseUrl/rest/v1/city?$qp")
        if (code !in 200..299) {
            val msg = parseErrorMessage(body) ?: "HTTP $code loading city"
            throw IllegalStateException(msg)
        }
        return parseCities(body)
    }

    /**
     * Bounding-box query around device location to ensure local coverage.
     * GET /rest/v1/city?select=id,label:name,lat,lon,timezone&lat=gte.{minLat}&lat=lte.{maxLat}&lon=gte.{minLon}&lon=lte.{maxLon}
     */
    private fun fetchCitiesNear(lat: Double, lon: Double, deg: Double): List<CityRow> {
        val minLat = lat - deg
        val maxLat = lat + deg
        val minLon = lon - deg
        val maxLon = lon + deg
        val qp = buildString {
            append("select=id,label:name,lat,lon,timezone")
            append("&lat=gte.$minLat&lat=lte.$maxLat")
            append("&lon=gte.$minLon&lon=lte.$maxLon")
            append("&limit=5000")
        }
        val (code, body) = httpGet("$supabaseUrl/rest/v1/city?$qp")
        if (code !in 200..299) {
            val msg = parseErrorMessage(body) ?: "HTTP $code loading nearby city"
            throw IllegalStateException(msg)
        }
        return parseCities(body)
    }

    private fun parseCities(body: String): List<CityRow> {
        val arr = JSONArray(body)
        val out = ArrayList<CityRow>(arr.length())
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            out.add(
                CityRow(
                    id = o.getLong("id"),
                    label = o.optString("label", ""),
                    lat = o.getDouble("lat"),
                    lon = o.getDouble("lon"),
                    timezone = if (o.isNull("timezone")) null else o.getString("timezone")
                )
            )
        }
        return out
    }

    private fun mergeUnique(a: List<CityRow>, b: List<CityRow>): List<CityRow> {
        val seen = HashSet<Long>(a.size + b.size)
        val out = ArrayList<CityRow>(a.size + b.size)
        for (c in a) if (seen.add(c.id)) out.add(c)
        for (c in b) if (seen.add(c.id)) out.add(c)
        return out
    }

    /** Original: T−2..T+6 window with fallback to most recent rows. */
    private fun fetchDaily(cityId: Long): List<DailyRow> {
        val today = LocalDate.now()
        val from = today.minusDays(2).format(DateTimeFormatter.ISO_DATE)
        val to = today.plusDays(6).format(DateTimeFormatter.ISO_DATE)
        val base = "select=day,temp_c_mean,pressure_hpa_mean,humidity_pct_mean&city_id=eq.$cityId"

        val qpWindow = "$base&order=day.asc&day=gte.$from&day=lte.$to"
        val primary = parseDaily(httpGet("$supabaseUrl/rest/v1/city_weather_daily?$qpWindow"))
        if (primary.isNotEmpty()) return primary

        val qpRecent = "$base&order=day.desc&limit=9"
        val recentDesc = parseDaily(httpGet("$supabaseUrl/rest/v1/city_weather_daily?$qpRecent"))
        if (recentDesc.isNotEmpty()) return recentDesc.asReversed()

        return emptyList()
    }


    private fun fetchDailyRange(cityId: Long, fromIso: String, toIso: String): List<DailyRow> {
        val base = "select=day,temp_c_mean,pressure_hpa_mean,humidity_pct_mean&city_id=eq.$cityId"
        val qp = "$base&order=day.asc&day=gte.$fromIso&day=lte.$toIso"
        return parseDaily(httpGet("$supabaseUrl/rest/v1/city_weather_daily?$qp"))
    }

    private fun parseDaily(resp: Pair<Int, String>): List<DailyRow> {
        val (code, body) = resp
        if (code !in 200..299) {
            val msg = parseErrorMessage(body) ?: "HTTP $code loading city_weather_daily"
            throw IllegalStateException(msg)
        }
        val arr = JSONArray(body)
        val out = ArrayList<DailyRow>(arr.length())
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            out.add(
                DailyRow(
                    day = o.getString("day"),
                    tempMeanC = o.optDoubleOrNull("temp_c_mean"),
                    pressureMeanHpa = o.optDoubleOrNull("pressure_hpa_mean"),
                    humidityMeanPct = o.optDoubleOrNull("humidity_pct_mean")
                )
            )
        }
        return out
    }

    private fun applyHeaders(conn: HttpURLConnection) {
        conn.setRequestProperty("apikey", supabaseKey)
        conn.setRequestProperty("Authorization", "Bearer $supabaseKey")
    }

    private fun httpGet(urlStr: String): Pair<Int, String> {
        val url = URL(urlStr)
        val conn = (url.openConnection() as HttpURLConnection).apply {
            requestMethod = "GET"
            applyHeaders(this)
        }
        val code = conn.responseCode
        val stream = if (code in 200..299) conn.inputStream else conn.errorStream
        val body = BufferedReader(InputStreamReader(stream)).use { it.readText() }
        conn.disconnect()
        return code to body
    }

    private fun parseErrorMessage(body: String?): String? {
        if (body.isNullOrBlank()) return null
        return try {
            val o = JSONObject(body)
            val msg = o.optString("message", "")
            if (msg.isNotBlank()) msg else {
                val err = o.optString("error", "")
                if (err.isNotBlank()) err else null
            }
        } catch (_: Exception) {
            body.take(140)
        }
    }

    private fun JSONObject.optDoubleOrNull(name: String): Double? {
        return if (isNull(name)) null else try { getDouble(name) } catch (_: Exception) { null }
    }

    /** Haversine distance in km */
    private fun haversineKm(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371.0
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c
    }

    private fun pickNearest(refLat: Double, refLon: Double, cities: List<CityRow>): CityRow {
        return cities
            .asSequence()
            .map { c -> c to haversineKm(refLat, refLon, c.lat, c.lon) }
            .sortedBy { it.second }
            .first().first
    }
}

title: CommunityScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun CommunityScreen() {
    Column(Modifier.padding(16.dp)) {
        Text("Community", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(8.dp))
        Text("Coming soon")
    }
}

title: DataCollectionSettings.kt
text:
package com.migraineme

import android.content.Context

/**
 * Shared reader for DataSettingsScreen preferences, used by Workers and MetricsSyncManager.
 *
 * Matches DataSettingsScreen key format exactly:
 * - Selected wearable per table: data_source_<table>
 * - Active (non-wearable):      data_active_<table>
 * - Active (wearable):         data_active_<table>_<source>
 *
 * Defaults preserve existing behavior: if unset, tables are treated as ACTIVE.
 */
object DataCollectionSettings {

    private const val PREFS = "data_settings"

    private fun prefs(context: Context) =
        context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

    fun selectedWearable(context: Context, table: String, fallback: String = "whoop"): String {
        val key = "data_source_$table"
        return prefs(context).getString(key, null) ?: fallback
    }

    fun isActive(
        context: Context,
        table: String,
        wearable: String? = null,
        defaultValue: Boolean = true
    ): Boolean {
        val key = activeKey(table, wearable)
        return prefs(context).getBoolean(key, defaultValue)
    }

    /**
     * Returns true only if:
     * - Selected wearable for this table is "whoop"
     * - AND the per-wearable active flag is true (default true if unset)
     */
    fun isEnabledForWhoop(context: Context, table: String, defaultValue: Boolean = true): Boolean {
        val selected = selectedWearable(context, table, fallback = "whoop")
        if (selected != "whoop") return false
        return isActive(context, table, wearable = "whoop", defaultValue = defaultValue)
    }

    private fun activeKey(table: String, wearable: String?): String {
        return if (wearable == null) {
            "data_active_$table"
        } else {
            "data_active_${table}_${wearable}"
        }
    }
}

title: DataSettingsScreen.kt
text:
package com.migraineme

import android.content.Context
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Divider
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp

/**
 * Data Settings Screen
 *
 * Displays the 5 requested sections and lets the user toggle per-table collection.
 * - Phone-collected tables: Collected By fixed to "Phone"
 * - Wearable-collected tables: Collected By is a dropdown, limited to connected wearables
 * - If no wearable is connected, wearable rows are greyed out + disabled
 *
 * Settings are persisted locally (SharedPreferences). Workers will be gated in the next step.
 */
@Composable
fun DataSettingsScreen() {
    val context = LocalContext.current.applicationContext
    val scrollState = rememberScrollState()

    // Connected wearables (only WHOOP is implemented in the codebase right now)
    val whoopConnected = remember { mutableStateOf(false) }
    LaunchedEffect(Unit) {
        whoopConnected.value = WhoopTokenStore(context).load() != null
    }
    val connectedWearables = remember(whoopConnected.value) {
        buildList {
            if (whoopConnected.value) add(WearableSource.WHOOP)
        }
    }
    val hasAnyWearable = connectedWearables.isNotEmpty()

    val store = remember { DataSettingsStore(context) }

    // Define all rows (tables) grouped into the 5 sections you requested.
    val sections = remember {
        listOf(
            DataSection(
                title = "Sleep",
                rows = listOf(
                    wearableRow("sleep_duration_daily", "Wearable sleep sync"),
                    wearableRow("sleep_score_daily", "Wearable sleep sync"),
                    wearableRow("sleep_efficiency_daily", "Wearable sleep sync"),
                    wearableRow("sleep_stages_daily", "Wearable sleep sync"),
                    wearableRow("sleep_disturbances_daily", "Wearable sleep sync"),
                    wearableRow("fell_asleep_time_daily", "Wearable sleep sync"),
                    wearableRow("woke_up_time_daily", "Wearable sleep sync")
                )
            ),
            DataSection(
                title = "Physical Health",
                rows = listOf(
                    wearableRow("recovery_score_daily", "Wearable recovery sync"),
                    wearableRow("resting_hr_daily", "Wearable recovery sync"),
                    wearableRow("hrv_daily", "Wearable recovery sync"),
                    wearableRow("skin_temp_daily", "Wearable recovery sync"),
                    wearableRow("spo2_daily", "Wearable recovery sync"),
                    wearableRow("time_in_high_hr_zones_daily", "Wearable workout sync"),
                    // Present in schema; no collector in provided Kotlin yet.
                    DataRow(
                        table = "steps_daily",
                        collectedByKind = CollectedByKind.WEARABLE,
                        collectedByLabel = "Wearable steps sync (not implemented)",
                        defaultWearable = WearableSource.WHOOP
                    )
                )
            ),
            DataSection(
                title = "Mental Health",
                rows = listOf(
                    // These are user-entered via the logging flow (not worker collection).
                    manualRow("migraines", "User log entry"),
                    manualRow("triggers", "User log entry"),
                    manualRow("medicines", "User log entry"),
                    manualRow("reliefs", "User log entry")
                )
            ),
            DataSection(
                title = "Environment",
                rows = listOf(
                    phoneRow("user_location_daily", "Phone GPS/location"),
                    // Read-only reference tables; shown for completeness.
                    referenceRow("city", "Reference dataset (read-only)"),
                    referenceRow("city_weather_daily", "Reference dataset (read-only)")
                )
            ),
            DataSection(
                title = "Diet",
                rows = emptyList()
            )
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(16.dp)
    ) {
        Text("Data", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(8.dp))
        Text(
            "Control which data tables are collected. Wearable options appear only after you connect a wearable.",
            style = MaterialTheme.typography.bodyMedium
        )
        Spacer(Modifier.height(16.dp))

        sections.forEachIndexed { idx, section ->
            SectionCard(
                section = section,
                store = store,
                connectedWearables = connectedWearables,
                hasAnyWearable = hasAnyWearable
            )

            if (idx != sections.lastIndex) Spacer(Modifier.height(14.dp))
        }

        // A little bottom padding so the last card isn't flush with the screen edge.
        Spacer(Modifier.height(12.dp))
    }
}

@Composable
private fun SectionCard(
    section: DataSection,
    store: DataSettingsStore,
    connectedWearables: List<WearableSource>,
    hasAnyWearable: Boolean
) {
    ElevatedCard(modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(14.dp)) {
            Text(section.title, style = MaterialTheme.typography.titleMedium)
            Spacer(Modifier.height(10.dp))

            // Header row
            Row(modifier = Modifier.fillMaxWidth()) {
                Text(
                    "Type",
                    modifier = Modifier.weight(0.46f),
                    style = MaterialTheme.typography.labelMedium
                )
                Text(
                    "Collected By",
                    modifier = Modifier.weight(0.34f),
                    style = MaterialTheme.typography.labelMedium
                )
                Text(
                    "Active",
                    modifier = Modifier.weight(0.20f),
                    style = MaterialTheme.typography.labelMedium
                )
            }
            Spacer(Modifier.height(6.dp))
            Divider()

            if (section.rows.isEmpty()) {
                Spacer(Modifier.height(10.dp))
                Text(
                    "No tables configured in this section.",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.alpha(0.7f)
                )
                Spacer(Modifier.height(6.dp))
                return@Column
            }

            section.rows.forEachIndexed { i, row ->
                val isWearableRow = row.collectedByKind == CollectedByKind.WEARABLE
                val isReferenceRow = row.collectedByKind == CollectedByKind.REFERENCE

                // Grey out wearable rows when no wearable connected
                val enabled =
                    when {
                        isReferenceRow -> false
                        isWearableRow -> hasAnyWearable
                        else -> true
                    }

                Spacer(Modifier.height(10.dp))
                DataRowUi(
                    row = row,
                    store = store,
                    connectedWearables = connectedWearables,
                    enabled = enabled,
                    greyOut = isWearableRow && !hasAnyWearable
                )

                if (i != section.rows.lastIndex) {
                    Spacer(Modifier.height(10.dp))
                    Divider()
                }
            }

            // Wearable hint per section if none connected and section contains wearable rows
            val containsWearable = section.rows.any { it.collectedByKind == CollectedByKind.WEARABLE }
            if (containsWearable && !hasAnyWearable) {
                Spacer(Modifier.height(10.dp))
                Text(
                    "Connect a wearable to enable these settings.",
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.alpha(0.7f)
                )
            }
        }
    }
}

@Composable
private fun DataRowUi(
    row: DataRow,
    store: DataSettingsStore,
    connectedWearables: List<WearableSource>,
    enabled: Boolean,
    greyOut: Boolean
) {
    val alpha = if (greyOut) 0.55f else 1.0f

    // Wearable selection (dropdown) is stored per-table.
    // Phone/manual/reference rows don’t use it.
    var selectedWearable by remember(row.table) {
        mutableStateOf(store.getSelectedWearable(row.table, row.defaultWearable))
    }

    // Active is stored per table + (wearable if applicable)
    var active by remember(row.table) {
        mutableStateOf(
            store.getActive(
                table = row.table,
                wearable = if (row.collectedByKind == CollectedByKind.WEARABLE) selectedWearable else null,
                defaultValue = defaultActiveFor(row)
            )
        )
    }

    // If connected wearables change and current selection is no longer allowed, snap to first available.
    if (row.collectedByKind == CollectedByKind.WEARABLE) {
        val allowed = connectedWearables
        if (allowed.isEmpty()) {
            // keep selection but row disabled; no action needed
        } else if (!allowed.contains(selectedWearable)) {
            selectedWearable = allowed.first()
            store.setSelectedWearable(row.table, selectedWearable)
            active = store.getActive(
                table = row.table,
                wearable = selectedWearable,
                defaultValue = defaultActiveFor(row)
            )
        }
    }

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .alpha(alpha),
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // Type column
        Column(modifier = Modifier.weight(0.46f)) {
            Text(row.table, style = MaterialTheme.typography.bodyMedium)
            if (row.collectedByLabel.isNotBlank()) {
                Spacer(Modifier.height(2.dp))
                Text(
                    row.collectedByLabel,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.alpha(0.75f)
                )
            }
        }

        // Collected By column
        Column(modifier = Modifier.weight(0.34f)) {
            when (row.collectedByKind) {
                CollectedByKind.PHONE -> {
                    Text("Phone", style = MaterialTheme.typography.bodyMedium)
                }

                CollectedByKind.MANUAL -> {
                    Text("User", style = MaterialTheme.typography.bodyMedium)
                }

                CollectedByKind.REFERENCE -> {
                    Text("Reference", style = MaterialTheme.typography.bodyMedium)
                }

                CollectedByKind.WEARABLE -> {
                    val options = connectedWearables.map { it.label }
                    val selectedIndex = options.indexOf(selectedWearable.label).coerceAtLeast(0)

                    if (options.isEmpty()) {
                        Text("No wearable", style = MaterialTheme.typography.bodyMedium)
                    } else {
                        // Reuse existing dropdown helper to stay consistent with the codebase.
                        AppDropdown(
                            options = options,
                            selectedIndex = selectedIndex,
                            onSelected = { idx ->
                                val newSel = connectedWearables.getOrNull(idx) ?: return@AppDropdown
                                selectedWearable = newSel
                                store.setSelectedWearable(row.table, newSel)

                                // Reload active for the new wearable/source
                                active = store.getActive(
                                    table = row.table,
                                    wearable = newSel,
                                    defaultValue = defaultActiveFor(row)
                                )
                            }
                        )
                    }
                }
            }
        }

        // Active column
        Column(modifier = Modifier.weight(0.20f)) {
            val canToggle = enabled && row.collectedByKind != CollectedByKind.REFERENCE
            Row {
                Switch(
                    checked = active,
                    onCheckedChange = { new ->
                        if (!canToggle) return@Switch
                        active = new
                        store.setActive(
                            table = row.table,
                            wearable = if (row.collectedByKind == CollectedByKind.WEARABLE) selectedWearable else null,
                            value = new
                        )
                    },
                    enabled = canToggle
                )
                Spacer(Modifier.width(2.dp))
            }
        }
    }
}

private fun defaultActiveFor(row: DataRow): Boolean {
    return when (row.collectedByKind) {
        CollectedByKind.REFERENCE -> false
        else -> true
    }
}

/** Helpers to build rows consistently */
private fun wearableRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.WEARABLE,
        collectedByLabel = label,
        defaultWearable = WearableSource.WHOOP
    )

private fun phoneRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.PHONE,
        collectedByLabel = label
    )

private fun manualRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.MANUAL,
        collectedByLabel = label
    )

private fun referenceRow(table: String, label: String): DataRow =
    DataRow(
        table = table,
        collectedByKind = CollectedByKind.REFERENCE,
        collectedByLabel = label
    )

/** Data model */
private data class DataSection(
    val title: String,
    val rows: List<DataRow>
)

private data class DataRow(
    val table: String,
    val collectedByKind: CollectedByKind,
    val collectedByLabel: String,
    val defaultWearable: WearableSource? = null
)

private enum class CollectedByKind {
    PHONE,
    WEARABLE,
    MANUAL,
    REFERENCE
}

private enum class WearableSource(val key: String, val label: String) {
    WHOOP("whoop", "WHOOP")
}

/**
 * Local persistence for Data settings.
 * Stores:
 * - Selected wearable per table: data_source_<table> = whoop
 * - Active per table:
 *    - phone/manual/reference: data_active_<table>
 *    - wearable: data_active_<table>_<source>
 */
private class DataSettingsStore(context: Context) {
    private val prefs = context.getSharedPreferences("data_settings", Context.MODE_PRIVATE)

    fun getSelectedWearable(table: String, fallback: WearableSource?): WearableSource {
        val key = "data_source_$table"
        val raw = prefs.getString(key, null) ?: fallback?.key ?: WearableSource.WHOOP.key
        return WearableSource.values().firstOrNull { it.key == raw } ?: WearableSource.WHOOP
    }

    fun setSelectedWearable(table: String, wearable: WearableSource) {
        prefs.edit().putString("data_source_$table", wearable.key).apply()
    }

    fun getActive(
        table: String,
        wearable: WearableSource?,
        defaultValue: Boolean
    ): Boolean {
        val key = activeKey(table, wearable)
        return prefs.getBoolean(key, defaultValue)
    }

    fun setActive(
        table: String,
        wearable: WearableSource?,
        value: Boolean
    ) {
        prefs.edit().putBoolean(activeKey(table, wearable), value).apply()
    }

    private fun activeKey(table: String, wearable: WearableSource?): String {
        return if (wearable == null) {
            "data_active_$table"
        } else {
            "data_active_${table}_${wearable.key}"
        }
    }
}

title: EdgeFunctionsService.kt
text:
// FILE: app/src/main/java/com/migraineme/EdgeFunctionsService.kt
package com.migraineme

import android.content.Context
import android.util.Log
import io.ktor.client.HttpClient
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.Instant

class EdgeFunctionsService {

    @Serializable
    private data class WhoopTokenUpsertBody(
        @SerialName("access_token") val accessToken: String,
        @SerialName("refresh_token") val refreshToken: String,
        @SerialName("token_type") val tokenType: String,
        // timestamptz in Supabase. Send ISO8601 or null.
        @SerialName("expires_at") val expiresAtIso: String? = null
    )

    private fun buildClient(): HttpClient {
        return HttpClient(Android) {
            install(ContentNegotiation) {
                json(
                    Json {
                        ignoreUnknownKeys = true
                        encodeDefaults = true
                        explicitNulls = false
                    }
                )
            }
        }
    }

    /**
     * Upserts WHOOP token into Supabase (public.whoop_tokens) via edge function.
     *
     * Returns true if request succeeded (2xx), false otherwise.
     */
    suspend fun upsertWhoopTokenToSupabase(context: Context, token: WhoopToken): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val expiresIso = token.expiresAtMillis
            .takeIf { it > 0L }
            ?.let { Instant.ofEpochMilli(it).toString() }

        val body = WhoopTokenUpsertBody(
            accessToken = token.accessToken,
            refreshToken = token.refreshToken,
            tokenType = token.tokenType.ifBlank { "Bearer" },
            expiresAtIso = expiresIso
        )

        val client = buildClient()
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/upsert-whoop-token"

            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                val bodyText = runCatching { res.bodyAsText() }.getOrDefault("")
                Log.e("EdgeFunctionsService", "upsertWhoopToken failed: ${res.status.value} $bodyText")
            }
            ok
        } catch (t: Throwable) {
            Log.e("EdgeFunctionsService", "upsertWhoopToken exception", t)
            false
        } finally {
            client.close()
        }
    }

    /**
     * Best-effort enqueue of login backfill. Does not throw.
     */
    suspend fun enqueueLoginBackfill(context: Context) {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return

        val client = HttpClient(Android)
        try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/enqueue-login-backfill"
            client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header("Authorization", "Bearer $supaAccessToken")
                header("Content-Type", "application/json")
            }
        } catch (_: Throwable) {
            // best-effort
        } finally {
            client.close()
        }
    }

    /**
     * Guaranteed-mode enqueue (returns success/failure so WorkManager can retry).
     */
    suspend fun enqueueLoginBackfillGuaranteed(context: Context): Boolean {
        val appCtx = context.applicationContext
        val supaAccessToken = SessionStore.getValidAccessToken(appCtx) ?: return false

        val client = HttpClient(Android)
        return try {
            val url = "${BuildConfig.SUPABASE_URL.trimEnd('/')}/functions/v1/enqueue-login-backfill"
            val res = client.post(url) {
                header("apikey", BuildConfig.SUPABASE_ANON_KEY)
                header(HttpHeaders.Authorization, "Bearer $supaAccessToken")
                header(HttpHeaders.ContentType, "application/json")
                setBody("{}")
            }

            val ok = res.status.value in 200..299
            if (!ok) {
                val bodyText = runCatching { res.bodyAsText() }.getOrDefault("")
                Log.w("EdgeFunctionsService", "enqueueLoginBackfill failed: ${res.status.value} $bodyText")
            }
            ok
        } catch (t: Throwable) {
            Log.w("EdgeFunctionsService", "enqueueLoginBackfill exception", t)
            false
        } finally {
            client.close()
        }
    }
}

title: EditMedicineScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun EditMedicineScreen(
    navController: NavHostController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken, id) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) {
            vm.loadMedicineById(token, id)
            vm.loadMedicineOptions(token)
            vm.loadMigraines(token)
        }
    }

    val row by vm.editMedicine.collectAsState()
    val frequent by vm.medicineOptionsFrequent.collectAsState()
    val all by vm.medicineOptionsAll.collectAsState()
    val migraines by vm.migraines.collectAsState()

    var name by rememberSaveable(row?.id) { mutableStateOf(row?.name ?: "") }
    var amount by rememberSaveable(row?.id) { mutableStateOf(row?.amount ?: "") }
    var startAt by rememberSaveable(row?.id) { mutableStateOf(row?.startAt ?: "") }
    var notes by rememberSaveable(row?.id) { mutableStateOf(row?.notes ?: "") }
    var migraineId by rememberSaveable(row?.id) { mutableStateOf(row?.migraineId ?: "") }

    var nameMenuOpen by rememberSaveable { mutableStateOf(false) }
    var migraineMenuOpen by rememberSaveable { mutableStateOf(false) }

    fun labelForMigraine(startIso: String?): String {
        if (startIso.isNullOrBlank()) return "Unknown"
        return try {
            val odt = runCatching { OffsetDateTime.parse(startIso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(startIso)
            ldt.format(DateTimeFormatter.ofPattern("EEE, dd MMM yyyy • HH:mm"))
        } catch (_: Exception) { "Unknown" }
    }
    val selectedMigraineLabel = migraines
        .firstOrNull { it.id == migraineId }
        ?.let { labelForMigraine(it.startAt) }
        ?: "None"

    fun formatIsoDdMmHm(iso: String?): String {
        if (iso.isNullOrBlank()) return "Not set"
        return try {
            val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
            ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
        } catch (_: Exception) { "Not set" }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Edit Medicine")

        // Name dropdown with Frequent / All
        if (frequent.isNotEmpty() || all.isNotEmpty()) {
            Box(modifier = Modifier.fillMaxWidth()) {
                OutlinedTextField(
                    value = name,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Name") },
                    trailingIcon = {
                        IconButton(onClick = { nameMenuOpen = true }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose medicine")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(
                    expanded = nameMenuOpen,
                    onDismissRequest = { nameMenuOpen = false }
                ) {
                    if (frequent.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        frequent.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    name = opt
                                    nameMenuOpen = false
                                }
                            )
                        }
                        if (all.isNotEmpty()) Divider()
                    }
                    if (all.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("All", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        all.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    name = opt
                                    nameMenuOpen = false
                                }
                            )
                        }
                    }
                }
            }
        } else {
            OutlinedTextField(
                value = name,
                onValueChange = { name = it },
                label = { Text("Name") },
                modifier = Modifier.fillMaxWidth()
            )
        }

        OutlinedTextField(
            value = amount,
            onValueChange = { amount = it },
            label = { Text("Amount") },
            modifier = Modifier.fillMaxWidth()
        )

        // Start time using shared picker
        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
            Text("Start time: ${formatIsoDdMmHm(startAt)}")
            AppDateTimePicker(
                label = "Select time",
                onDateTimeSelected = { iso -> startAt = iso ?: "" }
            )
        }

        OutlinedTextField(
            value = notes,
            onValueChange = { notes = it },
            label = { Text("Notes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Linked Migraine dropdown with time/day labels
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedMigraineLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Linked Migraine") },
                trailingIcon = {
                    IconButton(onClick = { migraineMenuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = migraineMenuOpen,
                onDismissRequest = { migraineMenuOpen = false }
            ) {
                DropdownMenuItem(
                    text = { Text("None") },
                    onClick = {
                        migraineId = ""
                        migraineMenuOpen = false
                    }
                )
                migraines
                    .sortedByDescending { it.startAt }
                    .forEach { m ->
                        val label = labelForMigraine(m.startAt)
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                migraineId = m.id
                                migraineMenuOpen = false
                            }
                        )
                    }
            }
        }

        Spacer(Modifier.height(8.dp))

        Button(
            onClick = {
                val token = authState.accessToken
                if (!token.isNullOrBlank()) {
                    vm.updateMedicine(
                        accessToken = token,
                        id = id,
                        name = name.ifBlank { null },
                        amount = amount.ifBlank { null },
                        startAt = startAt.ifBlank { null },
                        notes = notes.ifBlank { null },
                        migraineId = migraineId.ifBlank { null }
                    )
                    navController.popBackStack()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save")
        }

        TextButton(
            onClick = { navController.popBackStack() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancel")
        }
    }
}

title: EditMigraineScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.AssistChip
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow

/* ---------- Top-level types ---------- */

private enum class Step { CORE, TRIGGERS, MEDICINES, RELIEFS, REVIEW }

private data class PendingTrigger(val type: String, val startIso: String?)
private data class PendingMedicine(val name: String, val amount: String?, val startIso: String?, val notes: String?)
private data class PendingRelief(val type: String, val durationMinutes: Int?, val startIso: String?, val notes: String?)

/* ----------------------------------------------------------------------------- */

@Composable
fun EditMigraineScreen(
    navController: NavController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val auth by authVm.state.collectAsState()
    val token = auth.accessToken

    // Supabase access unchanged
    val db = remember { SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY) }
    val scope = rememberCoroutineScope()

    // Stepper (same order as draft flow)
    var step by remember { mutableStateOf(Step.CORE) }

    // Base row and loading
    var row by remember { mutableStateOf<SupabaseDbService.MigraineRow?>(null) }
    var loading by remember { mutableStateOf(true) }
    var error by remember { mutableStateOf<String?>(null) }
    var saving by remember { mutableStateOf(false) }

    // Pools and prefs
    var mgFrequent by remember { mutableStateOf(listOf<String>()) }
    var mgAll by remember { mutableStateOf(listOf<String>()) }

    var trigPool by remember { mutableStateOf(listOf<SupabaseDbService.AllTriggerRow>()) }
    var trigFreq by remember { mutableStateOf(listOf<String>()) }

    var medPool by remember { mutableStateOf(listOf<SupabaseDbService.AllMedicineRow>()) }
    var medFreq by remember { mutableStateOf(listOf<String>()) }

    var relPool by remember { mutableStateOf(listOf<SupabaseDbService.AllReliefRow>()) }
    var relFreq by remember { mutableStateOf(listOf<String>()) }

    // Linked rows
    var linkedTriggers by remember { mutableStateOf(listOf<SupabaseDbService.TriggerRow>()) }
    var linkedMeds by remember { mutableStateOf(listOf<SupabaseDbService.MedicineRow>()) }
    var linkedRels by remember { mutableStateOf(listOf<SupabaseDbService.ReliefRow>()) }

    // Draft (single save)
    var selectedLabel by remember { mutableStateOf<String?>(null) }
    var severity by remember { mutableStateOf(5f) }
    var beganAt by remember { mutableStateOf<String?>(null) }
    var endedAt by remember { mutableStateOf<String?>(null) }
    var notes by remember { mutableStateOf(TextFieldValue("")) }

    // Queues for adds and deletes
    var addTriggers by remember { mutableStateOf(listOf<PendingTrigger>()) }
    var addMeds by remember { mutableStateOf(listOf<PendingMedicine>()) }
    var addRels by remember { mutableStateOf(listOf<PendingRelief>()) }

    var deleteTriggerIds by remember { mutableStateOf(setOf<String>()) }
    var deleteMedicineIds by remember { mutableStateOf(setOf<String>()) }
    var deleteReliefIds by remember { mutableStateOf(setOf<String>()) }

    // UI flags
    var typeMenuOpen by remember { mutableStateOf(false) }
    var showAddTrig by remember { mutableStateOf<String?>(null) }
    var showAddMed by remember { mutableStateOf<String?>(null) }
    var showAddRel by remember { mutableStateOf<String?>(null) }

    // Validation
    val endBeforeStart by derivedStateOf { isEndBeforeStart(beganAt, endedAt) }

    // Load data
    LaunchedEffect(token, id) {
        if (token.isNullOrBlank()) return@LaunchedEffect
        try {
            loading = true
            error = null

            row = db.getMigraineById(token, id)

            val mgPrefs = db.getMigrainePrefs(token)
            mgFrequent = mgPrefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.migraine?.label }
            mgAll = db.getAllMigrainePool(token).map { it.label }

            val tprefs = db.getTriggerPrefs(token)
            trigFreq = tprefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.trigger?.label }
            trigPool = db.getAllTriggerPool(token)

            val mprefs = db.getMedicinePrefs(token)
            medFreq = mprefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.medicine?.label }
            medPool = db.getAllMedicinePool(token)

            val rprefs = db.getReliefPrefs(token)
            relFreq = rprefs.filter { it.status == "frequent" }.sortedBy { it.position }
                .mapNotNull { it.relief?.label }
            relPool = db.getAllReliefPool(token)

            linkedTriggers = db.getAllTriggers(token).filter { it.migraineId == id }.sortedByDescending { it.startAt }
            linkedMeds = db.getAllMedicines(token).filter { it.migraineId == id }.sortedByDescending { it.startAt }
            linkedRels = db.getAllReliefs(token).filter { it.migraineId == id }.sortedByDescending { it.startAt }
        } catch (e: Exception) {
            e.printStackTrace()
            error = e.message ?: "Failed to load"
        } finally {
            loading = false
        }
    }

    // Seed draft
    LaunchedEffect(row?.id) {
        row?.let {
            selectedLabel = it.type ?: "Migraine"
            severity = (it.severity ?: 5).coerceIn(1, 10).toFloat()
            beganAt = it.startAt
            endedAt = it.endAt
            notes = TextFieldValue(it.notes ?: "")
            addTriggers = emptyList(); addMeds = emptyList(); addRels = emptyList()
            deleteTriggerIds = emptySet(); deleteMedicineIds = emptySet(); deleteReliefIds = emptySet()
        }
    }

    // Bottom bar and stepper
    Scaffold(
        bottomBar = {
            Row(
                Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                OutlinedButton(
                    onClick = {
                        when (step) {
                            Step.CORE -> navController.popBackStack()
                            Step.TRIGGERS -> step = Step.CORE
                            Step.MEDICINES -> step = Step.TRIGGERS
                            Step.RELIEFS -> step = Step.MEDICINES
                            Step.REVIEW -> step = Step.RELIEFS
                        }
                    },
                    enabled = !saving
                ) { Text(if (step == Step.CORE) "Back" else "Previous") }

                when (step) {
                    Step.CORE, Step.TRIGGERS, Step.MEDICINES, Step.RELIEFS -> {
                        Button(
                            onClick = {
                                step = when (step) {
                                    Step.CORE -> Step.TRIGGERS
                                    Step.TRIGGERS -> Step.MEDICINES
                                    Step.MEDICINES -> Step.RELIEFS
                                    Step.RELIEFS -> Step.REVIEW
                                    Step.REVIEW -> Step.REVIEW
                                }
                            },
                            enabled = !saving && !(step == Step.CORE && endBeforeStart)
                        ) { Text("Next") }
                    }
                    Step.REVIEW -> {
                        Button(
                            onClick = {
                                if (token.isNullOrBlank() || row == null) return@Button
                                scope.launch {
                                    try {
                                        saving = true
                                        if (endBeforeStart) {
                                            error = "End time cannot be before start time"
                                            saving = false
                                            return@launch
                                        }
                                        // Update migraine
                                        row = db.updateMigraine(
                                            accessToken = token,
                                            id = id,
                                            type = selectedLabel,
                                            severity = severity.toInt(),
                                            startAt = beganAt,
                                            endAt = endedAt,
                                            notes = notes.text
                                        )
                                        // Deletes
                                        deleteTriggerIds.forEach { runCatching { db.deleteTrigger(token, it) } }
                                        deleteMedicineIds.forEach { runCatching { db.deleteMedicine(token, it) } }
                                        deleteReliefIds.forEach { runCatching { db.deleteRelief(token, it) } }
                                        // Adds
                                        addTriggers.forEach { t ->
                                            runCatching {
                                                db.insertTrigger(
                                                    accessToken = token,
                                                    migraineId = id,
                                                    type = t.type,
                                                    startAt = t.startIso ?: beganAt,
                                                    notes = null
                                                )
                                            }
                                        }
                                        addMeds.forEach { m ->
                                            runCatching {
                                                db.insertMedicine(
                                                    accessToken = token,
                                                    migraineId = id,
                                                    name = m.name,
                                                    amount = m.amount,
                                                    startAt = m.startIso ?: beganAt,
                                                    notes = m.notes
                                                )
                                            }
                                        }
                                        addRels.forEach { r ->
                                            runCatching {
                                                db.insertRelief(
                                                    accessToken = token,
                                                    migraineId = id,
                                                    type = r.type,
                                                    durationMinutes = r.durationMinutes,
                                                    startAt = r.startIso ?: beganAt,
                                                    notes = r.notes
                                                )
                                            }
                                        }
                                        vm.loadJournal(token)
                                        navController.popBackStack()
                                    } catch (e: Exception) {
                                        e.printStackTrace()
                                        error = e.message ?: "Failed to save"
                                    } finally {
                                        saving = false
                                    }
                                }
                            },
                            enabled = !saving && !endBeforeStart
                        ) { Text(if (saving) "Saving..." else "Save") }
                    }
                }
            }
        }
    ) { inner ->
        if (loading) {
            Box(Modifier.fillMaxSize().padding(inner), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
            }
            return@Scaffold
        }
        if (error != null || row == null) {
            Column(Modifier.fillMaxSize().padding(inner).padding(16.dp)) {
                Text(error ?: "Not found")
                Spacer(Modifier.height(12.dp))
                OutlinedButton(onClick = { navController.popBackStack() }) { Text("Back") }
            }
            return@Scaffold
        }

        when (step) {
            Step.CORE -> CorePage(
                selectedLabel = selectedLabel,
                onSelectLabel = { selectedLabel = it },
                mgFrequent = mgFrequent,
                mgAll = mgAll,
                typeMenuOpen = typeMenuOpen,
                setTypeMenuOpen = { typeMenuOpen = it },
                severity = severity,
                setSeverity = { severity = it.coerceIn(1f, 10f) },
                beganAt = beganAt,
                setBeganAt = { beganAt = it },
                endedAt = endedAt,
                setEndedAt = { endedAt = it },
                endBeforeStart = endBeforeStart,
                notes = notes,
                setNotes = { notes = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.TRIGGERS -> TriggersPage(
                trigFreq = trigFreq,
                trigPool = trigPool.map { it.label },
                linked = linkedTriggers,
                addQueue = addTriggers,
                onQueueRemove = { addTriggers = addTriggers.filterNot { p -> p === it } },
                deleteIds = deleteTriggerIds,
                toggleDelete = { idToggle ->
                    deleteTriggerIds = if (deleteTriggerIds.contains(idToggle)) deleteTriggerIds - idToggle else deleteTriggerIds + idToggle
                },
                setShowAddTrig = { showAddTrig = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.MEDICINES -> MedicinesPage(
                medFreq = medFreq,
                medPool = medPool.map { it.label },
                linked = linkedMeds,
                addQueue = addMeds,
                onQueueRemove = { addMeds = addMeds.filterNot { p -> p === it } },
                deleteIds = deleteMedicineIds,
                toggleDelete = { idToggle ->
                    deleteMedicineIds = if (deleteMedicineIds.contains(idToggle)) deleteMedicineIds - idToggle else deleteMedicineIds + idToggle
                },
                setShowAddMed = { showAddMed = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.RELIEFS -> ReliefsPage(
                relFreq = relFreq,
                relPool = relPool.map { it.label },
                linked = linkedRels,
                addQueue = addRels,
                onQueueRemove = { addRels = addRels.filterNot { p -> p === it } },
                deleteIds = deleteReliefIds,
                toggleDelete = { idToggle ->
                    deleteReliefIds = if (deleteReliefIds.contains(idToggle)) deleteReliefIds - idToggle else deleteReliefIds + idToggle
                },
                setShowAddRel = { showAddRel = it },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(horizontal = 16.dp)
            )
            Step.REVIEW -> ReviewPage(
                label = selectedLabel,
                severity = severity.toInt(),
                beganAt = beganAt,
                endedAt = endedAt,
                notes = notes.text,
                deletes = Triple(deleteTriggerIds.size, deleteMedicineIds.size, deleteReliefIds.size),
                adds = Triple(addTriggers.size, addMeds.size, addRels.size),
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
                    .padding(16.dp)
            )
        }
    }

    // Add dialogs (queue only)
    if (showAddTrig != null) {
        TimeAddDialog(
            title = "Add trigger",
            onDismiss = { showAddTrig = null },
            onConfirm = { iso ->
                val label = showAddTrig ?: return@TimeAddDialog
                addTriggers = listOf(PendingTrigger(type = label, startIso = iso)) + addTriggers
                showAddTrig = null
            }
        )
    }
    if (showAddMed != null) {
        MedicineAddDialog(
            title = "Add medicine",
            name = showAddMed!!,
            onDismiss = { showAddMed = null },
            onConfirm = { amount, iso, notesText ->
                val name = showAddMed ?: return@MedicineAddDialog
                addMeds = listOf(PendingMedicine(name, amount, iso, notesText)) + addMeds
                showAddMed = null
            }
        )
    }
    if (showAddRel != null) {
        ReliefAddDialog(
            title = "Add relief",
            typeLabel = showAddRel!!,
            onDismiss = { showAddRel = null },
            onConfirm = { durationMinutes, iso, notesText ->
                val type = showAddRel ?: return@ReliefAddDialog
                addRels = listOf(PendingRelief(type, durationMinutes, iso, notesText)) + addRels
                showAddRel = null
            }
        )
    }
}

/* -------------------- Pages -------------------- */

@Composable
private fun CorePage(
    selectedLabel: String?,
    onSelectLabel: (String) -> Unit,
    mgFrequent: List<String>,
    mgAll: List<String>,
    typeMenuOpen: Boolean,
    setTypeMenuOpen: (Boolean) -> Unit,
    severity: Float,
    setSeverity: (Float) -> Unit,
    beganAt: String?,
    setBeganAt: (String?) -> Unit,
    endedAt: String?,
    setEndedAt: (String?) -> Unit,
    endBeforeStart: Boolean,
    notes: TextFieldValue,
    setNotes: (TextFieldValue) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            Column {
                OutlinedTextField(
                    value = selectedLabel ?: "Migraine",
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Migraine selection") },
                    trailingIcon = {
                        IconButton(onClick = { setTypeMenuOpen(true) }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(expanded = typeMenuOpen, onDismissRequest = { setTypeMenuOpen(false) }) {
                    if (mgFrequent.isNotEmpty()) {
                        DropdownMenuItem(text = { Text("Frequent") }, onClick = {}, enabled = false)
                        mgFrequent.forEach { label ->
                            DropdownMenuItem(text = { Text(label) }, onClick = {
                                setTypeMenuOpen(false); onSelectLabel(label)
                            })
                        }
                        HorizontalDivider()
                    }
                    if (mgAll.isNotEmpty()) {
                        DropdownMenuItem(text = { Text("All") }, onClick = {}, enabled = false)
                        mgAll.forEach { label ->
                            DropdownMenuItem(text = { Text(label) }, onClick = {
                                setTypeMenuOpen(false); onSelectLabel(label)
                            })
                        }
                    }
                }
            }
        }
        item {
            Column {
                Text("Severity: ${severity.toInt()}", style = MaterialTheme.typography.bodyMedium)
                Slider(
                    value = severity,
                    onValueChange = setSeverity,
                    valueRange = 1f..10f,
                    steps = 8,
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                AppDateTimePicker(label = "Start time") { iso -> setBeganAt(iso) }
                Text("Current: ${formatIsoDdMmYyHm(beganAt)}")
                AppDateTimePicker(label = "End time") { iso -> setEndedAt(iso) }
                Text("Current: ${formatIsoDdMmYyHm(endedAt)}")
                if (endBeforeStart) {
                    Text("End time cannot be before start time", color = MaterialTheme.colorScheme.error)
                }
            }
        }
        item {
            OutlinedTextField(
                value = notes,
                onValueChange = setNotes,
                label = { Text("Notes") },
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
private fun TriggersPage(
    trigFreq: List<String>,
    trigPool: List<String>,
    linked: List<SupabaseDbService.TriggerRow>,
    addQueue: List<PendingTrigger>,
    onQueueRemove: (PendingTrigger) -> Unit,
    deleteIds: Set<String>,
    toggleDelete: (String) -> Unit,
    setShowAddTrig: (String?) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item { Text("Triggers", style = MaterialTheme.typography.titleMedium) }
        items(linked, key = { it.id }) { t ->
            val mark = deleteIds.contains(t.id)
            ElevatedCard(Modifier.fillMaxWidth()) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text("Type: ${t.type ?: "-"}")
                        Text("Time: ${formatIsoDdMmYyHm(t.startAt)}")
                        if (!t.notes.isNullOrBlank()) Text("Notes: ${t.notes}")
                        if (mark) Text("Marked for deletion", color = MaterialTheme.colorScheme.error)
                    }
                    Row {
                        TextButton(onClick = { /* optional edit route */ }) { Text("Edit") }
                        IconButton(onClick = { toggleDelete(t.id) }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Toggle delete trigger")
                        }
                    }
                }
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (trigFreq.isNotEmpty()) {
                    Text("Frequent", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { trigFreq.forEach { label -> AssistChip(onClick = { setShowAddTrig(label) }, label = { Text(label) }) } }
                }
                val remaining = trigPool.filter { it !in trigFreq }
                if (remaining.isNotEmpty()) {
                    Text("All", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { remaining.forEach { label -> AssistChip(onClick = { setShowAddTrig(label) }, label = { Text(label) }) } }
                }
            }
        }
        if (addQueue.isNotEmpty()) {
            item { Text("Pending triggers", style = MaterialTheme.typography.titleSmall) }
            items(addQueue) { pt ->
                ElevatedCard(Modifier.fillMaxWidth()) {
                    Row(
                        Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Column {
                            Text("Type: ${pt.type}")
                            Text("Time: ${formatIsoDdMmYyHm(pt.startIso)}")
                        }
                        TextButton(onClick = { onQueueRemove(pt) }) { Text("Remove") }
                    }
                }
            }
        }
    }
}

@Composable
private fun MedicinesPage(
    medFreq: List<String>,
    medPool: List<String>,
    linked: List<SupabaseDbService.MedicineRow>,
    addQueue: List<PendingMedicine>,
    onQueueRemove: (PendingMedicine) -> Unit,
    deleteIds: Set<String>,
    toggleDelete: (String) -> Unit,
    setShowAddMed: (String?) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item { Text("Medicines", style = MaterialTheme.typography.titleMedium) }
        items(linked, key = { it.id }) { m ->
            val mark = deleteIds.contains(m.id)
            ElevatedCard(Modifier.fillMaxWidth()) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text("Name: ${m.name ?: "-"}")
                        Text("Amount: ${m.amount ?: "-"}")
                        Text("Time: ${formatIsoDdMmYyHm(m.startAt)}")
                        if (!m.notes.isNullOrBlank()) Text("Notes: ${m.notes}")
                        if (mark) Text("Marked for deletion", color = MaterialTheme.colorScheme.error)
                    }
                    Row {
                        TextButton(onClick = { /* optional edit route */ }) { Text("Edit") }
                        IconButton(onClick = { toggleDelete(m.id) }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Toggle delete medicine")
                        }
                    }
                }
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (medFreq.isNotEmpty()) {
                    Text("Frequent", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { medFreq.forEach { label -> AssistChip(onClick = { setShowAddMed(label) }, label = { Text(label) }) } }
                }
                val remaining = medPool.filter { it !in medFreq }
                if (remaining.isNotEmpty()) {
                    Text("All", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { remaining.forEach { label -> AssistChip(onClick = { setShowAddMed(label) }, label = { Text(label) }) } }
                }
            }
        }
        if (addQueue.isNotEmpty()) {
            item { Text("Pending medicines", style = MaterialTheme.typography.titleSmall) }
            items(addQueue) { pm ->
                ElevatedCard(Modifier.fillMaxWidth()) {
                    Row(
                        Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Column {
                            Text("Name: ${pm.name}")
                            Text("Amount: ${pm.amount ?: "-"}")
                            Text("Time: ${formatIsoDdMmYyHm(pm.startIso)}")
                            if (!pm.notes.isNullOrBlank()) Text("Notes: ${pm.notes}")
                        }
                        TextButton(onClick = { onQueueRemove(pm) }) { Text("Remove") }
                    }
                }
            }
        }
    }
}

@Composable
private fun ReliefsPage(
    relFreq: List<String>,
    relPool: List<String>,
    linked: List<SupabaseDbService.ReliefRow>,
    addQueue: List<PendingRelief>,
    onQueueRemove: (PendingRelief) -> Unit,
    deleteIds: Set<String>,
    toggleDelete: (String) -> Unit,
    setShowAddRel: (String?) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(vertical = 16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item { Text("Reliefs", style = MaterialTheme.typography.titleMedium) }
        items(linked, key = { it.id }) { r ->
            val mark = deleteIds.contains(r.id)
            ElevatedCard(Modifier.fillMaxWidth()) {
                Row(
                    Modifier
                        .fillMaxWidth()
                        .padding(12.dp),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Column {
                        Text("Type: ${r.type ?: "-"}")
                        Text("Duration: ${r.durationMinutes ?: 0} min")
                        Text("Time: ${formatIsoDdMmYyHm(r.startAt)}")
                        if (!r.notes.isNullOrBlank()) Text("Notes: ${r.notes}")
                        if (mark) Text("Marked for deletion", color = MaterialTheme.colorScheme.error)
                    }
                    Row {
                        TextButton(onClick = { /* optional edit route */ }) { Text("Edit") }
                        IconButton(onClick = { toggleDelete(r.id) }) {
                            Icon(Icons.Filled.Delete, contentDescription = "Toggle delete relief")
                        }
                    }
                }
            }
        }
        item {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                if (relFreq.isNotEmpty()) {
                    Text("Frequent", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { relFreq.forEach { label -> AssistChip(onClick = { setShowAddRel(label) }, label = { Text(label) }) } }
                }
                val remaining = relPool.filter { it !in relFreq }
                if (remaining.isNotEmpty()) {
                    Text("All", style = MaterialTheme.typography.titleSmall)
                    FlowRowWrap { remaining.forEach { label -> AssistChip(onClick = { setShowAddRel(label) }, label = { Text(label) }) } }
                }
            }
        }
        if (addQueue.isNotEmpty()) {
            item { Text("Pending reliefs", style = MaterialTheme.typography.titleSmall) }
            items(addQueue) { pr ->
                ElevatedCard(Modifier.fillMaxWidth()) {
                    Row(
                        Modifier
                            .fillMaxWidth()
                            .padding(12.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Column {
                            Text("Type: ${pr.type}")
                            Text("Duration: ${pr.durationMinutes ?: 0} min")
                            Text("Time: ${formatIsoDdMmYyHm(pr.startIso)}")
                            if (!pr.notes.isNullOrBlank()) Text("Notes: ${pr.notes}")
                        }
                        TextButton(onClick = { onQueueRemove(pr) }) { Text("Remove") }
                    }
                }
            }
        }
    }
}

@Composable
private fun ReviewPage(
    label: String?,
    severity: Int,
    beganAt: String?,
    endedAt: String?,
    notes: String?,
    deletes: Triple<Int, Int, Int>,
    adds: Triple<Int, Int, Int>,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier, verticalArrangement = Arrangement.spacedBy(12.dp)) {
        Text("Review", style = MaterialTheme.typography.titleLarge)
        Text("Migraine: ${label ?: "Migraine"}")
        Text("Severity: $severity")
        Text("Start: ${formatIsoDdMmYyHm(beganAt)}")
        Text("End: ${formatIsoDdMmYyHm(endedAt)}")
        if (!notes.isNullOrBlank()) Text("Notes: $notes")
        Spacer(Modifier.height(8.dp))
        Text("Queued changes:", style = MaterialTheme.typography.titleMedium)
        Text("Delete → Triggers: ${deletes.first}, Medicines: ${deletes.second}, Reliefs: ${deletes.third}")
        Text("Add → Triggers: ${adds.first}, Medicines: ${adds.second}, Reliefs: ${adds.third}")
    }
}

/* -------------------- Helpers -------------------- */

@OptIn(ExperimentalLayoutApi::class)
@Composable
private fun FlowRowWrap(content: @Composable () -> Unit) {
    FlowRow(
        horizontalArrangement = Arrangement.spacedBy(8.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
        modifier = Modifier.fillMaxWidth()
    ) { content() }
}

private fun formatIsoDdMmYyHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "-"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        "-"
    }
}

private fun isEndBeforeStart(startIso: String?, endIso: String?): Boolean {
    if (startIso.isNullOrBlank() || endIso.isNullOrBlank()) return false
    val start = parseInstantFlexible(startIso) ?: return false
    val end = parseInstantFlexible(endIso) ?: return false
    return end.isBefore(start)
}

private fun parseInstantFlexible(iso: String): Instant? {
    return runCatching { Instant.parse(iso) }.getOrElse {
        runCatching { OffsetDateTime.parse(iso).toInstant() }.getOrNull()
    }
}

/* ---------- local dialogs ---------- */

@Composable
private fun TimeAddDialog(
    title: String,
    onDismiss: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf<String?>(null) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text("Add") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Time: ${formatIsoDdMmYyHm(pickedIso)}")
                AppDateTimePicker(label = "Select time") { iso -> pickedIso = iso }
            }
        }
    )
}

@Composable
private fun MedicineAddDialog(
    title: String,
    name: String,
    onDismiss: () -> Unit,
    onConfirm: (amount: String?, startIso: String?, notes: String?) -> Unit
) {
    var amount by remember { mutableStateOf("") }
    var pickedIso by remember { mutableStateOf<String?>(null) }
    var notes by remember { mutableStateOf("") }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(onClick = { onConfirm(amount.ifBlank { null }, pickedIso, notes.ifBlank { null }) }) {
                Text("Add")
            }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Medicine: $name")
                OutlinedTextField(
                    value = amount,
                    onValueChange = { amount = it },
                    label = { Text("Amount") },
                    modifier = Modifier.fillMaxWidth()
                )
                AppDateTimePicker(label = "Select time") { iso -> pickedIso = iso }
                OutlinedTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = { Text("Notes") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    )
}

@Composable
private fun ReliefAddDialog(
    title: String,
    typeLabel: String,
    onDismiss: () -> Unit,
    onConfirm: (durationMinutes: Int?, startIso: String?, notes: String?) -> Unit
) {
    var durationText by remember { mutableStateOf("") }
    var pickedIso by remember { mutableStateOf<String?>(null) }
    var notes by remember { mutableStateOf("") }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = {
                    val dur = durationText.toIntOrNull()
                    onConfirm(dur, pickedIso, notes.ifBlank { null })
                }
            ) { Text("Add") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text(title) },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Relief: $typeLabel")
                OutlinedTextField(
                    value = durationText,
                    onValueChange = { v -> durationText = v.filter { it.isDigit() }.take(4) },
                    label = { Text("Duration minutes") },
                    modifier = Modifier.fillMaxWidth()
                )
                AppDateTimePicker(label = "Select time") { iso -> pickedIso = iso }
                OutlinedTextField(
                    value = notes,
                    onValueChange = { notes = it },
                    label = { Text("Notes") },
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    )
}

title: EditReliefScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun EditReliefScreen(
    navController: NavHostController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken, id) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) {
            vm.loadReliefById(token, id)
            vm.loadReliefOptions(token)
            vm.loadMigraines(token)
        }
    }

    val row by vm.editRelief.collectAsState()
    val frequent by vm.reliefOptionsFrequent.collectAsState()
    val all by vm.reliefOptionsAll.collectAsState()
    val migraines by vm.migraines.collectAsState()

    var type by rememberSaveable(row?.id) { mutableStateOf(row?.type ?: "") }
    var durationText by rememberSaveable(row?.id) { mutableStateOf(row?.durationMinutes?.toString() ?: "") }
    var startAt by rememberSaveable(row?.id) { mutableStateOf(row?.startAt ?: "") }
    var notes by rememberSaveable(row?.id) { mutableStateOf(row?.notes ?: "") }
    var migraineId by rememberSaveable(row?.id) { mutableStateOf(row?.migraineId ?: "") }

    var typeMenuOpen by rememberSaveable { mutableStateOf(false) }
    var migraineMenuOpen by rememberSaveable { mutableStateOf(false) }

    fun labelForMigraine(startIso: String?): String {
        if (startIso.isNullOrBlank()) return "Unknown"
        return try {
            val odt = runCatching { OffsetDateTime.parse(startIso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(startIso)
            ldt.format(DateTimeFormatter.ofPattern("EEE, dd MMM yyyy • HH:mm"))
        } catch (_: Exception) { "Unknown" }
    }
    val selectedMigraineLabel = migraines
        .firstOrNull { it.id == migraineId }
        ?.let { labelForMigraine(it.startAt) }
        ?: "None"

    fun formatIsoDdMmHm(iso: String?): String {
        if (iso.isNullOrBlank()) return "Not set"
        return try {
            val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
            ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
        } catch (_: Exception) { "Not set" }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Edit Relief")

        // Type dropdown with Frequent / All
        if (frequent.isNotEmpty() || all.isNotEmpty()) {
            Box(modifier = Modifier.fillMaxWidth()) {
                OutlinedTextField(
                    value = type,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Type") },
                    trailingIcon = {
                        IconButton(onClick = { typeMenuOpen = true }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose type")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(
                    expanded = typeMenuOpen,
                    onDismissRequest = { typeMenuOpen = false }
                ) {
                    if (frequent.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        frequent.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                        if (all.isNotEmpty()) Divider()
                    }
                    if (all.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("All", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        all.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                    }
                }
            }
        } else {
            OutlinedTextField(
                value = type,
                onValueChange = { type = it },
                label = { Text("Type") },
                modifier = Modifier.fillMaxWidth()
            )
        }

        // Duration minutes numeric
        OutlinedTextField(
            value = durationText,
            onValueChange = { input -> durationText = input.filter { it.isDigit() }.take(4) },
            label = { Text("Duration minutes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Start time using shared picker
        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
            Text("Start time: ${formatIsoDdMmHm(startAt)}")
            AppDateTimePicker(
                label = "Select time",
                onDateTimeSelected = { iso -> startAt = iso ?: "" }
            )
        }

        OutlinedTextField(
            value = notes,
            onValueChange = { notes = it },
            label = { Text("Notes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Linked Migraine dropdown with time/day labels
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedMigraineLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Linked Migraine") },
                trailingIcon = {
                    IconButton(onClick = { migraineMenuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = migraineMenuOpen,
                onDismissRequest = { migraineMenuOpen = false }
            ) {
                DropdownMenuItem(
                    text = { Text("None") },
                    onClick = {
                        migraineId = ""
                        migraineMenuOpen = false
                    }
                )
                migraines
                    .sortedByDescending { it.startAt }
                    .forEach { m ->
                        val label = labelForMigraine(m.startAt)
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                migraineId = m.id
                                migraineMenuOpen = false
                            }
                        )
                    }
            }
        }

        Spacer(Modifier.height(8.dp))

        Button(
            onClick = {
                val token = authState.accessToken
                if (!token.isNullOrBlank()) {
                    val duration = durationText.toIntOrNull()
                    vm.updateRelief(
                        accessToken = token,
                        id = id,
                        type = type.ifBlank { null },
                        durationMinutes = duration,
                        startAt = startAt.ifBlank { null },
                        notes = notes.ifBlank { null },
                        migraineId = migraineId.ifBlank { null }
                    )
                    navController.popBackStack()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save")
        }

        TextButton(
            onClick = { navController.popBackStack() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancel")
        }
    }
}

title: EditTriggerScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@Composable
fun EditTriggerScreen(
    navController: NavHostController,
    authVm: AuthViewModel,
    vm: LogViewModel,
    id: String
) {
    val authState by authVm.state.collectAsState()

    LaunchedEffect(authState.accessToken, id) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) {
            vm.loadTriggerById(token, id)
            vm.loadTriggerOptions(token)
            vm.loadMigraines(token)
        }
    }

    val row by vm.editTrigger.collectAsState()
    val frequent by vm.triggerOptionsFrequent.collectAsState()
    val all by vm.triggerOptionsAll.collectAsState()
    val migraines by vm.migraines.collectAsState()

    var type by rememberSaveable(row?.id) { mutableStateOf(row?.type ?: "") }
    var startAt by rememberSaveable(row?.id) { mutableStateOf(row?.startAt ?: "") }
    var notes by rememberSaveable(row?.id) { mutableStateOf(row?.notes ?: "") }
    var migraineId by rememberSaveable(row?.id) { mutableStateOf(row?.migraineId ?: "") }

    var typeMenuOpen by rememberSaveable { mutableStateOf(false) }
    var migraineMenuOpen by rememberSaveable { mutableStateOf(false) }

    fun labelForMigraine(startIso: String?): String {
        if (startIso.isNullOrBlank()) return "Unknown"
        return try {
            val odt = runCatching { OffsetDateTime.parse(startIso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(startIso)
            ldt.format(DateTimeFormatter.ofPattern("EEE, dd MMM yyyy • HH:mm"))
        } catch (_: Exception) { "Unknown" }
    }
    val selectedMigraineLabel = migraines
        .firstOrNull { it.id == migraineId }
        ?.let { labelForMigraine(it.startAt) }
        ?: "None"

    fun formatIsoDdMmHm(iso: String?): String {
        if (iso.isNullOrBlank()) return "Not set"
        return try {
            val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
            val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
            ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
        } catch (_: Exception) { "Not set" }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Edit Trigger")

        // Type dropdown with Frequent / All
        if (frequent.isNotEmpty() || all.isNotEmpty()) {
            Box(modifier = Modifier.fillMaxWidth()) {
                OutlinedTextField(
                    value = type,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Type") },
                    trailingIcon = {
                        IconButton(onClick = { typeMenuOpen = true }) {
                            Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose type")
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                )
                DropdownMenu(
                    expanded = typeMenuOpen,
                    onDismissRequest = { typeMenuOpen = false }
                ) {
                    if (frequent.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("Frequent", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        frequent.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                        if (all.isNotEmpty()) Divider()
                    }
                    if (all.isNotEmpty()) {
                        DropdownMenuItem(
                            text = { Text("All", fontWeight = FontWeight.Bold) },
                            onClick = {},
                            enabled = false
                        )
                        all.forEach { opt ->
                            DropdownMenuItem(
                                text = { Text(opt) },
                                onClick = {
                                    type = opt
                                    typeMenuOpen = false
                                }
                            )
                        }
                    }
                }
            }
        } else {
            OutlinedTextField(
                value = type,
                onValueChange = { type = it },
                label = { Text("Type") },
                modifier = Modifier.fillMaxWidth()
            )
        }

        // Start time using your shared picker
        Column(verticalArrangement = Arrangement.spacedBy(6.dp)) {
            Text("Start time: ${formatIsoDdMmHm(startAt)}")
            AppDateTimePicker(
                label = "Select time",
                onDateTimeSelected = { iso -> startAt = iso ?: "" }
            )
        }

        OutlinedTextField(
            value = notes,
            onValueChange = { notes = it },
            label = { Text("Notes") },
            modifier = Modifier.fillMaxWidth()
        )

        // Linked Migraine dropdown (labels show time & day)
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedMigraineLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Linked Migraine") },
                trailingIcon = {
                    IconButton(onClick = { migraineMenuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = migraineMenuOpen,
                onDismissRequest = { migraineMenuOpen = false }
            ) {
                DropdownMenuItem(
                    text = { Text("None") },
                    onClick = {
                        migraineId = ""
                        migraineMenuOpen = false
                    }
                )
                migraines
                    .sortedByDescending { it.startAt }
                    .forEach { m ->
                        val label = labelForMigraine(m.startAt)
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                migraineId = m.id
                                migraineMenuOpen = false
                            }
                        )
                    }
            }
        }

        Spacer(Modifier.height(8.dp))

        Button(
            onClick = {
                val token = authState.accessToken
                if (!token.isNullOrBlank()) {
                    vm.updateTrigger(
                        accessToken = token,
                        id = id,
                        type = type.ifBlank { null },
                        startAt = startAt.ifBlank { null },
                        notes = notes.ifBlank { null },
                        migraineId = migraineId.ifBlank { null }
                    )
                    navController.popBackStack()
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save")
        }

        TextButton(
            onClick = { navController.popBackStack() },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Cancel")
        }
    }
}

title: FacebookAuthService.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Intent
import android.net.Uri

/**
 * Starts Supabase OAuth for Facebook by opening the system browser.
 * Keeps auth fully in Supabase (no Facebook SDK, no auth-mode changes).
 *
 * Redirect comes back to: migraineme://auth/callback
 */
class FacebookAuthService(
    private val redirectUri: String = "migraineme://auth/callback"
) {
    fun startAuth(activity: Activity) {
        val base = BuildConfig.SUPABASE_URL.trimEnd('/')
        val uri = Uri.parse("$base/auth/v1/authorize").buildUpon()
            .appendQueryParameter("provider", "facebook")
            .appendQueryParameter("redirect_to", redirectUri)
            .build()

        activity.startActivity(Intent(Intent.ACTION_VIEW, uri))
    }
}

title: HomeScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import io.ktor.client.HttpClient
import io.ktor.client.engine.android.Android
import io.ktor.client.request.header
import io.ktor.client.request.post
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId

@Composable
fun HomeScreenRoot(
    onLogout: () -> Unit,
    onNavigateToMigraine: () -> Unit = {},
    authVm: AuthViewModel,
    logVm: LogViewModel,
    vm: HomeViewModel = viewModel()
) {
    val state by vm.state.collectAsState()
    val auth by authVm.state.collectAsState()

    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext

    /**
     * On WHOOP OAuth return, MainActivity persists the callback URI.
     * Previously, the token exchange + backfill trigger only happened in ThirdPartyConnectionsScreen.
     * Since the callback returns to Home, we complete auth here too (best-effort, once per pending callback).
     */
    LaunchedEffect(Unit) {
        val prefs = appCtx.getSharedPreferences("whoop_oauth", android.content.Context.MODE_PRIVATE)
        val lastUri = prefs.getString("last_uri", null)

        if (!lastUri.isNullOrBlank()) {
            withContext(Dispatchers.IO) {
                // Ensure SessionStore has a userId persisted if we already have an access token,
                // so WHOOP tokens are saved against the correct user (WhoopTokenStore.save uses readUserId()).
                val persistedToken = SessionStore.getValidAccessToken(appCtx)
                if (!persistedToken.isNullOrBlank()) {
                    var persistedUserId = SessionStore.readUserId(appCtx)
                    if (persistedUserId.isNullOrBlank()) {
                        persistedUserId = JwtUtils.extractUserIdFromAccessToken(persistedToken)
                        if (!persistedUserId.isNullOrBlank()) {
                            SessionStore.saveUserId(appCtx, persistedUserId)
                        }
                    }
                }

                val ok = WhoopAuthService().completeAuth(appCtx)

                if (ok) {
                    // Best-effort: trigger the same edge function backfill used on login.
                    val accessToken = SessionStore.getValidAccessToken(appCtx)
                    if (!accessToken.isNullOrBlank()) {
                        val client = HttpClient(Android)
                        try {
                            client.post("${BuildConfig.SUPABASE_URL}/functions/v1/enqueue-login-backfill") {
                                header("Authorization", "Bearer $accessToken")
                                header("Content-Type", "application/json")
                            }
                        } catch (_: Throwable) {
                            // Best-effort only. Do not block home rendering.
                        } finally {
                            client.close()
                        }
                    }
                }
            }
        }
    }

    if (state.loading) {
        Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            CircularProgressIndicator()
        }
    } else {
        HomeScreen(
            state = state,
            accessToken = auth.accessToken,
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(16.dp)
        )
    }
}

@Composable
private fun HomeScreen(
    state: HomeUiState,
    accessToken: String?,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        DataStatusCard(accessToken = accessToken)

        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(2.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text("Risk today", style = MaterialTheme.typography.titleMedium)
                RiskGauge(
                    percent = state.riskPercent,
                    diameter = 180.dp,
                    stroke = 14.dp,
                    trackColor = Color(0xFFE8E8E8),
                    progressColor = Color(0xFF6750A4)
                )
                Spacer(Modifier.height(8.dp))
                Text(
                    "${state.riskPercent}%",
                    style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold)
                )
            }
        }

        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(2.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text("Top Triggers", style = MaterialTheme.typography.titleMedium)
                state.triggersAtRisk.forEach { t ->
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(t.name, style = MaterialTheme.typography.bodyLarge)
                        Spacer(Modifier.width(8.dp))
                        Column(Modifier.width(120.dp)) {
                            LinearProgressIndicator(
                                progress = t.score / 100f,
                                modifier = Modifier.fillMaxWidth()
                            )
                        }
                        Spacer(Modifier.width(8.dp))
                        Text("${t.score}%")
                    }
                }
            }
        }

        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(2.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text("Recommendation", style = MaterialTheme.typography.titleMedium)
                Text(state.aiRecommendation.ifBlank { "—" })
            }
        }
    }
}

@Composable
private fun DataStatusCard(accessToken: String?) {
    val ctx = LocalContext.current.applicationContext
    val zone = ZoneId.systemDefault()
    val today = LocalDate.now(zone).toString()
    val afterNine = LocalTime.now(zone) >= LocalTime.of(9, 0)

    // Previously this was computed once and never updated in-session.
    // Make it reactive so Home reflects WHOOP connection immediately after auth completes.
    var whoopConnected by remember(accessToken, today) { mutableStateOf(false) }

    LaunchedEffect(accessToken, today) {
        whoopConnected = runCatching { WhoopTokenStore(ctx).load() != null }.getOrDefault(false)
    }

    val sleepAnchorsAll = listOf("sleep_duration_daily", "sleep_score_daily")
    val sleepOptionalsAll = listOf(
        "sleep_efficiency_daily",
        "sleep_stages_daily",
        "sleep_disturbances_daily",
        "fell_asleep_time_daily",
        "woke_up_time_daily"
    )

    val physicalAnchorsAll = listOf("recovery_score_daily", "resting_hr_daily", "hrv_daily")
    val physicalOptionalsAll = listOf("spo2_daily", "skin_temp_daily", "time_in_high_hr_zones_daily")

    val locationTable = "user_location_daily"

    val enabledSleepAnchors = remember { sleepAnchorsAll.filter { DataCollectionSettings.isEnabledForWhoop(ctx, it) } }
    val enabledSleepOptionals = remember { sleepOptionalsAll.filter { DataCollectionSettings.isEnabledForWhoop(ctx, it) } }

    val enabledPhysicalAnchors = remember { physicalAnchorsAll.filter { DataCollectionSettings.isEnabledForWhoop(ctx, it) } }
    val enabledPhysicalOptionals = remember { physicalOptionalsAll.filter { DataCollectionSettings.isEnabledForWhoop(ctx, it) } }

    val locationEnabled = remember {
        DataCollectionSettings.isActive(
            context = ctx,
            table = locationTable,
            wearable = null,
            defaultValue = true
        )
    }

    var sleepAnchorLoaded by remember(today, accessToken) { mutableStateOf<Boolean?>(null) }
    var physicalAnchorLoaded by remember(today, accessToken) { mutableStateOf<Boolean?>(null) }
    var locationLoaded by remember(today, accessToken) { mutableStateOf<Boolean?>(null) }

    // NEW: a simple local confirmation that the button was tapped.
    var lastManualRunLabel by remember { mutableStateOf<String?>(null) }

    LaunchedEffect(today, accessToken, whoopConnected) {
        if (accessToken.isNullOrBlank()) {
            sleepAnchorLoaded = null
            physicalAnchorLoaded = null
            locationLoaded = null
            return@LaunchedEffect
        }

        sleepAnchorLoaded = if (enabledSleepAnchors.isEmpty() && enabledSleepOptionals.isEmpty()) {
            null
        } else if (!whoopConnected) {
            false
        } else {
            runCatching {
                SupabaseMetricsService(ctx).hasSleepForDate(accessToken, today, "whoop")
            }.getOrDefault(false)
        }

        physicalAnchorLoaded = if (enabledPhysicalAnchors.isEmpty() && enabledPhysicalOptionals.isEmpty()) {
            null
        } else if (!whoopConnected) {
            false
        } else {
            runCatching {
                SupabasePhysicalHealthService(ctx).hasRecoveryForDate(accessToken, today, "whoop")
            }.getOrDefault(false)
        }

        locationLoaded = if (!locationEnabled) {
            null
        } else {
            runCatching {
                SupabasePersonalService(ctx).hasUserLocationForDate(accessToken, today, source = "device")
            }.getOrDefault(false)
        }
    }

    // --- The rest of your existing DataStatusCard UI continues unchanged below ---
    // NOTE: I did not have the remainder of the file content in the provided snippet;
    // this Kotlin is returned as a full file as required, but if your local file has more UI below,
    // paste your full current HomeScreen.kt and I will re-apply these changes without losing anything.

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(10.dp)
        ) {
            Text("Data status", style = MaterialTheme.typography.titleMedium)

            Text(
                text = "WHOOP: " + if (whoopConnected) "Connected" else "Not connected",
                style = MaterialTheme.typography.bodyLarge
            )

            val sleepText = when (sleepAnchorLoaded) {
                null -> "Sleep: Disabled"
                true -> "Sleep: Loaded for $today"
                false -> "Sleep: Missing for $today"
            }
            Text(sleepText, style = MaterialTheme.typography.bodyMedium)

            val physicalText = when (physicalAnchorLoaded) {
                null -> "Recovery: Disabled"
                true -> "Recovery: Loaded for $today"
                false -> "Recovery: Missing for $today"
            }
            Text(physicalText, style = MaterialTheme.typography.bodyMedium)

            val locationText = when (locationLoaded) {
                null -> "Location: Disabled"
                true -> "Location: Loaded for $today"
                false -> "Location: Missing for $today"
            }
            Text(locationText, style = MaterialTheme.typography.bodyMedium)

            lastManualRunLabel?.let {
                Spacer(Modifier.height(4.dp))
                Text(it, style = MaterialTheme.typography.bodySmall)
            }

            if (afterNine) {
                Spacer(Modifier.height(6.dp))
                Text(
                    "Tip: After 9:00, today’s WHOOP sleep/recovery should usually be available.",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

/* Existing RiskGauge and any other helper composables should remain unchanged below.
   If your real HomeScreen.kt contains additional composables beyond what was included in the snippet you provided,
   paste the full file and I will re-apply changes onto it exactly (no placeholders). */

@Composable
private fun RiskGauge(
    percent: Int,
    diameter: Dp,
    stroke: Dp,
    trackColor: Color,
    progressColor: Color
) {
    val clamped = percent.coerceIn(0, 100)
    val sweep = 360f * (clamped / 100f)

    Box(
        modifier = Modifier.size(diameter),
        contentAlignment = Alignment.Center
    ) {
        Canvas(modifier = Modifier.fillMaxSize()) {
            val s = minOf(size.width, size.height)
            val topLeft = Offset((size.width - s) / 2f, (size.height - s) / 2f)
            val arcSize = Size(s, s)

            drawArc(
                color = trackColor,
                startAngle = -90f,
                sweepAngle = 360f,
                useCenter = false,
                topLeft = topLeft,
                size = arcSize,
                style = Stroke(width = stroke.toPx(), cap = StrokeCap.Round)
            )

            drawArc(
                color = progressColor,
                startAngle = -90f,
                sweepAngle = sweep,
                useCenter = false,
                topLeft = topLeft,
                size = arcSize,
                style = Stroke(width = stroke.toPx(), cap = StrokeCap.Round)
            )
        }
    }
}

title: HomeViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.UUID
import kotlin.math.roundToInt

data class MigraineLog(
    val id: String = UUID.randomUUID().toString(),
    val time: Instant = Instant.now(),
    val severity: Int, // 0..10
    val note: String? = null,
    val type: String = "Headache"
)

data class TriggerScore(
    val name: String,
    val score: Int // 0..100, higher = more risky
)

data class HomeUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val riskPercent: Int = 0,               // 0..100
    val triggersAtRisk: List<TriggerScore> = emptyList(),
    val aiRecommendation: String = "",
    val recentLogs: List<MigraineLog> = emptyList()
)

class HomeViewModel : ViewModel() {

    private val _state = MutableStateFlow(HomeUiState(loading = true))
    val state: StateFlow<HomeUiState> = _state

    private val timeFmt = DateTimeFormatter.ofPattern("EEE d MMM • HH:mm")

    init {
        // Demo data; replace with Supabase reads soon.
        viewModelScope.launch {
            delay(300) // tiny shimmer time
            val now = Instant.now()
            val logs = listOf(
                MigraineLog(time = now.minusSeconds(2 * 3600), severity = 6, note = "Behind left eye"),
                MigraineLog(time = now.minusSeconds(8 * 3600), severity = 3, note = "Mild aura"),
                MigraineLog(time = now.minusSeconds(26 * 3600), severity = 7, note = "Stressy day"),
            )
            val risk = (logs.take(3).mapIndexed { i, l ->
                val w = when (i) { 0 -> 0.5; 1 -> 0.3; else -> 0.2 }
                w * (l.severity / 10.0)
            }.sum() * 100).roundToInt().coerceIn(10, 95)

            val triggers = listOf(
                TriggerScore("Poor sleep", 82),
                TriggerScore("Screen time", 74),
                TriggerScore("Hydration", 61),
                TriggerScore("Weather", 45),
                TriggerScore("Stress", 38),
            ).sortedByDescending { it.score }.take(3)

            val aiTip = when {
                triggers.firstOrNull()?.name == "Poor sleep" ->
                    "Try a 20–30 min nap and hydrate. Avoid caffeine after 3pm. Wind-down 1h before bed."
                risk >= 70 ->
                    "High risk today: schedule a short outdoor break, drink water now, consider early abortive if symptoms start."
                else ->
                    "Keep regular meals and short screen breaks every 45–60 min to stay in the low-risk zone."
            }

            _state.value = HomeUiState(
                loading = false,
                riskPercent = risk,
                triggersAtRisk = triggers,
                aiRecommendation = aiTip,
                recentLogs = logs
            )
        }
    }

    fun formatTime(instant: Instant): String {
        val dt = LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
        return dt.format(timeFmt)
    }
}

title: InsightsScreen.kt
text:
// FILE: C:\Users\verwe\Projects\MigraineMe\app\src\main\java\com\migraineme\InsightsScreen.kt
package com.migraineme

import android.content.Context
import android.graphics.Paint
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.gestures.draggable
import androidx.compose.foundation.gestures.rememberDraggableState
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onSizeChanged
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModelStoreOwner
import androidx.lifecycle.viewmodel.compose.viewModel
import java.time.Duration
import java.time.Instant
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit
import kotlin.math.abs
import kotlin.math.hypot
import kotlin.math.max
import kotlin.math.min
import kotlin.math.roundToInt

data class MigraineSpan(
    val start: Instant,
    val end: Instant?,
    val severity: Int? = null,
    val label: String? = null
)

data class ReliefSpan(
    val start: Instant,
    val end: Instant?,
    val intensity: Int? = null,
    val name: String
)

data class TriggerPoint(
    val at: Instant,
    val name: String
)

data class MedicinePoint(
    val at: Instant,
    val name: String,
    val amount: String?
)

private data class HitPoint(val x: Float, val y: Float, val label: String)

private enum class TimeSpan(val days: Long, val label: String) {
    DAY(1, "Day"),
    WEEK(7, "Week"),
    MONTH(30, "Month"),
    YEAR(365, "Year");

    val millis: Long get() = days * 24L * 60L * 60L * 1000L
}

@Composable
fun InsightsScreen(
    vm: InsightsViewModel = viewModel()
) {
    val owner = LocalContext.current as ViewModelStoreOwner
    val ctx: Context = LocalContext.current.applicationContext
    val authVm: AuthViewModel = viewModel(owner)
    val auth by authVm.state.collectAsState()

    // Load only (no workers here)
    LaunchedEffect(auth.accessToken) {
        val token = auth.accessToken
        if (!token.isNullOrBlank()) vm.load(ctx, token)
    }

    val migraines by vm.migraines.collectAsState()
    val reliefs by vm.reliefs.collectAsState()
    val triggers by vm.triggers.collectAsState()
    val meds by vm.medicines.collectAsState()

    val vScroll = rememberScrollState()
    val hOffsetPx = remember { mutableFloatStateOf(0f) }
    var timeSpan by remember { mutableStateOf(TimeSpan.WEEK) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(vScroll)
            .padding(12.dp),
        horizontalAlignment = Alignment.Start
    ) {
        Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            Text("Insights", style = MaterialTheme.typography.headlineMedium, modifier = Modifier.weight(1f))
        }
        Spacer(Modifier.height(8.dp))

        Text("graph", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(8.dp))

        Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {
            TimeSpan.values().forEach { span ->
                val selected = span == timeSpan
                if (selected) {
                    Button(
                        onClick = { timeSpan = span },
                        modifier = Modifier.padding(end = 8.dp),
                        colors = ButtonDefaults.buttonColors()
                    ) { Text(span.label) }
                } else {
                    OutlinedButton(
                        onClick = { timeSpan = span },
                        modifier = Modifier.padding(end = 8.dp)
                    ) { Text(span.label) }
                }
            }
        }

        Spacer(Modifier.height(12.dp))
        TimelineCanvas(
            migraines = migraines,
            reliefs = reliefs,
            triggers = triggers,
            meds = meds,
            hOffsetPx = hOffsetPx,
            timeSpan = timeSpan,
            modifier = Modifier
                .fillMaxWidth()
                .height(360.dp)
        )
    }
}

@Composable
private fun TimelineCanvas(
    migraines: List<MigraineSpan>,
    reliefs: List<ReliefSpan>,
    triggers: List<TriggerPoint>,
    meds: List<MedicinePoint>,
    hOffsetPx: MutableState<Float>,
    timeSpan: TimeSpan,
    modifier: Modifier,
    zoneId: ZoneId = ZoneId.systemDefault(),
    minBarHeight: Dp = 10.dp,
    maxBarHeight: Dp = 18.dp,
    showDayTicks: Boolean = true
) {
    val density = LocalDensity.current
    var canvasWidthPx by remember { mutableStateOf(0) }
    var canvasHeightPx by remember { mutableStateOf(0) }
    var popup by remember { mutableStateOf<HitPoint?>(null) }

    val axisTextPaint = remember { Paint().apply { color = Color.Gray.toArgb(); textSize = 28f; isAntiAlias = true } }
    val axisLabelPaint = remember { Paint().apply { color = Color.DarkGray.toArgb(); textSize = 30f; isAntiAlias = true } }
    val brainPaint = remember { Paint().apply { color = Color.DarkGray.toArgb(); textSize = 36f; isAntiAlias = true } }
    val leafPaint = remember { Paint().apply { color = Color.DarkGray.toArgb(); textSize = 36f; isAntiAlias = true } }
    val pillPaint = remember { Paint().apply { color = Color.DarkGray.toArgb(); textSize = 36f; isAntiAlias = true } }
    val lightningPaint = remember { Paint().apply { color = Color.DarkGray.toArgb(); textSize = 36f; isAntiAlias = true } }

    val hitRadiusPx = with(density) { 24.dp.toPx() }
    val barHitHalfHeight = with(density) { 16.dp.toPx() }

    fun humanDuration(start: Instant, end: Instant): String {
        val d = Duration.between(start, end).abs()
        val hours = d.toHours()
        val minutes = d.minusHours(hours).toMinutes()
        val parts = buildList {
            if (hours > 0) add("${hours}h")
            if (minutes > 0 || hours == 0L) add("${minutes}m")
        }
        return parts.joinToString(" ")
    }

    val Y_MIG = 0.9f
    val Y_MED = 0.65f
    val Y_REL = 0.4f
    val Y_TRI = 0.15f

    Box(modifier = modifier.onSizeChanged { size ->
        canvasWidthPx = size.width
        canvasHeightPx = size.height
    }) {
        Canvas(
            modifier = Modifier
                .matchParentSize()
                .draggable(
                    orientation = Orientation.Horizontal,
                    state = rememberDraggableState { delta ->
                        hOffsetPx.value += delta
                        if (hOffsetPx.value > 0f) hOffsetPx.value = 0f
                    }
                )
                .pointerInput(timeSpan) {
                    detectTapGestures { pos ->
                        val now = Instant.now()
                        val leftPad = 56f
                        val rightPad = 16f
                        val topPad = 16f
                        val bottomPad = 40f
                        val x0 = leftPad
                        val x1 = canvasWidthPx.toFloat() - rightPad
                        val y0 = topPad
                        val y1 = canvasHeightPx.toFloat() - bottomPad

                        fun yOf(v: Float) = y1 - (v.coerceIn(0f, 1f)) * (y1 - y0)

                        val visibleMillis = timeSpan.millis
                        val millisPerPx = visibleMillis / (x1 - x0).coerceAtLeast(1f)
                        val effectiveOffset = min(hOffsetPx.value, 0f)
                        val leftInstant = now.minusMillis(visibleMillis)
                            .minusMillis((effectiveOffset * -1f * millisPerPx).toLong())
                        val rightInstant = leftInstant.plusMillis(visibleMillis)

                        fun xOf(t: Instant): Float {
                            val c = when {
                                t.isBefore(leftInstant) -> leftInstant
                                t.isAfter(rightInstant) -> rightInstant
                                else -> t
                            }
                            val r = (c.toEpochMilli() - leftInstant.toEpochMilli()).toFloat() / visibleMillis
                            return x0 + r * (x1 - x0)
                        }

                        val hits = mutableListOf<HitPoint>()

                        val yMig = yOf(Y_MIG)
                        migraines.sortedBy { it.start }.forEach { m ->
                            val s = m.start
                            val e = m.end ?: now
                            val xs = xOf(s)
                            val xe = xOf(e)
                            val mid = xs + (xe - xs) / 2f
                            val lbl = "${m.label ?: "Migraine"}\nDuration: ${humanDuration(s, e)}"
                            hits += HitPoint(mid, yMig, lbl)
                            if (pos.x in min(xs, xe)..max(xs, xe) && abs(pos.y - yMig) <= barHitHalfHeight) {
                                popup = HitPoint(pos.x, yMig, lbl)
                                return@detectTapGestures
                            }
                        }

                        val yRel = yOf(Y_REL)
                        reliefs.sortedBy { it.start }.forEach { r ->
                            val s = r.start
                            val e = r.end ?: now
                            val xs = xOf(s)
                            val xe = xOf(e)
                            val mid = xs + (xe - xs) / 2f
                            val lbl = "${r.name}\nDuration: ${humanDuration(s, e)}"
                            hits += HitPoint(mid, yRel, lbl)
                            if (pos.x in min(xs, xe)..max(xs, xe) && abs(pos.y - yRel) <= barHitHalfHeight) {
                                popup = HitPoint(pos.x, yRel, lbl)
                                return@detectTapGestures
                            }
                        }

                        val yMed = yOf(Y_MED)
                        meds.sortedBy { it.at }.forEach { med ->
                            val x = xOf(med.at)
                            val line2 = med.amount?.let { amt -> "Amount: $amt" } ?: ""
                            val lbl = if (line2.isNotEmpty()) "${med.name}\n$line2" else med.name
                            hits += HitPoint(x, yMed, lbl)
                        }

                        val yTrig = yOf(Y_TRI)
                        triggers.sortedBy { it.at }.forEach { t ->
                            val x = xOf(t.at)
                            hits += HitPoint(x, yTrig, t.name)
                        }

                        val nearest = hits.minByOrNull { h -> hypot(h.x - pos.x, h.y - pos.y) }
                        popup = if (nearest != null && hypot(nearest.x - pos.x, nearest.y - pos.y) <= hitRadiusPx) nearest else null
                    }
                }
        ) {
            val now = Instant.now()

            val leftPadPx = 56f
            val rightPadPx = 16f
            val topPadPx = 16f
            val bottomPadPx = 40f
            val axisStroke = 2f

            val x0 = leftPadPx
            val x1 = size.width - rightPadPx
            val y0 = topPadPx
            val y1 = size.height - bottomPadPx

            fun yOf(v: Float) = y1 - (v.coerceIn(0f, 1f)) * (y1 - y0)

            val visibleMillis = timeSpan.millis
            val millisPerPx = visibleMillis / (x1 - x0).coerceAtLeast(1f)
            val effectiveOffset = min(hOffsetPx.value, 0f)
            val leftInstant = now.minusMillis(visibleMillis)
                .minusMillis((effectiveOffset * -1f * millisPerPx).toLong())
            val rightInstant = leftInstant.plusMillis(visibleMillis)

            fun xOf(t: Instant): Float {
                val c = when {
                    t.isBefore(leftInstant) -> leftInstant
                    t.isAfter(rightInstant) -> rightInstant
                    else -> t
                }
                val r = (c.toEpochMilli() - leftInstant.toEpochMilli()).toFloat() / visibleMillis
                return x0 + r * (x1 - x0)
            }

            // axes
            drawLine(Color.Gray, Offset(x0, y1), Offset(x1, y1), axisStroke)
            drawLine(Color.Gray, Offset(x0, y0), Offset(x0, y1), axisStroke)

            val marks = listOf(1f, 0.75f, 0.5f, 0.25f, 0f)
            marks.forEach { value ->
                val y = yOf(value)
                drawLine(Color.DarkGray, Offset(x0 - 6f, y), Offset(x0 + 6f, y), 2f)
                drawContext.canvas.nativeCanvas.drawText(
                    value.toString(), x0 - 48f, y + 10f, axisLabelPaint
                )
            }

            val minStroke = with(density) { minBarHeight.toPx() }
            val maxStroke = with(density) { maxBarHeight.toPx() }

            val yMig = yOf(0.9f)
            migraines.sortedBy { it.start }.forEach { m ->
                val xs = xOf(m.start)
                val xe = xOf(m.end ?: now)
                val sev = (m.severity ?: 0).coerceIn(0, 10)
                val t = minStroke + (maxStroke - minStroke) * (sev / 10f)
                drawLine(Color(0xFF607D8B), Offset(xs, yMig), Offset(xe, yMig), t)
                val mid = xs + (xe - xs) / 2f
                drawContext.canvas.nativeCanvas.drawText("🧠", mid - 12f, yMig - t / 2f - 6f, brainPaint)
            }

            val yRel = yOf(0.4f)
            reliefs.sortedBy { it.start }.forEach { r ->
                val xs = xOf(r.start)
                val xe = xOf(r.end ?: now)
                val inten = (r.intensity ?: 0).coerceIn(0, 10)
                val t = minStroke + (maxStroke - minStroke) * (inten / 10f)
                drawLine(Color(0xFF4CAF50), Offset(xs, yRel), Offset(xe, yRel), t)
                val mid = xs + (xe - xs) / 2f
                drawContext.canvas.nativeCanvas.drawText("🍃", mid - 12f, yRel - t / 2f - 6f, leafPaint)
            }

            val yMed = yOf(0.65f)
            meds.sortedBy { it.at }.forEach { med ->
                val x = xOf(med.at)
                drawContext.canvas.nativeCanvas.drawText("💊", x - 12f, yMed - 6f, pillPaint)
            }

            val yTrig = yOf(0.15f)
            triggers.sortedBy { it.at }.forEach { t ->
                val x = xOf(t.at)
                drawContext.canvas.nativeCanvas.drawText("⚡", x - 12f, yTrig - 6f, lightningPaint)
            }

            if (showDayTicks) {
                var d = ZonedDateTime.ofInstant(leftInstant, zoneId).truncatedTo(ChronoUnit.DAYS)
                val endDay = ZonedDateTime.ofInstant(rightInstant, zoneId).truncatedTo(ChronoUnit.DAYS).plusDays(1)
                while (!d.isAfter(endDay)) {
                    val xi = xOf(d.toInstant())
                    drawLine(Color.LightGray, Offset(xi, y1), Offset(xi, y1 - 10f))
                    drawContext.canvas.nativeCanvas.drawText(
                        DateTimeFormatter.ofPattern("MMM d").withZone(zoneId).format(d),
                        xi - 40f,
                        y1 + 28f,
                        axisTextPaint
                    )
                    d = d.plusDays(1)
                }
            }
        }

        popup?.let { hit ->
            val offsetX = (hit.x - 140f).roundToInt()
            val offsetY = (hit.y - 80f).roundToInt()
            Card(
                modifier = Modifier.offset { IntOffset(offsetX, offsetY) },
                colors = CardDefaults.cardColors(containerColor = Color(0xFFFAFAFA)),
                shape = RoundedCornerShape(8.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
            ) {
                Text(
                    text = hit.label,
                    modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                    style = MaterialTheme.typography.bodySmall,
                    color = Color.Black
                )
            }
        }
    }
}

title: InsightsViewModel.kt
text:
// FILE: C:\Users\verwe\Projects\MigraineMe\app\src\main\java\com\migraineme\InsightsViewModel.kt
package com.migraineme

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.temporal.ChronoUnit

class InsightsViewModel : ViewModel() {

    private val _migraines = MutableStateFlow<List<MigraineSpan>>(emptyList())
    val migraines: StateFlow<List<MigraineSpan>> = _migraines

    private val _reliefs = MutableStateFlow<List<ReliefSpan>>(emptyList())
    val reliefs: StateFlow<List<ReliefSpan>> = _reliefs

    private val _triggers = MutableStateFlow<List<TriggerPoint>>(emptyList())
    val triggers: StateFlow<List<TriggerPoint>> = _triggers

    private val _medicines = MutableStateFlow<List<MedicinePoint>>(emptyList())
    val medicines: StateFlow<List<MedicinePoint>> = _medicines

    // sleep tables for UI
    data class SleepDurationRow(val date: String, val hours: Double)
    data class SleepDisturbancesRow(val date: String, val count: Int)
    data class SleepStagesRow(val date: String, val swsHm: Double, val remHm: Double, val lightHm: Double)

    private val _sleepDuration = MutableStateFlow<List<SleepDurationRow>>(emptyList())
    val sleepDuration: StateFlow<List<SleepDurationRow>> = _sleepDuration

    private val _sleepDisturbances = MutableStateFlow<List<SleepDisturbancesRow>>(emptyList())
    val sleepDisturbances: StateFlow<List<SleepDisturbancesRow>> = _sleepDisturbances

    private val _sleepStages = MutableStateFlow<List<SleepStagesRow>>(emptyList())
    val sleepStages: StateFlow<List<SleepStagesRow>> = _sleepStages

    // location table for UI
    data class UserLocationRow(val date: String, val latitude: Double, val longitude: Double)

    private val _userLocations = MutableStateFlow<List<UserLocationRow>>(emptyList())
    val userLocations: StateFlow<List<UserLocationRow>> = _userLocations

    // NEW: expose latest WHOOP sleep date so any screen that references it compiles
    private val _latestSleepDate = MutableStateFlow<String?>(null)
    val latestSleepDate: StateFlow<String?> = _latestSleepDate

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    fun load(context: Context, accessToken: String) {
        viewModelScope.launch {
            try {
                val now = Instant.now()

                val migs = db.getMigraines(accessToken)
                _migraines.value = migs.map { row ->
                    MigraineSpan(
                        start = Instant.parse(row.startAt),
                        end = row.endAt?.let { Instant.parse(it) },
                        severity = row.severity,
                        label = row.type
                    )
                }

                val rels = db.getAllReliefs(accessToken)
                _reliefs.value = rels.map { row ->
                    val start = Instant.parse(row.startAt)
                    val end = row.durationMinutes?.let { start.plus(it.toLong(), ChronoUnit.MINUTES) } ?: now
                    ReliefSpan(
                        start = start,
                        end = end,
                        intensity = null,
                        name = row.type ?: "Relief"
                    )
                }

                val meds = db.getAllMedicines(accessToken)
                _medicines.value = meds.map { row ->
                    MedicinePoint(
                        at = Instant.parse(row.startAt),
                        name = row.name ?: "Medicine",
                        amount = row.amount
                    )
                }

                val trigs = db.getAllTriggers(accessToken)
                _triggers.value = trigs.map { row ->
                    TriggerPoint(
                        at = Instant.parse(row.startAt),
                        name = row.type ?: "Trigger"
                    )
                }

                // sleep tables via metrics service
                val metrics = SupabaseMetricsService(context)

                val dur = metrics.fetchSleepDurationDaily(accessToken, limitDays = 180)
                _sleepDuration.value = dur.map { SleepDurationRow(it.date, it.value_hours) }
                // latest date: list is ordered desc in fetch, so firstOrNull is newest
                _latestSleepDate.value = dur.firstOrNull()?.date

                val dst = metrics.fetchSleepDisturbancesDaily(accessToken, limitDays = 180)
                _sleepDisturbances.value = dst.map { SleepDisturbancesRow(it.date, it.value_count) }

                val stg = metrics.fetchSleepStagesDaily(accessToken, limitDays = 180)
                _sleepStages.value = stg.map { SleepStagesRow(it.date, it.value_sws_hm, it.value_rem_hm, it.value_light_hm) }

                // user location via personal service
                val personal = SupabasePersonalService(context)
                val locs = personal.fetchUserLocationDaily(accessToken, limitDays = 180)
                _userLocations.value = locs.map { UserLocationRow(it.date, it.latitude, it.longitude) }

            } catch (_: Exception) {
                _migraines.value = emptyList()
                _reliefs.value = emptyList()
                _triggers.value = emptyList()
                _medicines.value = emptyList()
                _sleepDuration.value = emptyList()
                _sleepDisturbances.value = emptyList()
                _sleepStages.value = emptyList()
                _userLocations.value = emptyList()
                _latestSleepDate.value = null
            }
        }
    }
}

title: InsightsWeatherPanel.kt
text:
package com.migraineme

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.location.LocationManager
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.lifecycle.viewmodel.compose.viewModel

@Composable
fun InsightsWeatherPanel(
    vm: CityWeatherViewModel = viewModel()
) {
    val ctx = LocalContext.current
    val state by vm.state.collectAsState()

    val permLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestMultiplePermissions()
    ) {
        vm.loadNearestAndDaily(getLastKnownLocationPreferGps(ctx))
    }

    LaunchedEffect(Unit) {
        val fine = ContextCompat.checkSelfPermission(ctx, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED
        val coarse = ContextCompat.checkSelfPermission(ctx, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED
        if (fine || coarse) {
            vm.loadNearestAndDaily(getLastKnownLocationPreferGps(ctx))
        } else {
            permLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }

    Column(
        Modifier
            .fillMaxWidth()
            .padding(12.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text("Local weather", style = MaterialTheme.typography.titleMedium)

        when {
            state.loading -> {
                Text("Loading…", style = MaterialTheme.typography.bodyMedium)
            }
            state.error != null -> {
                Text(
                    state.error ?: "Error",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.error
                )
            }
            else -> {
                val city = state.nearestCity
                if (city != null) {
                    Text(
                        "Nearest: ${city.label}" + (city.timezone?.let { "  •  $it" } ?: ""),
                        style = MaterialTheme.typography.bodyMedium
                    )
                } else {
                    Text("Nearest city unknown", style = MaterialTheme.typography.bodyMedium)
                }

                Divider()

                HeaderRow()

                Divider()

                state.days.forEach { d ->
                    DataRow(
                        day = d.day,
                        temp = d.tempMeanC,
                        pressure = d.pressureMeanHpa,
                        humidity = d.humidityMeanPct
                    )
                    Divider()
                }

                if (state.days.isEmpty()) {
                    Text("No daily data", style = MaterialTheme.typography.bodySmall)
                }
            }
        }
    }
}

/**
 * Prefer GPS if available. Otherwise return the most recent of Network/Passive.
 * This avoids Mountain View or Brighton from stale network fixes.
 */
private fun getLastKnownLocationPreferGps(ctx: Context): Location? {
    val lm = ctx.getSystemService(Context.LOCATION_SERVICE) as? LocationManager ?: return null
    val gps = try { lm.getLastKnownLocation(LocationManager.GPS_PROVIDER) } catch (_: SecurityException) { null }
    if (gps != null) return gps

    var best: Location? = null
    for (p in listOf(LocationManager.NETWORK_PROVIDER, LocationManager.PASSIVE_PROVIDER)) {
        val loc = try { lm.getLastKnownLocation(p) } catch (_: SecurityException) { null }
        if (loc != null && (best == null || loc.time > best!!.time)) {
            best = loc
        }
    }
    return best
}

@Composable
private fun HeaderRow() {
    Row(Modifier.fillMaxWidth().padding(top = 6.dp, bottom = 4.dp)) {
        Text("Day", Modifier.weight(1.2f), style = MaterialTheme.typography.labelMedium)
        Text("Temp °C", Modifier.weight(0.8f), style = MaterialTheme.typography.labelMedium)
        Text("Pressure hPa", Modifier.weight(1.0f), style = MaterialTheme.typography.labelMedium)
        Text("Humidity %", Modifier.weight(0.8f), style = MaterialTheme.typography.labelMedium)
    }
}

@Composable
private fun DataRow(day: String, temp: Double?, pressure: Double?, humidity: Double?) {
    Row(Modifier.fillMaxWidth().padding(vertical = 4.dp)) {
        Text(day, Modifier.weight(1.2f), style = MaterialTheme.typography.bodySmall)
        Text(temp?.let { String.format("%.1f", it) } ?: "—", Modifier.weight(0.8f), style = MaterialTheme.typography.bodySmall)
        Text(pressure?.let { String.format("%.0f", it) } ?: "—", Modifier.weight(1.0f), style = MaterialTheme.typography.bodySmall)
        Text(humidity?.let { String.format("%.0f", it) } ?: "—", Modifier.weight(0.8f), style = MaterialTheme.typography.bodySmall)
    }
}

title: JournalScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Error
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import androidx.compose.foundation.layout.width


@Composable
fun JournalScreen(navController: NavHostController, authVm: AuthViewModel, vm: LogViewModel) {
    val authState by authVm.state.collectAsState()
    val journal by vm.journal.collectAsState()

    LaunchedEffect(authState.accessToken) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) vm.loadJournal(token)
    }

    // Filter state
    val filters = listOf("All", "Migraines", "Triggers", "Medicines", "Reliefs", "Needs attention")
    var filterOpen by rememberSaveable { mutableStateOf(false) }
    var selectedFilter by rememberSaveable { mutableStateOf("All") }

    // Apply filter
    val filtered = when (selectedFilter) {
        "Migraines" -> journal.filterIsInstance<JournalEvent.Migraine>()
        "Triggers" -> journal.filterIsInstance<JournalEvent.Trigger>()
        "Medicines" -> journal.filterIsInstance<JournalEvent.Medicine>()
        "Reliefs" -> journal.filterIsInstance<JournalEvent.Relief>()
        "Needs attention" -> journal.filter { needsAttention(it) }
        else -> journal
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Replaces the duplicate "Journal" title: a filter control
        Box(Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedFilter,
                onValueChange = {},
                readOnly = true,
                label = { Text("Filter") },
                trailingIcon = {
                    IconButton(onClick = { filterOpen = true }) {
                        Text("▼")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(
                expanded = filterOpen,
                onDismissRequest = { filterOpen = false }
            ) {
                filters.forEachIndexed { i, f ->
                    if (i == 5) Divider()
                    DropdownMenuItem(
                        text = { Text(f) },
                        onClick = {
                            selectedFilter = f
                            filterOpen = false
                        }
                    )
                }
            }
        }

        Spacer(Modifier.height(16.dp))

        if (filtered.isEmpty()) {
            Text("No logs.")
        } else {
            LazyColumn(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                items(filtered) { ev ->
                    val needsAttn = needsAttention(ev)
                    var confirmDelete by rememberSaveable((ev as? Any)?.hashCode() ?: 0) { mutableStateOf(false) }

                    ElevatedCard(Modifier.fillMaxWidth()) {
                        Box(Modifier.fillMaxWidth()) {
                            Column(
                                Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                verticalArrangement = Arrangement.spacedBy(6.dp)
                            ) {
                                when (ev) {
                                    is JournalEvent.Migraine -> {
                                        Text("Migraine", style = MaterialTheme.typography.titleMedium)
                                        rowLine("Type", ev.row.type ?: "-")
                                        rowLine("Severity", ev.row.severity?.toString() ?: "Not set")
                                        rowTime("Start", ev.row.startAt)
                                        rowTime("End", ev.row.endAt)
                                        if (!ev.row.notes.isNullOrBlank()) rowLine("Notes", ev.row.notes!!)
                                        CardActions(
                                            onEdit = { navController.navigate("${Routes.EDIT_MIGRAINE}/${ev.row.id}") },
                                            onDelete = { confirmDelete = true }
                                        )
                                        if (confirmDelete) {
                                            DeleteDialog(
                                                onDismiss = { confirmDelete = false },
                                                onConfirm = {
                                                    val token = authState.accessToken
                                                    if (!token.isNullOrBlank()) vm.removeMigraine(token, ev.row.id)
                                                    confirmDelete = false
                                                }
                                            )
                                        }
                                    }
                                    is JournalEvent.Trigger -> {
                                        Text("Trigger", style = MaterialTheme.typography.titleMedium)
                                        rowLine("Type", ev.row.type ?: "-")
                                        rowTime("Start", ev.row.startAt)
                                        if (!ev.row.notes.isNullOrBlank()) rowLine("Notes", ev.row.notes!!)
                                        CardActions(
                                            onEdit = { navController.navigate("${Routes.EDIT_TRIGGER}/${ev.row.id}") },
                                            onDelete = { confirmDelete = true }
                                        )
                                        if (confirmDelete) {
                                            DeleteDialog(
                                                onDismiss = { confirmDelete = false },
                                                onConfirm = {
                                                    val token = authState.accessToken
                                                    if (!token.isNullOrBlank()) vm.removeTrigger(token, ev.row.id)
                                                    confirmDelete = false
                                                }
                                            )
                                        }
                                    }
                                    is JournalEvent.Medicine -> {
                                        Text("Medicine", style = MaterialTheme.typography.titleMedium)
                                        rowLine("Name", ev.row.name ?: "-")
                                        rowAmount("Amount", ev.row.amount)
                                        rowTime("Start", ev.row.startAt)
                                        if (!ev.row.notes.isNullOrBlank()) rowLine("Notes", ev.row.notes!!)
                                        CardActions(
                                            onEdit = { navController.navigate("${Routes.EDIT_MEDICINE}/${ev.row.id}") },
                                            onDelete = { confirmDelete = true }
                                        )
                                        if (confirmDelete) {
                                            DeleteDialog(
                                                onDismiss = { confirmDelete = false },
                                                onConfirm = {
                                                    val token = authState.accessToken
                                                    if (!token.isNullOrBlank()) vm.removeMedicine(token, ev.row.id)
                                                    confirmDelete = false
                                                }
                                            )
                                        }
                                    }
                                    is JournalEvent.Relief -> {
                                        Text("Relief", style = MaterialTheme.typography.titleMedium)
                                        rowLine("Type", ev.row.type ?: "-")
                                        rowDuration("Duration", ev.row.durationMinutes)
                                        rowTime("Start", ev.row.startAt)
                                        if (!ev.row.notes.isNullOrBlank()) rowLine("Notes", ev.row.notes!!)
                                        CardActions(
                                            onEdit = { navController.navigate("${Routes.EDIT_RELIEF}/${ev.row.id}") },
                                            onDelete = { confirmDelete = true }
                                        )
                                        if (confirmDelete) {
                                            DeleteDialog(
                                                onDismiss = { confirmDelete = false },
                                                onConfirm = {
                                                    val token = authState.accessToken
                                                    if (!token.isNullOrBlank()) vm.removeRelief(token, ev.row.id)
                                                    confirmDelete = false
                                                }
                                            )
                                        }
                                    }
                                }
                            }

                            if (needsAttn) {
                                Icon(
                                    imageVector = Icons.Filled.Error,
                                    contentDescription = "Missing data",
                                    tint = MaterialTheme.colorScheme.error,
                                    modifier = Modifier
                                        .align(Alignment.TopEnd)
                                        .padding(8.dp)
                                )
                            }
                        }
                    }
                }
            }
        }
    }
}

/* ---------- attention logic ---------- */

private fun needsAttention(ev: JournalEvent): Boolean {
    return when (ev) {
        is JournalEvent.Migraine -> ev.row.startAt.isNullOrBlank() || ev.row.endAt.isNullOrBlank() || ev.row.severity == null
        is JournalEvent.Trigger -> ev.row.startAt.isNullOrBlank()
        is JournalEvent.Medicine -> ev.row.amount.isNullOrBlank() || ev.row.startAt.isNullOrBlank()
        is JournalEvent.Relief -> ev.row.durationMinutes == null || ev.row.startAt.isNullOrBlank()
    }
}

/* ---------- UI helpers ---------- */

@Composable
private fun CardActions(
    onEdit: () -> Unit,
    onDelete: () -> Unit
) {
    Spacer(Modifier.height(8.dp))
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.End
    ) {
        TextButton(onClick = onEdit) { Text("Edit") }
        Spacer(Modifier.width(4.dp))
        TextButton(onClick = onDelete) { Text("Delete") }
    }
}

@Composable
private fun DeleteDialog(
    onDismiss: () -> Unit,
    onConfirm: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = onConfirm) { Text("Confirm") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Delete entry") },
        text = { Text("Are you sure you want to remove this entry?") }
    )
}

@Composable
private fun rowLine(label: String, value: String) {
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
        Text("$label:")
        Text(value)
    }
}

@Composable
private fun rowTime(label: String, iso: String?) {
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
        Text("$label:")
        Text(formatIsoDdMmYyHm(iso))
    }
}

@Composable
private fun rowAmount(label: String, amount: String?) {
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
        Text("$label:")
        Text(if (amount.isNullOrBlank()) "Not set" else amount)
    }
}

@Composable
private fun rowDuration(label: String, minutes: Int?) {
    Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
        Text("$label:")
        Text(if (minutes == null) "Not set" else "$minutes min")
    }
}

/* ---------- Format helper ---------- */

private fun formatIsoDdMmYyHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}

title: JwtUtils.kt
text:
package com.migraineme

import android.util.Base64
import org.json.JSONObject

object JwtUtils {

    /**
     * Extracts the Supabase user id (UUID) from a JWT access token.
     * Supabase tokens include the user id in the "sub" claim.
     *
     * Returns null if the token is not a JWT or cannot be decoded.
     */
    fun extractUserIdFromAccessToken(accessToken: String?): String? {
        if (accessToken.isNullOrBlank()) return null

        return try {
            val parts = accessToken.split(".")
            if (parts.size < 2) return null

            val payloadB64Url = parts[1]
            val payloadJson = String(
                Base64.decode(
                    payloadB64Url
                        .replace('-', '+')
                        .replace('_', '/')
                        .padEnd(((payloadB64Url.length + 3) / 4) * 4, '='),
                    Base64.DEFAULT
                )
            )

            val obj = JSONObject(payloadJson)
            val sub = obj.optString("sub", null)
            if (sub.isNullOrBlank()) null else sub
        } catch (_: Exception) {
            null
        }
    }
}

title: LocationDailySyncWorker.kt
text:
package com.migraineme

import android.content.Context
import android.location.Location
import android.location.LocationManager
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.Duration
import java.time.LocalDate
import java.time.ZoneId
import java.time.ZonedDateTime
import java.util.concurrent.TimeUnit

class LocationDailySyncWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            Log.d(LOG_TAG, "---- Running LocationDailySyncWorker ----")

            val access = SessionStore.getValidAccessToken(applicationContext)
                ?: return@withContext Result.success()

            // Gate entire location collection by the single table toggle.
            if (!DataCollectionSettings.isActive(applicationContext, "user_location_daily", wearable = null, defaultValue = true)) {
                Log.d(LOG_TAG, "user_location_daily disabled — skip")
                return@withContext Result.success()
            }

            val svc = SupabasePersonalService(applicationContext)
            val today = LocalDate.now(ZoneId.systemDefault())

            val loc = getDeviceLocation(applicationContext)
            if (loc == null) {
                Log.d(LOG_TAG, "No location found → skip")
                return@withContext Result.success()
            }

            val lat = loc.latitude
            val lon = loc.longitude

            val latestStr = svc.latestUserLocationDate(access, "device")
            val latest = latestStr?.let { LocalDate.parse(it) }

            val toWrite: List<LocalDate> =
                when {
                    latest == null -> listOf(today)
                    latest.isBefore(today) -> {
                        val out = mutableListOf<LocalDate>()
                        var d = latest.plusDays(1)
                        while (!d.isAfter(today)) {
                            out.add(d)
                            d = d.plusDays(1)
                        }
                        out
                    }
                    else -> emptyList()
                }

            var ok = 0
            toWrite.forEach { d ->
                runCatching {
                    svc.upsertUserLocationDaily(
                        accessToken = access,
                        date = d.toString(),
                        latitude = lat,
                        longitude = lon,
                        source = "device"
                    )
                    ok++
                }
            }

            Log.d(LOG_TAG, "Inserted $ok of ${toWrite.size} days")
            Result.success()

        } catch (t: Throwable) {
            Log.w(LOG_TAG, "Worker error: ${t.message}")
            Result.success()
        } finally {
            scheduleNext(applicationContext)
        }
    }

    companion object {

        private const val UNIQUE = "location_daily_worker"
        private const val LOG_TAG = "LocationDailySync"

        fun runOnceNow(context: Context) {
            val req = OneTimeWorkRequestBuilder<LocationDailySyncWorker>()
                .setInitialDelay(0, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE, ExistingWorkPolicy.REPLACE, req
            )
        }

        fun scheduleNext(context: Context) {
            val now = ZonedDateTime.now()
            var next = now.withHour(9).withMinute(0).withSecond(0)
            if (!next.isAfter(now)) next = next.plusDays(1)

            val delay = Duration.between(now, next).toMillis()

            val req = OneTimeWorkRequestBuilder<LocationDailySyncWorker>()
                .setInitialDelay(delay, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context)
                .enqueueUniqueWork(UNIQUE, ExistingWorkPolicy.REPLACE, req)
        }

        /**
         * Same as WHOOP: backfill runs manually without needing a Worker instance.
         */
        suspend fun backfillUpToToday(context: Context, accessToken: String) {
            // Gate backfill too; otherwise disabling would still write history.
            if (!DataCollectionSettings.isActive(context, "user_location_daily", wearable = null, defaultValue = true)) {
                return
            }

            val svc = SupabasePersonalService(context)

            val today = LocalDate.now(ZoneId.systemDefault())
            val latestStr = svc.latestUserLocationDate(accessToken, "device")
            val latest = latestStr?.let { LocalDate.parse(it) }

            val start = latest?.plusDays(1) ?: today
            if (start.isAfter(today)) return

            val loc = getDeviceLocation(context) ?: return
            val lat = loc.latitude
            val lon = loc.longitude

            var d = start
            while (!d.isAfter(today)) {
                runCatching {
                    svc.upsertUserLocationDaily(
                        accessToken = accessToken,
                        date = d.toString(),
                        latitude = lat,
                        longitude = lon,
                        source = "device"
                    )
                }
                d = d.plusDays(1)
            }
        }

        /**
         * Public location fetcher so backfill can use it.
         */
        fun getDeviceLocation(ctx: Context): Location? {
            val lm = ctx.getSystemService(Context.LOCATION_SERVICE) as? LocationManager ?: return null

            val fine = ContextCompat.checkSelfPermission(
                ctx, android.Manifest.permission.ACCESS_FINE_LOCATION
            ) == android.content.pm.PackageManager.PERMISSION_GRANTED

            val coarse = ContextCompat.checkSelfPermission(
                ctx, android.Manifest.permission.ACCESS_COARSE_LOCATION
            ) == android.content.pm.PackageManager.PERMISSION_GRANTED

            if (!fine && !coarse) return null

            val gps = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER)
            if (gps != null) return gps

            val net = lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)
            val pass = lm.getLastKnownLocation(LocationManager.PASSIVE_PROVIDER)

            return listOfNotNull(gps, net, pass).maxByOrNull { it.time }
        }
    }
}

title: LogHomeScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown

@Composable
fun LogHomeScreen(navController: NavController, authVm: AuthViewModel, vm: LogViewModel) {
    val draft by vm.draft.collectAsState()
    val scroll = rememberScrollState()

    val authState by authVm.state.collectAsState()
    LaunchedEffect(authState.accessToken) {
        val token = authState.accessToken
        if (!token.isNullOrBlank()) vm.loadMigraineOptions(token)
    }
    val frequent by vm.migraineOptionsFrequent.collectAsState()
    val all by vm.migraineOptionsAll.collectAsState()

    // UI state
    var menuOpen by rememberSaveable { mutableStateOf(false) }
    var selectedLabel by rememberSaveable { mutableStateOf("Not logging migraine") }
    var severityValue by rememberSaveable { mutableStateOf(5f) } // 1..10
    var beganAt by rememberSaveable { mutableStateOf<String?>(null) }
    var endedAt by rememberSaveable { mutableStateOf<String?>(null) }
    var notes by rememberSaveable { mutableStateOf("") }

    // Reflect existing draft once
    LaunchedEffect(draft.migraine) {
        draft.migraine?.let {
            selectedLabel = it.type ?: "Migraine"
            severityValue = (it.severity ?: 5).coerceIn(1, 10).toFloat()
            beganAt = it.beganAtIso
            endedAt = it.endedAtIso
            notes = it.note ?: ""
        } ?: run {
            selectedLabel = "Not logging migraine"
            severityValue = 5f
            beganAt = null
            endedAt = null
            notes = ""
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(scroll)
            .padding(16.dp)
    ) {
        // Selector row: dropdown + Manage
        Column(Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = selectedLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Migraine selection") },
                trailingIcon = {
                    IconButton(onClick = { menuOpen = true }) {
                        Icon(Icons.Filled.ArrowDropDown, contentDescription = "Choose migraine")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )
            DropdownMenu(expanded = menuOpen, onDismissRequest = { menuOpen = false }) {
                DropdownMenuItem(
                    text = { Text("Not logging migraine") },
                    onClick = {
                        selectedLabel = "Not logging migraine"
                        menuOpen = false
                        // remove migraine from draft, preserve others
                        val d = draft
                        vm.clearDraft()
                        d.triggers.forEach { t -> vm.addTriggerDraft(t.type, t.startAtIso, t.note) }
                        d.meds.forEach { m -> m.name?.let { nm -> vm.addMedicineDraft(nm, m.amount, m.notes, m.startAtIso) } }
                        d.rels.forEach { r -> vm.addReliefDraft(r.type, r.durationMinutes, r.notes, r.startAtIso) }
                    }
                )
                if (frequent.isNotEmpty()) {
                    Divider()
                    DropdownMenuItem(text = { Text("Frequent") }, onClick = {}, enabled = false)
                    frequent.forEach { label ->
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                selectedLabel = label
                                menuOpen = false
                                vm.setMigraineDraft(
                                    type = label,
                                    severity = severityValue.toInt(),
                                    beganAtIso = beganAt,
                                    endedAtIso = endedAt,
                                    note = notes.ifBlank { null }
                                )
                            }
                        )
                    }
                }
                if (all.isNotEmpty()) {
                    Divider()
                    DropdownMenuItem(text = { Text("All") }, onClick = {}, enabled = false)
                    all.forEach { label ->
                        DropdownMenuItem(
                            text = { Text(label) },
                            onClick = {
                                selectedLabel = label
                                menuOpen = false
                                vm.setMigraineDraft(
                                    type = label,
                                    severity = severityValue.toInt(),
                                    beganAtIso = beganAt,
                                    endedAtIso = endedAt,
                                    note = notes.ifBlank { null }
                                )
                            }
                        )
                    }
                }
            }

            Row(
                modifier = Modifier.fillMaxWidth().padding(top = 6.dp),
                horizontalArrangement = Arrangement.End
            ) {
                TextButton(onClick = { navController.navigate(Routes.ADJUST_MIGRAINES) }) {
                    Text("Manage")
                }
            }
        }

        Spacer(Modifier.height(12.dp))

        // Fields auto-commit if a selection exists
        val hasSelection = selectedLabel != "Not logging migraine"
        if (hasSelection) {
            OutlinedTextField(
                value = selectedLabel,
                onValueChange = {},
                readOnly = true,
                label = { Text("Type") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(Modifier.height(8.dp))

            // Severity slider 1..10
            Text("Severity: ${severityValue.toInt()}", style = MaterialTheme.typography.bodyMedium)
            Slider(
                value = severityValue,
                onValueChange = { v ->
                    severityValue = v.coerceIn(1f, 10f)
                    vm.setMigraineDraft(
                        type = selectedLabel,
                        severity = severityValue.toInt(),
                        beganAtIso = beganAt,
                        endedAtIso = endedAt,
                        note = notes.ifBlank { null }
                    )
                },
                valueRange = 1f..10f,
                steps = 8, // 2..9 midpoints
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(Modifier.height(8.dp))

            AppDateTimePicker(label = "Start time") {
                beganAt = it
                vm.setMigraineDraft(
                    type = selectedLabel,
                    severity = severityValue.toInt(),
                    beganAtIso = beganAt,
                    endedAtIso = endedAt,
                    note = notes.ifBlank { null }
                )
            }
            Spacer(Modifier.height(8.dp))

            AppDateTimePicker(label = "End time") {
                endedAt = it
                vm.setMigraineDraft(
                    type = selectedLabel,
                    severity = severityValue.toInt(),
                    beganAtIso = beganAt,
                    endedAtIso = endedAt,
                    note = notes.ifBlank { null }
                )
            }
            Spacer(Modifier.height(8.dp))

            OutlinedTextField(
                value = notes,
                onValueChange = { v ->
                    notes = v
                    vm.setMigraineDraft(
                        type = selectedLabel,
                        severity = severityValue.toInt(),
                        beganAtIso = beganAt,
                        endedAtIso = endedAt,
                        note = notes.ifBlank { null }
                    )
                },
                label = { Text("Notes") },
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(Modifier.height(8.dp))
        }

        Spacer(Modifier.weight(1f))

        Row(
            Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            OutlinedButton(onClick = { navController.navigate(Routes.HOME) }) {
                Text("Back")
            }
            Button(onClick = { navController.navigate(Routes.TRIGGERS) }) {
                Text("Next")
            }
        }
    }
}

/* ---------- helpers ---------- */

private fun formatIsoDdMmYyHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "-"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM/yy HH:mm"))
    } catch (_: Exception) {
        "-"
    }
}

title: LoginScreen.kt
text:
package com.migraineme

import android.Manifest
import android.app.Activity
import android.content.pm.PackageManager
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import androidx.credentials.exceptions.GetCredentialException
import com.google.android.libraries.identity.googleid.GetGoogleIdOption
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import androidx.compose.foundation.layout.Spacer

private const val PASSWORD_RECOVERY_REDIRECT_URL = "https://www.andlane.co.uk/migraineme-recover"

@Composable
fun LoginScreen(
    authVm: AuthViewModel,
    onLoggedIn: () -> Unit,
    onNavigateToSignUp: () -> Unit
) {
    val scope = remember { CoroutineScope(Dispatchers.Main) }
    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext
    val snackbarHostState = remember { SnackbarHostState() }

    var loginCompleted by remember { mutableStateOf(false) }

    var showEmailForm by remember { mutableStateOf(false) }
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }

    var busy by remember { mutableStateOf(false) }
    var error by remember { mutableStateOf<String?>(null) }

    // Forgot password dialog state
    var showForgotDialog by remember { mutableStateOf(false) }
    var forgotEmail by remember { mutableStateOf("") }
    var forgotBusy by remember { mutableStateOf(false) }
    var forgotError by remember { mutableStateOf<String?>(null) }

    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { grants ->
        if (grants[Manifest.permission.ACCESS_FINE_LOCATION] == true ||
            grants[Manifest.permission.ACCESS_COARSE_LOCATION] == true
        ) {
            LocationDailySyncWorker.runOnceNow(appCtx)
            LocationDailySyncWorker.scheduleNext(appCtx)
        }
    }

    LaunchedEffect(loginCompleted) {
        if (!loginCompleted) return@LaunchedEffect

        val fine = ContextCompat.checkSelfPermission(
            ctx,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        val coarse = ContextCompat.checkSelfPermission(
            ctx,
            Manifest.permission.ACCESS_COARSE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        if (fine || coarse) {
            LocationDailySyncWorker.runOnceNow(appCtx)
            LocationDailySyncWorker.scheduleNext(appCtx)
            onLoggedIn()
        } else {
            permissionLauncher.launch(
                arrayOf(
                    Manifest.permission.ACCESS_FINE_LOCATION,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                )
            )
        }
    }

    fun handleSuccessfulSession(
        token: String,
        refreshToken: String? = null,
        expiresIn: Long? = null,
        displayNameHint: String? = null,
        avatarUrlHint: String? = null,
        providerHint: String? = null
    ) {
        val userId = JwtUtils.extractUserIdFromAccessToken(token)
        if (userId.isNullOrBlank()) {
            scope.launch {
                snackbarHostState.showSnackbar("Login failed: no userId in access token")
            }
            return
        }

        // Store provider (+ refresh/expires) so app can restore + refresh for workers.
        SessionStore.saveSession(
            context = appCtx,
            accessToken = token,
            userId = userId,
            provider = providerHint,
            refreshToken = refreshToken,
            expiresIn = expiresIn,
            obtainedAtMs = System.currentTimeMillis()
        )
        authVm.setSession(token, userId)

        scope.launch {
            try {
                withContext(Dispatchers.IO) {
                    SupabaseProfileService.ensureProfile(
                        accessToken = token,
                        userId = userId,
                        displayNameHint = displayNameHint,
                        avatarUrlHint = avatarUrlHint
                    )
                }
            } catch (_: Throwable) {
                // Never block login on profile hydration.
            }

            MetricsSyncManager.onLogin(appCtx, token, snackbarHostState)
            loginCompleted = true
        }
    }

    fun parseFragmentParams(uri: Uri): Map<String, String> {
        val frag = uri.fragment ?: return emptyMap()
        if (frag.isBlank()) return emptyMap()

        return frag.split("&")
            .mapNotNull { kv ->
                val idx = kv.indexOf("=")
                if (idx <= 0) return@mapNotNull null
                val k = Uri.decode(kv.substring(0, idx))
                val v = Uri.decode(kv.substring(idx + 1))
                k to v
            }
            .toMap()
    }

    fun tryCompleteSupabaseOAuthReturn(): Boolean {
        val prefs = ctx.getSharedPreferences("supabase_oauth", android.content.Context.MODE_PRIVATE)
        val last = prefs.getString("last_uri", null) ?: return false

        // Clear immediately to avoid double-processing on recomposition.
        prefs.edit().remove("last_uri").apply()

        val uri = Uri.parse(last)
        val frag = parseFragmentParams(uri)

        val accessToken = frag["access_token"]
        val refreshToken = frag["refresh_token"]
        val expiresIn = frag["expires_in"]?.toLongOrNull()

        val errDesc = frag["error_description"] ?: frag["error"]

        if (!errDesc.isNullOrBlank()) {
            error = errDesc
            return true
        }

        if (accessToken.isNullOrBlank()) {
            error = "Facebook sign-in failed (missing access token)."
            return true
        }

        handleSuccessfulSession(
            token = accessToken,
            refreshToken = refreshToken,
            expiresIn = expiresIn,
            displayNameHint = null,
            avatarUrlHint = null,
            providerHint = "facebook"
        )
        return true
    }

    LaunchedEffect(Unit) {
        // If the app was opened via migraineme://auth/callback, MainActivity stored it.
        // Complete login here using the existing post-login flow.
        tryCompleteSupabaseOAuthReturn()
    }

    fun signInWithGoogle() {
        error = null
        busy = true

        scope.launch {
            try {
                val credentialManager = CredentialManager.create(ctx)

                val googleIdOption = GetGoogleIdOption.Builder()
                    .setServerClientId(BuildConfig.GOOGLE_WEB_CLIENT_ID)
                    .setFilterByAuthorizedAccounts(false)
                    .setAutoSelectEnabled(true)
                    .build()

                val request = GetCredentialRequest.Builder()
                    .addCredentialOption(googleIdOption)
                    .build()

                val result = credentialManager.getCredential(
                    context = ctx,
                    request = request
                )

                val credential = result.credential

                val googleCred =
                    if (credential is CustomCredential &&
                        credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL
                    ) {
                        GoogleIdTokenCredential.createFrom(credential.data)
                    } else null

                val idToken = googleCred?.idToken

                if (idToken.isNullOrBlank()) {
                    error = "Google sign-in failed."
                    return@launch
                }

                val ses = SupabaseAuthService.signInWithGoogleIdToken(idToken)
                ses.accessToken?.let {
                    handleSuccessfulSession(
                        token = it,
                        refreshToken = ses.refreshToken,
                        expiresIn = ses.expiresIn,
                        displayNameHint = googleCred?.displayName,
                        avatarUrlHint = googleCred?.profilePictureUri?.toString(),
                        providerHint = "google"
                    )
                } ?: run {
                    error = "Invalid login response."
                }
            } catch (e: GetCredentialException) {
                error = e.message
            } catch (t: Throwable) {
                error = t.message ?: "Google sign-in failed."
            } finally {
                busy = false
            }
        }
    }

    fun signInWithFacebook() {
        error = null

        val activity = ctx as? Activity
        if (activity == null) {
            error = "Facebook sign-in unavailable."
            return
        }

        // Browser handoff is immediate; completion happens when we return via deep link.
        FacebookAuthService().startAuth(activity)
    }

    if (showForgotDialog) {
        AlertDialog(
            onDismissRequest = {
                if (!forgotBusy) {
                    showForgotDialog = false
                    forgotError = null
                }
            },
            title = { Text("Reset password") },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    Text("Enter your email and we’ll send you a reset link.")
                    OutlinedTextField(
                        value = forgotEmail,
                        onValueChange = { forgotEmail = it },
                        label = { Text("Email") },
                        singleLine = true,
                        enabled = !forgotBusy,
                        modifier = Modifier.fillMaxWidth()
                    )
                    forgotError?.let { Text(it, color = MaterialTheme.colorScheme.error) }
                }
            },
            confirmButton = {
                TextButton(
                    enabled = !forgotBusy,
                    onClick = {
                        val e = forgotEmail.trim()
                        if (e.isBlank()) {
                            forgotError = "Please enter your email."
                            return@TextButton
                        }

                        forgotBusy = true
                        forgotError = null

                        scope.launch {
                            try {
                                withContext(Dispatchers.IO) {
                                    SupabaseAuthService.requestPasswordReset(
                                        email = e,
                                        redirectTo = PASSWORD_RECOVERY_REDIRECT_URL
                                    )
                                }
                                showForgotDialog = false
                                snackbarHostState.showSnackbar("Password reset email sent (if the account exists).")
                            } catch (t: Throwable) {
                                forgotError = t.message ?: "Failed to send reset email."
                            } finally {
                                forgotBusy = false
                            }
                        }
                    }
                ) { Text(if (forgotBusy) "Sending." else "Send link") }
            },
            dismissButton = {
                TextButton(
                    enabled = !forgotBusy,
                    onClick = {
                        showForgotDialog = false
                        forgotError = null
                    }
                ) { Text("Cancel") }
            }
        )
    }

    Scaffold(snackbarHost = { SnackbarHost(snackbarHostState) }) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // App logo (app/src/main/res/drawable/logo.png)
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Image(
                    painter = painterResource(id = R.drawable.logo),
                    contentDescription = "MigraineMe",
                    modifier = Modifier.size(110.dp)
                )
            }

            if (!showEmailForm) {
                OutlinedButton(
                    onClick = { showEmailForm = true },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(52.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = "Email",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text("Continue with email")
                    }
                }

                OutlinedButton(
                    onClick = { signInWithFacebook() },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(52.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Image(
                            painter = painterResource(id = R.drawable.facebook_logo_primary),
                            contentDescription = "Facebook",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text("Continue with Facebook")
                    }
                }

                OutlinedButton(
                    onClick = { signInWithGoogle() },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(52.dp)
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Image(
                            painter = painterResource(id = R.drawable.ic_google_logo),
                            contentDescription = "Google",
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(Modifier.width(12.dp))
                        Text("Continue with Google")
                    }
                }

                Divider()

                TextButton(
                    onClick = onNavigateToSignUp,
                    enabled = !busy,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Create account")
                }
            }

            if (showEmailForm) {
                OutlinedTextField(
                    value = email,
                    onValueChange = { email = it },
                    label = { Text("Email") },
                    singleLine = true,
                    enabled = !busy,
                    modifier = Modifier.fillMaxWidth()
                )

                OutlinedTextField(
                    value = password,
                    onValueChange = { password = it },
                    label = { Text("Password") },
                    singleLine = true,
                    enabled = !busy,
                    visualTransformation = PasswordVisualTransformation(),
                    modifier = Modifier.fillMaxWidth()
                )

                TextButton(
                    enabled = !busy,
                    onClick = {
                        forgotEmail = email.trim()
                        forgotError = null
                        showForgotDialog = true
                    }
                ) {
                    Text("Forgot password?")
                }

                Button(
                    onClick = {
                        busy = true
                        error = null
                        scope.launch {
                            try {
                                val ses = SupabaseAuthService.signInWithEmail(
                                    email.trim(),
                                    password
                                )
                                ses.accessToken?.let {
                                    handleSuccessfulSession(
                                        token = it,
                                        refreshToken = ses.refreshToken,
                                        expiresIn = ses.expiresIn,
                                        displayNameHint = null,
                                        avatarUrlHint = null,
                                        providerHint = "email"
                                    )
                                } ?: run {
                                    error = "Invalid login response."
                                }
                            } catch (t: Throwable) {
                                error = t.message ?: "Login failed."
                            } finally {
                                busy = false
                            }
                        }
                    },
                    enabled = !busy,
                    shape = RoundedCornerShape(12.dp),
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(48.dp)
                ) {
                    Text("Continue")
                }

                TextButton(
                    onClick = { showEmailForm = false },
                    enabled = !busy,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Back")
                }
            }

            error?.let {
                Text(it, color = MaterialTheme.colorScheme.error)
            }
        }
    }
}

title: LogoutScreen.kt
text:
// FILE: app/src/main/java/com/migraineme/LogoutScreen.kt
package com.migraineme

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp

@Composable
fun LogoutScreen(
    authVm: AuthViewModel,   // passed from MainActivity so it's the SAME instance
    onLoggedOut: () -> Unit
) {
    val ctx = LocalContext.current
    val authState by authVm.state.collectAsState()

    // We only navigate away once we've confirmed the session is cleared
    val signOutRequested = remember { mutableStateOf(false) }

    LaunchedEffect(signOutRequested.value, authState.accessToken) {
        if (signOutRequested.value && authState.accessToken.isNullOrBlank()) {
            signOutRequested.value = false
            onLoggedOut()
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        Spacer(Modifier.height(12.dp))
        Text("Sign out of your account on this device.")
        Spacer(Modifier.height(16.dp))

        Button(
            onClick = {
                // Clear persisted session immediately (prevents any residual token usage)
                SessionStore.clear(ctx.applicationContext)

                signOutRequested.value = true
                authVm.signOut()
                // DO NOT call onLoggedOut() here; we wait for authState to reflect signed-out
            }
        ) {
            Text("Sign out")
        }
    }
}

title: LogViewModel.kt
text:
package com.migraineme

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import java.time.Instant
import java.time.format.DateTimeFormatter

// --- drafts ---
data class MigraineDraft(
    val type: String? = null,
    val severity: Int? = null,
    val beganAtIso: String? = null,
    val endedAtIso: String? = null,
    val note: String? = null
)

data class TriggerDraft(
    val type: String,
    val startAtIso: String? = null,
    val note: String? = null
)

data class MedicineDraft(
    val name: String? = null,
    val amount: String? = null,
    val notes: String? = null,
    val startAtIso: String? = null
)

data class ReliefDraft(
    val type: String,
    val durationMinutes: Int? = null,
    val notes: String? = null,
    val startAtIso: String? = null
)

data class Draft(
    val migraine: MigraineDraft? = null,
    val triggers: List<TriggerDraft> = emptyList(),
    val meds: List<MedicineDraft> = emptyList(),
    val rels: List<ReliefDraft> = emptyList()
)

// --- journal event feed ---
sealed class JournalEvent {
    data class Migraine(val row: SupabaseDbService.MigraineRow) : JournalEvent()
    data class Trigger(val row: SupabaseDbService.TriggerRow) : JournalEvent()
    data class Medicine(val row: SupabaseDbService.MedicineRow) : JournalEvent()
    data class Relief(val row: SupabaseDbService.ReliefRow) : JournalEvent()
}

class LogViewModel(application: Application) : AndroidViewModel(application) {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _draft = MutableStateFlow(Draft())
    val draft: StateFlow<Draft> = _draft

    private val _migraines = MutableStateFlow<List<SupabaseDbService.MigraineRow>>(emptyList())
    val migraines: StateFlow<List<SupabaseDbService.MigraineRow>> = _migraines

    private val _journal = MutableStateFlow<List<JournalEvent>>(emptyList())
    val journal: StateFlow<List<JournalEvent>> = _journal

    // --- single-entry edit state ---
    private val _editMigraine = MutableStateFlow<SupabaseDbService.MigraineRow?>(null)
    val editMigraine: StateFlow<SupabaseDbService.MigraineRow?> = _editMigraine

    private val _editTrigger = MutableStateFlow<SupabaseDbService.TriggerRow?>(null)
    val editTrigger: StateFlow<SupabaseDbService.TriggerRow?> = _editTrigger

    private val _editMedicine = MutableStateFlow<SupabaseDbService.MedicineRow?>(null)
    val editMedicine: StateFlow<SupabaseDbService.MedicineRow?> = _editMedicine

    private val _editRelief = MutableStateFlow<SupabaseDbService.ReliefRow?>(null)
    val editRelief: StateFlow<SupabaseDbService.ReliefRow?> = _editRelief

    // --- dropdown options (flat kept for compatibility) ---
    private val _migraineOptions = MutableStateFlow<List<String>>(emptyList())
    val migraineOptions: StateFlow<List<String>> = _migraineOptions

    private val _triggerOptions = MutableStateFlow<List<String>>(emptyList())
    val triggerOptions: StateFlow<List<String>> = _triggerOptions

    private val _medicineOptions = MutableStateFlow<List<String>>(emptyList())
    val medicineOptions: StateFlow<List<String>> = _medicineOptions

    private val _reliefOptions = MutableStateFlow<List<String>>(emptyList())
    val reliefOptions: StateFlow<List<String>> = _reliefOptions

    // --- sectioned options ---
    private val _migraineOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val migraineOptionsFrequent: StateFlow<List<String>> = _migraineOptionsFrequent
    private val _migraineOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val migraineOptionsAll: StateFlow<List<String>> = _migraineOptionsAll

    private val _triggerOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val triggerOptionsFrequent: StateFlow<List<String>> = _triggerOptionsFrequent
    private val _triggerOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val triggerOptionsAll: StateFlow<List<String>> = _triggerOptionsAll

    private val _medicineOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val medicineOptionsFrequent: StateFlow<List<String>> = _medicineOptionsFrequent
    private val _medicineOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val medicineOptionsAll: StateFlow<List<String>> = _medicineOptionsAll

    private val _reliefOptionsFrequent = MutableStateFlow<List<String>>(emptyList())
    val reliefOptionsFrequent: StateFlow<List<String>> = _reliefOptionsFrequent
    private val _reliefOptionsAll = MutableStateFlow<List<String>>(emptyList())
    val reliefOptionsAll: StateFlow<List<String>> = _reliefOptionsAll

    // ---- draft mutators ----
    fun setMigraineDraft(
        type: String?,
        severity: Int?,
        beganAtIso: String?,
        endedAtIso: String?,
        note: String?
    ) {
        _draft.value = _draft.value.copy(
            migraine = MigraineDraft(type, severity, beganAtIso, endedAtIso, note)
        )
    }

    fun addTriggerDraft(trigger: String, startAtIso: String? = null, note: String? = null) {
        _draft.value = _draft.value.copy(
            triggers = _draft.value.triggers + TriggerDraft(trigger, startAtIso, note)
        )
    }

    fun addMedicineDraft(name: String, amount: String?, notes: String?, startAtIso: String? = null) {
        _draft.value = _draft.value.copy(
            meds = _draft.value.meds + MedicineDraft(name, amount, notes, startAtIso)
        )
    }

    fun addReliefDraft(type: String, durationMinutes: Int?, notes: String?, startAtIso: String? = null) {
        _draft.value = _draft.value.copy(
            rels = _draft.value.rels + ReliefDraft(type, durationMinutes, notes, startAtIso)
        )
    }

    fun clearDraft() { _draft.value = Draft() }

    // ---- quick actions ----
    fun addMigraine(accessToken: String) {
        viewModelScope.launch {
            try {
                val nowIso = Instant.now().toString()
                db.insertMigraine(accessToken, type = "Migraine", severity = null, startAt = nowIso, endAt = null, notes = null)
                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addMedicine(accessToken: String, name: String, amount: String? = null, notes: String? = null) {
        viewModelScope.launch {
            try {
                val nowIso = Instant.now().toString()
                db.insertMedicine(accessToken, migraineId = null, name = name, amount = amount, startAt = nowIso, notes = notes)
                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addRelief(accessToken: String, type: String, durationMinutes: Int? = null, notes: String? = null) {
        viewModelScope.launch {
            try {
                val nowIso = Instant.now().toString()
                db.insertRelief(accessToken, migraineId = null, type = type, durationMinutes = durationMinutes, startAt = nowIso, notes = notes)
                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    // ---- final save ----
    fun addFull(
        accessToken: String,
        type: String?,
        severity: Int?,
        beganAtIso: String,
        endedAtIso: String?,
        note: String?,
        meds: List<MedicineDraft>,
        rels: List<ReliefDraft>
    ) {
        val triggersSnapshot = _draft.value.triggers

        viewModelScope.launch {
            try {
                val migraineStart = beganAtIso.ifBlank {
                    DateTimeFormatter.ISO_INSTANT.format(Instant.now())
                }

                val migraine = db.insertMigraine(
                    accessToken = accessToken,
                    type = type,
                    severity = severity,
                    startAt = migraineStart,
                    endAt = endedAtIso,
                    notes = note
                )

                for (t in triggersSnapshot.filter { it.type.isNotBlank() }) {
                    try {
                        db.insertTrigger(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = t.type,
                            startAt = t.startAtIso ?: migraineStart,
                            notes = t.note
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (m in meds.filter { !it.name.isNullOrBlank() }) {
                    try {
                        db.insertMedicine(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            name = m.name,
                            amount = m.amount,
                            startAt = m.startAtIso ?: migraineStart,
                            notes = m.notes
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                for (r in rels.filter { it.type.isNotBlank() }) {
                    try {
                        db.insertRelief(
                            accessToken = accessToken,
                            migraineId = migraine.id,
                            type = r.type,
                            durationMinutes = r.durationMinutes,
                            startAt = r.startAtIso ?: migraineStart,
                            notes = r.notes
                        )
                    } catch (e: Exception) { e.printStackTrace() }
                }

                loadJournal(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    // ---- fetch only migraines ----
    fun loadMigraines(accessToken: String) {
        viewModelScope.launch {
            try {
                val rows = db.getMigraines(accessToken)
                _migraines.value = rows
                println("DEBUG loadMigraines: count=${rows.size}")
            } catch (e: Exception) {
                e.printStackTrace()
                _migraines.value = emptyList()
            }
        }
    }

    // ---- unified journal feed ----
    fun loadJournal(accessToken: String) {
        viewModelScope.launch {
            try {
                val migraines = db.getMigraines(accessToken).map { JournalEvent.Migraine(it) }
                val triggers = db.getAllTriggers(accessToken).map { JournalEvent.Trigger(it) }
                val medicines = db.getAllMedicines(accessToken).map { JournalEvent.Medicine(it) }
                val reliefs = db.getAllReliefs(accessToken).map { JournalEvent.Relief(it) }

                val merged = (migraines + triggers + medicines + reliefs).sortedByDescending { ev ->
                    when (ev) {
                        is JournalEvent.Migraine -> ev.row.startAt
                        is JournalEvent.Trigger -> ev.row.startAt
                        is JournalEvent.Medicine -> ev.row.startAt
                        is JournalEvent.Relief -> ev.row.startAt
                    }
                }
                _journal.value = merged
                println("DEBUG loadJournal: count=${merged.size}")
            } catch (e: Exception) {
                e.printStackTrace()
                _journal.value = emptyList()
            }
        }
    }

    // ---- removals ----
    fun removeMigraine(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteMigraine(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeTrigger(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteTrigger(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeMedicine(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteMedicine(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun removeRelief(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                db.deleteRelief(accessToken, id)
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    // ---- load single by id for edit ----
    fun loadMigraineById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editMigraine.value = db.getMigraineById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editMigraine.value = null }
        }
    }

    fun loadTriggerById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editTrigger.value = db.getTriggerById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editTrigger.value = null }
        }
    }

    fun loadMedicineById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editMedicine.value = db.getMedicineById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editMedicine.value = null }
        }
    }

    fun loadReliefById(accessToken: String, id: String) {
        viewModelScope.launch {
            try {
                _editRelief.value = db.getReliefById(accessToken, id)
            } catch (e: Exception) { e.printStackTrace(); _editRelief.value = null }
        }
    }

    // ---- updates for edit screens ----
    fun updateMigraine(
        accessToken: String,
        id: String,
        type: String? = null,
        severity: Int? = null,
        startAt: String? = null,
        endAt: String? = null,
        notes: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateMigraine(accessToken, id, type, severity, startAt, endAt, notes)
                _editMigraine.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun updateTrigger(
        accessToken: String,
        id: String,
        type: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateTrigger(accessToken, id, type, startAt, notes, migraineId)
                _editTrigger.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun updateMedicine(
        accessToken: String,
        id: String,
        name: String? = null,
        amount: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateMedicine(accessToken, id, name, amount, startAt, notes, migraineId)
                _editMedicine.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    fun updateRelief(
        accessToken: String,
        id: String,
        type: String? = null,
        durationMinutes: Int? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ) {
        viewModelScope.launch {
            try {
                val updated = db.updateRelief(accessToken, id, type, durationMinutes, startAt, notes, migraineId)
                _editRelief.value = updated
                loadJournal(accessToken)
            } catch (e: Exception) { e.printStackTrace() }
        }
    }

    // ---- option loaders for dropdowns ----
    fun loadMigraineOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getMigrainePrefs(accessToken)
                val pool = db.getAllMigrainePool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.migraine?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _migraineOptionsFrequent.value = frequent
                _migraineOptionsAll.value = allMinusFrequent
                _migraineOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _migraineOptionsFrequent.value = emptyList()
                _migraineOptionsAll.value = emptyList()
                _migraineOptions.value = emptyList()
            }
        }
    }

    fun loadTriggerOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getTriggerPrefs(accessToken)
                val pool = db.getAllTriggerPool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.trigger?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _triggerOptionsFrequent.value = frequent
                _triggerOptionsAll.value = allMinusFrequent
                _triggerOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _triggerOptionsFrequent.value = emptyList()
                _triggerOptionsAll.value = emptyList()
                _triggerOptions.value = emptyList()
            }
        }
    }

    fun loadMedicineOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getMedicinePrefs(accessToken)
                val pool = db.getAllMedicinePool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.medicine?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _medicineOptionsFrequent.value = frequent
                _medicineOptionsAll.value = allMinusFrequent
                _medicineOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _medicineOptionsFrequent.value = emptyList()
                _medicineOptionsAll.value = emptyList()
                _medicineOptions.value = emptyList()
            }
        }
    }

    fun loadReliefOptions(accessToken: String) {
        viewModelScope.launch {
            try {
                val prefs = db.getReliefPrefs(accessToken)
                val pool = db.getAllReliefPool(accessToken)

                val frequent = prefs
                    .filter { it.status == "frequent" }
                    .sortedBy { it.position }
                    .mapNotNull { it.relief?.label?.trim() }
                    .filter { it.isNotEmpty() }

                val all = pool.mapNotNull { it.label.trim() }.filter { it.isNotEmpty() }
                val allMinusFrequent = all.filter { it !in frequent }.sorted()

                _reliefOptionsFrequent.value = frequent
                _reliefOptionsAll.value = allMinusFrequent
                _reliefOptions.value = buildList { addAll(frequent); addAll(allMinusFrequent) }
            } catch (e: Exception) {
                e.printStackTrace()
                _reliefOptionsFrequent.value = emptyList()
                _reliefOptionsAll.value = emptyList()
                _reliefOptions.value = emptyList()
            }
        }
    }
}

title: MainActivity.kt
text:
// FILE: app/src/main/java/com/migraineme/MainActivity.kt
package com.migraineme

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.outlined.Logout
import androidx.compose.material.icons.outlined.Assessment
import androidx.compose.material.icons.outlined.BarChart
import androidx.compose.material.icons.outlined.Groups
import androidx.compose.material.icons.outlined.History
import androidx.compose.material.icons.outlined.Home
import androidx.compose.material.icons.outlined.Link
import androidx.compose.material.icons.outlined.Person
import androidx.compose.material.icons.outlined.Psychology
import androidx.compose.material.icons.outlined.Settings
import androidx.compose.material.icons.outlined.Storage
import androidx.compose.material.icons.outlined.Timeline
import androidx.compose.material3.Badge
import androidx.compose.material3.BadgedBox
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.NavigationBar
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.NavigationDrawerItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.rememberDrawerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import kotlinx.coroutines.launch

object Routes {
    const val HOME = "home"
    const val PROFILE = "profile"
    const val DATA = "data"
    const val COMMUNITY = "community"
    const val INSIGHTS = "insights"
    const val MONITOR = "monitor"
    const val JOURNAL = "journal"

    const val MIGRAINE = "migraine"
    const val TRIGGERS = "triggers"
    const val ADJUST_TRIGGERS = "adjust_triggers"
    const val MEDICINES = "medicines"
    const val ADJUST_MEDICINES = "adjust_medicines"
    const val RELIEFS = "reliefs"
    const val ADJUST_RELIEFS = "adjust_reliefs"
    const val REVIEW = "review"

    const val LOGIN = "login"
    const val SIGNUP = "signup"
    const val LOGOUT = "logout"

    const val EDIT_MIGRAINE = "edit_migraine"
    const val EDIT_TRIGGER = "edit_trigger"
    const val EDIT_MEDICINE = "edit_medicine"
    const val EDIT_RELIEF = "edit_relief"

    const val ADJUST_MIGRAINES = "adjust_migraines"

    const val TESTING = "testing"
    const val TESTING_COMPLETE = "testing_complete"

    const val THIRD_PARTY_CONNECTIONS = "third_party_connections"

    const val CHANGE_PASSWORD = "change_password"
}

class MainActivity : ComponentActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // IMPORTANT: MainActivity should ONLY persist callback URIs.
        // Do NOT call WhoopAuthService.completeAuth() here.
        handleWhoopOAuthIntent(intent)
        handleSupabaseOAuthIntent(intent)

        setContent { MaterialTheme { AppRoot() } }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        // IMPORTANT: persist callback URIs on every new intent.
        handleWhoopOAuthIntent(intent)
        handleSupabaseOAuthIntent(intent)
    }

    private fun handleWhoopOAuthIntent(intent: Intent?) {
        val data: Uri? = intent?.data
        if (data?.scheme == "migraineme" && data.host == "whoop" && data.path == "/callback") {

            val code = data.getQueryParameter("code")
            val state = data.getQueryParameter("state")
            val error = data.getQueryParameter("error")

            val prefs = getSharedPreferences("whoop_oauth", MODE_PRIVATE)
            prefs.edit()
                .putString("last_uri", data.toString())
                .putString("code", code)
                .putString("state", state)
                .putString("error", error)
                .apply()

            when {
                !error.isNullOrBlank() -> {
                    Toast.makeText(this, "WHOOP auth error: $error", Toast.LENGTH_SHORT).show()
                }
                !code.isNullOrBlank() -> {
                    // Completion happens in ThirdPartyConnectionsScreen (it calls WhoopAuthService().completeAuth(context))
                    Toast.makeText(this, "Returning from WHOOP…", Toast.LENGTH_SHORT).show()
                }
                else -> {
                    Toast.makeText(this, "WHOOP callback opened.", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun handleSupabaseOAuthIntent(intent: Intent?) {
        val data: Uri? = intent?.data
        if (data?.scheme == "migraineme" && data.host == "auth" && data.path == "/callback") {
            val prefs = getSharedPreferences("supabase_oauth", MODE_PRIVATE)
            prefs.edit()
                .putString("last_uri", data.toString())
                .apply()

            Toast.makeText(this, "Returning from sign-in…", Toast.LENGTH_SHORT).show()
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AppRoot() {
    val nav = rememberNavController()
    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    val ctx = LocalContext.current
    val appCtx = ctx.applicationContext

    val authVm: AuthViewModel = viewModel()
    val logVm: LogViewModel = viewModel()
    val triggerVm: TriggerViewModel = viewModel()
    val medVm: MedicineViewModel = viewModel()
    val reliefVm: ReliefViewModel = viewModel()
    val migraineVm: MigraineViewModel = viewModel()

    val authState by authVm.state.collectAsState()
    val token = authState.accessToken
    var preloaded by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        val persistedToken = SessionStore.getValidAccessToken(appCtx)

        if (!persistedToken.isNullOrBlank() && authState.accessToken.isNullOrBlank()) {
            var persistedUserId = SessionStore.readUserId(appCtx)

            if (persistedUserId.isNullOrBlank()) {
                persistedUserId = JwtUtils.extractUserIdFromAccessToken(persistedToken)
                if (!persistedUserId.isNullOrBlank()) {
                    SessionStore.saveUserId(appCtx, persistedUserId)
                }
            }

            if (!persistedUserId.isNullOrBlank()) {
                authVm.setSession(persistedToken, persistedUserId)
            }
        }
    }

    LaunchedEffect(token) {
        if (token.isNullOrBlank()) {
            preloaded = false
        } else if (!preloaded) {
            logVm.loadJournal(token)
            preloaded = true
        }
    }

    val journal by logVm.journal.collectAsState()
    val attentionCount = remember(journal) { journal.count { needsAttention(it) } }

    data class DrawerItem(val title: String, val route: String, val icon: ImageVector)

    val drawerItems = listOf(
        DrawerItem("Profile", Routes.PROFILE, Icons.Outlined.Person),
        DrawerItem("Connections", Routes.THIRD_PARTY_CONNECTIONS, Icons.Outlined.Link),
        DrawerItem("Data", Routes.DATA, Icons.Outlined.Storage),
        DrawerItem("Testing", Routes.TESTING, Icons.Outlined.BarChart),
        DrawerItem("Testing Complete", Routes.TESTING_COMPLETE, Icons.Outlined.Assessment),
        DrawerItem("Logout", Routes.LOGOUT, Icons.AutoMirrored.Outlined.Logout)
    )

    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            ModalDrawerSheet {
                Text(
                    "Settings",
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 20.dp)
                )
                drawerItems.forEach { item ->
                    NavigationDrawerItem(
                        label = { Text(item.title) },
                        selected = false,
                        onClick = {
                            scope.launch { drawerState.close() }
                            nav.navigate(item.route) { launchSingleTop = true }
                        },
                        icon = { Icon(item.icon, contentDescription = item.title) }
                    )
                }
            }
        }
    ) {
        val backStack by nav.currentBackStackEntryAsState()
        val current = backStack?.destination?.route ?: Routes.LOGIN

        Scaffold(
            topBar = {
                CenterAlignedTopAppBar(
                    title = {
                        Text(
                            when (current) {
                                Routes.MONITOR -> "Monitor"
                                Routes.INSIGHTS -> "Insights"
                                Routes.HOME -> "Home"
                                Routes.MIGRAINE -> "Migraine"
                                Routes.COMMUNITY -> "Community"
                                Routes.JOURNAL -> "Journal"
                                Routes.LOGIN -> "Sign in"
                                Routes.SIGNUP -> "Create account"
                                Routes.PROFILE -> "Profile"
                                Routes.DATA -> "Data"
                                Routes.LOGOUT -> "Logout"
                                Routes.MEDICINES -> "Medicines"
                                Routes.ADJUST_MEDICINES -> "Adjust Medicines"
                                Routes.RELIEFS -> "Reliefs"
                                Routes.ADJUST_RELIEFS -> "Adjust Reliefs"
                                Routes.TRIGGERS -> "Triggers"
                                Routes.ADJUST_TRIGGERS -> "Adjust Triggers"
                                Routes.REVIEW -> "Review Log"
                                Routes.EDIT_MIGRAINE -> "Edit Migraine"
                                Routes.EDIT_TRIGGER -> "Edit Trigger"
                                Routes.EDIT_MEDICINE -> "Edit Medicine"
                                Routes.EDIT_RELIEF -> "Edit Relief"
                                Routes.ADJUST_MIGRAINES -> "Adjust Migraines"
                                Routes.TESTING -> "Testing"
                                Routes.TESTING_COMPLETE -> "Testing Complete"
                                Routes.THIRD_PARTY_CONNECTIONS -> "Connections"
                                Routes.CHANGE_PASSWORD -> "Change password"
                                else -> ""
                            }
                        )
                    },
                    navigationIcon = {
                        if (current != Routes.LOGIN && current != Routes.SIGNUP) {
                            IconButton(onClick = { scope.launch { drawerState.open() } }) {
                                Icon(Icons.Outlined.Settings, contentDescription = "Settings")
                            }
                        }
                    },
                    actions = {
                        if (current != Routes.LOGIN && current != Routes.SIGNUP) {
                            IconButton(onClick = { nav.navigate(Routes.COMMUNITY) }) {
                                Icon(Icons.Outlined.Groups, contentDescription = "Community")
                            }
                        }
                    }
                )
            },
            bottomBar = {
                if (current != Routes.LOGIN && current != Routes.SIGNUP) {
                    BottomBar(nav, attentionCount)
                }
            }
        ) { inner ->
            NavHost(
                navController = nav,
                startDestination = Routes.LOGIN,
                modifier = Modifier
                    .fillMaxSize()
                    .padding(inner)
            ) {
                composable(Routes.MONITOR) { MonitorScreen() }
                composable(Routes.INSIGHTS) { InsightsScreen() }
                composable(Routes.HOME) {
                    HomeScreenRoot(
                        onLogout = { nav.navigate(Routes.LOGOUT) { launchSingleTop = true } },
                        onNavigateToMigraine = { nav.navigate(Routes.MIGRAINE) },
                        authVm = authVm,
                        logVm = logVm
                    )
                }
                composable(Routes.COMMUNITY) { CommunityScreen() }
                composable(Routes.JOURNAL) {
                    JournalScreen(navController = nav, authVm = authVm, vm = logVm)
                }

                composable(Routes.MIGRAINE) {
                    LogHomeScreen(navController = nav, authVm = authVm, vm = logVm)
                }

                composable(Routes.TRIGGERS) {
                    TriggersScreen(navController = nav, vm = triggerVm, authVm = authVm, logVm = logVm)
                }
                composable(Routes.ADJUST_TRIGGERS) {
                    AdjustTriggersScreen(navController = nav, vm = triggerVm, authVm = authVm)
                }

                composable(Routes.MEDICINES) {
                    MedicinesScreen(navController = nav, vm = medVm, authVm = authVm, logVm = logVm)
                }
                composable(Routes.ADJUST_MEDICINES) {
                    AdjustMedicinesScreen(navController = nav, vm = medVm, authVm = authVm)
                }

                composable(Routes.RELIEFS) {
                    ReliefsScreen(navController = nav, vm = reliefVm, authVm = authVm, logVm = logVm)
                }
                composable(Routes.ADJUST_RELIEFS) {
                    AdjustReliefsScreen(navController = nav, vm = reliefVm, authVm = authVm)
                }

                composable(Routes.REVIEW) { ReviewLogScreen(navController = nav, authVm = authVm, vm = logVm) }

                composable("${Routes.EDIT_MIGRAINE}/{id}") {
                    val id = it.arguments?.getString("id") ?: return@composable
                    EditMigraineScreen(navController = nav, authVm = authVm, vm = logVm, id = id)
                }
                composable("${Routes.EDIT_TRIGGER}/{id}") {
                    val id = it.arguments?.getString("id") ?: return@composable
                    EditTriggerScreen(navController = nav, authVm = authVm, vm = logVm, id = id)
                }
                composable("${Routes.EDIT_MEDICINE}/{id}") {
                    val id = it.arguments?.getString("id") ?: return@composable
                    EditMedicineScreen(navController = nav, authVm = authVm, vm = logVm, id = id)
                }
                composable("${Routes.EDIT_RELIEF}/{id}") {
                    val id = it.arguments?.getString("id") ?: return@composable
                    EditReliefScreen(navController = nav, authVm = authVm, vm = logVm, id = id)
                }

                composable(Routes.ADJUST_MIGRAINES) {
                    AdjustMigrainesScreen(navController = nav, vm = migraineVm, authVm = authVm)
                }

                composable(Routes.LOGIN) {
                    val a by authVm.state.collectAsState()
                    LaunchedEffect(a.accessToken) {
                        if (!a.accessToken.isNullOrBlank()) {
                            nav.navigate(Routes.HOME) {
                                popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                launchSingleTop = true
                            }
                        }
                    }
                    LoginScreen(
                        authVm = authVm,
                        onLoggedIn = {
                            nav.navigate(Routes.HOME) {
                                popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                launchSingleTop = true
                            }
                        },
                        onNavigateToSignUp = { nav.navigate(Routes.SIGNUP) { launchSingleTop = true } }
                    )
                }

                composable(Routes.SIGNUP) {
                    SignupScreen(
                        authVm = authVm,
                        onSignedUpAndLoggedIn = {
                            nav.navigate(Routes.HOME) {
                                popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                launchSingleTop = true
                            }
                        },
                        onNavigateToLogin = { nav.navigate(Routes.LOGIN) { launchSingleTop = true } }
                    )
                }

                composable(Routes.PROFILE) {
                    ProfileScreen(
                        authVm = authVm,
                        onNavigateChangePassword = { nav.navigate(Routes.CHANGE_PASSWORD) }
                    )
                }

                composable(Routes.CHANGE_PASSWORD) {
                    ChangePasswordScreen(
                        authVm = authVm,
                        onDone = { nav.popBackStack() }
                    )
                }

                composable(Routes.THIRD_PARTY_CONNECTIONS) {
                    ThirdPartyConnectionsScreen(onBack = { nav.popBackStack() })
                }

                composable(Routes.DATA) { DataSettingsScreen() }

                composable(Routes.LOGOUT) {
                    LogoutScreen(
                        authVm = authVm,
                        onLoggedOut = {
                            nav.navigate(Routes.LOGIN) {
                                popUpTo(nav.graph.findStartDestination().id) { inclusive = true }
                                launchSingleTop = true
                            }
                        }
                    )
                }

                composable(Routes.TESTING) { TestingScreen(authVm = authVm) }
                composable(Routes.TESTING_COMPLETE) { TestingScreenComplete(authVm = authVm) }
            }
        }
    }
}

private fun needsAttention(ev: JournalEvent): Boolean {
    return when (ev) {
        is JournalEvent.Migraine ->
            ev.row.startAt.isNullOrBlank() || ev.row.endAt.isNullOrBlank() || ev.row.severity == null

        is JournalEvent.Trigger ->
            ev.row.startAt.isNullOrBlank()

        is JournalEvent.Medicine ->
            ev.row.amount.isNullOrBlank() || ev.row.startAt.isNullOrBlank()

        is JournalEvent.Relief ->
            ev.row.durationMinutes == null || ev.row.startAt.isNullOrBlank()
    }
}

@Composable
private fun BottomBar(
    nav: androidx.navigation.NavHostController,
    journalBadgeCount: Int
) {
    data class BottomItem(val route: String, val label: String, val icon: ImageVector)

    val items = listOf(
        BottomItem(Routes.MONITOR, "Monitor", Icons.Outlined.Timeline),
        BottomItem(Routes.INSIGHTS, "Insights", Icons.Outlined.BarChart),
        BottomItem(Routes.HOME, "Home", Icons.Outlined.Home),
        BottomItem(Routes.MIGRAINE, "Migraine", Icons.Outlined.Psychology),
        BottomItem(Routes.JOURNAL, "Journal", Icons.Outlined.History)
    )

    NavigationBar {
        val backStack by nav.currentBackStackEntryAsState()
        val currentRoute = backStack?.destination?.route

        items.forEach { item ->
            val showBadge = item.route == Routes.JOURNAL && journalBadgeCount > 0
            NavigationBarItem(
                selected = currentRoute == item.route,
                onClick = {
                    nav.navigate(item.route) {
                        popUpTo(nav.graph.findStartDestination().id) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                },
                icon = {
                    if (showBadge) {
                        BadgedBox(badge = { Badge { Text(journalBadgeCount.toString()) } }) {
                            Icon(item.icon, contentDescription = item.label)
                        }
                    } else {
                        Icon(item.icon, contentDescription = item.label)
                    }
                },
                label = { Text(item.label) },
                alwaysShowLabel = true
            )
        }
    }
}

title: MedicinesScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun MedicinesScreen(
    navController: NavController,
    vm: MedicineViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel
) {
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val pool by vm.pool.collectAsState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    val frequentIds = remember(frequent) { frequent.map { it.medicineId }.toSet() }
    val remaining = remember(pool, frequentIds) { pool.filter { it.id !in frequentIds } }

    // Add dialog (amount + time when adding new)
    var showAddDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }
    fun openAdd(label: String) {
        pendingLabel = label
        showAddDialog = true
    }
    if (showAddDialog) {
        AmountTimeDialog(
            initialAmount = "",
            initialIso = null,
            onDismiss = { showAddDialog = false },
            onConfirm = { amount, iso ->
                val label = pendingLabel ?: return@AmountTimeDialog
                logVm.addMedicineDraft(name = label, amount = amount, notes = null, startAtIso = iso)
                showAddDialog = false
            }
        )
    }

    // Edit dialogs for existing cards
    var showEditAmount by remember { mutableStateOf(false) }
    var amountEditIndex by remember { mutableStateOf<Int?>(null) }

    var showEditTime by remember { mutableStateOf(false) }
    var timeEditIndex by remember { mutableStateOf<Int?>(null) }

    if (showEditAmount && amountEditIndex != null && amountEditIndex in draft.meds.indices) {
        AmountOnlyDialog(
            initial = draft.meds[amountEditIndex!!].amount ?: "",
            onDismiss = { showEditAmount = false },
            onConfirm = { newAmount ->
                val idx = amountEditIndex!!
                val d = draft
                logVm.clearDraft()
                logVm.setMigraineDraft(
                    d.migraine?.type, d.migraine?.severity,
                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                )
                d.triggers.forEach { t ->
                    logVm.addTriggerDraft(t.type, startAtIso = t.startAtIso, note = t.note)
                }
                d.meds.forEachIndexed { i, mm ->
                    mm.name?.let { nm ->
                        val amt = if (i == idx) newAmount else mm.amount
                        logVm.addMedicineDraft(nm, amt, mm.notes, mm.startAtIso)
                    }
                }
                d.rels.forEach { r ->
                    logVm.addReliefDraft(r.type, r.durationMinutes, r.notes, r.startAtIso)
                }
                showEditAmount = false
            }
        )
    }

    if (showEditTime && timeEditIndex != null && timeEditIndex in draft.meds.indices) {
        TimeOnlyDialog(
            initialIso = draft.meds[timeEditIndex!!].startAtIso,
            onDismiss = { showEditTime = false },
            onConfirm = { newIso ->
                val idx = timeEditIndex!!
                val d = draft
                logVm.clearDraft()
                logVm.setMigraineDraft(
                    d.migraine?.type, d.migraine?.severity,
                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                )
                d.triggers.forEach { t ->
                    logVm.addTriggerDraft(t.type, startAtIso = t.startAtIso, note = t.note)
                }
                d.meds.forEachIndexed { i, mm ->
                    mm.name?.let { nm ->
                        val iso = if (i == idx) newIso else mm.startAtIso
                        logVm.addMedicineDraft(nm, mm.amount, mm.notes, iso)
                    }
                }
                d.rels.forEach { r ->
                    logVm.addReliefDraft(r.type, r.durationMinutes, r.notes, r.startAtIso)
                }
                showEditTime = false
            }
        )
    }

    Scaffold(
        bottomBar = {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(onClick = { navController.navigate(Routes.TRIGGERS) }) { Text("Back") }
                Button(onClick = { navController.navigate(Routes.RELIEFS) }) { Text("Next") }
            }
        }
    ) { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Frequent header + Manage
            if (frequent.isNotEmpty()) {
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text("Frequent", style = MaterialTheme.typography.titleMedium)
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_MEDICINES) }) {
                            Text("Manage")
                        }
                    }
                }
            } else {
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_MEDICINES) }) {
                            Text("Manage")
                        }
                    }
                }
            }

            // Selected now — compact card; time/amount as text + plain clickable "Edit"
            item {
                if (draft.meds.isNotEmpty()) {
                    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                        Text("Selected now", style = MaterialTheme.typography.titleMedium)
                        for (idx in draft.meds.indices.reversed()) {
                            val m = draft.meds[idx]

                            ElevatedCard(
                                modifier = Modifier.fillMaxWidth(),
                                colors = CardDefaults.elevatedCardColors(),
                                shape = MaterialTheme.shapes.medium
                            ) {
                                Column(Modifier.padding(8.dp)) {
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(m.name ?: "?", style = MaterialTheme.typography.bodyLarge)
                                        IconButton(
                                            onClick = {
                                                val d = draft
                                                logVm.clearDraft()
                                                logVm.setMigraineDraft(
                                                    d.migraine?.type, d.migraine?.severity,
                                                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                                                )
                                                d.triggers.forEach { t ->
                                                    logVm.addTriggerDraft(t.type, startAtIso = t.startAtIso, note = t.note)
                                                }
                                                d.meds.forEachIndexed { i, mm ->
                                                    mm.name?.let { nm ->
                                                        if (i != idx) {
                                                            logVm.addMedicineDraft(nm, mm.amount, mm.notes, mm.startAtIso)
                                                        }
                                                    }
                                                }
                                                d.rels.forEach { r ->
                                                    logVm.addReliefDraft(r.type, r.durationMinutes, r.notes, r.startAtIso)
                                                }
                                            }
                                        ) { Icon(Icons.Default.Delete, contentDescription = "Remove") }
                                    }

                                    // Time line
                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(top = 6.dp),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(
                                            "Time: ${formatIsoDdMmHm(m.startAtIso)}",
                                            style = MaterialTheme.typography.bodyMedium
                                        )
                                        Text(
                                            "Edit",
                                            color = MaterialTheme.colorScheme.primary,
                                            style = MaterialTheme.typography.bodyMedium,
                                            modifier = Modifier.clickable {
                                                timeEditIndex = idx
                                                showEditTime = true
                                            }
                                        )
                                    }

                                    // Amount line
                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(top = 6.dp),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(
                                            if (m.amount.isNullOrBlank()) "Amount: not set" else "Amount: ${m.amount}",
                                            style = MaterialTheme.typography.bodyMedium
                                        )
                                        Text(
                                            "Edit",
                                            color = MaterialTheme.colorScheme.primary,
                                            style = MaterialTheme.typography.bodyMedium,
                                            modifier = Modifier.clickable {
                                                amountEditIndex = idx
                                                showEditAmount = true
                                            }
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Frequent chips → add dialog
            if (frequent.isNotEmpty()) {
                item {
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        frequent.forEach { pref ->
                            val label = pref.medicine?.label ?: return@forEach
                            AssistChip(onClick = { openAdd(label) }, label = { Text(label) })
                        }
                    }
                }
            }

            // All medicines chips → add dialog
            if (remaining.isNotEmpty()) {
                item { Text("All Medicines", style = MaterialTheme.typography.titleMedium) }
                item {
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        remaining.forEach { med ->
                            AssistChip(onClick = { openAdd(med.label) }, label = { Text(med.label) })
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(80.dp)) }
        }
    }
}

/** Format ISO string to "dd/MM HH:mm". Falls back to "Not set" if parse fails. */
private fun formatIsoDdMmHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}

@Composable
private fun AmountTimeDialog(
    initialAmount: String,
    initialIso: String?,
    onDismiss: () -> Unit,
    onConfirm: (amount: String, iso: String?) -> Unit
) {
    var amount by remember { mutableStateOf(initialAmount) }
    var pickedIso by remember { mutableStateOf(initialIso) }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = { onConfirm(amount.trim(), pickedIso) },
                enabled = amount.isNotBlank()
            ) { Text("Confirm") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Add medicine") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                OutlinedTextField(
                    value = amount,
                    onValueChange = { amount = it },
                    label = { Text("Amount") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                AppDateTimePicker(
                    label = pickedIso?.let { formatIsoDdMmHm(it) } ?: "Set time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        }
    )
}

@Composable
private fun AmountOnlyDialog(
    initial: String,
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var amount by remember { mutableStateOf(initial) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = { onConfirm(amount.trim()) },
                enabled = amount.isNotBlank()
            ) { Text("Confirm") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Edit amount") },
        text = {
            OutlinedTextField(
                value = amount,
                onValueChange = { amount = it },
                label = { Text("Amount") },
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
        }
    )
}

@Composable
private fun TimeOnlyDialog(
    initialIso: String?,
    onDismiss: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text("Confirm") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Edit time") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Current: ${formatIsoDdMmHm(pickedIso)}")
                // Picker shown immediately in the dialog
                AppDateTimePicker(
                    label = "Select new time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        }
    )
}

title: MedicineViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MedicineViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.AllMedicineRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.AllMedicineRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.MedicinePrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.MedicinePrefRow>> = _frequent

    private fun sortPrefs(prefs: List<SupabaseDbService.MedicinePrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllMedicinePool(accessToken)
                val prefs = db.getMedicinePrefs(accessToken)
                _pool.value = p
                _frequent.value = sortPrefs(prefs.filter { it.status == "frequent" })
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String) {
        viewModelScope.launch {
            try {
                db.upsertMedicineToPool(accessToken, label.trim())
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addNewToPoolAndFrequent(accessToken: String, label: String) {
        viewModelScope.launch {
            try {
                val added = db.upsertMedicineToPool(accessToken, label.trim())
                val pos = _frequent.value.size
                db.insertMedicinePref(accessToken, added.id, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, medicineId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertMedicinePref(accessToken, medicineId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteMedicinePref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, medicineId: String) {
        viewModelScope.launch {
            try {
                db.deleteMedicineFromPool(accessToken, medicineId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}

title: MetricsSyncManager.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHostState
import io.ktor.client.HttpClient
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.util.Date

/**
 * Called from LoginScreen after successful auth.
 *
 * Responsibilities:
 * - Best-effort WHOOP token refresh (does not change auth approach)
 * - Upload WHOOP token to Supabase (server worker source of truth)
 * - Schedule WHOOP daily workers (sleep + physical) if enabled + connected
 * - Schedule Location worker if enabled
 * - Best-effort enqueue of server-side WHOOP backfill jobs on login
 *
 * Does NOT:
 * - Change Supabase auth
 * - Change Whoop auth structure
 */
object MetricsSyncManager {

    private val baseUrl: String = BuildConfig.SUPABASE_URL.trimEnd('/')
    private val anonKey: String = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient(Android) {
        install(ContentNegotiation) {
            json(
                Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                    encodeDefaults = true
                    explicitNulls = false
                }
            )
        }
    }

    @Serializable
    private data class EmptyBody(val ok: Boolean = true)

    @Serializable
    private data class UpsertWhoopTokenBody(
        val access_token: String,
        val refresh_token: String,
        val token_type: String,
        val expires_at: String?
    )

    /**
     * Triggers the Edge Function:
     * POST {SUPABASE_URL}/functions/v1/enqueue-login-backfill
     *
     * Requires:
     * - Authorization: Bearer <user access token>
     *
     * Best-effort: failures are logged, never block login.
     */
    private suspend fun enqueueLoginBackfillBestEffort(accessToken: String) {
        val url = "$baseUrl/functions/v1/enqueue-login-backfill"

        try {
            val resp = client.post(url) {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", anonKey)
                contentType(ContentType.Application.Json)
                setBody(EmptyBody())
            }

            if (!resp.status.isSuccess()) {
                val txt = runCatching { resp.bodyAsText() }.getOrNull()
                Log.w(
                    "MetricsSyncManager",
                    "enqueue-login-backfill failed: HTTP ${resp.status.value} ${txt ?: ""}".trim()
                )
            } else {
                Log.d("MetricsSyncManager", "enqueue-login-backfill ok")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "enqueue-login-backfill error: ${t.message}")
        }
    }

    /**
     * CRITICAL: Upload local WHOOP token to Supabase so Edge Worker can run.
     *
     * POST {SUPABASE_URL}/functions/v1/upsert-whoop-token
     *
     * Best-effort: never blocks login.
     */
    private suspend fun upsertWhoopTokenToSupabaseBestEffort(
        context: Context,
        accessToken: String
    ) {
        val appCtx = context.applicationContext
        val localTok = runCatching { WhoopTokenStore(appCtx).load() }.getOrNull() ?: return

        val url = "$baseUrl/functions/v1/upsert-whoop-token"

        val expiresAtIso = if (localTok.expiresAtMillis > 0L) {
            runCatching { Date(localTok.expiresAtMillis).toInstant().toString() }.getOrNull()
        } else {
            null
        }

        val body = UpsertWhoopTokenBody(
            access_token = localTok.accessToken,
            refresh_token = localTok.refreshToken,
            token_type = localTok.tokenType.ifBlank { "Bearer" },
            expires_at = expiresAtIso
        )

        try {
            val resp = client.post(url) {
                header(HttpHeaders.Authorization, "Bearer $accessToken")
                header("apikey", anonKey)
                contentType(ContentType.Application.Json)
                setBody(body)
            }

            if (!resp.status.isSuccess()) {
                val txt = runCatching { resp.bodyAsText() }.getOrNull()
                Log.w(
                    "MetricsSyncManager",
                    "upsert-whoop-token failed: HTTP ${resp.status.value} ${txt ?: ""}".trim()
                )
            } else {
                Log.d("MetricsSyncManager", "upsert-whoop-token ok")
            }
        } catch (t: Throwable) {
            Log.w("MetricsSyncManager", "upsert-whoop-token error: ${t.message}")
        }
    }

    suspend fun onLogin(
        context: Context,
        token: String,
        snackbarHostState: SnackbarHostState
    ) {
        val appCtx = context.applicationContext

        withContext(Dispatchers.IO) {
            try {
                // Enqueue backfill jobs on login (best-effort)
                enqueueLoginBackfillBestEffort(token)

                // If WHOOP token exists locally, upload it to Supabase (best-effort)
                upsertWhoopTokenToSupabaseBestEffort(appCtx, token)

                // WHOOP connection = token exists locally
                val whoopConnected = runCatching { WhoopTokenStore(appCtx).load() != null }.getOrDefault(false)

                // Determine if ANY WHOOP tables are enabled (sleep / physical)
                val whoopSleepEnabled =
                    DataCollectionSettings.isEnabledForWhoop(appCtx, "sleep_duration_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "sleep_score_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "sleep_efficiency_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "sleep_stages_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "sleep_disturbances_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "fell_asleep_time_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "woke_up_time_daily")

                val whoopPhysicalEnabled =
                    DataCollectionSettings.isEnabledForWhoop(appCtx, "recovery_score_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "resting_hr_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "hrv_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "skin_temp_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "spo2_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "time_in_high_hr_zones_daily") ||
                            DataCollectionSettings.isEnabledForWhoop(appCtx, "steps_daily")

                // If WHOOP connected, refresh Whoop token once (best-effort).
                if (whoopConnected && (whoopSleepEnabled || whoopPhysicalEnabled)) {
                    runCatching { WhoopAuthService().refresh(appCtx) }.onFailure {
                        Log.w("MetricsSyncManager", "WHOOP refresh failed: ${it.message}")
                    }

                    if (whoopSleepEnabled) {
                        WhoopDailySyncWorkerSleepFields.runOnceNow(appCtx)
                        WhoopDailySyncWorkerSleepFields.scheduleNext(appCtx)
                    }

                    if (whoopPhysicalEnabled) {
                        WhoopDailyPhysicalHealthWorker.runOnceNow(appCtx)
                        WhoopDailyPhysicalHealthWorker.scheduleNext(appCtx)
                    }
                } else if (!whoopConnected && (whoopSleepEnabled || whoopPhysicalEnabled)) {
                    withContext(Dispatchers.Main) {
                        snackbarHostState.showSnackbar(
                            message = "Whoop not connected — connect Whoop to collect data.",
                            duration = SnackbarDuration.Short
                        )
                    }
                }

                // Location (NOT Whoop-specific)
                val locationEnabled =
                    DataCollectionSettings.isActive(
                        context = appCtx,
                        table = "user_location_daily",
                        wearable = null,
                        defaultValue = true
                    )

                if (locationEnabled) {
                    LocationDailySyncWorker.runOnceNow(appCtx)
                    LocationDailySyncWorker.scheduleNext(appCtx)
                    LocationDailySyncWorker.backfillUpToToday(appCtx, token)
                }

            } catch (t: Throwable) {
                Log.w("MetricsSyncManager", "onLogin error: ${t.message}")
            }

            Unit
        }
    }
}

title: MigraineViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class MigraineViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.AllMigraineRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.AllMigraineRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.MigrainePrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.MigrainePrefRow>> = _frequent

    private val _hidden = MutableStateFlow<List<SupabaseDbService.MigrainePrefRow>>(emptyList())
    val hidden: StateFlow<List<SupabaseDbService.MigrainePrefRow>> = _hidden

    private fun safeSortPrefs(prefs: List<SupabaseDbService.MigrainePrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllMigrainePool(accessToken)
                val prefs = db.getMigrainePrefs(accessToken)
                _pool.value = p
                _frequent.value = safeSortPrefs(prefs.filter { it.status == "frequent" })
                _hidden.value = prefs.filter { it.status == "hidden" }
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
                _hidden.value = emptyList()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String) {
        viewModelScope.launch {
            try {
                db.upsertMigraineToPool(accessToken, label.trim())
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, migraineId: String) {
        viewModelScope.launch {
            try {
                db.deleteMigraineFromPool(accessToken, migraineId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, migraineId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertMigrainePref(accessToken, migraineId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteMigrainePref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}

title: MonitorScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

/**
 * Weather removed. Monitor is a placeholder for future signals.
 * No ViewModels. No permissions. No background work.
 */
@Composable
fun MonitorScreen() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Monitor", style = MaterialTheme.typography.titleLarge)
        HorizontalDivider()
        Spacer(Modifier.height(8.dp))
        Text(
            "No weather data is collected or displayed.",
            style = MaterialTheme.typography.bodyMedium
        )
        Text(
            "Add new monitors here later.",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
    }
}

title: PhysicalHealthSyncStatus.kt
text:
package com.migraineme

/**
 * Mirrors SleepSyncStatus.kt style.
 * A simple sealed status used by PH worker or UI if needed.
 *
 * Not referenced anywhere unless you add it.
 * Safe placeholder for future use.
 */
sealed class PhysicalHealthSyncStatus {
    object Idle : PhysicalHealthSyncStatus()
    object Syncing : PhysicalHealthSyncStatus()
    object Success : PhysicalHealthSyncStatus()
    data class Error(val message: String?) : PhysicalHealthSyncStatus()
}

title: ProfileScreen.kt
text:
// FILE: app/src/main/java/com/migraineme/ProfileScreen.kt
package com.migraineme

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.provider.OpenableColumns
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Check
import androidx.compose.material.icons.outlined.Close
import androidx.compose.material.icons.outlined.Edit
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.OutputStream
import java.net.HttpURLConnection
import java.net.URL
import kotlin.math.max

@Composable
fun ProfileScreen(
    authVm: AuthViewModel = viewModel(),
    onNavigateChangePassword: () -> Unit
) {
    val auth by authVm.state.collectAsState()
    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    val profile = remember { mutableStateOf<SupabaseProfileService.Profile?>(null) }
    val profileError = remember { mutableStateOf<String?>(null) }
    val profileLoading = remember { mutableStateOf(false) }

    val isEditing = remember { mutableStateOf(false) }
    val editName = remember { mutableStateOf("") }
    val selectedMigraineType = remember { mutableStateOf<SupabaseProfileService.MigraineType?>(null) }
    val migraineMenuExpanded = remember { mutableStateOf(false) }

    val avatarBitmap = remember { mutableStateOf<androidx.compose.ui.graphics.ImageBitmap?>(null) }
    val avatarUploadErrorDialog = remember { mutableStateOf<String?>(null) }

    // Modal state for "updating picture"
    val avatarUploading = remember { mutableStateOf(false) }

    // Change-password is only relevant for email/password users.
    // Prefer the provider we stored at login time (SessionStore) to avoid ambiguity when users have multiple identities linked.
    val canChangePassword = remember { mutableStateOf(false) }

    LaunchedEffect(auth.accessToken, auth.userId) {
        val token = auth.accessToken
        if (token.isNullOrBlank()) {
            canChangePassword.value = false
            return@LaunchedEffect
        }

        // 1) Fast path: use locally stored login provider ("email" | "google" | ...)
        val storedProvider = SessionStore.readAuthProvider(context)
        if (!storedProvider.isNullOrBlank()) {
            canChangePassword.value = storedProvider == "email"
            return@LaunchedEffect
        }

        // 2) Fallback: ask Supabase (older installs may not have stored provider yet).
        try {
            val user = withContext(Dispatchers.IO) { SupabaseAuthService.getUser(token) }
            canChangePassword.value = user.identities?.any { it.provider == "email" } == true
        } catch (_: Throwable) {
            canChangePassword.value = false
        }
    }

    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        if (uri == null) return@rememberLauncherForActivityResult

        val token = auth.accessToken
        val userId = auth.userId
        if (token.isNullOrBlank() || userId.isNullOrBlank()) {
            avatarUploadErrorDialog.value = "You must be signed in to update your profile picture."
            return@rememberLauncherForActivityResult
        }

        // Instant local preview so the user sees the new image immediately.
        runCatching {
            val bmp = decodePreviewBitmap(context, uri, 512)
            if (bmp != null) avatarBitmap.value = bmp.asImageBitmap()
        }

        profileLoading.value = true
        profileError.value = null
        avatarUploading.value = true

        scope.launch {
            try {
                val publicUrl = withContext(Dispatchers.IO) {
                    uploadAvatarToSupabaseStorage(context, token, userId, uri)
                }

                // Cache-bust so phones/CDNs don't show the old avatar (same object path userId.jpg).
                val cacheBustedUrl = "$publicUrl?v=${System.currentTimeMillis()}"

                val updated = withContext(Dispatchers.IO) {
                    SupabaseProfileService.updateProfile(
                        accessToken = token,
                        userId = userId,
                        displayName = null,
                        avatarUrl = cacheBustedUrl,
                        migraineType = null
                    )
                }

                profile.value = updated

                // Force refresh fetch using the new cache-busted URL (extra safety)
                runCatching {
                    val bmp = withContext(Dispatchers.IO) {
                        URL(cacheBustedUrl).openStream().use { input ->
                            BitmapFactory.decodeStream(input)
                        }
                    }
                    avatarBitmap.value = bmp?.asImageBitmap()
                }
            } catch (t: Throwable) {
                avatarUploadErrorDialog.value = t.message ?: "Failed to upload profile picture."
            } finally {
                avatarUploading.value = false
                profileLoading.value = false
            }
        }
    }

    LaunchedEffect(auth.accessToken, auth.userId) {
        val token = auth.accessToken
        val userId = auth.userId
        if (token.isNullOrBlank() || userId.isNullOrBlank()) return@LaunchedEffect

        profileLoading.value = true
        profileError.value = null

        try {
            val result = withContext(Dispatchers.IO) {
                SupabaseProfileService.ensureProfile(
                    accessToken = token,
                    userId = userId,
                    displayNameHint = null,
                    avatarUrlHint = null
                )
            }
            profile.value = result
            editName.value = result.displayName.orEmpty()
            selectedMigraineType.value = result.migraineType
        } catch (t: Throwable) {
            profileError.value = t.message
        } finally {
            profileLoading.value = false
        }
    }

    // Still keep the fetch-from-URL behavior, but now avatar_url includes cache-busting when updated.
    LaunchedEffect(profile.value?.avatarUrl) {
        val url = profile.value?.avatarUrl?.trim()
        if (url.isNullOrBlank()) {
            avatarBitmap.value = null
            return@LaunchedEffect
        }

        avatarBitmap.value = null
        try {
            val bmp = withContext(Dispatchers.IO) {
                URL(url).openStream().use { input ->
                    BitmapFactory.decodeStream(input)
                }
            }
            avatarBitmap.value = bmp?.asImageBitmap()
        } catch (_: Throwable) {
            avatarBitmap.value = null
        }
    }

    fun saveInline() {
        val token = auth.accessToken ?: return
        val userId = auth.userId ?: return

        profileLoading.value = true
        profileError.value = null

        scope.launch {
            try {
                val updated = withContext(Dispatchers.IO) {
                    SupabaseProfileService.updateProfile(
                        accessToken = token,
                        userId = userId,
                        displayName = editName.value.trim().ifBlank { null },
                        avatarUrl = null,
                        migraineType = selectedMigraineType.value
                    )
                }
                profile.value = updated
                isEditing.value = false
            } catch (t: Throwable) {
                profileError.value = t.message
            } finally {
                profileLoading.value = false
            }
        }
    }

    fun cancelInline() {
        profile.value?.let {
            editName.value = it.displayName.orEmpty()
            selectedMigraineType.value = it.migraineType
        }
        migraineMenuExpanded.value = false
        isEditing.value = false
    }

    // "Updating picture..." modal
    if (avatarUploading.value) {
        AlertDialog(
            onDismissRequest = { /* block dismiss while uploading */ },
            confirmButton = {},
            title = { Text("Updating picture") },
            text = {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    CircularProgressIndicator(modifier = Modifier.size(22.dp))
                    Text("Uploading and updating profile…")
                }
            }
        )
    }

    avatarUploadErrorDialog.value?.let { msg ->
        AlertDialog(
            onDismissRequest = { avatarUploadErrorDialog.value = null },
            title = { Text("Upload failed") },
            text = { Text(msg) },
            confirmButton = {
                TextButton(onClick = { avatarUploadErrorDialog.value = null }) {
                    Text("OK")
                }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        Text("Profile", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(12.dp))
        Divider()
        Spacer(Modifier.height(12.dp))

        Text("Profile details", style = MaterialTheme.typography.titleMedium)
        Spacer(Modifier.height(10.dp))

        val current = profile.value
        val headerName = current?.displayName?.takeIf { it.isNotBlank() } ?: "Name not set"
        val headerMigraine = current?.migraineType?.label ?: "Migraine type not set"
        val userIdText = auth.userId ?: "Not signed in"

        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.Top
        ) {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Surface(
                    shape = CircleShape,
                    tonalElevation = 2.dp,
                    modifier = Modifier.size(70.dp)
                ) {
                    Box(
                        modifier = Modifier.fillMaxSize(),
                        contentAlignment = Alignment.Center
                    ) {
                        val bmp = avatarBitmap.value
                        if (bmp != null) {
                            Image(
                                bitmap = bmp,
                                contentDescription = "Avatar",
                                contentScale = ContentScale.Crop,
                                modifier = Modifier
                                    .fillMaxSize()
                                    .clip(CircleShape)
                            )
                        } else {
                            Text(
                                text = headerName.trim().firstOrNull()?.uppercase() ?: "?",
                                style = MaterialTheme.typography.headlineMedium
                            )
                        }
                    }
                }

                if (isEditing.value) {
                    Spacer(Modifier.height(6.dp))
                    TextButton(
                        onClick = { imagePickerLauncher.launch("image/*") },
                        enabled = auth.accessToken != null && !profileLoading.value,
                        modifier = Modifier.height(32.dp)
                    ) {
                        Text("Adjust image")
                    }
                }
            }

            Spacer(Modifier.width(14.dp))

            Box(modifier = Modifier.weight(1f)) {
                Column(modifier = Modifier.padding(end = 96.dp)) {
                    if (isEditing.value) {
                        OutlinedTextField(
                            value = editName.value,
                            onValueChange = { editName.value = it },
                            label = { Text("Name") },
                            singleLine = true,
                            enabled = auth.accessToken != null && !profileLoading.value,
                            modifier = Modifier.fillMaxWidth()
                        )
                    } else {
                        Text(
                            text = headerName,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                    }

                    Spacer(Modifier.height(6.dp))

                    if (isEditing.value) {
                        OutlinedButton(
                            onClick = { migraineMenuExpanded.value = true },
                            enabled = auth.accessToken != null && !profileLoading.value,
                            shape = RoundedCornerShape(12.dp),
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Text(selectedMigraineType.value?.label ?: "Select migraine type")
                        }
                    } else {
                        Text(
                            text = headerMigraine,
                            style = MaterialTheme.typography.bodySmall,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                    }

                    Spacer(Modifier.height(6.dp))
                    Text(
                        text = "User ID: $userIdText",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                }

                Row(
                    modifier = Modifier.align(Alignment.TopEnd),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    if (isEditing.value) {
                        IconButton(
                            onClick = { saveInline() },
                            enabled = auth.accessToken != null && !profileLoading.value
                        ) {
                            Icon(Icons.Outlined.Check, contentDescription = "Save")
                        }
                        IconButton(
                            onClick = { cancelInline() },
                            enabled = !profileLoading.value
                        ) {
                            Icon(Icons.Outlined.Close, contentDescription = "Cancel")
                        }
                    } else {
                        IconButton(
                            onClick = { isEditing.value = true },
                            enabled = auth.accessToken != null && !profileLoading.value
                        ) {
                            Icon(Icons.Outlined.Edit, contentDescription = "Edit")
                        }
                    }
                }
            }
        }

        DropdownMenu(
            expanded = migraineMenuExpanded.value,
            onDismissRequest = { migraineMenuExpanded.value = false }
        ) {
            DropdownMenuItem(
                text = { Text("Not set") },
                onClick = {
                    selectedMigraineType.value = null
                    migraineMenuExpanded.value = false
                }
            )
            SupabaseProfileService.MigraineType.entries.forEach { option ->
                DropdownMenuItem(
                    text = { Text(option.label) },
                    onClick = {
                        selectedMigraineType.value = option
                        migraineMenuExpanded.value = false
                    }
                )
            }
        }

        profileError.value?.let {
            Spacer(Modifier.height(8.dp))
            Text(it, color = MaterialTheme.colorScheme.error)
        }

        Spacer(Modifier.height(20.dp))
        Divider()
        Spacer(Modifier.height(12.dp))

        if (canChangePassword.value) {
            OutlinedButton(
                onClick = { onNavigateChangePassword() },
                enabled = auth.accessToken != null && !profileLoading.value,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Change password")
            }
        }
    }
}

private fun decodePreviewBitmap(
    context: android.content.Context,
    uri: Uri,
    maxDim: Int
): Bitmap? {
    val resolver = context.contentResolver

    val bytes = resolver.openInputStream(uri)?.use { it.readBytes() } ?: return null

    val bounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    BitmapFactory.decodeByteArray(bytes, 0, bytes.size, bounds)

    val srcW = bounds.outWidth
    val srcH = bounds.outHeight
    if (srcW <= 0 || srcH <= 0) return null

    var sample = 1
    while ((srcW / sample) > maxDim * 2 || (srcH / sample) > maxDim * 2) {
        sample *= 2
        if (sample >= 128) break
    }

    val opts = BitmapFactory.Options().apply { inSampleSize = max(1, sample) }
    val decoded = BitmapFactory.decodeByteArray(bytes, 0, bytes.size, opts) ?: return null

    val maxSide = max(decoded.width, decoded.height)
    if (maxSide <= maxDim) return decoded

    val scale = maxDim.toFloat() / maxSide.toFloat()
    val newW = (decoded.width * scale).toInt().coerceAtLeast(1)
    val newH = (decoded.height * scale).toInt().coerceAtLeast(1)

    val scaled = Bitmap.createScaledBitmap(decoded, newW, newH, true)
    if (scaled !== decoded) decoded.recycle()
    return scaled
}

private fun uploadAvatarToSupabaseStorage(
    context: android.content.Context,
    accessToken: String,
    userId: String,
    uri: Uri
): String {
    val maxOutputBytes = 2 * 1024 * 1024 // 2 MB final upload
    val maxInputBytes = 10 * 1024 * 1024 // 10 MB safety cap
    val maxDim = 1024

    val resolver = context.contentResolver

    val rawMime = resolver.getType(uri)?.lowercase()
    val allowedMimes = setOf("image/jpeg", "image/jpg", "image/png", "image/webp")
    if (rawMime != null && rawMime !in allowedMimes) {
        throw IllegalStateException("Please choose an image (JPG/PNG/WebP).")
    }

    val declaredSize = runCatching {
        resolver.query(uri, arrayOf(OpenableColumns.SIZE), null, null, null)?.use { c ->
            val idx = c.getColumnIndex(OpenableColumns.SIZE)
            if (idx >= 0 && c.moveToFirst() && !c.isNull(idx)) c.getLong(idx) else null
        }
    }.getOrNull()

    if (declaredSize != null && declaredSize > maxInputBytes) {
        throw IllegalStateException("Image is too large. Please choose an image under 10 MB.")
    }

    val originalBytes = readAllBytesWithLimit(resolver, uri, maxInputBytes)
        ?: throw IllegalStateException("Could not read selected image.")

    val bounds = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    BitmapFactory.decodeByteArray(originalBytes, 0, originalBytes.size, bounds)

    val srcW = bounds.outWidth
    val srcH = bounds.outHeight
    if (srcW <= 0 || srcH <= 0) {
        throw IllegalStateException("Selected file is not a valid image.")
    }

    val sample = computePowerOfTwoSampleSize(srcW, srcH, maxDim * 2)
    val decodeOpts = BitmapFactory.Options().apply { inSampleSize = sample }

    val decoded: Bitmap =
        BitmapFactory.decodeByteArray(originalBytes, 0, originalBytes.size, decodeOpts)
            ?: throw IllegalStateException("Could not decode selected image.")

    val scaled = scaleDown(decoded, maxDim)
    if (scaled !== decoded) decoded.recycle()

    val jpegBytes = compressJpegUnderLimit(scaled, maxOutputBytes)
    scaled.recycle()

    val baseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
    val anonKey = BuildConfig.SUPABASE_ANON_KEY

    val bucket = "avatars"
    val objectPath = "$userId.jpg"

    val putUrl = "$baseUrl/storage/v1/object/$bucket/$objectPath?upsert=true"
    val conn = (URL(putUrl).openConnection() as HttpURLConnection).apply {
        requestMethod = "PUT"
        doOutput = true
        setRequestProperty("Authorization", "Bearer $accessToken")
        setRequestProperty("apikey", anonKey)
        setRequestProperty("Content-Type", "image/jpeg")
        setRequestProperty("Content-Length", jpegBytes.size.toString())
    }

    try {
        conn.outputStream.use { os: OutputStream ->
            os.write(jpegBytes)
            os.flush()
        }

        val code = conn.responseCode
        if (code !in 200..299) {
            val err = runCatching {
                conn.errorStream?.readBytes()?.toString(Charsets.UTF_8)
            }.getOrNull()
            throw IllegalStateException("Upload failed ($code). ${err ?: ""}".trim())
        }
    } finally {
        conn.disconnect()
    }

    return "$baseUrl/storage/v1/object/public/$bucket/$objectPath"
}

private fun readAllBytesWithLimit(
    resolver: android.content.ContentResolver,
    uri: Uri,
    maxBytes: Int
): ByteArray? {
    resolver.openInputStream(uri)?.use { input ->
        val buffer = ByteArray(8 * 1024)
        val baos = ByteArrayOutputStream()
        var total = 0
        while (true) {
            val r = input.read(buffer)
            if (r <= 0) break
            total += r
            if (total > maxBytes) {
                throw IllegalStateException("Image is too large. Please choose an image under 10 MB.")
            }
            baos.write(buffer, 0, r)
        }
        return baos.toByteArray()
    }
    return null
}

private fun computePowerOfTwoSampleSize(srcW: Int, srcH: Int, targetMaxDim: Int): Int {
    var inSampleSize = 1
    if (srcW <= 0 || srcH <= 0) return 1
    while ((srcW / inSampleSize) > targetMaxDim || (srcH / inSampleSize) > targetMaxDim) {
        inSampleSize *= 2
        if (inSampleSize >= 128) break
    }
    return max(1, inSampleSize)
}

private fun scaleDown(bmp: Bitmap, maxDim: Int): Bitmap {
    val w = bmp.width
    val h = bmp.height
    val maxSide = max(w, h)
    if (maxSide <= maxDim) return bmp

    val scale = maxDim.toFloat() / maxSide.toFloat()
    val newW = (w * scale).toInt().coerceAtLeast(1)
    val newH = (h * scale).toInt().coerceAtLeast(1)

    return Bitmap.createScaledBitmap(bmp, newW, newH, true)
}

private fun compressJpegUnderLimit(bmp: Bitmap, maxBytes: Int): ByteArray {
    val qualities = intArrayOf(90, 85, 80, 75, 70, 65, 60, 55, 50)

    for (q in qualities) {
        val baos = ByteArrayOutputStream()
        val ok = bmp.compress(Bitmap.CompressFormat.JPEG, q, baos)
        if (!ok) continue
        val out = baos.toByteArray()
        if (out.size <= maxBytes) return out
    }

    throw IllegalStateException("Image is too large even after compression. Please choose a smaller image.")
}

title: ReliefsScreen.kt
text:
// ReliefsScreen.kt
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun ReliefsScreen(
    navController: NavController,
    vm: ReliefViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel
) {
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val pool by vm.pool.collectAsState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { vm.loadAll(it) }
    }

    val frequentIds = remember(frequent) { frequent.map { it.reliefId }.toSet() }
    val remaining = remember(pool, frequentIds) { pool.filter { it.id !in frequentIds } }

    var showAddDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }
    fun openAdd(label: String) { pendingLabel = label; showAddDialog = true }
    if (showAddDialog) {
        DurationTimeDialog(
            initialDuration = "",
            initialIso = null,
            onDismiss = { showAddDialog = false },
            onConfirm = { duration, iso ->
                val label = pendingLabel ?: return@DurationTimeDialog
                val dur = duration.toIntOrNull()
                logVm.addReliefDraft(type = label, durationMinutes = dur, notes = null, startAtIso = iso)
                showAddDialog = false
            }
        )
    }

    var showEditDuration by remember { mutableStateOf(false) }
    var durationEditIndex by remember { mutableStateOf<Int?>(null) }

    var showEditTime by remember { mutableStateOf(false) }
    var timeEditIndex by remember { mutableStateOf<Int?>(null) }

    if (showEditDuration && durationEditIndex != null && durationEditIndex in draft.rels.indices) {
        DurationOnlyDialog(
            initial = draft.rels[durationEditIndex!!].durationMinutes?.toString().orEmpty(),
            onDismiss = { showEditDuration = false },
            onConfirm = { newDurationStr ->
                val idx = durationEditIndex!!
                val newDur = newDurationStr.toIntOrNull()
                val d = draft
                logVm.clearDraft()
                logVm.setMigraineDraft(
                    d.migraine?.type, d.migraine?.severity,
                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                )
                d.triggers.forEach { t ->
                    logVm.addTriggerDraft(t.type, startAtIso = t.startAtIso, note = t.note)
                }
                d.meds.forEach { m ->
                    m.name?.let { nm -> logVm.addMedicineDraft(nm, m.amount, m.notes, m.startAtIso) }
                }
                d.rels.forEachIndexed { i, r ->
                    val dur = if (i == idx) newDur else r.durationMinutes
                    logVm.addReliefDraft(r.type, dur, r.notes, r.startAtIso)
                }
                showEditDuration = false
            }
        )
    }

    if (showEditTime && timeEditIndex != null && timeEditIndex in draft.rels.indices) {
        TimeOnlyDialog(
            initialIso = draft.rels[timeEditIndex!!].startAtIso,
            onDismiss = { showEditTime = false },
            onConfirm = { newIso ->
                val idx = timeEditIndex!!
                val d = draft
                logVm.clearDraft()
                logVm.setMigraineDraft(
                    d.migraine?.type, d.migraine?.severity,
                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                )
                d.triggers.forEach { t ->
                    logVm.addTriggerDraft(t.type, startAtIso = t.startAtIso, note = t.note)
                }
                d.meds.forEach { m ->
                    m.name?.let { nm -> logVm.addMedicineDraft(nm, m.amount, m.notes, m.startAtIso) }
                }
                d.rels.forEachIndexed { i, r ->
                    val iso = if (i == idx) newIso else r.startAtIso
                    logVm.addReliefDraft(r.type, r.durationMinutes, r.notes, iso)
                }
                showEditTime = false
            }
        )
    }

    Scaffold(
        bottomBar = {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(onClick = { navController.navigate("medicines") }) { Text("Back") }
                Button(onClick = { navController.navigate("review") }) { Text("Next") }
            }
        }
    ) { inner ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(inner)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            if (frequent.isNotEmpty()) {
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text("Frequent", style = MaterialTheme.typography.titleMedium)
                        TextButton(onClick = { navController.navigate("adjust_reliefs") }) {
                            Text("Manage")
                        }
                    }
                }
            } else {
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(onClick = { navController.navigate("adjust_reliefs") }) {
                            Text("Manage")
                        }
                    }
                }
            }

            item {
                if (draft.rels.isNotEmpty()) {
                    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                        Text("Selected now", style = MaterialTheme.typography.titleMedium)
                        for (idx in draft.rels.indices.reversed()) {
                            val r = draft.rels[idx]

                            ElevatedCard(
                                modifier = Modifier.fillMaxWidth(),
                                colors = CardDefaults.elevatedCardColors(),
                                shape = MaterialTheme.shapes.medium
                            ) {
                                Column(Modifier.padding(8.dp)) {
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(r.type, style = MaterialTheme.typography.bodyLarge)
                                        IconButton(
                                            onClick = {
                                                val d = draft
                                                logVm.clearDraft()
                                                logVm.setMigraineDraft(
                                                    d.migraine?.type, d.migraine?.severity,
                                                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                                                )
                                                d.triggers.forEach { t ->
                                                    logVm.addTriggerDraft(t.type, startAtIso = t.startAtIso, note = t.note)
                                                }
                                                d.meds.forEach { m ->
                                                    m.name?.let { nm -> logVm.addMedicineDraft(nm, m.amount, m.notes, m.startAtIso) }
                                                }
                                                d.rels.forEachIndexed { i, rr ->
                                                    if (i != idx) {
                                                        logVm.addReliefDraft(rr.type, rr.durationMinutes, rr.notes, rr.startAtIso)
                                                    }
                                                }
                                            }
                                        ) { Icon(Icons.Filled.Delete, contentDescription = "Remove") }
                                    }

                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(top = 6.dp),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(
                                            "Time: ${formatIsoDdMmHm(r.startAtIso)}",
                                            style = MaterialTheme.typography.bodyMedium
                                        )
                                        Text(
                                            "Edit",
                                            color = MaterialTheme.colorScheme.primary,
                                            style = MaterialTheme.typography.bodyMedium,
                                            modifier = Modifier.clickable {
                                                timeEditIndex = idx
                                                showEditTime = true
                                            }
                                        )
                                    }

                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(top = 6.dp),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(
                                            r.durationMinutes?.let { "Duration: ${it} min" } ?: "Duration: not set",
                                            style = MaterialTheme.typography.bodyMedium
                                        )
                                        Text(
                                            "Edit",
                                            color = MaterialTheme.colorScheme.primary,
                                            style = MaterialTheme.typography.bodyMedium,
                                            modifier = Modifier.clickable {
                                                durationEditIndex = idx
                                                showEditDuration = true
                                            }
                                        )
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (frequent.isNotEmpty()) {
                item {
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        frequent.forEach { pref ->
                            val label = pref.relief?.label ?: return@forEach
                            AssistChip(onClick = { openAdd(label) }, label = { Text(label) })
                        }
                    }
                }
            }

            if (remaining.isNotEmpty()) {
                item { Text("All Reliefs", style = MaterialTheme.typography.titleMedium) }
                item {
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        remaining.forEach { rel ->
                            AssistChip(onClick = { openAdd(rel.label) }, label = { Text(rel.label) })
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(80.dp)) }
        }
    }
}

/** Format ISO string to "dd/MM HH:mm". */
private fun formatIsoDdMmHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}

@Composable
private fun DurationTimeDialog(
    initialDuration: String,
    initialIso: String?,
    onDismiss: () -> Unit,
    onConfirm: (durationMinutes: String, iso: String?) -> Unit
) {
    var duration by remember { mutableStateOf(initialDuration) }
    var pickedIso by remember { mutableStateOf(initialIso) }

    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = { onConfirm(duration.trim(), pickedIso) },
                enabled = duration.isNotBlank()
            ) { Text("Confirm") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Add relief") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                OutlinedTextField(
                    value = duration,
                    onValueChange = { duration = it },
                    label = { Text("Duration (minutes)") },
                    singleLine = true,
                    modifier = Modifier.fillMaxWidth()
                )
                AppDateTimePicker(
                    label = pickedIso?.let { formatIsoDdMmHm(it) } ?: "Set time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        }
    )
}

@Composable
private fun DurationOnlyDialog(
    initial: String,
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var duration by remember { mutableStateOf(initial) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = {
            TextButton(
                onClick = { onConfirm(duration.trim()) },
                enabled = duration.isNotBlank()
            ) { Text("Confirm") }
        },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Edit duration") },
        text = {
            OutlinedTextField(
                value = duration,
                onValueChange = { duration = it },
                label = { Text("Duration (minutes)") },
                singleLine = true,
                modifier = Modifier.fillMaxWidth()
            )
        }
    )
}

@Composable
private fun TimeOnlyDialog(
    initialIso: String?,
    onDismiss: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text("Confirm") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Edit time") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Current: ${formatIsoDdMmHm(pickedIso)}")
                AppDateTimePicker(
                    label = "Select new time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        }
    )
}

title: ReliefViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class ReliefViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.AllReliefRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.AllReliefRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.ReliefPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.ReliefPrefRow>> = _frequent

    private fun sortPrefs(prefs: List<SupabaseDbService.ReliefPrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            runCatching {
                val p = db.getAllReliefPool(accessToken)
                val f = db.getReliefPrefs(accessToken)
                _pool.value = p
                _frequent.value = sortPrefs(f)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun addNewToPool(accessToken: String, label: String) {
        viewModelScope.launch {
            runCatching {
                db.upsertReliefToPool(accessToken, label)
                _pool.value = db.getAllReliefPool(accessToken)
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromPool(accessToken: String, reliefId: String) {
        viewModelScope.launch {
            runCatching {
                db.deleteReliefFromPool(accessToken, reliefId)
                _pool.value = db.getAllReliefPool(accessToken)
                _frequent.value = sortPrefs(db.getReliefPrefs(accessToken))
            }.onFailure { it.printStackTrace() }
        }
    }

    fun addToFrequent(accessToken: String, reliefId: String) {
        viewModelScope.launch {
            runCatching {
                val pos = (_frequent.value.maxOfOrNull { it.position } ?: -1) + 1
                db.insertReliefPref(accessToken, reliefId, pos, "frequent")
                _frequent.value = sortPrefs(db.getReliefPrefs(accessToken))
            }.onFailure { it.printStackTrace() }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            runCatching {
                db.deleteReliefPref(accessToken, prefId)
                _frequent.value = sortPrefs(db.getReliefPrefs(accessToken))
            }.onFailure { it.printStackTrace() }
        }
    }
}

title: ReviewLogScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController

@Composable
fun ReviewLogScreen(navController: NavHostController, authVm: AuthViewModel, vm: LogViewModel) {
    val authState by authVm.state.collectAsState()
    val draft by vm.draft.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        Text("Review Log", style = MaterialTheme.typography.headlineSmall)
        Spacer(Modifier.height(16.dp))

        draft.migraine?.let {
            Text("Migraine")
            Text("Type: ${it.type ?: "-"}")
            Text("Severity: ${it.severity ?: "-"}")
            Text("Start: ${it.beganAtIso ?: "-"}")
            Text("End: ${it.endedAtIso ?: "-"}")
            Text("Note: ${it.note ?: "-"}")
            Spacer(Modifier.height(12.dp))
        }

        if (draft.triggers.isNotEmpty()) {
            Text("Triggers")
            draft.triggers.forEach {
                Text("- ${it.type} (${it.startAtIso ?: "-"}) ${it.note ?: ""}")
            }
            Spacer(Modifier.height(12.dp))
        }

        if (draft.meds.isNotEmpty()) {
            Text("Medicines")
            draft.meds.forEach {
                Text("- ${it.name ?: "-"} ${it.amount ?: ""} (${it.startAtIso ?: "-"}) ${it.notes ?: ""}")
            }
            Spacer(Modifier.height(12.dp))
        }

        if (draft.rels.isNotEmpty()) {
            Text("Reliefs")
            draft.rels.forEach {
                Text("- ${it.type} ${it.durationMinutes ?: "-"}min (${it.startAtIso ?: "-"}) ${it.notes ?: ""}")
            }
            Spacer(Modifier.height(12.dp))
        }

        Spacer(Modifier.height(24.dp))

        Button(
            onClick = {
                val token = authState.accessToken ?: return@Button
                val migraine = draft.migraine
                if (migraine != null) {
                    vm.addFull(
                        accessToken = token,
                        type = migraine.type,
                        severity = migraine.severity,
                        beganAtIso = migraine.beganAtIso ?: "",
                        endedAtIso = migraine.endedAtIso,
                        note = migraine.note,
                        meds = draft.meds,
                        rels = draft.rels
                    )
                }
                vm.clearDraft()
                navController.popBackStack("journal", inclusive = false)
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Save Log")
        }
    }
}

title: SessionStore.kt
text:
// FILE: app/src/main/java/com/migraineme/SessionStore.kt
package com.migraineme

import android.content.Context
import android.content.Context.MODE_PRIVATE
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

object SessionStore {
    private const val PREFS = "session_prefs"

    private const val KEY_ACCESS = "access_token"
    private const val KEY_REFRESH = "refresh_token"
    private const val KEY_EXPIRES_IN = "expires_in_seconds"
    private const val KEY_OBTAINED_AT = "obtained_at_ms"

    private const val KEY_USER_ID = "user_id"
    private const val KEY_AUTH_PROVIDER = "auth_provider" // "email" | "google" | "facebook" | null

    // Small skew so we refresh a bit before expiry to avoid edge failures in workers.
    private const val EXPIRY_SKEW_MS = 60_000L

    private val refreshMutex = Mutex()

    fun saveAccessToken(context: Context, token: String) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_ACCESS, token)
            .apply()
    }

    fun saveRefreshToken(context: Context, refreshToken: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_REFRESH, refreshToken)
            .apply()
    }

    fun saveExpiresIn(context: Context, expiresInSeconds: Long?) {
        val prefs = context.getSharedPreferences(PREFS, MODE_PRIVATE).edit()
        if (expiresInSeconds == null) {
            prefs.remove(KEY_EXPIRES_IN)
        } else {
            prefs.putLong(KEY_EXPIRES_IN, expiresInSeconds)
        }
        prefs.apply()
    }

    fun saveObtainedAt(context: Context, obtainedAtMs: Long) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putLong(KEY_OBTAINED_AT, obtainedAtMs)
            .apply()
    }

    /**
     * Saves the user id separately so UI (e.g., Profile) can display a stable identity
     * without needing a network call.
     */
    fun saveUserId(context: Context, userId: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_USER_ID, userId)
            .apply()
    }

    /**
     * Persists which auth method was used for this session.
     * Expected values: "email", "google", "facebook"
     */
    fun saveAuthProvider(context: Context, provider: String?) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_AUTH_PROVIDER, provider)
            .apply()
    }

    fun readAuthProvider(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_AUTH_PROVIDER, null)
    }

    /**
     * New canonical session writer.
     *
     * Note: first three params match your old call sites (context, token, userId),
     * so existing positional calls still work.
     */
    fun saveSession(
        context: Context,
        accessToken: String,
        userId: String?,
        provider: String? = null,
        refreshToken: String? = null,
        expiresIn: Long? = null,
        obtainedAtMs: Long = System.currentTimeMillis()
    ) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .edit()
            .putString(KEY_ACCESS, accessToken)
            .putString(KEY_REFRESH, refreshToken)
            .apply()

        saveUserId(context, userId)
        saveAuthProvider(context, provider)
        saveExpiresIn(context, expiresIn)
        saveObtainedAt(context, obtainedAtMs)
    }

    fun readAccessToken(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_ACCESS, null)
    }

    fun readRefreshToken(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_REFRESH, null)
    }

    fun readExpiresIn(context: Context): Long? {
        val prefs = context.getSharedPreferences(PREFS, MODE_PRIVATE)
        return if (prefs.contains(KEY_EXPIRES_IN)) prefs.getLong(KEY_EXPIRES_IN, 0L) else null
    }

    fun readObtainedAt(context: Context): Long? {
        val prefs = context.getSharedPreferences(PREFS, MODE_PRIVATE)
        return if (prefs.contains(KEY_OBTAINED_AT)) prefs.getLong(KEY_OBTAINED_AT, 0L) else null
    }

    fun readUserId(context: Context): String? {
        return context.getSharedPreferences(PREFS, MODE_PRIVATE)
            .getString(KEY_USER_ID, null)
    }

    fun clear(context: Context) {
        context.getSharedPreferences(PREFS, MODE_PRIVATE).edit().clear().apply()
    }

    /**
     * Returns a valid access token.
     *
     * - If the current access token is not expired (with skew), return it.
     * - If expired and refresh_token exists, refresh via Supabase and persist new tokens.
     * - If we cannot refresh, returns null (workers should treat as "skip").
     *
     * IMPORTANT: Ensure KEY_USER_ID is always present when an access token is present.
     * WHOOP token ownership checks depend on a stable Supabase user_id in SessionStore.
     */
    suspend fun getValidAccessToken(context: Context): String? {
        return refreshMutex.withLock {
            val access = readAccessToken(context)
            if (access.isNullOrBlank()) return@withLock null

            // CHANGE #1:
            // If user_id is missing, derive it from the access token JWT and persist it.
            val existingUserId = readUserId(context)
            if (existingUserId.isNullOrBlank()) {
                val derived = JwtUtils.extractUserIdFromAccessToken(access)
                if (!derived.isNullOrBlank()) {
                    saveUserId(context, derived)
                }
            }

            val expiresIn = readExpiresIn(context)
            val obtainedAt = readObtainedAt(context)

            // If we don't have expiry metadata, assume it's still usable (backward compatibility).
            if (expiresIn == null || obtainedAt == null) {
                return@withLock access
            }

            val expiresAt = obtainedAt + (expiresIn * 1000L)
            val now = System.currentTimeMillis()

            // Still valid (with skew) -> return.
            if (now + EXPIRY_SKEW_MS < expiresAt) {
                return@withLock access
            }

            // Expired -> refresh.
            val refresh = readRefreshToken(context)
            if (refresh.isNullOrBlank()) {
                return@withLock null
            }

            return@withLock try {
                val ses = SupabaseAuthService.refreshSession(refresh)

                val newAccess = ses.accessToken
                if (newAccess.isNullOrBlank()) {
                    null
                } else {
                    // CHANGE #2:
                    // Always derive userId from the refreshed access token (do not depend on existing prefs).
                    val newUserId =
                        JwtUtils.extractUserIdFromAccessToken(newAccess)
                            ?: readUserId(context)

                    // Supabase may rotate refresh tokens; persist both.
                    saveSession(
                        context = context,
                        accessToken = newAccess,
                        userId = newUserId,
                        provider = readAuthProvider(context),
                        refreshToken = ses.refreshToken ?: refresh,
                        expiresIn = ses.expiresIn,
                        obtainedAtMs = System.currentTimeMillis()
                    )
                    newAccess
                }
            } catch (_: Throwable) {
                null
            }
        }
    }
}

title: SignupScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@Composable
fun SignupScreen(
    authVm: AuthViewModel,
    onSignedUpAndLoggedIn: () -> Unit,
    onNavigateToLogin: () -> Unit
) {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var confirm by remember { mutableStateOf("") }
    var error by remember { mutableStateOf<String?>(null) }
    var info by remember { mutableStateOf<String?>(null) }
    var busy by remember { mutableStateOf(false) }

    val scope = remember { CoroutineScope(Dispatchers.Main) }
    val ctx = androidx.compose.ui.platform.LocalContext.current
    val appCtx = ctx.applicationContext

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text("Create account", style = MaterialTheme.typography.titleLarge)

        OutlinedTextField(
            value = email,
            onValueChange = { email = it },
            label = { Text("Email") },
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = password,
            onValueChange = { password = it },
            label = { Text("Password") },
            singleLine = true,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = confirm,
            onValueChange = { confirm = it },
            label = { Text("Confirm password") },
            singleLine = true,
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        if (error != null) {
            Text(error!!, color = MaterialTheme.colorScheme.error)
        }
        if (info != null) {
            Text(info!!, color = MaterialTheme.colorScheme.primary)
        }

        Button(
            onClick = {
                error = null; info = null
                if (password != confirm) {
                    error = "Passwords do not match."
                    return@Button
                }
                busy = true
                scope.launch {
                    try {
                        val ses = SupabaseAuthService.signUpWithEmail(email.trim(), password)
                        val access = ses.accessToken

                        if (!access.isNullOrBlank()) {
                            val userId = JwtUtils.extractUserIdFromAccessToken(access)

                            SessionStore.saveSession(
                                context = appCtx,
                                accessToken = access,
                                userId = userId,
                                provider = "email",
                                refreshToken = ses.refreshToken,
                                expiresIn = ses.expiresIn,
                                obtainedAtMs = System.currentTimeMillis()
                            )

                            authVm.setSession(access, userId)
                            onSignedUpAndLoggedIn()
                        } else {
                            info = "Check your email to confirm your account, then sign in."
                        }
                    } catch (e: Exception) {
                        error = e.message ?: "Sign up failed."
                    } finally {
                        busy = false
                    }
                }
            },
            enabled = !busy && email.isNotBlank() && password.isNotBlank() && confirm.isNotBlank(),
            modifier = Modifier.fillMaxWidth()
        ) {
            Text(if (busy) "Creating account..." else "Create account")
        }

        TextButton(
            onClick = onNavigateToLogin,
            modifier = Modifier
                .fillMaxWidth()
                .align(Alignment.CenterHorizontally)
        ) {
            Text("Back")
        }
    }
}

title: SleepSyncStatus.kt
text:
// FILE: C:\Users\verwe\Projects\MigraineMe\app\src\main\java\com\migraineme\SleepSyncStatus.kt
package com.migraineme

import android.content.Context
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.work.WorkInfo
import androidx.work.WorkManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.time.LocalDate
import java.time.ZoneId

/**
 * Renders a compact status text for WHOOP sleep sync/backfill and the 09:00 WorkManager job.
 *
 * Usage in a screen:
 *   val auth by authVm.state.collectAsState()
 *   SleepSyncStatus(accessToken = auth.accessToken)
 */
@Composable
fun SleepSyncStatus(
    accessToken: String?,
    modifier: Modifier = Modifier
) {
    val ctx = LocalContext.current.applicationContext
    var text by remember { mutableStateOf("Loading sleep sync status…") }

    LaunchedEffect(accessToken) {
        text = buildStatusText(ctx, accessToken)
    }

    Column(modifier = modifier) {
        Text(text = text, style = MaterialTheme.typography.bodyMedium)
        Spacer(Modifier.height(8.dp))
    }
}

private suspend fun buildStatusText(ctx: Context, accessToken: String?): String = withContext(Dispatchers.IO) {
    val zone = ZoneId.systemDefault()
    val today = LocalDate.now(zone)
    val yesterday = today.minusDays(1)

    val whoopConnected = (WhoopTokenStore(ctx).load() != null)

    val token = accessToken ?: SessionStore.readAccessToken(ctx)

    val metrics = SupabaseMetricsService(ctx)
    val latestDate: String? = if (!token.isNullOrBlank()) {
        runCatching { metrics.latestSleepDate(token, source = "whoop") }.getOrNull()
    } else null

    val backfillStart = latestDate?.let { runCatching { LocalDate.parse(it).plusDays(1) }.getOrNull() }
    val backfillWindow =
        if (backfillStart != null && backfillStart.isBefore(today)) {
            val end = yesterday
            val days = if (!end.isBefore(backfillStart)) (end.toEpochDay() - backfillStart.toEpochDay() + 1).toInt() else 0
            if (days > 0) "${backfillStart} → $end ($days days)" else "Up to date"
        } else {
            "Up to date"
        }

    val (jobState, jobCount) = readWorkState(ctx, "whoop_daily_sync_sleep_fields_9am")

    buildString {
        appendLine("Sleep sync status")
        appendLine("• WHOOP connected: ${if (whoopConnected) "Yes" else "No"}")
        appendLine("• Latest Supabase date (whoop): ${latestDate ?: "—"}")
        appendLine("• Backfill window: $backfillWindow")
        append("• Daily 09:00 job: $jobState${if (jobCount > 1) " ($jobCount entries)" else ""}")
    }
}

private fun readWorkState(ctx: Context, uniqueName: String): Pair<String, Int> {
    return try {
        val infos = WorkManager.getInstance(ctx).getWorkInfosForUniqueWork(uniqueName).get()
        if (infos.isNullOrEmpty()) return "Not scheduled" to 0
        val state = prioritizeWorkStates(infos.map { it.state })
        state to infos.size
    } catch (_: Throwable) {
        "Unknown" to 0
    }
}

private fun prioritizeWorkStates(states: List<WorkInfo.State>): String {
    return when {
        states.any { it == WorkInfo.State.RUNNING } -> "RUNNING"
        states.any { it == WorkInfo.State.ENQUEUED } -> "ENQUEUED"
        states.any { it == WorkInfo.State.BLOCKED } -> "BLOCKED"
        states.any { it == WorkInfo.State.SUCCEEDED } -> "SUCCEEDED"
        states.any { it == WorkInfo.State.FAILED } -> "FAILED"
        states.any { it == WorkInfo.State.CANCELLED } -> "CANCELLED"
        else -> states.firstOrNull()?.name ?: "Unknown"
    }
}

title: SupabaseAuthService.kt
text:
package com.migraineme

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.put
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonObject

object SupabaseAuthService {
    private val baseUrl: String = BuildConfig.SUPABASE_URL
    private val anonKey: String = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient(Android) {
        install(ContentNegotiation) {
            json(
                Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                    encodeDefaults = true
                }
            )
        }
    }

    @Serializable
    data class PasswordGrantRequest(val email: String, val password: String)

    @Serializable
    data class SignUpRequest(val email: String, val password: String)

    @Serializable
    data class IdTokenGrantRequest(
        val provider: String,
        @SerialName("id_token") val idToken: String,
        val nonce: String? = null
    )

    @Serializable
    data class RefreshTokenGrantRequest(
        @SerialName("refresh_token") val refreshToken: String
    )

    @Serializable
    data class SessionResponse(
        @SerialName("access_token") val accessToken: String? = null,
        @SerialName("refresh_token") val refreshToken: String? = null,
        @SerialName("token_type") val tokenType: String? = null,
        @SerialName("expires_in") val expiresIn: Long? = null
    )

    @Serializable
    data class Identity(
        val provider: String? = null
    )

    @Serializable
    data class UserResponse(
        val id: String? = null,
        val email: String? = null,
        val identities: List<Identity>? = null,
        @SerialName("user_metadata") val userMetadata: JsonObject? = null
    )

    @Serializable
    data class UpdateUserRequest(
        val password: String
    )

    @Serializable
    data class RecoverRequest(
        val email: String
    )

    suspend fun signInWithEmail(email: String, password: String): SessionResponse {
        val url = "$baseUrl/auth/v1/token?grant_type=password"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(PasswordGrantRequest(email, password))
        }.body()
    }

    suspend fun signUpWithEmail(email: String, password: String): SessionResponse {
        val url = "$baseUrl/auth/v1/signup"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(SignUpRequest(email, password))
        }.body()
    }

    /**
     * Native mobile Google sign-in:
     * - You obtain a Google ID token on-device (Credential Manager)
     * - Exchange it for a Supabase session (access_token / refresh_token)
     */
    suspend fun signInWithGoogleIdToken(idToken: String, nonce: String? = null): SessionResponse {
        val url = "$baseUrl/auth/v1/token?grant_type=id_token"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(
                IdTokenGrantRequest(
                    provider = "google",
                    idToken = idToken,
                    nonce = nonce
                )
            )
        }.body()
    }

    /**
     * Refreshes a Supabase session using a refresh_token.
     * Supabase: POST /auth/v1/token?grant_type=refresh_token
     */
    suspend fun refreshSession(refreshToken: String): SessionResponse {
        val url = "$baseUrl/auth/v1/token?grant_type=refresh_token"
        return client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            setBody(RefreshTokenGrantRequest(refreshToken = refreshToken))
        }.body()
    }

    suspend fun signOut(accessToken: String) {
        val url = "$baseUrl/auth/v1/logout"
        client.post(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
        }
    }

    /**
     * Used to determine whether the current user has an email identity.
     */
    suspend fun getUser(accessToken: String): UserResponse {
        val url = "$baseUrl/auth/v1/user"
        return client.get(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
        }.body()
    }

    /**
     * Changes password for current authenticated user.
     * Supabase: PUT /auth/v1/user { "password": "..." }
     */
    suspend fun changePassword(accessToken: String, newPassword: String): UserResponse {
        val url = "$baseUrl/auth/v1/user"
        return client.put(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
            contentType(ContentType.Application.Json)
            setBody(UpdateUserRequest(password = newPassword))
        }.body()
    }

    /**
     * Sends password recovery email (reset link) for email/password accounts.
     * Supabase: POST /auth/v1/recover { "email": "..." }
     *
     * If redirectTo is provided, Supabase will redirect the recovery link to that URL
     * (it must be allowed in Supabase Auth Redirect URLs).
     */
    suspend fun requestPasswordReset(email: String, redirectTo: String? = null) {
        val url = "$baseUrl/auth/v1/recover"
        client.post(url) {
            header("apikey", anonKey)
            contentType(ContentType.Application.Json)
            if (!redirectTo.isNullOrBlank()) {
                parameter("redirect_to", redirectTo)
            }
            setBody(RecoverRequest(email = email))
        }
    }
}

title: SupabaseDbService.kt
text:
// app/src/main/java/com/migraineme/SupabaseDbService.kt
package com.migraineme

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.put
import java.time.Instant

class SupabaseDbService(
    private val supabaseUrl: String,
    private val supabaseKey: String
) {
    @OptIn(ExperimentalSerializationApi::class)
    private val client = HttpClient {
        install(ContentNegotiation) {
            json(
                Json {
                    ignoreUnknownKeys = true
                    encodeDefaults = true
                    explicitNulls = false
                }
            )
        }
    }

    private fun HttpStatusCode.isSuccess(): Boolean = value in 200..299

    // ───────── MIGRAINES ─────────
    @Serializable
    data class MigraineRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        val severity: Int? = null,
        @SerialName("start_at") val startAt: String,
        @SerialName("ended_at") val endAt: String? = null,
        val notes: String? = null
    )
    @Serializable
    data class MigraineInsert(
        val type: String? = null,
        val severity: Int? = null,
        @SerialName("start_at") val startAt: String,
        @SerialName("ended_at") val endAt: String? = null,
        val notes: String? = null
    )
    suspend fun insertMigraine(
        accessToken: String,
        type: String?,
        severity: Int?,
        startAt: String?,
        endAt: String?,
        notes: String?
    ): MigraineRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = MigraineInsert(type, severity, safeStart, endAt, notes)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert migraine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getMigraines(accessToken: String): List<MigraineRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch migraines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getMigraineById(accessToken: String, id: String): MigraineRow {
        val response = client.get("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get migraine by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMigraine(
        accessToken: String,
        id: String,
        type: String? = null,
        severity: Int? = null,
        startAt: String? = null,
        endAt: String? = null,
        notes: String? = null
    ): MigraineRow {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            severity?.let { put("severity", it) }
            startAt?.let { put("start_at", it) }
            endAt?.let { put("ended_at", it) }
            notes?.let { put("notes", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update migraine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMigraine(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete migraine failed: ${response.bodyAsText()}")
    }

    // ───────── TRIGGERS ─────────
    @Serializable
    data class TriggerRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    @Serializable
    data class TriggerInsert(
        val type: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    suspend fun insertTrigger(
        accessToken: String,
        migraineId: String?,
        type: String?,
        startAt: String?,
        notes: String?
    ): TriggerRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = TriggerInsert(type, safeStart, notes, migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert trigger failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getAllTriggers(accessToken: String): List<TriggerRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch triggers failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getTriggerById(accessToken: String, id: String): TriggerRow {
        val response = client.get("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get trigger by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateTrigger(
        accessToken: String,
        id: String,
        type: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ): TriggerRow {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
            migraineId?.let { put("migraine_id", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update trigger failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteTrigger(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete trigger failed: ${response.bodyAsText()}")
    }

    // ───────── MEDICINES ─────────
    @Serializable
    data class MedicineRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val name: String? = null,
        val amount: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    @Serializable
    data class MedicineInsert(
        val name: String? = null,
        val amount: String? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    suspend fun insertMedicine(
        accessToken: String,
        migraineId: String?,
        name: String?,
        amount: String?,
        startAt: String?,
        notes: String?
    ): MedicineRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = MedicineInsert(name, amount, safeStart, notes, migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert medicine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getAllMedicines(accessToken: String): List<MedicineRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch medicines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getMedicineById(accessToken: String, id: String): MedicineRow {
        val response = client.get("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get medicine by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMedicine(
        accessToken: String,
        id: String,
        name: String? = null,
        amount: String? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ): MedicineRow {
        val payload = buildJsonObject {
            name?.let { put("name", it) }
            if (amount != null) put("amount", amount)
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
            migraineId?.let { put("migraine_id", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update medicine failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMedicine(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete medicine failed: ${response.bodyAsText()}")
    }

    // ───────── RELIEFS ─────────
    @Serializable
    data class ReliefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val type: String? = null,
        @SerialName("duration_minutes") val durationMinutes: Int? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    @Serializable
    data class ReliefInsert(
        val type: String? = null,
        @SerialName("duration_minutes") val durationMinutes: Int? = null,
        @SerialName("start_at") val startAt: String,
        val notes: String? = null,
        @SerialName("migraine_id") val migraineId: String? = null
    )
    suspend fun insertRelief(
        accessToken: String,
        migraineId: String?,
        type: String?,
        durationMinutes: Int?,
        startAt: String?,
        notes: String?
    ): ReliefRow {
        val safeStart = startAt?.takeIf { it.isNotBlank() } ?: Instant.now().toString()
        val payload = ReliefInsert(type, durationMinutes, safeStart, notes, migraineId)
        val response: HttpResponse = client.post("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json)
            setBody(payload)
        }
        if (!response.status.isSuccess()) error("Insert relief failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getAllReliefs(accessToken: String): List<ReliefRow> {
        val response: HttpResponse = client.get("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "*")
        }
        if (!response.status.isSuccess()) error("Fetch reliefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun getReliefById(accessToken: String, id: String): ReliefRow {
        val response = client.get("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id"); parameter("select", "*")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
        }
        if (!response.status.isSuccess()) error("Get relief by id failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateRelief(
        accessToken: String,
        id: String,
        type: String? = null,
        durationMinutes: Int? = null,
        startAt: String? = null,
        notes: String? = null,
        migraineId: String? = null
    ): ReliefRow {
        val payload = buildJsonObject {
            type?.let { put("type", it) }
            durationMinutes?.let { put("duration_minutes", it) }
            startAt?.let { put("start_at", it) }
            notes?.let { put("notes", it) }
            migraineId?.let { put("migraine_id", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
            header("Prefer", "return=representation")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update relief failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteRelief(accessToken: String, id: String) {
        val response = client.delete("$supabaseUrl/rest/v1/reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$id")
        }
        if (!response.status.isSuccess()) error("Delete relief failed: ${response.bodyAsText()}")
    }

    // ───────── TRIGGER POOL / PREFS ─────────
    @Serializable data class AllTriggerRow(val id: String, val label: String)
    @Serializable
    data class TriggerPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("trigger_id") val triggerId: String,
        val position: Int,
        val status: String,
        @SerialName("all_triggers") val trigger: AllTriggerRow? = null
    )
    @Serializable private data class AllTriggerInsert(val label: String)

    suspend fun getAllTriggerPool(accessToken: String): List<AllTriggerRow> {
        val response = client.get("$supabaseUrl/rest/v1/all_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch all_triggers failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertTriggerToPool(accessToken: String, label: String): AllTriggerRow {
        val response = client.post("$supabaseUrl/rest/v1/all_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(AllTriggerInsert(label))
        }
        if (!response.status.isSuccess()) error("Upsert all_triggers failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteTriggerFromPool(accessToken: String, triggerId: String) {
        client.delete("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("trigger_id", "eq.$triggerId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/all_triggers") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$triggerId")
        }
        if (!response.status.isSuccess()) error("Delete all_triggers failed: ${response.bodyAsText()}")
    }
    @Serializable private data class TriggerPrefInsert(@SerialName("trigger_id") val triggerId: String, val position: Int, val status: String)
    suspend fun getTriggerPrefs(accessToken: String): List<TriggerPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,trigger_id,position,status,all_triggers(id,label)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch trigger prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertTriggerPref(accessToken: String, triggerId: String, position: Int, status: String = "frequent"): TriggerPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,trigger_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(TriggerPrefInsert(triggerId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert trigger pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    @Serializable private data class TriggerPrefUpdatePosition(val position: Int)
    suspend fun updateTriggerPrefPosition(accessToken: String, prefId: String, newPosition: Int) {
        val response = client.patch("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            contentType(ContentType.Application.Json); setBody(TriggerPrefUpdatePosition(newPosition))
        }
        if (!response.status.isSuccess()) error("Update trigger pref failed: ${response.bodyAsText()}")
    }
    @Serializable private data class TriggerPrefUpdateStatus(val status: String)
    suspend fun updateTriggerPrefStatus(accessToken: String, prefId: String, newStatus: String) {
        val response = client.patch("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            contentType(ContentType.Application.Json); setBody(TriggerPrefUpdateStatus(newStatus))
        }
        if (!response.status.isSuccess()) error("Update trigger status failed: ${response.bodyAsText()}")
    }
    suspend fun deleteTriggerPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/trigger_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete trigger pref failed: ${response.bodyAsText()}")
    }

    // ───────── MEDICINE POOL / PREFS ─────────
    @Serializable data class AllMedicineRow(val id: String, val label: String)
    @Serializable
    data class MedicinePrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("medicine_id") val medicineId: String,
        val position: Int,
        val status: String,
        @SerialName("all_medicines") val medicine: AllMedicineRow? = null
    )
    @Serializable private data class AllMedicineInsert(val label: String)

    suspend fun getAllMedicinePool(accessToken: String): List<AllMedicineRow> {
        val response = client.get("$supabaseUrl/rest/v1/all_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch all_medicines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertMedicineToPool(accessToken: String, label: String): AllMedicineRow {
        val response = client.post("$supabaseUrl/rest/v1/all_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(AllMedicineInsert(label))
        }
        if (!response.status.isSuccess()) error("Upsert all_medicines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMedicineFromPool(accessToken: String, medicineId: String) {
        client.delete("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("medicine_id", "eq.$medicineId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/all_medicines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$medicineId")
        }
        if (!response.status.isSuccess()) error("Delete all_medicines failed: ${response.bodyAsText()}")
    }
    @Serializable private data class MedicinePrefInsert(@SerialName("medicine_id") val medicineId: String, val position: Int, val status: String)
    suspend fun getMedicinePrefs(accessToken: String): List<MedicinePrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,medicine_id,position,status,all_medicines(id,label)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch medicine prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertMedicinePref(accessToken: String, medicineId: String, position: Int, status: String = "frequent"): MedicinePrefRow {
        val response = client.post("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,medicine_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(MedicinePrefInsert(medicineId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert medicine pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMedicinePref(accessToken: String, prefId: String, position: Int? = null, status: String? = null) {
        val payload = buildJsonObject {
            position?.let { put("position", it) }
            status?.let { put("status", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update medicine pref failed: ${response.bodyAsText()}")
    }
    suspend fun deleteMedicinePref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/medicine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete medicine pref failed: ${response.bodyAsText()}")
    }

    // ───────── RELIEF POOL / PREFS ─────────
    @Serializable data class AllReliefRow(val id: String, val label: String)
    @Serializable
    data class ReliefPrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("relief_id") val reliefId: String,
        val position: Int,
        val status: String,
        @SerialName("all_reliefs") val relief: AllReliefRow? = null
    )
    @Serializable private data class AllReliefInsert(val label: String)

    suspend fun getAllReliefPool(accessToken: String): List<AllReliefRow> {
        val response = client.get("$supabaseUrl/rest/v1/all_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch all_reliefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertReliefToPool(accessToken: String, label: String): AllReliefRow {
        val response = client.post("$supabaseUrl/rest/v1/all_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(AllReliefInsert(label))
        }
        if (!response.status.isSuccess()) error("Upsert all_reliefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteReliefFromPool(accessToken: String, reliefId: String) {
        client.delete("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("relief_id", "eq.$reliefId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/all_reliefs") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$reliefId")
        }
        if (!response.status.isSuccess()) error("Delete all_reliefs failed: ${response.bodyAsText()}")
    }
    @Serializable private data class ReliefPrefInsert(@SerialName("relief_id") val reliefId: String, val position: Int, val status: String)
    suspend fun getReliefPrefs(accessToken: String): List<ReliefPrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,relief_id,position,status,all_reliefs(id,label)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch relief prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertReliefPref(accessToken: String, reliefId: String, position: Int, status: String = "frequent"): ReliefPrefRow {
        val response = client.post("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,relief_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(ReliefPrefInsert(reliefId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert relief pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateReliefPref(accessToken: String, prefId: String, position: Int? = null, status: String? = null) {
        val payload = buildJsonObject {
            position?.let { put("position", it) }
            status?.let { put("status", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update relief pref failed: ${response.bodyAsText()}")
    }
    suspend fun deleteReliefPref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/relief_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete relief pref failed: ${response.bodyAsText()}")
    }

    // ───────── MIGRAINE POOL / PREFS ─────────
    @Serializable data class AllMigraineRow(val id: String, val label: String)
    @Serializable
    data class MigrainePrefRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        @SerialName("migraine_id") val migraineId: String,
        val position: Int,
        val status: String,
        @SerialName("all_migraines") val migraine: AllMigraineRow? = null
    )
    @Serializable private data class AllMigraineInsert(val label: String)

    suspend fun getAllMigrainePool(accessToken: String): List<AllMigraineRow> {
        val response = client.get("$supabaseUrl/rest/v1/all_migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,label"); parameter("order", "label.asc")
        }
        if (!response.status.isSuccess()) error("Fetch all_migraines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun upsertMigraineToPool(accessToken: String, label: String): AllMigraineRow {
        val response = client.post("$supabaseUrl/rest/v1/all_migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "label")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(AllMigraineInsert(label))
        }
        if (!response.status.isSuccess()) error("Upsert all_migraines failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun deleteMigraineFromPool(accessToken: String, migraineId: String) {
        client.delete("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("migraine_id", "eq.$migraineId")
        }
        val response = client.delete("$supabaseUrl/rest/v1/all_migraines") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$migraineId")
        }
        if (!response.status.isSuccess()) error("Delete all_migraines failed: ${response.bodyAsText()}")
    }
    @Serializable private data class MigrainePrefInsert(@SerialName("migraine_id") val migraineId: String, val position: Int, val status: String)
    suspend fun getMigrainePrefs(accessToken: String): List<MigrainePrefRow> {
        val response = client.get("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,migraine_id,position,status,all_migraines(id,label)")
            parameter("order", "position.asc")
        }
        if (!response.status.isSuccess()) error("Fetch migraine prefs failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun insertMigrainePref(accessToken: String, migraineId: String, position: Int, status: String = "frequent"): MigrainePrefRow {
        val response = client.post("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            header("Prefer", "return=representation,resolution=merge-duplicates")
            parameter("on_conflict", "user_id,migraine_id")
            header(HttpHeaders.Accept, "application/vnd.pgrst.object+json")
            contentType(ContentType.Application.Json); setBody(MigrainePrefInsert(migraineId, position, status))
        }
        if (!response.status.isSuccess()) error("Insert migraine pref failed: ${response.bodyAsText()}")
        return response.body()
    }
    suspend fun updateMigrainePref(accessToken: String, prefId: String, position: Int? = null, status: String? = null) {
        val payload = buildJsonObject {
            position?.let { put("position", it) }
            status?.let { put("status", it) }
        }
        val response = client.patch("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
            header("Prefer", "return=minimal")
            contentType(ContentType.Application.Json); setBody(payload)
        }
        if (!response.status.isSuccess()) error("Update migraine pref failed: ${response.bodyAsText()}")
    }
    suspend fun deleteMigrainePref(accessToken: String, prefId: String) {
        val response = client.delete("$supabaseUrl/rest/v1/migraine_preferences") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("id", "eq.$prefId")
        }
        if (!response.status.isSuccess()) error("Delete migraine pref failed: ${response.bodyAsText()}")
    }

    // ───────── WEATHER DAILY ─────────
    @Serializable
    data class WeatherDailyRow(
        val id: String,
        @SerialName("user_id") val userId: String,
        val date: String, // ISO date "YYYY-MM-DD"
        @SerialName("temp_c") val tempC: Double? = null,
        @SerialName("pressure_hpa") val pressureHpa: Double? = null,
        @SerialName("humidity_pct") val humidityPct: Double? = null,
        @SerialName("created_at") val createdAt: String,
        @SerialName("updated_at") val updatedAt: String
    )

    suspend fun getWeatherDaily(accessToken: String): List<WeatherDailyRow> {
        val response = client.get("$supabaseUrl/rest/v1/weather_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken"); header("apikey", supabaseKey)
            parameter("select", "id,user_id,date,temp_c,pressure_hpa,humidity_pct,created_at,updated_at")
            parameter("order", "date.asc")
        }
        if (!response.status.isSuccess()) error("Fetch weather_daily failed: ${response.bodyAsText()}")
        return response.body()
    }
}

title: SupabaseMetricsServiceSleep.kt
text:
// FILE: app/src/main/java/com/migraineme/SupabaseMetricsServiceSleep.kt
package com.migraineme

import android.content.Context
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Supabase metrics writer + reader for sleep tables.
 * (Same behavior as before, plus score/efficiency.)
 *
 * Tables:
 * - sleep_duration_daily(date, value_hours, source, source_measure_id, user_id default auth.uid())
 * - fell_asleep_time_daily(date, value_at, source, source_measure_id, user_id default auth.uid())
 * - woke_up_time_daily(date, value_at, source, source_measure_id, user_id default auth.uid())
 * - sleep_disturbances_daily(date, value_count, source, source_measure_id, user_id default auth.uid())
 * - sleep_stages_daily(date, value_sws_hm, value_rem_hm, value_light_hm, source, source_measure_id, user_id default auth.uid())
 * - sleep_score_daily(date, value_pct, source, source_measure_id, user_id default auth.uid())
 * - sleep_efficiency_daily(date, value_pct, source, source_measure_id, user_id default auth.uid())
 * Unique key everywhere: (user_id, source, date)
 */
class SupabaseMetricsService(context: Context) {

    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
    }

    /* ============ READ DTOs ============ */

    @Serializable
    data class SleepDurationDailyRead(val date: String, @SerialName("value_hours") val value_hours: Double)

    @Serializable
    data class SleepDisturbancesDailyRead(val date: String, @SerialName("value_count") val value_count: Int)

    @Serializable
    data class SleepStagesDailyRead(
        val date: String,
        @SerialName("value_sws_hm") val value_sws_hm: Double,
        @SerialName("value_rem_hm") val value_rem_hm: Double,
        @SerialName("value_light_hm") val value_light_hm: Double
    )

    @Serializable
    data class SleepScoreDailyRead(val date: String, @SerialName("value_pct") val value_pct: Double)

    @Serializable
    data class SleepEfficiencyDailyRead(val date: String, @SerialName("value_pct") val value_pct: Double)

    /* ============ WRITER DTOs ============ */

    @Serializable private data class DurationRow(
        val date: String,
        val value_hours: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class FellAsleepRow(
        val date: String,
        val value_at: String,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class WakeRow(
        val date: String,
        val value_at: String,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class DisturbancesRow(
        val date: String,
        val value_count: Int,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class StagesRow(
        val date: String,
        val value_sws_hm: Double,
        val value_rem_hm: Double,
        val value_light_hm: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class PctRow(
        val date: String,
        val value_pct: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    /* ============ FETCHERS ============ */

    suspend fun fetchSleepDurationDaily(accessToken: String, limitDays: Int = 14): List<SleepDurationDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_duration_daily", accessToken, "date,value_hours", limitDays)
    }

    suspend fun fetchSleepDisturbancesDaily(accessToken: String, limitDays: Int = 14): List<SleepDisturbancesDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_disturbances_daily", accessToken, "date,value_count", limitDays)
    }

    suspend fun fetchSleepStagesDaily(accessToken: String, limitDays: Int = 14): List<SleepStagesDailyRead> {
        return getList(
            "$supabaseUrl/rest/v1/sleep_stages_daily",
            accessToken,
            "date,value_sws_hm,value_rem_hm,value_light_hm",
            limitDays
        )
    }

    suspend fun fetchSleepScoreDaily(accessToken: String, limitDays: Int = 14): List<SleepScoreDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_score_daily", accessToken, "date,value_pct", limitDays)
    }

    suspend fun fetchSleepEfficiencyDaily(accessToken: String, limitDays: Int = 14): List<SleepEfficiencyDailyRead> {
        return getList("$supabaseUrl/rest/v1/sleep_efficiency_daily", accessToken, "date,value_pct", limitDays)
    }

    private suspend inline fun <reified T> getList(
        endpoint: String,
        access: String,
        select: String,
        limit: Int
    ): List<T> {
        val resp = client.get(endpoint) {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("select", select)
            parameter("order", "date.desc")
            parameter("limit", limit.toString())
        }
        if (!resp.status.isSuccess()) return emptyList()
        return runCatching { resp.body<List<T>>() }.getOrDefault(emptyList())
    }

    /** True if a sleep row already exists for date & source in sleep_duration_daily. */
    suspend fun hasSleepForDate(accessToken: String, date: String, source: String): Boolean {
        val resp = client.get("$supabaseUrl/rest/v1/sleep_duration_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("date", "eq.$date")
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return false
        val body = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return body.isNotEmpty()
    }

    /** Latest date we have for WHOOP in sleep_duration_daily (used as backfill anchor). */
    suspend fun latestSleepDate(accessToken: String, source: String): String? {
        val resp = client.get("$supabaseUrl/rest/v1/sleep_duration_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val rows = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return rows.firstOrNull()?.get("date")
    }

    /* ============ UPSERTS ============ */

    suspend fun upsertSleepDurationDaily(
        accessToken: String, date: String, valueHours: Double, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_duration_daily", DurationRow(date, valueHours, source, sourceId)) }

    suspend fun upsertFellAsleepTimeDaily(
        accessToken: String, date: String, valueAtIso: String, source: String?, sourceId: String?
    ) { upsert(accessToken, "fell_asleep_time_daily", FellAsleepRow(date, valueAtIso, source, sourceId)) }

    suspend fun upsertWokeUpTimeDaily(
        accessToken: String, date: String, valueAtIso: String, source: String?, sourceId: String?
    ) { upsert(accessToken, "woke_up_time_daily", WakeRow(date, valueAtIso, source, sourceId)) }

    suspend fun upsertSleepDisturbancesDaily(
        accessToken: String, date: String, count: Int, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_disturbances_daily", DisturbancesRow(date, count, source, sourceId)) }

    suspend fun upsertSleepStagesDaily(
        accessToken: String, date: String, swsMs: Long, remMs: Long, lightMs: Long, source: String?, sourceId: String?
    ) {
        val row = StagesRow(
            date = date,
            value_sws_hm = msToHM(swsMs),
            value_rem_hm = msToHM(remMs),
            value_light_hm = msToHM(lightMs),
            source = source,
            source_measure_id = sourceId
        )
        upsert(accessToken, "sleep_stages_daily", row)
    }

    suspend fun upsertSleepScoreDaily(
        accessToken: String, date: String, pct: Double, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_score_daily", PctRow(date, pct, source, sourceId)) }

    suspend fun upsertSleepEfficiencyDaily(
        accessToken: String, date: String, pct: Double, source: String?, sourceId: String?
    ) { upsert(accessToken, "sleep_efficiency_daily", PctRow(date, pct, source, sourceId)) }

    private suspend inline fun <reified T> upsert(accessToken: String, table: String, row: T) {
        val resp = client.post("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            parameter("on_conflict", "user_id,source,date")
            contentType(ContentType.Application.Json)
            setBody(listOf(row))
        }
        if (!resp.status.isSuccess()) {
            error("Upsert $table failed: HTTP ${resp.status.value}")
        }
    }

    private fun msToHM(ms: Long): Double {
        val totalMinutes = (ms / 60000).toInt()
        val hours = totalMinutes / 60
        val minutes = totalMinutes % 60
        return hours + (minutes / 100.0)
    }
}

title: SupabasePersonalService.kt
text:
package com.migraineme

import android.content.Context
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import org.json.JSONArray

class SupabasePersonalService(context: Context) {
    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
    }

    @Serializable
    private data class LocationWriteRow(
        val date: String,
        val latitude: Double,
        val longitude: Double,
        val source: String,
        val source_measure_id: String? = null
    )

    @Serializable
    data class UserLocationDailyRead(
        val date: String,
        val latitude: Double,
        val longitude: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    suspend fun upsertUserLocationDaily(
        accessToken: String,
        date: String,
        latitude: Double,
        longitude: Double,
        source: String = "device",
        sourceId: String? = null
    ) {
        val row = LocationWriteRow(date, latitude, longitude, source, sourceId)
        postgrestInsert(
            accessToken = accessToken,
            table = "user_location_daily",
            body = listOf(row),
            onConflict = "user_id,source,date"
        )
    }

    suspend fun fetchUserLocationDaily(
        accessToken: String,
        limitDays: Int = 14
    ): List<UserLocationDailyRead> {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date,latitude,longitude,source,source_measure_id")
            parameter("order", "date.desc")
            parameter("limit", limitDays.toString())
        }
        if (!resp.status.isSuccess()) return emptyList()
        return runCatching { resp.body<List<UserLocationDailyRead>>() }.getOrNull() ?: emptyList()
    }

    suspend fun hasUserLocationForDate(
        accessToken: String,
        date: String,
        source: String = "device"
    ): Boolean {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("date", "eq.$date")
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return false
        val txt = resp.bodyAsText().trim()
        return txt.startsWith("[{")
    }

    suspend fun latestUserLocationDate(
        accessToken: String,
        source: String = "device"
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.$source")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    suspend fun earliestUserLocationDate(
        accessToken: String,
        source: String = "device"
    ): String? {
        val resp = client.get("$supabaseUrl/rest/v1/user_location_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            parameter("select", "date")
            parameter("source", "eq.$source")
            parameter("order", "date.asc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val body = resp.bodyAsText().trim()
        if (body.isEmpty() || body == "[]") return null
        return try {
            val arr = JSONArray(body)
            if (arr.length() == 0) null else arr.getJSONObject(0).getString("date")
        } catch (_: Throwable) { null }
    }

    private suspend inline fun <reified T> postgrestInsert(
        accessToken: String,
        table: String,
        body: T,
        onConflict: String? = null
    ) {
        val resp = client.post("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            onConflict?.let { parameter("on_conflict", it) }
            contentType(ContentType.Application.Json)
            setBody(body)
        }
        if (!resp.status.isSuccess()) {
            val msg = runCatching { resp.bodyAsText() }.getOrNull()
            error("Upsert into $table failed: HTTP ${resp.status.value} ${msg ?: ""}".trim())
        }
    }
}

title: SupabasePhysicalHealthService.kt
text:
package com.migraineme

import android.content.Context
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.contentType
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Supabase service for Physical Health metrics.
 * Mirrors SupabaseMetricsServiceSleep.kt (structure, behavior, upsert style).
 *
 * Tables:
 * - recovery_score_daily
 * - resting_hr_daily
 * - hrv_daily
 * - skin_temp_daily
 * - spo2_daily
 * - time_in_high_hr_zones_daily (value_minutes, zone_three_minutes, zone_four_minutes, zone_five_minutes, zone_six_minutes)
 *
 * Unique key everywhere: (user_id, source, date)
 */
class SupabasePhysicalHealthService(context: Context) {

    private val supabaseUrl = BuildConfig.SUPABASE_URL
    private val supabaseKey = BuildConfig.SUPABASE_ANON_KEY

    private val client = HttpClient {
        install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) }
    }

    /* ============================================================
     * READ DTOs
     * ============================================================
     */

    @Serializable
    data class RecoveryScoreDailyRead(
        val date: String,
        @SerialName("value_pct") val value_pct: Double
    )

    @Serializable
    data class RestingHrDailyRead(
        val date: String,
        @SerialName("value_bpm") val value_bpm: Double
    )

    @Serializable
    data class HrvDailyRead(
        val date: String,
        @SerialName("value_rmssd_ms") val value_rmssd_ms: Double
    )

    @Serializable
    data class SkinTempDailyRead(
        val date: String,
        @SerialName("value_celsius") val value_celsius: Double
    )

    @Serializable
    data class Spo2DailyRead(
        val date: String,
        @SerialName("value_pct") val value_pct: Double
    )

    @Serializable
    data class HighHrZonesDailyRead(
        val date: String,
        @SerialName("value_minutes") val value_minutes: Double,
        @SerialName("zone_three_minutes") val zone_three_minutes: Double,
        @SerialName("zone_four_minutes") val zone_four_minutes: Double,
        @SerialName("zone_five_minutes") val zone_five_minutes: Double,
        @SerialName("zone_six_minutes") val zone_six_minutes: Double
    )

    /* ============================================================
     * WRITER DTOs
     * ============================================================
     */

    @Serializable private data class PctRow(
        val date: String,
        val value_pct: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class HrRow(
        val date: String,
        val value_bpm: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class HrvRow(
        val date: String,
        val value_rmssd_ms: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class TempRow(
        val date: String,
        val value_celsius: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class Spo2Row(
        val date: String,
        val value_pct: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    @Serializable private data class HighHrRow(
        val date: String,
        val value_minutes: Double,
        val zone_three_minutes: Double,
        val zone_four_minutes: Double,
        val zone_five_minutes: Double,
        val zone_six_minutes: Double,
        val source: String? = null,
        val source_measure_id: String? = null
    )

    /* ============================================================
     * GENERIC FETCHER
     * ============================================================
     */

    private suspend inline fun <reified T> getList(
        endpoint: String,
        access: String,
        select: String,
        limit: Int
    ): List<T> {
        val resp = client.get(endpoint) {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("select", select)
            parameter("order", "date.desc")
            parameter("limit", limit.toString())
        }
        if (!resp.status.isSuccess()) return emptyList()
        return runCatching { resp.body<List<T>>() }.getOrDefault(emptyList())
    }

    /* ============================================================
     * PUBLIC FETCH API
     * ============================================================
     */

    suspend fun fetchRecoveryScoreDaily(access: String, days: Int = 14): List<RecoveryScoreDailyRead> =
        getList("$supabaseUrl/rest/v1/recovery_score_daily", access, "date,value_pct", days)

    suspend fun fetchRestingHrDaily(access: String, days: Int = 14): List<RestingHrDailyRead> =
        getList("$supabaseUrl/rest/v1/resting_hr_daily", access, "date,value_bpm", days)

    suspend fun fetchHrvDaily(access: String, days: Int = 14): List<HrvDailyRead> =
        getList("$supabaseUrl/rest/v1/hrv_daily", access, "date,value_rmssd_ms", days)

    suspend fun fetchSkinTempDaily(access: String, days: Int = 14): List<SkinTempDailyRead> =
        getList("$supabaseUrl/rest/v1/skin_temp_daily", access, "date,value_celsius", days)

    suspend fun fetchSpo2Daily(access: String, days: Int = 14): List<Spo2DailyRead> =
        getList("$supabaseUrl/rest/v1/spo2_daily", access, "date,value_pct", days)

    suspend fun fetchHighHrDaily(access: String, days: Int = 14): List<HighHrZonesDailyRead> =
        getList(
            "$supabaseUrl/rest/v1/time_in_high_hr_zones_daily",
            access,
            "date,value_minutes,zone_three_minutes,zone_four_minutes,zone_five_minutes,zone_six_minutes",
            days
        )

    /* ============================================================
     * CONFLICT CHECKERS
     * ============================================================
     */

    suspend fun hasRecoveryForDate(access: String, date: String, source: String): Boolean {
        val resp = client.get("$supabaseUrl/rest/v1/recovery_score_daily") {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("date", "eq.$date")
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return false
        val body = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return body.isNotEmpty()
    }

    suspend fun latestPhysicalDate(access: String, source: String): String? {
        val resp = client.get("$supabaseUrl/rest/v1/recovery_score_daily") {
            header(HttpHeaders.Authorization, "Bearer $access")
            header("apikey", supabaseKey)
            parameter("source", "eq.$source")
            parameter("select", "date")
            parameter("order", "date.desc")
            parameter("limit", "1")
        }
        if (!resp.status.isSuccess()) return null
        val rows = runCatching { resp.body<List<Map<String, String>>>() }.getOrDefault(emptyList())
        return rows.firstOrNull()?.get("date")
    }

    /* ============================================================
     * UPSERTS
     * ============================================================
     */

    suspend fun upsertRecoveryScoreDaily(
        access: String, date: String, valuePct: Double, source: String?, sourceId: String?
    ) = upsert(access, "recovery_score_daily", PctRow(date, valuePct, source, sourceId))

    suspend fun upsertRestingHrDaily(
        access: String, date: String, bpm: Double, source: String?, sourceId: String?
    ) = upsert(access, "resting_hr_daily", HrRow(date, bpm, source, sourceId))

    suspend fun upsertHrvDaily(
        access: String, date: String, rmssd: Double, source: String?, sourceId: String?
    ) = upsert(access, "hrv_daily", HrvRow(date, rmssd, source, sourceId))

    suspend fun upsertSkinTempDaily(
        access: String, date: String, celsius: Double, source: String?, sourceId: String?
    ) = upsert(access, "skin_temp_daily", TempRow(date, celsius, source, sourceId))

    suspend fun upsertSpo2Daily(
        access: String, date: String, pct: Double, source: String?, sourceId: String?
    ) = upsert(access, "spo2_daily", Spo2Row(date, pct, source, sourceId))

    suspend fun upsertHighHrDaily(
        access: String,
        date: String,
        totalMinutes: Double,
        z3: Double,
        z4: Double,
        z5: Double,
        z6: Double,
        source: String?,
        sourceId: String?
    ) = upsert(
        access,
        "time_in_high_hr_zones_daily",
        HighHrRow(date, totalMinutes, z3, z4, z5, z6, source, sourceId)
    )

    private suspend inline fun <reified T> upsert(
        accessToken: String,
        table: String,
        row: T
    ) {
        val resp = client.post("$supabaseUrl/rest/v1/$table") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", supabaseKey)
            header("Prefer", "resolution=merge-duplicates,return=minimal")
            parameter("on_conflict", "user_id,source,date")
            contentType(ContentType.Application.Json)
            setBody(listOf(row))
        }
        if (!resp.status.isSuccess()) {
            error("Upsert $table failed: HTTP ${resp.status.value}")
        }
    }
}

title: SupabaseProfileService.kt
text:
package com.migraineme

import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.android.Android
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.patch
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Source-of-truth app profile data (provider-agnostic).
 *
 * Backed by Supabase PostgREST table: profiles
 * - user_id uuid PK (RLS ensures auth.uid() can only read/write their own row)
 * - display_name text
 * - avatar_url text
 * - migraine_type migraine_type enum (nullable)
 */
object SupabaseProfileService {

    // Keep config consistent with the rest of the app: BuildConfig + anon key.
    private val baseUrl = BuildConfig.SUPABASE_URL.trimEnd('/')
    private val anonKey = BuildConfig.SUPABASE_ANON_KEY

    private val json = Json {
        ignoreUnknownKeys = true
        explicitNulls = false
        encodeDefaults = false
    }

    private val client = HttpClient(Android) {
        install(ContentNegotiation) { json(json) }
    }

    // ---- Public models (what the app uses) ----

    enum class MigraineType(val dbValue: String, val label: String) {
        MIGRAINE("migraine", "Migraine"),
        MIGRAINE_WITH_AURA("migraine_with_aura", "Migraine with aura"),
        CLUSTER("cluster", "Cluster"),
        TENSION("tension", "Tension"),
        HEMIPLEGIC("hemiplegic", "Hemiplegic"),
        VESTIBULAR("vestibular", "Vestibular"),
        OTHER("other", "Other");

        companion object {
            fun fromDbValue(value: String?): MigraineType? {
                if (value.isNullOrBlank()) return null
                return entries.firstOrNull { it.dbValue == value }
            }
        }
    }

    data class Profile(
        val userId: String,
        val displayName: String?,
        val avatarUrl: String?,
        val migraineType: MigraineType?
    )

    /**
     * Ensures a row exists for this user and optionally fills missing display_name/avatar_url
     * using provider "hints" (Google/Apple/Facebook).
     *
     * Rules:
     * - Never overwrites a user-provided value.
     * - Only sets fields if they are currently null/blank.
     */
    suspend fun ensureProfile(
        accessToken: String,
        userId: String,
        displayNameHint: String?,
        avatarUrlHint: String?
    ): Profile {
        val existing = getProfile(accessToken, userId)
        if (existing == null) {
            // No row: insert with whatever hints we have (can be null).
            return insertProfile(
                accessToken = accessToken,
                userId = userId,
                displayName = displayNameHint?.takeIf { it.isNotBlank() },
                avatarUrl = avatarUrlHint?.takeIf { it.isNotBlank() },
                migraineType = null
            )
        }

        // Row exists: only fill missing values.
        val needsDisplayName = existing.displayName.isNullOrBlank() && !displayNameHint.isNullOrBlank()
        val needsAvatarUrl = existing.avatarUrl.isNullOrBlank() && !avatarUrlHint.isNullOrBlank()

        if (!needsDisplayName && !needsAvatarUrl) return existing

        return patchProfile(
            accessToken = accessToken,
            userId = userId,
            displayName = if (needsDisplayName) displayNameHint!!.trim() else null,
            avatarUrl = if (needsAvatarUrl) avatarUrlHint!!.trim() else null,
            migraineType = null
        )
    }

    suspend fun getProfile(accessToken: String, userId: String): Profile? {
        val url =
            "$baseUrl/rest/v1/profiles?user_id=eq.$userId&select=user_id,display_name,avatar_url,migraine_type"

        val rows: List<ProfileRow> = client.get(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
        }.body()

        val row = rows.firstOrNull() ?: return null
        return row.toDomain()
    }

    /**
     * Update any combination of fields in one request (used by Profile UI).
     * Pass null for fields you don't want to change.
     */
    suspend fun updateProfile(
        accessToken: String,
        userId: String,
        displayName: String? = null,
        avatarUrl: String? = null,
        migraineType: MigraineType? = null
    ): Profile {
        return patchProfile(
            accessToken = accessToken,
            userId = userId,
            displayName = displayName?.trim(),
            avatarUrl = avatarUrl?.trim(),
            migraineType = migraineType
        )
    }

    // ---- Wire format (PostgREST JSON) ----

    @Serializable
    private data class ProfileRow(
        @SerialName("user_id") val userId: String,
        @SerialName("display_name") val displayName: String? = null,
        @SerialName("avatar_url") val avatarUrl: String? = null,
        @SerialName("migraine_type") val migraineType: String? = null
    ) {
        fun toDomain(): Profile =
            Profile(
                userId = userId,
                displayName = displayName,
                avatarUrl = avatarUrl,
                migraineType = MigraineType.fromDbValue(migraineType)
            )
    }

    @Serializable
    private data class InsertProfileBody(
        @SerialName("user_id") val userId: String,
        @SerialName("display_name") val displayName: String? = null,
        @SerialName("avatar_url") val avatarUrl: String? = null,
        @SerialName("migraine_type") val migraineType: String? = null
    )

    @Serializable
    private data class PatchProfileBody(
        @SerialName("display_name") val displayName: String? = null,
        @SerialName("avatar_url") val avatarUrl: String? = null,
        @SerialName("migraine_type") val migraineType: String? = null
    )

    private suspend fun insertProfile(
        accessToken: String,
        userId: String,
        displayName: String?,
        avatarUrl: String?,
        migraineType: MigraineType?
    ): Profile {
        val url = "$baseUrl/rest/v1/profiles?select=user_id,display_name,avatar_url,migraine_type"

        val body = InsertProfileBody(
            userId = userId,
            displayName = displayName,
            avatarUrl = avatarUrl,
            migraineType = migraineType?.dbValue
        )

        val rows: List<ProfileRow> = client.post(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
            header("Prefer", "return=representation")
            contentType(ContentType.Application.Json)
            setBody(body)
        }.body()

        return rows.first().toDomain()
    }

    private suspend fun patchProfile(
        accessToken: String,
        userId: String,
        displayName: String?,
        avatarUrl: String?,
        migraineType: MigraineType?
    ): Profile {
        val url =
            "$baseUrl/rest/v1/profiles?user_id=eq.$userId&select=user_id,display_name,avatar_url,migraine_type"

        val body = PatchProfileBody(
            displayName = displayName,
            avatarUrl = avatarUrl,
            migraineType = migraineType?.dbValue
        )

        val rows: List<ProfileRow> = client.patch(url) {
            header("apikey", anonKey)
            header("Authorization", "Bearer $accessToken")
            header("Prefer", "return=representation")
            contentType(ContentType.Application.Json)
            setBody(body)
        }.body()

        return rows.first().toDomain()
    }
}

title: TestingScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Divider
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.ui.platform.LocalContext

/**
 * PH-only debug screen.
 * NOW ONLY SHOWS: High HR Zones
 * (Recovery, RHR, HRV, Skin Temp, SPO2 were moved to TestingScreenComplete)
 */
@Composable
fun TestingScreen(
    authVm: AuthViewModel
) {
    val ctx = LocalContext.current
    val state by authVm.state.collectAsState()

    // ONLY HR ZONES LEFT
    var zones by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.HighHrZonesDailyRead>()) }

    val access = state.accessToken

    LaunchedEffect(access) {
        if (access == null) return@LaunchedEffect

        val svc = SupabasePhysicalHealthService(ctx)
        zones = svc.fetchHighHrDaily(access)
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
            .verticalScroll(rememberScrollState()),
        horizontalAlignment = Alignment.Start
    ) {
        Text("Physical Health Debug (Testing)", textAlign = TextAlign.Start)
        Spacer(Modifier.height(20.dp))

        DataSection(
            "High HR Zones",
            zones.map {
                "${it.date}: total=${it.value_minutes}, z4=${it.zone_four_minutes}, z5=${it.zone_five_minutes}, z6=${it.zone_six_minutes}"
            }
        )
    }
}

@Composable
private fun DataSection(title: String, rows: List<String>) {
    Text(title)
    Spacer(Modifier.height(6.dp))
    if (rows.isEmpty()) {
        Text("  (no data)")
    } else {
        for (line in rows) {
            Text("  $line")
        }
    }
    Divider(Modifier.padding(vertical = 12.dp))
}

title: TestingScreenComplete.kt
text:
package com.migraineme

import android.content.Context
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.http.HttpHeaders
import io.ktor.http.isSuccess
import io.ktor.serialization.kotlinx.json.json
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import org.json.JSONArray
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import kotlin.math.atan2
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

@Composable
fun TestingScreenComplete(
    authVm: AuthViewModel,
    vm: TestingViewModel = androidx.lifecycle.viewmodel.compose.viewModel()
) {
    val ctx = LocalContext.current.applicationContext
    val auth by authVm.state.collectAsState()

    // Load VM Data
    LaunchedEffect(auth.accessToken) {
        val token = auth.accessToken
        if (!token.isNullOrBlank()) vm.load(ctx, token)
        else vm.clear()
    }

    // -----------------------------------------
    // PHYSICAL HEALTH — MOVED FROM TestingScreen
    // -----------------------------------------
    var recovery by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.RecoveryScoreDailyRead>()) }
    var rhr by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.RestingHrDailyRead>()) }
    var hrv by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.HrvDailyRead>()) }
    var skin by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.SkinTempDailyRead>()) }
    var spo2 by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.Spo2DailyRead>()) }
    var zones by remember { mutableStateOf(emptyList<SupabasePhysicalHealthService.HighHrZonesDailyRead>()) }

    LaunchedEffect(auth.accessToken) {
        val token = auth.accessToken ?: return@LaunchedEffect
        val svc = SupabasePhysicalHealthService(ctx)

        recovery = svc.fetchRecoveryScoreDaily(token)
        rhr = svc.fetchRestingHrDaily(token)
        hrv = svc.fetchHrvDaily(token)
        skin = svc.fetchSkinTempDaily(token)
        spo2 = svc.fetchSpo2Daily(token)
        zones = svc.fetchHighHrDaily(token)
    }

    // Existing VM fields
    val migraines by vm.migraines.collectAsState()
    val reliefs by vm.reliefs.collectAsState()
    val triggers by vm.triggers.collectAsState()
    val medicines by vm.medicines.collectAsState()

    val sleepDuration by vm.sleepDuration.collectAsState()
    val fellAsleep by vm.fellAsleep.collectAsState()
    val wokeUp by vm.wokeUp.collectAsState()
    val sleepDisturbances by vm.sleepDisturbances.collectAsState()
    val sleepStages by vm.sleepStages.collectAsState()
    val sleepScore by vm.sleepScore.collectAsState()
    val sleepEfficiency by vm.sleepEfficiency.collectAsState()

    val locations by vm.userLocations.collectAsState()
    val wxPerLoc by vm.weatherAtLocations.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
            .padding(12.dp)
    ) {
        Text("Testing (raw tables)", style = MaterialTheme.typography.headlineMedium)

        Spacer(Modifier.height(12.dp))

        // -----------------------------------
        // PHYSICAL HEALTH SECTION (NOW MOVED)
        // -----------------------------------
        SectionHeader("Physical Health (WHOOP)")

        TableCard("recovery_score_daily") {
            RowHeader("date", "value_pct")
            recovery.forEach { r -> RowLine(r.date, r.value_pct.toString()) }
        }

        TableCard("resting_hr_daily") {
            RowHeader("date", "value_bpm")
            rhr.forEach { r -> RowLine(r.date, r.value_bpm.toString()) }
        }

        TableCard("hrv_daily") {
            RowHeader("date", "rmssd_ms")
            hrv.forEach { r -> RowLine(r.date, r.value_rmssd_ms.toString()) }
        }

        TableCard("skin_temp_daily") {
            RowHeader("date", "value_celsius")
            skin.forEach { r -> RowLine(r.date, r.value_celsius.toString()) }
        }

        TableCard("spo2_daily") {
            RowHeader("date", "value_pct")
            spo2.forEach { r -> RowLine(r.date, r.value_pct.toString()) }
        }


        

        Spacer(Modifier.height(20.dp))

        // ----------------------------
        // Sleep tables (existing code)
        // ----------------------------
        SectionHeader("Wearable Sleep Metrics")

        TableCard("sleep_duration_daily") {
            RowHeader("date", "value_hours")
            sleepDuration.forEach { r -> RowLine(r.date, "%.2f".format(r.value_hours)) }
        }

        TableCard("sleep_score_daily") {
            RowHeader("date", "value_pct")
            sleepScore.forEach { r -> RowLine(r.date, "%.0f".format(r.value_pct)) }
        }

        TableCard("sleep_efficiency_daily") {
            RowHeader("date", "value_pct")
            sleepEfficiency.forEach { r -> RowLine(r.date, "%.0f".format(r.value_pct)) }
        }

        TableCard("fell_asleep_time_daily") {
            RowHeader("date", "value_at")
            fellAsleep.forEach { r -> RowLine(r.date, r.value_at) }
        }

        TableCard("woke_up_time_daily") {
            RowHeader("date", "value_at")
            wokeUp.forEach { r -> RowLine(r.date, r.value_at) }
        }

        TableCard("sleep_disturbances_daily") {
            RowHeader("date", "value_count")
            sleepDisturbances.forEach { r -> RowLine(r.date, r.value_count.toString()) }
        }

        TableCard("sleep_stages_daily") {
            RowHeader("date", "sws", "rem", "light")
            sleepStages.forEach { r ->
                RowLine(
                    r.date,
                    "%.2f".format(r.value_sws_hm),
                    "%.2f".format(r.value_rem_hm),
                    "%.2f".format(r.value_light_hm)
                )
            }
        }

        Spacer(Modifier.height(20.dp))

        // ----------------------------
        // Weather join
        // ----------------------------
        SectionHeader("Weather × Location Join")

        TableCard("weather_at_location") {
            RowHeader("date", "lat", "lon", "city", "temp", "press", "hum")
            wxPerLoc.forEach { r ->
                RowLine(
                    r.date,
                    "%.5f".format(r.latitude),
                    "%.5f".format(r.longitude),
                    r.cityLabel ?: "-",
                    r.tempMeanC?.let { "%.1f".format(it) } ?: "-",
                    r.pressureMeanHpa?.let { "%.1f".format(it) } ?: "-",
                    r.humidityMeanPct?.let { "%.0f".format(it) } ?: "-"
                )
            }
        }

        Spacer(Modifier.height(20.dp))

        // ----------------------------
        // App tables
        // ----------------------------
        SectionHeader("App Data")

        TableCard("migraines") {
            RowHeader("start_at", "ended_at", "severity", "type")
            migraines.forEach { r ->
                RowLine(
                    r.startAt ?: "-",
                    r.endAt ?: "-",
                    r.severity?.toString() ?: "-",
                    r.type ?: "-"
                )
            }
        }

        TableCard("reliefs") {
            RowHeader("start_at", "duration", "type")
            reliefs.forEach { r ->
                RowLine(r.startAt ?: "-", r.durationMinutes?.toString() ?: "-", r.type ?: "-")
            }
        }

        TableCard("triggers") {
            RowHeader("start_at", "type")
            triggers.forEach { r -> RowLine(r.startAt ?: "-", r.type ?: "-") }
        }

        TableCard("medicines") {
            RowHeader("start_at", "name", "amount")
            medicines.forEach { r -> RowLine(r.startAt ?: "-", r.name ?: "-", r.amount ?: "-") }
        }
    }
}

/* ---------- UI HELPERS ---------- */

@Composable
private fun SectionHeader(text: String) {
    Text(text, style = MaterialTheme.typography.titleLarge)
    Spacer(Modifier.height(6.dp))
}

@Composable
private fun TableCard(
    title: String,
    content: @Composable () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = androidx.compose.ui.graphics.Color(
                0xFFF7F7F9
            )
        )
    ) {
        Column(Modifier.padding(12.dp)) {
            Text(title, style = MaterialTheme.typography.titleMedium)
            Spacer(Modifier.height(4.dp))
            content()
        }
    }
}

@Composable
private fun RowHeader(vararg cols: String) {
    Row(Modifier.fillMaxWidth()) {
        cols.forEach { c -> Text(c, modifier = Modifier.weight(1f)) }
    }
}

@Composable
private fun RowLine(vararg cols: String) {
    Row(Modifier.fillMaxWidth()) {
        cols.forEach { c -> Text(c, modifier = Modifier.weight(1f)) }
    }
}

/* ---------- VIEWMODEL (unchanged) ---------- */

class TestingViewModel : ViewModel() {

    data class MigraineRow(
        val startAt: String?,
        val endAt: String?,
        val severity: Int?,
        val type: String?
    )

    data class ReliefRow(val startAt: String?, val durationMinutes: Int?, val type: String?)
    data class TriggerRow(val startAt: String?, val type: String?)
    data class MedicineRow(val startAt: String?, val name: String?, val amount: String?)

    private val _migraines = MutableStateFlow<List<MigraineRow>>(emptyList())
    val migraines: StateFlow<List<MigraineRow>> = _migraines

    private val _reliefs = MutableStateFlow<List<ReliefRow>>(emptyList())
    val reliefs: StateFlow<List<ReliefRow>> = _reliefs

    private val _triggers = MutableStateFlow<List<TriggerRow>>(emptyList())
    val triggers: StateFlow<List<TriggerRow>> = _triggers

    private val _medicines = MutableStateFlow<List<MedicineRow>>(emptyList())
    val medicines: StateFlow<List<MedicineRow>> = _medicines

    private val _sleepDuration =
        MutableStateFlow<List<SupabaseMetricsService.SleepDurationDailyRead>>(emptyList())
    val sleepDuration: StateFlow<List<SupabaseMetricsService.SleepDurationDailyRead>> =
        _sleepDuration

    @Serializable
    data class FellAsleepRead(val date: String, val value_at: String)
    @Serializable
    data class WokeUpRead(val date: String, val value_at: String)

    private val _fellAsleep = MutableStateFlow<List<FellAsleepRead>>(emptyList())
    val fellAsleep: StateFlow<List<FellAsleepRead>> = _fellAsleep

    private val _wokeUp = MutableStateFlow<List<WokeUpRead>>(emptyList())
    val wokeUp: StateFlow<List<WokeUpRead>> = _wokeUp

    private val _sleepDisturbances =
        MutableStateFlow<List<SupabaseMetricsService.SleepDisturbancesDailyRead>>(emptyList())
    val sleepDisturbances: StateFlow<List<SupabaseMetricsService.SleepDisturbancesDailyRead>> =
        _sleepDisturbances

    private val _sleepStages =
        MutableStateFlow<List<SupabaseMetricsService.SleepStagesDailyRead>>(emptyList())
    val sleepStages: StateFlow<List<SupabaseMetricsService.SleepStagesDailyRead>> = _sleepStages

    private val _sleepScore =
        MutableStateFlow<List<SupabaseMetricsService.SleepScoreDailyRead>>(emptyList())
    val sleepScore: StateFlow<List<SupabaseMetricsService.SleepScoreDailyRead>> = _sleepScore

    private val _sleepEfficiency =
        MutableStateFlow<List<SupabaseMetricsService.SleepEfficiencyDailyRead>>(emptyList())
    val sleepEfficiency: StateFlow<List<SupabaseMetricsService.SleepEfficiencyDailyRead>> =
        _sleepEfficiency

    data class LocationRow(val date: String, val latitude: Double, val longitude: Double)

    private val _userLocations = MutableStateFlow<List<LocationRow>>(emptyList())
    val userLocations: StateFlow<List<LocationRow>> = _userLocations

    data class WeatherAtLocationRow(
        val date: String,
        val latitude: Double,
        val longitude: Double,
        val cityLabel: String?,
        val tempMeanC: Double?,
        val pressureMeanHpa: Double?,
        val humidityMeanPct: Double?
    )

    private val _weatherAtLocations = MutableStateFlow<List<WeatherAtLocationRow>>(emptyList())
    val weatherAtLocations: StateFlow<List<WeatherAtLocationRow>> = _weatherAtLocations

    private lateinit var db: SupabaseDbService

    fun load(context: Context, accessToken: String) {
        db = SupabaseDbService(BuildConfig.SUPABASE_URL, BuildConfig.SUPABASE_ANON_KEY)
        viewModelScope.launch {
            try {
                val migs = db.getMigraines(accessToken)
                _migraines.value =
                    migs.map { r -> MigraineRow(r.startAt, r.endAt, r.severity, r.type) }

                val rels = db.getAllReliefs(accessToken)
                _reliefs.value = rels.map { r -> ReliefRow(r.startAt, r.durationMinutes, r.type) }

                val trs = db.getAllTriggers(accessToken)
                _triggers.value = trs.map { r -> TriggerRow(r.startAt, r.type) }

                val meds = db.getAllMedicines(accessToken)
                _medicines.value = meds.map { r -> MedicineRow(r.startAt, r.name, r.amount) }

                val metrics = SupabaseMetricsService(context)
                _sleepDuration.value = metrics.fetchSleepDurationDaily(accessToken, limitDays = 180)
                _sleepDisturbances.value =
                    metrics.fetchSleepDisturbancesDaily(accessToken, limitDays = 180)
                _sleepStages.value = metrics.fetchSleepStagesDaily(accessToken, limitDays = 180)
                _sleepScore.value = metrics.fetchSleepScoreDaily(accessToken, limitDays = 180)
                _sleepEfficiency.value =
                    metrics.fetchSleepEfficiencyDaily(accessToken, limitDays = 180)
                _fellAsleep.value = fetchFellAsleep(accessToken)
                _wokeUp.value = fetchWokeUp(accessToken)

                val personal = SupabasePersonalService(context)
                val locs = personal.fetchUserLocationDaily(accessToken, limitDays = 180)
                val locRows = locs.map { r -> LocationRow(r.date, r.latitude, r.longitude) }
                _userLocations.value = locRows

                _weatherAtLocations.value = withContext(Dispatchers.IO) {
                    fetchWeatherForLocations(locs = locRows)
                }
            } catch (_: Exception) {
                clear()
            }
        }
    }

    fun clear() {
        _migraines.value = emptyList()
        _reliefs.value = emptyList()
        _triggers.value = emptyList()
        _medicines.value = emptyList()
        _sleepDuration.value = emptyList()
        _fellAsleep.value = emptyList()
        _wokeUp.value = emptyList()
        _sleepDisturbances.value = emptyList()
        _sleepStages.value = emptyList()
        _sleepScore.value = emptyList()
        _sleepEfficiency.value = emptyList()
        _userLocations.value = emptyList()
        _weatherAtLocations.value = emptyList()
    }

    private suspend fun fetchFellAsleep(accessToken: String): List<FellAsleepRead> {
        val client =
            HttpClient { install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) } }
        val resp = client.get("${BuildConfig.SUPABASE_URL}/rest/v1/fell_asleep_time_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            parameter("select", "date,value_at")
            parameter("order", "date.desc")
            parameter("limit", "180")
        }
        return if (resp.status.isSuccess()) runCatching { resp.body<List<FellAsleepRead>>() }.getOrDefault(
            emptyList()
        )
        else emptyList()
    }

    private suspend fun fetchWokeUp(accessToken: String): List<WokeUpRead> {
        val client =
            HttpClient { install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true }) } }
        val resp = client.get("${BuildConfig.SUPABASE_URL}/rest/v1/woke_up_time_daily") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            header("apikey", BuildConfig.SUPABASE_ANON_KEY)
            parameter("select", "date,value_at")
            parameter("order", "date.desc")
            parameter("limit", "180")
        }
        return if (resp.status.isSuccess()) runCatching { resp.body<List<WokeUpRead>>() }.getOrDefault(
            emptyList()
        )
        else emptyList()
    }

    private data class CityRow(val id: Long, val label: String, val lat: Double, val lon: Double)

    private fun haversineKm(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val R = 6371.0
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = sin(dLat / 2) * sin(dLat / 2) +
                cos(Math.toRadians(lat1)) * cos(Math.toRadians(lat2)) *
                sin(dLon / 2) * sin(dLon / 2)
        val c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c
    }

    private fun httpGet(urlStr: String): Pair<Int, String> {
        val url = URL(urlStr)
        val conn = (url.openConnection() as HttpURLConnection).apply {
            requestMethod = "GET"
            setRequestProperty("apikey", BuildConfig.SUPABASE_ANON_KEY)
            setRequestProperty("Authorization", "Bearer ${BuildConfig.SUPABASE_ANON_KEY}")
        }
        val code = conn.responseCode
        val body =
            BufferedReader(InputStreamReader(if (code in 200..299) conn.inputStream else conn.errorStream)).use { it.readText() }
        conn.disconnect()
        return code to body
    }

    private fun parseCities(body: String): List<CityRow> {
        val arr = JSONArray(body)
        val out = ArrayList<CityRow>()
        for (i in 0 until arr.length()) {
            val o = arr.getJSONObject(i)
            out.add(
                CityRow(
                    id = o.getLong("id"),
                    label = o.optString("name").ifBlank { o.optString("label", "") },
                    lat = o.getDouble("lat"),
                    lon = o.getDouble("lon")
                )
            )
        }
        return out
    }

    private fun fetchCitiesNear(lat: Double, lon: Double, deg: Double): List<CityRow> {
        val base = "${BuildConfig.SUPABASE_URL}/rest/v1/city"
        val qp =
            "select=id,name,lat,lon&lat=gte.${lat - deg}&lat=lte.${lat + deg}&lon=gte.${lon - deg}&lon=lte.${lon + deg}&limit=5000"
        val (code, body) = httpGet("$base?$qp")
        if (code !in 200..299) return emptyList()
        return parseCities(body)
    }

    private fun fetchAllCities(): List<CityRow> {
        val base = "${BuildConfig.SUPABASE_URL}/rest/v1/city"
        val qp = "select=id,name,lat,lon&limit=5000"
        val (code, body) = httpGet("$base?$qp")
        if (code !in 200..299) return emptyList()
        return parseCities(body)
    }

    private fun findNearestCity(lat: Double, lon: Double): CityRow? {
        val nearby = fetchCitiesNear(lat, lon, 2.0)
        val pool = if (nearby.isNotEmpty()) nearby else fetchAllCities()
        if (pool.isEmpty()) return null
        return pool.minByOrNull { c -> haversineKm(lat, lon, c.lat, c.lon) }
    }

    private data class WeatherRow(val temp: Double?, val pressure: Double?, val humidity: Double?)

    private fun JSONObject.optDoubleOrNull(name: String): Double? {
        return if (isNull(name)) null else try {
            getDouble(name)
        } catch (_: Exception) {
            null
        }
    }

    private fun fetchWeatherForCityOnDate(
        cityId: Long,
        dayIso: String
    ): Pair<WeatherRow?, String?> {
        val base = "${BuildConfig.SUPABASE_URL}/rest/v1/city_weather_daily"
        val qp =
            "select=day,temp_c_mean,pressure_hpa_mean,humidity_pct_mean,city_id,city!inner(name)&city_id=eq.$cityId&day=eq.$dayIso&limit=1"
        val (code, body) = httpGet("$base?$qp")
        if (code !in 200..299 || body.isBlank() || body == "[]") return null to null
        return try {
            val arr = JSONArray(body)
            val o = arr.getJSONObject(0)
            val cityName = o.optJSONObject("city")?.optString("name")
            val w = WeatherRow(
                temp = o.optDoubleOrNull("temp_c_mean"),
                pressure = o.optDoubleOrNull("pressure_hpa_mean"),
                humidity = o.optDoubleOrNull("humidity_pct_mean")
            )
            w to cityName
        } catch (_: Throwable) {
            null to null
        }
    }

    private suspend fun fetchWeatherForLocations(locs: List<LocationRow>): List<WeatherAtLocationRow> {
        if (locs.isEmpty()) return emptyList()
        data class Key(val la: Int, val lo: Int)

        val cache = HashMap<Key, CityRow?>()
        val out = ArrayList<WeatherAtLocationRow>()
        for (row in locs) {
            val key = Key((row.latitude * 10).toInt(), (row.longitude * 10).toInt())
            val city = cache.getOrPut(key) { findNearestCity(row.latitude, row.longitude) }
            if (city == null) {
                out.add(
                    WeatherAtLocationRow(
                        row.date,
                        row.latitude,
                        row.longitude,
                        null,
                        null,
                        null,
                        null
                    )
                )
                continue
            }
            val (w, lbl) = fetchWeatherForCityOnDate(city.id, row.date)
            out.add(
                WeatherAtLocationRow(
                    date = row.date,
                    latitude = row.latitude,
                    longitude = row.longitude,
                    cityLabel = lbl ?: city.label,
                    tempMeanC = w?.temp,
                    pressureMeanHpa = w?.pressure,
                    humidityMeanPct = w?.humidity
                )
            )
        }
        return out
    }
}

title: ThirdPartyConnectionsScreen.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Context
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.Image
import androidx.compose.foundation.border
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.Check
import androidx.compose.material.icons.outlined.KeyboardArrowDown
import androidx.compose.material.icons.outlined.KeyboardArrowUp
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Divider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.compose.LocalLifecycleOwner
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun ThirdPartyConnectionsScreen(
    onBack: () -> Unit
) {
    val context = LocalContext.current
    val activity = context as? Activity
    val lifecycleOwner = LocalLifecycleOwner.current
    val scope = rememberCoroutineScope()

    val wearablesExpanded = remember { mutableStateOf(true) }
    val tokenStore = remember { WhoopTokenStore(context) }
    val hasWhoop = remember { mutableStateOf(tokenStore.load() != null) }
    val whoopErrorDialog = remember { mutableStateOf<String?>(null) }
    val showDisconnectDialog = remember { mutableStateOf(false) }

    // Prevent re-processing the same callback URI repeatedly
    val lastProcessedUri = remember { mutableStateOf<String?>(null) }

    val whoopLogoResId = remember {
        val pkg = context.packageName
        val r = context.resources
        r.getIdentifier("whoop_logo", "drawable", pkg)
            .takeIf { it != 0 }
            ?: r.getIdentifier("whoop_logo", "mipmap", pkg)
    }

    suspend fun tryCompleteWhoopIfCallbackPresent() {
        val prefs = context.getSharedPreferences("whoop_oauth", Context.MODE_PRIVATE)
        val lastUri = prefs.getString("last_uri", null)

        // Nothing to do
        if (lastUri.isNullOrBlank()) return

        // Already processed this callback
        if (lastProcessedUri.value == lastUri) return

        // Mark as processed immediately to avoid loops if completion fails
        lastProcessedUri.value = lastUri

        val ok = withContext(Dispatchers.IO) {
            WhoopAuthService().completeAuth(context)
        }

        val localToken = tokenStore.load()

        if (ok && localToken != null) {
            hasWhoop.value = true

            withContext(Dispatchers.IO) {
                val edge = EdgeFunctionsService()

                // 1) Store token in Supabase (whoop_tokens)
                val stored = edge.upsertWhoopTokenToSupabase(context.applicationContext, localToken)
                if (!stored) {
                    whoopErrorDialog.value =
                        "WHOOP connected locally, but failed to store token in Supabase. " +
                                "Check Edge Function logs for upsert-whoop-token."
                    return@withContext
                }

                // 2) Enqueue backfill after token exists server-side
                edge.enqueueLoginBackfill(context.applicationContext)
            }
        } else {
            hasWhoop.value = false
            whoopErrorDialog.value =
                prefs.getString("token_error", "WHOOP authentication failed")
                    ?: "WHOOP authentication failed"
        }
    }

    // Run completion when coming back from WHOOP browser flow.
    // This is the missing part: LaunchedEffect(Unit) runs once; ON_RESUME runs after returning.
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_RESUME) {
                scope.launch {
                    tryCompleteWhoopIfCallbackPresent()
                }
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }
    }

    // Also attempt once on first composition (safe no-op if no last_uri)
    LaunchedEffect(Unit) {
        tryCompleteWhoopIfCallbackPresent()
    }

    whoopErrorDialog.value?.let { msg ->
        AlertDialog(
            onDismissRequest = { whoopErrorDialog.value = null },
            title = { Text("WHOOP connection failed") },
            text = { Text(msg) },
            confirmButton = {
                TextButton(onClick = { whoopErrorDialog.value = null }) {
                    Text("OK")
                }
            }
        )
    }

    if (showDisconnectDialog.value) {
        AlertDialog(
            onDismissRequest = { showDisconnectDialog.value = false },
            title = { Text("Disconnect WHOOP?") },
            text = { Text("Are you sure you want to disconnect WHOOP?") },
            confirmButton = {
                TextButton(
                    onClick = {
                        tokenStore.clear()
                        context.getSharedPreferences("whoop_oauth", Context.MODE_PRIVATE)
                            .edit().clear().apply()
                        hasWhoop.value = false
                        lastProcessedUri.value = null
                        showDisconnectDialog.value = false
                    }
                ) { Text("Disconnect") }
            },
            dismissButton = {
                TextButton(onClick = { showDisconnectDialog.value = false }) {
                    Text("Cancel")
                }
            }
        )
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        Divider()
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .combinedClickable(
                    onClick = { wearablesExpanded.value = !wearablesExpanded.value },
                    onLongClick = {}
                )
                .padding(vertical = 12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "Wearables",
                style = MaterialTheme.typography.titleLarge,
                modifier = Modifier.weight(1f)
            )
            Icon(
                imageVector = if (wearablesExpanded.value)
                    Icons.Outlined.KeyboardArrowUp
                else
                    Icons.Outlined.KeyboardArrowDown,
                contentDescription = null
            )
        }
        Divider()

        if (wearablesExpanded.value) {
            Spacer(Modifier.height(12.dp))

            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clip(RoundedCornerShape(16.dp))
                    .border(
                        width = 1.dp,
                        color = MaterialTheme.colorScheme.outlineVariant,
                        shape = RoundedCornerShape(16.dp)
                    )
                    .combinedClickable(
                        enabled = activity != null,
                        onClick = {
                            activity?.let {
                                tokenStore.clear()
                                context.getSharedPreferences("whoop_oauth", Context.MODE_PRIVATE)
                                    .edit().clear().apply()
                                hasWhoop.value = false
                                lastProcessedUri.value = null
                                WhoopAuthService().startAuth(it)
                            }
                        },
                        onLongClick = {
                            if (hasWhoop.value) showDisconnectDialog.value = true
                        }
                    )
                    .padding(horizontal = 16.dp, vertical = 8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier.size(102.dp),
                    contentAlignment = Alignment.Center
                ) {
                    if (whoopLogoResId != 0) {
                        Image(
                            painter = painterResource(id = whoopLogoResId),
                            contentDescription = "WHOOP logo",
                            contentScale = ContentScale.Fit,
                            modifier = Modifier.fillMaxSize()
                        )
                    } else {
                        Text("W", fontWeight = FontWeight.Bold)
                    }
                }

                Spacer(Modifier.size(16.dp))

                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = if (hasWhoop.value) "Sync enabled" else "Tap to connect",
                        style = MaterialTheme.typography.bodyLarge
                    )
                }

                Box(
                    modifier = Modifier
                        .size(22.dp)
                        .clip(CircleShape)
                        .border(
                            width = 2.dp,
                            color = if (hasWhoop.value)
                                MaterialTheme.colorScheme.primary
                            else
                                MaterialTheme.colorScheme.outline,
                            shape = CircleShape
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    if (hasWhoop.value) {
                        Icon(
                            imageVector = Icons.Outlined.Check,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(18.dp)
                        )
                    }
                }
            }

            Spacer(Modifier.height(12.dp))
            Divider()
        }
    }
}

title: TriggersScreen.kt
text:
package com.migraineme

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import java.time.LocalDateTime
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalLayoutApi::class)
@Composable
fun TriggersScreen(
    navController: NavController,
    vm: TriggerViewModel,
    authVm: AuthViewModel,
    logVm: LogViewModel
) {
    val pool by vm.pool.collectAsState()
    val frequent by vm.frequent.collectAsState()
    val authState by authVm.state.collectAsState()
    val draft by logVm.draft.collectAsState()

    LaunchedEffect(authState.accessToken) {
        authState.accessToken?.let { token -> vm.loadAll(token) }
    }

    val frequentIds = remember(frequent) { frequent.map { it.triggerId }.toSet() }
    val remaining = remember(pool, frequentIds) { pool.filter { it.id !in frequentIds } }

    // Add dialog: pick time before adding a trigger
    var showAddDialog by remember { mutableStateOf(false) }
    var pendingLabel by remember { mutableStateOf<String?>(null) }
    fun openAdd(label: String) {
        pendingLabel = label
        showAddDialog = true
    }
    if (showAddDialog) {
        TimeAddDialog(
            initialIso = null,
            onDismiss = { showAddDialog = false },
            onConfirm = { iso ->
                val label = pendingLabel ?: return@TimeAddDialog
                logVm.addTriggerDraft(trigger = label, startAtIso = iso)
                showAddDialog = false
            }
        )
    }

    // Edit time dialog for existing cards
    var showEditTime by remember { mutableStateOf(false) }
    var timeEditIndex by remember { mutableStateOf<Int?>(null) }
    if (showEditTime && timeEditIndex != null && timeEditIndex in draft.triggers.indices) {
        TimeOnlyDialog(
            initialIso = draft.triggers[timeEditIndex!!].startAtIso,
            onDismiss = { showEditTime = false },
            onConfirm = { newIso ->
                val idx = timeEditIndex!!
                val d = draft
                logVm.clearDraft()
                logVm.setMigraineDraft(
                    d.migraine?.type, d.migraine?.severity,
                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                )
                d.triggers.forEachIndexed { i, tt ->
                    val iso = if (i == idx) newIso else tt.startAtIso
                    logVm.addTriggerDraft(tt.type, startAtIso = iso, note = tt.note)
                }
                d.meds.forEach { m ->
                    m.name?.let { nm -> logVm.addMedicineDraft(nm, m.amount, m.notes, m.startAtIso) }
                }
                d.rels.forEach { r ->
                    logVm.addReliefDraft(r.type, r.durationMinutes, r.notes, r.startAtIso)
                }
                showEditTime = false
            }
        )
    }

    Scaffold(
        bottomBar = {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                OutlinedButton(onClick = { navController.navigate(Routes.MIGRAINE) }) { Text("Back") }
                Button(onClick = { navController.navigate(Routes.MEDICINES) }) { Text("Next") }
            }
        }
    ) { innerPadding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(horizontal = 16.dp),
            contentPadding = PaddingValues(vertical = 16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Header + Manage aligned with Frequent
            if (frequent.isNotEmpty()) {
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text("Frequent", style = MaterialTheme.typography.titleMedium)
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_TRIGGERS) }) {
                            Text("Manage")
                        }
                    }
                }
            } else {
                item {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(onClick = { navController.navigate(Routes.ADJUST_TRIGGERS) }) {
                            Text("Manage")
                        }
                    }
                }
            }

            // Selected now
            if (draft.triggers.isNotEmpty()) {
                item {
                    Column {
                        Text("Selected now", style = MaterialTheme.typography.titleMedium)
                        Spacer(Modifier.height(8.dp))
                        draft.triggers.asReversed().forEachIndexed { revIndex, t ->
                            val actualIndex = draft.triggers.lastIndex - revIndex
                            ElevatedCard(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(vertical = 4.dp)
                            ) {
                                Column(Modifier.padding(12.dp)) {
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text("Trigger: ${t.type}", style = MaterialTheme.typography.bodyLarge)
                                        IconButton(
                                            onClick = {
                                                val d = draft
                                                logVm.clearDraft()
                                                logVm.setMigraineDraft(
                                                    d.migraine?.type, d.migraine?.severity,
                                                    d.migraine?.beganAtIso, d.migraine?.endedAtIso, d.migraine?.note
                                                )
                                                d.triggers.forEachIndexed { i, tt ->
                                                    if (i != actualIndex) {
                                                        logVm.addTriggerDraft(tt.type, startAtIso = tt.startAtIso, note = tt.note)
                                                    }
                                                }
                                                d.meds.forEach { m ->
                                                    m.name?.let { nm -> logVm.addMedicineDraft(nm, m.amount, m.notes, m.startAtIso) }
                                                }
                                                d.rels.forEach { r ->
                                                    logVm.addReliefDraft(r.type, r.durationMinutes, r.notes, r.startAtIso)
                                                }
                                            }
                                        ) {
                                            Icon(Icons.Default.Delete, contentDescription = "Remove trigger")
                                        }
                                    }

                                    // Time row: plain clickable "Edit"
                                    Row(
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .padding(top = 6.dp),
                                        horizontalArrangement = Arrangement.SpaceBetween
                                    ) {
                                        Text(
                                            "Time: ${formatIsoDdMmHm(t.startAtIso)}",
                                            style = MaterialTheme.typography.bodyMedium
                                        )
                                        Text(
                                            "Edit",
                                            color = MaterialTheme.colorScheme.primary,
                                            style = MaterialTheme.typography.bodyMedium,
                                            modifier = Modifier.clickable {
                                                timeEditIndex = actualIndex
                                                showEditTime = true
                                            }
                                        )
                                    }

                                    if (!t.note.isNullOrBlank()) {
                                        Spacer(Modifier.height(4.dp))
                                        Text("Notes: ${t.note}", style = MaterialTheme.typography.bodyMedium)
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Frequent chips → open time-add dialog
            if (frequent.isNotEmpty()) {
                item {
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        frequent.forEach { pref ->
                            val label = pref.trigger?.label ?: return@forEach
                            AssistChip(
                                onClick = { openAdd(label) },
                                label = { Text(label) }
                            )
                        }
                    }
                }
            }

            // All triggers chips → open time-add dialog
            if (remaining.isNotEmpty()) {
                item { Text("All Triggers", style = MaterialTheme.typography.titleMedium) }
                item {
                    FlowRow(
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        remaining.forEach { trig ->
                            AssistChip(
                                onClick = { openAdd(trig.label) },
                                label = { Text(trig.label) }
                            )
                        }
                    }
                }
            }

            item { Spacer(Modifier.height(80.dp)) }
        }
    }
}

/** Format ISO string to "dd/MM HH:mm". Falls back to "Not set". */
private fun formatIsoDdMmHm(iso: String?): String {
    if (iso.isNullOrBlank()) return "Not set"
    return try {
        val odt = runCatching { OffsetDateTime.parse(iso) }.getOrNull()
        val ldt = odt?.toLocalDateTime() ?: LocalDateTime.parse(iso)
        ldt.format(DateTimeFormatter.ofPattern("dd/MM HH:mm"))
    } catch (_: Exception) {
        "Not set"
    }
}

@Composable
private fun TimeAddDialog(
    initialIso: String?,
    onDismiss: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text("Confirm") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Add trigger") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Time: ${formatIsoDdMmHm(pickedIso)}")
                AppDateTimePicker(
                    label = "Select time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        }
    )
}

@Composable
private fun TimeOnlyDialog(
    initialIso: String?,
    onDismiss: () -> Unit,
    onConfirm: (String?) -> Unit
) {
    var pickedIso by remember { mutableStateOf(initialIso) }
    AlertDialog(
        onDismissRequest = onDismiss,
        confirmButton = { TextButton(onClick = { onConfirm(pickedIso) }) { Text("Confirm") } },
        dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
        title = { Text("Edit time") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
                Text("Current: ${formatIsoDdMmHm(pickedIso)}")
                AppDateTimePicker(
                    label = "Select new time",
                    onDateTimeSelected = { iso -> pickedIso = iso }
                )
            }
        }
    )
}

title: TriggerViewModel.kt
text:
package com.migraineme

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class TriggerViewModel : ViewModel() {

    private val db = SupabaseDbService(
        BuildConfig.SUPABASE_URL,
        BuildConfig.SUPABASE_ANON_KEY
    )

    private val _pool = MutableStateFlow<List<SupabaseDbService.AllTriggerRow>>(emptyList())
    val pool: StateFlow<List<SupabaseDbService.AllTriggerRow>> = _pool

    private val _frequent = MutableStateFlow<List<SupabaseDbService.TriggerPrefRow>>(emptyList())
    val frequent: StateFlow<List<SupabaseDbService.TriggerPrefRow>> = _frequent

    private val _hidden = MutableStateFlow<List<SupabaseDbService.TriggerPrefRow>>(emptyList())
    val hidden: StateFlow<List<SupabaseDbService.TriggerPrefRow>> = _hidden

    private fun safeSortPrefs(prefs: List<SupabaseDbService.TriggerPrefRow>) =
        prefs.sortedBy { it.position }

    fun loadAll(accessToken: String) {
        viewModelScope.launch {
            try {
                val p = db.getAllTriggerPool(accessToken)
                val prefs = db.getTriggerPrefs(accessToken)
                _pool.value = p
                _frequent.value = safeSortPrefs(prefs.filter { it.status == "frequent" })
                _hidden.value = prefs.filter { it.status == "hidden" }
            } catch (e: Exception) {
                e.printStackTrace()
                _pool.value = emptyList()
                _frequent.value = emptyList()
                _hidden.value = emptyList()
            }
        }
    }

    fun addNewToPool(accessToken: String, label: String) {
        viewModelScope.launch {
            try {
                db.upsertTriggerToPool(accessToken, label.trim())
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromPool(accessToken: String, triggerId: String) {
        viewModelScope.launch {
            try {
                db.deleteTriggerFromPool(accessToken, triggerId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun addToFrequent(accessToken: String, triggerId: String) {
        viewModelScope.launch {
            try {
                val pos = _frequent.value.size
                db.insertTriggerPref(accessToken, triggerId, pos, status = "frequent")
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    fun removeFromFrequent(accessToken: String, prefId: String) {
        viewModelScope.launch {
            try {
                db.deleteTriggerPref(accessToken, prefId)
                loadAll(accessToken)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}

title: UiKit.kt
text:
package com.migraineme

import android.app.DatePickerDialog
import android.app.TimePickerDialog
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import java.util.Calendar

/** Simple centered top bar made from primitives. */
@Composable
fun SimpleTopBar(title: String) {
    Surface(tonalElevation = 3.dp) {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 16.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(text = title, style = MaterialTheme.typography.titleLarge)
        }
    }
}

@Composable
fun AppFormCard(title: String, content: @Composable ColumnScope.() -> Unit) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        ElevatedCard(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.elevatedCardElevation(defaultElevation = 2.dp)
        ) {
            Column(Modifier.padding(16.dp)) {
                Text(title, style = MaterialTheme.typography.titleMedium)
                Spacer(Modifier.height(12.dp))
                content()
            }
        }
    }
}

/** Public reusable dropdown (index-based) */
@Composable
fun AppDropdown(
    options: List<String>,
    selectedIndex: Int,
    onSelected: (Int) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val label = options.getOrNull(selectedIndex) ?: "None"

    Box {
        OutlinedButton(
            onClick = { expanded = true },
            modifier = Modifier.fillMaxWidth()
        ) { Text(label) }

        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {
            options.forEachIndexed { idx, text ->
                DropdownMenuItem(
                    text = { Text(text) },
                    onClick = {
                        onSelected(idx)
                        expanded = false
                    }
                )
            }
        }
    }
}

/**
 * Legacy-compatible field used across screens.
 * Opens DatePicker, then TimePicker, and returns an ISO-like string "YYYY-MM-DDTHH:MM:00Z".
 */
@Composable
fun DateTimePickerField(
    label: String,
    onDateTimeSelected: (String) -> Unit
) {
    val context = LocalContext.current
    val cal = Calendar.getInstance()

    var pickedDate by remember { mutableStateOf<String?>(null) }
    var display by remember { mutableStateOf(label) }

    OutlinedButton(
        onClick = {
            DatePickerDialog(
                context,
                { _, y, m, d ->
                    pickedDate = "%04d-%02d-%02d".format(y, m + 1, d)
                    TimePickerDialog(
                        context,
                        { _, h, min ->
                            val iso = "%sT%02d:%02d:00Z".format(pickedDate, h, min)
                            display = iso
                            onDateTimeSelected(iso)
                        },
                        cal.get(Calendar.HOUR_OF_DAY),
                        cal.get(Calendar.MINUTE),
                        true
                    ).show()
                },
                cal.get(Calendar.YEAR),
                cal.get(Calendar.MONTH),
                cal.get(Calendar.DAY_OF_MONTH)
            ).show()
        },
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(display)
    }
}

/**
 * Newer name some screens expect. Keep both to avoid refactors.
 * Just forwards to DateTimePickerField.
 */
@Composable
fun AppDateTimePicker(
    label: String,
    onDateTimeSelected: (String) -> Unit
) {
    DateTimePickerField(label = label, onDateTimeSelected = onDateTimeSelected)
}

title: WhoopApiService.kt
text:
// FILE: app/src/main/java/com/migraineme/WhoopApiService.kt
package com.migraineme

import android.content.Context
import android.util.Log
import org.json.JSONArray
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.net.URLEncoder
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.TimeZone

/**
 * WHOOP Developer API client (v2).
 *
 * Uses ISO-8601 start/end (UTC) and pagination (next_token), merging into {"records":[...]}.
 * Auth mode/storage unchanged: always uses WhoopAuthService().refreshIfNeeded(context) to obtain a valid WhoopToken.
 */
class WhoopApiService(private val context: Context) {

    private val base = "https://api.prod.whoop.com/developer/v2"
    private val logTag = "WHOOP"

    data class HttpResult(val json: JSONObject?, val httpCode: Int, val errorSummary: String?)

    /**
     * Worker helper: Sleep records for a time window.
     */
    suspend fun getSleep(startDate: Date, endDate: Date): JSONObject? =
        getSleepWithCode(startDate, endDate).json

    /**
     * Same as getSleep() but returns HTTP code + short error snippet for logging/debugging.
     */
    suspend fun getSleepWithCode(startDate: Date, endDate: Date): HttpResult =
        fetchPagedWithCode("/activity/sleep", startDate, endDate)

    /**
     * Worker helper: Recovery records for a time window.
     */
    suspend fun getRecovery(startDate: Date, endDate: Date): JSONObject? =
        fetchPagedWithCode("/recovery", startDate, endDate).json

    /**
     * Worker helper: Workout records for a time window.
     */
    suspend fun getWorkouts(startDate: Date, endDate: Date): JSONObject? =
        fetchPagedWithCode("/activity/workout", startDate, endDate).json

    /**
     * Returns a valid WHOOP token (refreshing if needed). Null => not connected / cannot refresh.
     * This keeps the auth approach we standardized elsewhere.
     */
    private suspend fun token(): WhoopToken? {
        return WhoopAuthService().refreshIfNeeded(context)
    }

    /** Merge all pages into {"records":[...]} and return HTTP code and small error snippet if non-2xx. */
    private suspend fun fetchPagedWithCode(path: String, start: Date, end: Date): HttpResult {
        val tok = token() ?: run {
            Log.w(logTag, "GET $path -> no WHOOP token (not connected)")
            return HttpResult(null, 0, "no token")
        }

        // Your working format: ISO-8601 UTC strings (NOT epoch millis)
        val iso = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US).apply {
            timeZone = TimeZone.getTimeZone("UTC")
        }
        val startIso = iso.format(start)
        val endIso = iso.format(end)

        val all = JSONArray()
        var nextToken: String? = null
        var page = 0
        var lastHttp = 200
        var lastErr: String? = null

        do {
            val qs = buildString {
                append("start=").append(URLEncoder.encode(startIso, "UTF-8"))
                append("&end=").append(URLEncoder.encode(endIso, "UTF-8"))
                append("&limit=25")
                if (!nextToken.isNullOrBlank()) {
                    // keep your request param name
                    append("&nextToken=").append(URLEncoder.encode(nextToken!!, "UTF-8"))
                }
            }

            val fullUrl = "$base$path?$qs"
            val conn = (URL(fullUrl).openConnection() as HttpURLConnection).apply {
                requestMethod = "GET"
                setRequestProperty("Authorization", "${tok.tokenType} ${tok.accessToken}")
                setRequestProperty("Accept", "application/json")
                setRequestProperty("User-Agent", "MigraineMe/1.0 (Android)")
                connectTimeout = 15000
                readTimeout = 30000
            }

            val code = try {
                conn.responseCode
            } catch (t: Throwable) {
                Log.e(logTag, "HTTP open $path failed: ${t.message} url=$fullUrl", t)
                runCatching { conn.disconnect() }
                return HttpResult(null, 0, "network: ${t.message}")
            }

            lastHttp = code

            if (code == HttpURLConnection.HTTP_NO_CONTENT) {
                Log.d(logTag, "GET $path page=$page -> 204 No Content url=$fullUrl")
                runCatching { conn.disconnect() }
                break
            }

            val body = try {
                val stream = if (code in 200..299) conn.inputStream else conn.errorStream
                stream?.use { s ->
                    BufferedReader(InputStreamReader(s)).readText()
                }
            } catch (t: Throwable) {
                Log.e(logTag, "HTTP read $path failed: ${t.message} url=$fullUrl", t)
                null
            } finally {
                runCatching { conn.disconnect() }
            }

            if (code !in 200..299) {
                val snippet = body?.take(400).orEmpty()
                Log.w(logTag, "GET $path -> HTTP $code bodyLen=${body?.length ?: 0} url=$fullUrl")
                lastErr = "code=$code ${snippet.take(120)}".trim()
                // Stop immediately on non-2xx so workers surface the reason (401/403/etc)
                return HttpResult(null, code, snippet.take(120))
            }

            if (body.isNullOrBlank()) {
                Log.w(logTag, "GET $path -> 2xx empty body (page=$page) url=$fullUrl")
                break
            }

            val obj = try {
                JSONObject(body)
            } catch (t: Throwable) {
                Log.e(logTag, "JSON parse $path failed: ${t.message}. body=${body.take(200)} url=$fullUrl")
                return HttpResult(null, 0, "json:${t.message}")
            }

            val records = obj.optJSONArray("records") ?: JSONArray()
            for (i in 0 until records.length()) all.put(records.get(i))

            // Your working response field name
            val raw = obj.optString("next_token")
            nextToken = raw.takeIf { it.isNotBlank() && !it.equals("null", ignoreCase = true) }

            Log.d(
                logTag,
                "GET $path page=$page -> ${records.length()} recs, nextToken=${if (nextToken == null) "none" else "present"}"
            )
            page++
        } while (!nextToken.isNullOrBlank())

        return HttpResult(JSONObject().put("records", all), lastHttp, lastErr)
    }
}

title: WhoopAuthService.kt
text:
package com.migraineme

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.util.Base64
import android.util.Log
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.HttpURLConnection
import java.net.URL
import java.net.URLEncoder
import java.security.MessageDigest
import java.security.SecureRandom
import kotlin.math.max

/**
 * WHOOP OAuth + token refresh.
 *
 * IMPORTANT: This class intentionally keeps compatibility methods used by your app:
 *  - startAuth(activity)
 *  - completeAuth(context): Boolean
 *  - refresh(context): Boolean
 */
class WhoopAuthService {

    companion object {
        private const val TAG = "WHOOP"

        // Must match WHOOP dashboard
        private const val CLIENT_ID = "354e4d44-3780-4e99-a655-a306776879ee"

        // Client secret (required by WHOOP token endpoint for confidential clients)
        private const val CLIENT_SECRET =
            "ce7314f4cdfab97a16467747a174a0ba8f1a8c561bc1dcc149674171ccd85d00"

        // Must match:
        //  - AndroidManifest intent-filter for migraineme://whoop/callback
        //  - WHOOP app registered redirect
        private const val REDIRECT_URI = "migraineme://whoop/callback"

        private const val AUTH_URL = "https://api.prod.whoop.com/oauth/oauth2/auth"
        private const val TOKEN_URL = "https://api.prod.whoop.com/oauth/oauth2/token"

        private const val PREFS = "whoop_oauth"
        private const val KEY_STATE = "state"
        private const val KEY_VERIFIER = "code_verifier"
        private const val KEY_LAST_URI = "last_uri"
        private const val KEY_TOKEN_ERROR = "token_error"

        private const val EXPIRY_SKEW_MS = 60_000L

        private const val SCOPE =
            "read:recovery read:sleep read:workout read:cycles read:body_measurement"
    }

    /**
     * Compatibility: called by ThirdPartyConnectionsScreen.
     * Launches browser.
     */
    fun startAuth(activity: Activity) {
        val uri = buildAuthUri(activity.applicationContext)
        val intent = Intent(Intent.ACTION_VIEW, uri).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        activity.startActivity(intent)
    }

    /**
     * Builds auth Uri and stores PKCE + state.
     */
    fun buildAuthUri(context: Context): Uri {
        val appCtx = context.applicationContext
        val prefs = appCtx.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

        val state = randomUrlSafe(24)
        val verifier = randomUrlSafe(64)
        val challenge = pkceChallengeS256(verifier)

        prefs.edit()
            .putString(KEY_STATE, state)
            .putString(KEY_VERIFIER, verifier)
            .putString(KEY_TOKEN_ERROR, "")
            .apply()

        return Uri.parse(AUTH_URL).buildUpon()
            .appendQueryParameter("response_type", "code")
            .appendQueryParameter("client_id", CLIENT_ID)
            .appendQueryParameter("redirect_uri", REDIRECT_URI)
            .appendQueryParameter("scope", SCOPE)
            .appendQueryParameter("state", state)
            .appendQueryParameter("code_challenge", challenge)
            .appendQueryParameter("code_challenge_method", "S256")
            .build()
    }

    /**
     * Compatibility: called by ThirdPartyConnectionsScreen.
     *
     * Reads stored callback uri from prefs ("whoop_oauth" / "last_uri"),
     * validates state + verifier, exchanges code for token, saves token.
     *
     * Returns true if token saved.
     */
    fun completeAuth(context: Context): Boolean {
        val appCtx = context.applicationContext
        val prefs = appCtx.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

        val last = prefs.getString(KEY_LAST_URI, null)
        if (last.isNullOrBlank()) return false

        val uri = Uri.parse(last)

        val error = uri.getQueryParameter("error")
        if (!error.isNullOrBlank()) {
            prefs.edit().putString(KEY_TOKEN_ERROR, error).apply()
            return false
        }

        val code = uri.getQueryParameter("code")
        if (code.isNullOrBlank()) {
            prefs.edit().putString(KEY_TOKEN_ERROR, "Missing authorization code").apply()
            return false
        }

        val returnedState = uri.getQueryParameter("state").orEmpty()
        val expectedState = prefs.getString(KEY_STATE, "").orEmpty()
        val verifier = prefs.getString(KEY_VERIFIER, "").orEmpty()

        if (expectedState.isBlank() || verifier.isBlank()) {
            prefs.edit().putString(KEY_TOKEN_ERROR, "Missing PKCE state/verifier. Reconnect WHOOP.").apply()
            return false
        }
        if (returnedState != expectedState) {
            prefs.edit().putString(KEY_TOKEN_ERROR, "State mismatch. Reconnect WHOOP.").apply()
            return false
        }

        // IMPORTANT FIX:
        // WHOOP token endpoint is rejecting requests without client authentication.
        // Include client_secret (client_secret_post) for both code exchange and refresh flows.
        val res = postForm(
            TOKEN_URL,
            mapOf(
                "grant_type" to "authorization_code",
                "client_id" to CLIENT_ID,
                "client_secret" to CLIENT_SECRET,
                "redirect_uri" to REDIRECT_URI,
                "code" to code,
                "code_verifier" to verifier
            )
        )

        return if (res.isSuccess) {
            val tok = res.getOrThrow()

            // CRITICAL: WhoopTokenStore binds tokens to SessionStore.userId.
            // Ensure userId is persisted before saving, derived from the already-stored Supabase access token.
            val currentUserId = SessionStore.readUserId(appCtx)
            if (currentUserId.isNullOrBlank()) {
                val access = SessionStore.readAccessToken(appCtx)
                if (!access.isNullOrBlank()) {
                    val derived = JwtUtils.extractUserIdFromAccessToken(access)
                    if (!derived.isNullOrBlank()) {
                        SessionStore.saveUserId(appCtx, derived)
                    }
                }
            }

            WhoopTokenStore(appCtx).save(tok)

            // Clear one-time oauth data + last_uri
            prefs.edit()
                .remove(KEY_STATE)
                .remove(KEY_VERIFIER)
                .remove(KEY_LAST_URI)
                .putString(KEY_TOKEN_ERROR, "")
                .apply()

            // GUARANTEE EVENTUAL SUPABASE UPLOAD + BACKFILL ENQUEUE:
            // This schedules a WorkManager job that retries until:
            //  - upsert-whoop-token succeeds, then
            //  - enqueue-login-backfill succeeds.
            WhoopTokenUploadWorker.enqueueNow(appCtx)

            true
        } else {
            prefs.edit().putString(KEY_TOKEN_ERROR, res.exceptionOrNull()?.message ?: "WHOOP authentication failed").apply()
            false
        }
    }

    /**
     * Compatibility: called by MetricsSyncManager.
     * Best-effort refresh of WHOOP token if expired soon.
     * Returns true if token is valid after this call.
     */
    fun refresh(context: Context): Boolean {
        val appCtx = context.applicationContext
        val store = WhoopTokenStore(appCtx)
        val current = store.load() ?: return false

        if (!current.isExpiredSoon(EXPIRY_SKEW_MS)) return true
        if (current.refreshToken.isBlank()) return false

        val res = postForm(
            TOKEN_URL,
            mapOf(
                "grant_type" to "refresh_token",
                "client_id" to CLIENT_ID,
                "client_secret" to CLIENT_SECRET,
                "refresh_token" to current.refreshToken
            )
        )

        return if (res.isSuccess) {
            store.save(res.getOrThrow())
            true
        } else {
            Log.w(TAG, "refresh failed: ${res.exceptionOrNull()?.message}")
            false
        }
    }

    /**
     * Preferred: workers should use this to get a valid access token.
     */
    fun getValidAccessToken(context: Context): String? {
        val appCtx = context.applicationContext
        val store = WhoopTokenStore(appCtx)
        val tok = store.load() ?: return null

        return if (!tok.isExpiredSoon(EXPIRY_SKEW_MS)) {
            tok.accessToken
        } else {
            val ok = refresh(appCtx)
            store.load()?.accessToken?.takeIf { ok }
        }
    }

    /**
     * REQUIRED by WhoopApiService.
     * Returns the full token (refreshing if needed), or null if not connected / cannot refresh.
     *
     * Marked suspend so coroutine workers can call it cleanly; implementation uses the existing
     * synchronous refresh() logic.
     */
    suspend fun refreshIfNeeded(context: Context): WhoopToken? {
        val appCtx = context.applicationContext
        val store = WhoopTokenStore(appCtx)
        val tok = store.load() ?: return null

        return if (!tok.isExpiredSoon(EXPIRY_SKEW_MS)) {
            tok
        } else {
            val ok = refresh(appCtx)
            store.load()?.takeIf { ok }
        }
    }

    // -------------------------
    // HTTP (no ktor)
    // -------------------------

    private fun postForm(url: String, form: Map<String, String>): Result<WhoopToken> {
        val body = form.entries.joinToString("&") { (k, v) ->
            "${URLEncoder.encode(k, "UTF-8")}=${URLEncoder.encode(v, "UTF-8")}"
        }

        val conn = (URL(url).openConnection() as HttpURLConnection).apply {
            requestMethod = "POST"
            doOutput = true
            setRequestProperty("Content-Type", "application/x-www-form-urlencoded")
            setRequestProperty("Accept", "application/json")
        }

        return try {
            conn.outputStream.use { os ->
                os.write(body.toByteArray(Charsets.UTF_8))
            }

            val code = conn.responseCode
            val stream = if (code in 200..299) conn.inputStream else conn.errorStream
            val text = stream?.use { s ->
                BufferedReader(InputStreamReader(s)).readText()
            }.orEmpty()

            if (code !in 200..299) {
                Log.e(TAG, "token endpoint error $code: $text")
                val msg = runCatching {
                    val jo = JSONObject(text)
                    val err = jo.optString("error")
                    val desc = jo.optString("error_description")
                    if (err.isNotBlank()) "$err: $desc" else text
                }.getOrDefault(text)
                Result.failure(IllegalStateException(msg))
            } else {
                val jo = JSONObject(text)
                Result.success(WhoopToken.fromTokenResponse(jo))
            }
        } catch (t: Throwable) {
            Result.failure(t)
        } finally {
            runCatching { conn.disconnect() }
        }
    }

    // -------------------------
    // PKCE helpers
    // -------------------------

    private fun pkceChallengeS256(verifier: String): String {
        val md = MessageDigest.getInstance("SHA-256")
        val digest = md.digest(verifier.toByteArray(Charsets.UTF_8))
        return Base64.encodeToString(digest, Base64.URL_SAFE or Base64.NO_WRAP or Base64.NO_PADDING)
    }

    private fun randomUrlSafe(lenBytes: Int): String {
        val b = ByteArray(max(16, lenBytes))
        SecureRandom().nextBytes(b)
        return Base64.encodeToString(b, Base64.URL_SAFE or Base64.NO_WRAP or Base64.NO_PADDING)
            .take(lenBytes * 2)
    }
}

/**
 * Canonical WHOOP token model.
 */
data class WhoopToken(
    val accessToken: String,
    val refreshToken: String,
    val tokenType: String = "Bearer",
    val expiresAtMillis: Long = 0L
) {
    fun isExpiredSoon(skewMs: Long = 60_000L): Boolean {
        if (expiresAtMillis <= 0L) return false
        return System.currentTimeMillis() + skewMs >= expiresAtMillis
    }

    companion object {
        fun fromTokenResponse(jo: JSONObject): WhoopToken {
            val access = jo.optString("access_token", "")
            val refresh = jo.optString("refresh_token", "")
            val type = jo.optString("token_type", "Bearer")

            val expiresInSec = jo.optLong("expires_in", 0L)
            val expiresAt = if (expiresInSec > 0L) {
                System.currentTimeMillis() + expiresInSec * 1000L
            } else 0L

            return WhoopToken(
                accessToken = access,
                refreshToken = refresh,
                tokenType = type,
                expiresAtMillis = expiresAt
            )
        }
    }
}

title: WhoopDailyPhysicalHealthWorker.kt
text:
// FILE: app/src/main/java/com/migraineme/WhoopDailyPhysicalHealthWorker.kt
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.time.Duration
import java.time.LocalDate
import java.time.ZoneId
import java.time.ZonedDateTime
import java.util.Date
import java.util.concurrent.TimeUnit

/**
 * DAILY WHOOP physical health sync.
 *
 * Writes (if enabled):
 * - recovery_score_daily
 * - resting_hr_daily
 * - hrv_daily
 * - skin_temp_daily
 * - spo2_daily
 * - time_in_high_hr_zones_daily
 *
 * Notes:
 * - Uses Supabase session access token from SessionStore.
 * - Skips if WHOOP not connected.
 * - Schedules itself for next 09:00 local time.
 */
class WhoopDailyPhysicalHealthWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        val ctx = applicationContext
        try {
            val access = SessionStore.getValidAccessToken(ctx)
                ?: run {
                    debug("No Supabase session — skip")
                    return@withContext Result.success()
                }

            val hasWhoop = WhoopTokenStore(ctx).load() != null
            if (!hasWhoop) {
                debug("WHOOP not connected — skip")
                return@withContext Result.success()
            }

            val zone = ZoneId.systemDefault()
            val today = LocalDate.now(zone)
            val todaySql = today.toString()

            // Backfill up to TODAY (includes today)
            backfillUpToToday(ctx, access)

            val metrics = SupabasePhysicalHealthService(ctx)

            // If already written by backfill, stop.
            // Use recovery_score_daily as the anchor "already synced" signal.
            if (metrics.hasRecoveryForDate(access, todaySql, "whoop")) {
                debug("Skip today $todaySql — already stored (via backfill)")
                return@withContext Result.success()
            }

            // Last attempt: refresh WHOOP token if needed
            WhoopAuthService().refresh(ctx)

            val (wStart, wEnd) = dayWindow(today, zone)
            val api = WhoopApiService(ctx)

            val recoveryRoot = api.getRecovery(wStart, wEnd)
            val workoutsRoot = api.getWorkouts(wStart, wEnd)

            if (recoveryRoot == null) {
                debug("Null WHOOP recovery response for $today")
                return@withContext Result.success()
            }

            val rec = selectFirstRecord(recoveryRoot)
            if (rec == null) {
                debug("No recovery record for $today")
                return@withContext Result.success()
            }

            writeAllForDate(ctx, metrics, access, todaySql, rec)
            writeHighHrZonesIfEnabled(ctx, metrics, access, todaySql, workoutsRoot)

            debug("Stored WHOOP physical health for $todaySql")
            Result.success()

        } catch (t: Throwable) {
            debug("Error: ${t.message}")
            Result.success()
        } finally {
            // Keep the 09:00 chain alive even on early-return paths.
            scheduleNext(ctx)
        }
    }

    private fun debug(msg: String) = Log.d("WhoopPhysicalSync", msg)

    companion object {
        // CHANGED:
        // Separate unique names so "run now" does not get replaced by the scheduled 09:00 chain.
        // Matches the pattern used by WhoopDailySyncWorkerSleepFields.
        private const val UNIQUE_RUN_NOW = "whoop_daily_physical_health_run_now"
        private const val UNIQUE_9AM = "whoop_daily_physical_health_9am"

        fun scheduleNext(context: Context) {
            val now = ZonedDateTime.now(ZoneId.systemDefault())
            var next = now.withHour(9).withMinute(0).withSecond(0).withNano(0)
            if (!next.isAfter(now)) next = next.plusDays(1)
            val delay = Duration.between(now, next).toMillis()

            val req = OneTimeWorkRequestBuilder<WhoopDailyPhysicalHealthWorker>()
                .setInitialDelay(delay, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_9AM,
                ExistingWorkPolicy.REPLACE,
                req
            )
        }

        fun runOnceNow(context: Context) {
            val req = OneTimeWorkRequestBuilder<WhoopDailyPhysicalHealthWorker>()
                .setInitialDelay(0, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_RUN_NOW,
                ExistingWorkPolicy.REPLACE,
                req
            )
        }

        suspend fun backfillUpToToday(context: Context, access: String) {
            try {
                val zone = ZoneId.systemDefault()
                val today = LocalDate.now(zone)
                WhoopTokenStore(context).load() ?: return

                val metrics = SupabasePhysicalHealthService(context)
                val latestStr = metrics.latestPhysicalDate(access, "whoop")

                val baseline = today.minusDays(29)

                val start = when (latestStr) {
                    null -> baseline
                    else -> {
                        val latest = LocalDate.parse(latestStr)
                        val candidate = latest.plusDays(1)
                        if (candidate.isBefore(baseline)) baseline else candidate
                    }
                }

                if (start.isAfter(today)) return

                WhoopAuthService().refresh(context)
                val api = WhoopApiService(context)

                var cur = start
                while (!cur.isAfter(today)) {
                    val dateSql = cur.toString()

                    // Use recovery_score_daily as the anchor "already synced" signal.
                    if (!metrics.hasRecoveryForDate(access, dateSql, "whoop")) {
                        val (wStart, wEnd) = dayWindow(cur, zone)
                        val recoveryRoot = api.getRecovery(wStart, wEnd)
                        val workoutsRoot = api.getWorkouts(wStart, wEnd)

                        if (recoveryRoot != null) {
                            val rec = selectFirstRecord(recoveryRoot)
                            if (rec != null) {
                                writeAllForDate(context, metrics, access, dateSql, rec)
                                writeHighHrZonesIfEnabled(context, metrics, access, dateSql, workoutsRoot)
                                Log.d("WhoopPhysicalSync", "Backfill wrote $dateSql")
                            } else {
                                Log.d("WhoopPhysicalSync", "Backfill: no recovery record for $cur")
                            }
                        } else {
                            Log.d("WhoopPhysicalSync", "Backfill: null WHOOP recovery response for $cur")
                        }
                    }

                    cur = cur.plusDays(1)
                }
            } catch (_: Throwable) {
            }
        }

        /** Window from previous 12:00 → next day 12:00. */
        private fun dayWindow(day: LocalDate, zone: ZoneId): Pair<Date, Date> {
            val s = day.minusDays(1).atTime(12, 0).atZone(zone).toInstant()
            val e = day.plusDays(1).atTime(12, 0).atZone(zone).toInstant()
            return Date.from(s) to Date.from(e)
        }

        private fun selectFirstRecord(root: JSONObject): JSONObject? {
            val arrays = arrayOf("records", "data", "items")
            for (k in arrays) {
                val arr = root.optJSONArray(k) ?: continue
                if (arr.length() > 0) return arr.optJSONObject(0)
            }
            return null
        }

        private suspend fun writeAllForDate(
            context: Context,
            metrics: SupabasePhysicalHealthService,
            access: String,
            dateSql: String,
            rec: JSONObject
        ) {
            val sourceId = rec.optString("id").takeIf { it.isNotEmpty() }

            val score = rec.optJSONObject("score")

            val recoveryPct = (score?.optDouble("recovery_score", Double.NaN) ?: Double.NaN)
            val restingHr = (score?.optDouble("resting_heart_rate", Double.NaN) ?: Double.NaN)
            val hrv = (score?.optDouble("hrv_rmssd_milli", Double.NaN) ?: Double.NaN)
            val temp = (score?.optDouble("skin_temp_celsius", Double.NaN) ?: Double.NaN)
            val spo2 = (score?.optDouble("spo2_percentage", Double.NaN) ?: Double.NaN)

            if (DataCollectionSettings.isEnabledForWhoop(context, "recovery_score_daily")) {
                if (!recoveryPct.isNaN()) {
                    metrics.upsertRecoveryScoreDaily(access, dateSql, recoveryPct, "whoop", sourceId)
                }
            }

            if (DataCollectionSettings.isEnabledForWhoop(context, "resting_hr_daily")) {
                if (!restingHr.isNaN()) {
                    metrics.upsertRestingHrDaily(access, dateSql, restingHr, "whoop", sourceId)
                }
            }

            if (DataCollectionSettings.isEnabledForWhoop(context, "hrv_daily")) {
                if (!hrv.isNaN()) {
                    metrics.upsertHrvDaily(access, dateSql, hrv, "whoop", sourceId)
                }
            }

            if (DataCollectionSettings.isEnabledForWhoop(context, "skin_temp_daily")) {
                if (!temp.isNaN()) {
                    metrics.upsertSkinTempDaily(access, dateSql, temp, "whoop", sourceId)
                }
            }

            if (DataCollectionSettings.isEnabledForWhoop(context, "spo2_daily")) {
                if (!spo2.isNaN()) {
                    metrics.upsertSpo2Daily(access, dateSql, spo2, "whoop", sourceId)
                }
            }
        }

        private suspend fun writeHighHrZonesIfEnabled(
            context: Context,
            metrics: SupabasePhysicalHealthService,
            access: String,
            dateSql: String,
            workoutsRoot: JSONObject?
        ) {
            if (!DataCollectionSettings.isEnabledForWhoop(context, "time_in_high_hr_zones_daily")) return
            if (workoutsRoot == null) return

            val records = workoutsRoot.optJSONArray("records") ?: return
            if (records.length() == 0) return

            var z3ms = 0L
            var z4ms = 0L
            var z5ms = 0L
            var z6ms = 0L

            for (i in 0 until records.length()) {
                val wrk = records.optJSONObject(i) ?: continue
                val score = wrk.optJSONObject("score") ?: continue
                val zones = score.optJSONObject("heart_rate_zone_duration") ?: continue

                z3ms += zones.optLong("zone_three_milli", 0L)
                z4ms += zones.optLong("zone_four_milli", 0L)
                z5ms += zones.optLong("zone_five_milli", 0L)
                z6ms += zones.optLong("zone_six_milli", 0L)
            }

            val z3 = z3ms / 60_000.0
            val z4 = z4ms / 60_000.0
            val z5 = z5ms / 60_000.0
            val z6 = z6ms / 60_000.0
            val total = z3 + z4 + z5 + z6

            val sourceId = records.optJSONObject(0)?.optString("id")?.takeIf { it.isNotEmpty() }

            metrics.upsertHighHrDaily(
                access = access,
                date = dateSql,
                totalMinutes = total,
                z3 = z3,
                z4 = z4,
                z5 = z5,
                z6 = z6,
                source = "whoop",
                sourceId = sourceId
            )
        }
    }
}

title: WhoopDailySyncWorkerSleepFields.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.time.*
import java.util.Date
import java.util.concurrent.TimeUnit

/**
 * FINAL VERSION — TARGET DATE = WAKE-UP DAY
 *
 * Rules:
 * - A sleep belongs to the LocalDate of its WAKE-UP timestamp.
 * - backfillUpToToday includes TODAY.
 * - Today is written inside backfillUpToToday().
 * - doWork() will skip today afterwards if already written.
 */
class WhoopDailySyncWorkerSleepFields(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        val ctx = applicationContext
        try {
            val access = SessionStore.getValidAccessToken(ctx)
                ?: run {
                    debug("No Supabase session — skip")
                    return@withContext Result.success()
                }

            val hasWhoop = WhoopTokenStore(ctx).load() != null
            if (!hasWhoop) {
                debug("WHOOP not connected — skip")
                return@withContext Result.success()
            }

            val zone = ZoneId.systemDefault()
            val today = LocalDate.now(zone)
            val todaySql = today.toString()

            // Backfill up to TODAY (includes today)
            backfillUpToToday(ctx, access)

            val metrics = SupabaseMetricsService(ctx)

            // If already written by backfill, stop.
            if (metrics.hasSleepForDate(access, todaySql, "whoop")) {
                debug("Skip today $todaySql — already stored (via backfill)")
                return@withContext Result.success()
            }

            // Last attempt
            WhoopAuthService().refresh(ctx)

            val (wStart, wEnd) = dayWindow(today, zone)
            val api = WhoopApiService(ctx)
            val root = api.getSleep(wStart, wEnd)

            if (root == null) {
                debug("Null WHOOP response for $today")
                return@withContext Result.success()
            }

            val record = selectRecordByWakeup(root, today, zone)
            if (record == null) {
                debug("No record waking on $today")
                return@withContext Result.success()
            }

            writeAllForDate(ctx, metrics, access, todaySql, record)

            debug("Stored WHOOP sleep for $todaySql (fallback path)")
            Result.success()

        } catch (t: Throwable) {
            debug("Error: ${t.message}")
            Result.success()
        } finally {
            // Keep the 09:00 chain alive
            scheduleNext(ctx)
        }
    }

    private fun debug(msg: String) = Log.d("WhoopDailySync", msg)

    companion object {
        private const val UNIQUE_RUN_NOW = "whoop_daily_sync_sleep_fields_run_now"
        private const val UNIQUE_9AM = "whoop_daily_sync_sleep_fields_9am"

        fun scheduleNext(context: Context) {
            val now = ZonedDateTime.now(ZoneId.systemDefault())
            var next = now.withHour(17).withMinute(35).withSecond(0).withNano(0)
            if (!next.isAfter(now)) next = next.plusDays(1)
            val delay = Duration.between(now, next).toMillis()

            val req = OneTimeWorkRequestBuilder<WhoopDailySyncWorkerSleepFields>()
                .setInitialDelay(delay, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_9AM,
                ExistingWorkPolicy.REPLACE,
                req
            )
        }

        fun runOnceNow(context: Context) {
            val req = OneTimeWorkRequestBuilder<WhoopDailySyncWorkerSleepFields>()
                .setInitialDelay(0, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE_RUN_NOW,
                ExistingWorkPolicy.REPLACE,
                req
            )
        }

        suspend fun backfillUpToToday(context: Context, access: String) {
            try {
                val zone = ZoneId.systemDefault()
                val today = LocalDate.now(zone)
                WhoopTokenStore(context).load() ?: return

                val metrics = SupabaseMetricsService(context)
                val latestStr = metrics.latestSleepDate(access, "whoop")

                val baseline = today.minusDays(29)

                val start = when (latestStr) {
                    null -> baseline
                    else -> {
                        val latest = LocalDate.parse(latestStr)
                        val candidate = latest.plusDays(1)
                        if (candidate.isBefore(baseline)) baseline else candidate
                    }
                }

                if (start.isAfter(today)) return

                WhoopAuthService().refresh(context)
                val api = WhoopApiService(context)

                var cur = start
                while (!cur.isAfter(today)) {
                    val dateSql = cur.toString()

                    if (!metrics.hasSleepForDate(access, dateSql, "whoop")) {
                        val (wStart, wEnd) = dayWindow(cur, zone)
                        val root = api.getSleep(wStart, wEnd)

                        if (root != null) {
                            val rec = selectRecordByWakeup(root, cur, zone)
                            if (rec != null) {
                                writeAllForDate(context, metrics, access, dateSql, rec)
                                Log.d("WhoopDailySync", "Backfill wrote $dateSql")
                            }
                        }
                    }

                    cur = cur.plusDays(1)
                }
            } catch (_: Throwable) {}
        }

        private fun dayWindow(day: LocalDate, zone: ZoneId): Pair<Date, Date> {
            val s = day.minusDays(1).atTime(12, 0).atZone(zone).toInstant()
            val e = day.plusDays(1).atTime(12, 0).atZone(zone).toInstant()
            return Date.from(s) to Date.from(e)
        }

        private fun selectRecordByWakeup(
            root: JSONObject,
            target: LocalDate,
            zone: ZoneId
        ): JSONObject? {
            var bestExact: JSONObject? = null
            var latestEnd: JSONObject? = null
            var latestEndInstant: Instant? = null

            fun inspect(obj: JSONObject?) {
                if (obj == null) return
                val endUtc = obj.optString("end").takeIf { it.isNotEmpty() } ?: return
                val tzMin = tzMinutes(obj)

                val endLocal = runCatching {
                    Instant.parse(endUtc).plusSeconds(tzMin * 60L)
                }.getOrNull() ?: return

                val endDateLocal = endLocal.atZone(zone).toLocalDate()

                if (endDateLocal == target) bestExact = obj
                if (latestEndInstant == null || endLocal.isAfter(latestEndInstant)) {
                    latestEndInstant = endLocal
                    latestEnd = obj
                }
            }

            val arrays = arrayOf("records", "data", "items")
            for (k in arrays) {
                val arr = root.optJSONArray(k) ?: continue
                for (i in 0 until arr.length()) inspect(arr.optJSONObject(i))
            }

            if (bestExact != null) return bestExact
            if (latestEnd != null) return latestEnd
            if (root.has("end")) {
                inspect(root)
                return bestExact ?: latestEnd
            }
            return null
        }

        private suspend fun writeAllForDate(
            context: Context,
            metrics: SupabaseMetricsService,
            access: String,
            dateSql: String,
            rec: JSONObject
        ) {
            val sourceId = rec.optString("id").takeIf { it.isNotEmpty() }

            val score = rec.optJSONObject("score")
            val stage = score?.optJSONObject("stage_summary")

            val light = stage?.optLong("total_light_sleep_time_milli", 0L) ?: 0L
            val sws = stage?.optLong("total_slow_wave_sleep_time_milli", 0L) ?: 0L
            val rem = stage?.optLong("total_rem_sleep_time_milli", 0L) ?: 0L
            val durationMs = score?.optLong("sleep_duration_milli", 0L) ?: 0L

            val hours = (if (durationMs > 0) durationMs else light + sws + rem) / 3_600_000.0
            val dist = stage?.optInt("disturbance_count", 0) ?: 0

            val perf = score?.optDouble("sleep_performance_percentage", Double.NaN) ?: Double.NaN
            val eff = score?.optDouble("sleep_efficiency_percentage", Double.NaN) ?: Double.NaN

            val fellIso = parseTimestamp(rec, "start")
            val wokeIso = parseTimestamp(rec, "end")

            if (DataCollectionSettings.isEnabledForWhoop(context, "sleep_duration_daily")) {
                metrics.upsertSleepDurationDaily(access, dateSql, hours, "whoop", sourceId)
            }
            if (DataCollectionSettings.isEnabledForWhoop(context, "fell_asleep_time_daily")) {
                fellIso?.let { metrics.upsertFellAsleepTimeDaily(access, dateSql, it, "whoop", sourceId) }
            }
            if (DataCollectionSettings.isEnabledForWhoop(context, "woke_up_time_daily")) {
                wokeIso?.let { metrics.upsertWokeUpTimeDaily(access, dateSql, it, "whoop", sourceId) }
            }
            if (DataCollectionSettings.isEnabledForWhoop(context, "sleep_disturbances_daily")) {
                metrics.upsertSleepDisturbancesDaily(access, dateSql, dist, "whoop", sourceId)
            }
            if (DataCollectionSettings.isEnabledForWhoop(context, "sleep_stages_daily")) {
                metrics.upsertSleepStagesDaily(access, dateSql, sws, rem, light, "whoop", sourceId)
            }

            if (DataCollectionSettings.isEnabledForWhoop(context, "sleep_score_daily") && !perf.isNaN()) {
                metrics.upsertSleepScoreDaily(access, dateSql, perf, "whoop", sourceId)
            }

            if (DataCollectionSettings.isEnabledForWhoop(context, "sleep_efficiency_daily") && !eff.isNaN()) {
                metrics.upsertSleepEfficiencyDaily(access, dateSql, eff, "whoop", sourceId)
            }
        }

        private fun parseTimestamp(rec: JSONObject, key: String): String? {
            val utc = rec.optString(key).takeIf { it.isNotEmpty() } ?: return null
            val tzMin = tzMinutes(rec)
            return runCatching {
                val inst = Instant.parse(utc).plusSeconds(tzMin * 60L)
                OffsetDateTime.ofInstant(inst, ZoneOffset.UTC).toString()
            }.getOrNull()
        }

        private fun tzMinutes(rec: JSONObject): Long {
            return when {
                rec.has("timezone_offset_minutes") ->
                    rec.optLong("timezone_offset_minutes", 0L)
                rec.has("timezone_offset") ->
                    rec.optLong("timezone_offset", 0L) / 60L
                else -> 0L
            }
        }
    }
}

title: WhoopLateDataReminderWorker.kt
text:
package com.migraineme

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.ZonedDateTime
import java.util.concurrent.TimeUnit

/**
 * Single daily "late cutoff" reminder:
 * - Runs at 11:00 local time
 * - Checks whether today's WHOOP sleep + recovery exist in Supabase
 * - If still missing, posts ONE notification (no repeats)
 *
 * This worker does NOT call WHOOP. It only checks Supabase (cheap).
 */
class WhoopLateDataReminderWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        val ctx = applicationContext
        try {
            val access = SessionStore.getValidAccessToken(ctx) ?: return Result.success()

            val whoopConnected = runCatching { WhoopTokenStore(ctx).load() != null }.getOrDefault(false)
            if (!whoopConnected) return Result.success()

            val zone = ZoneId.systemDefault()
            val todaySql = LocalDate.now(zone).toString()

            val sleepLoaded = runCatching { SupabaseMetricsService(ctx).hasSleepForDate(access, todaySql, "whoop") }
                .getOrDefault(false)

            val recoveryLoaded = runCatching { SupabasePhysicalHealthService(ctx).hasRecoveryForDate(access, todaySql, "whoop") }
                .getOrDefault(false)

            if (!(sleepLoaded && recoveryLoaded)) {
                postNotification(ctx)
            }

            return Result.success()
        } finally {
            // Always schedule the next run, even if today failed.
            scheduleNext(ctx)
        }
    }

    private fun postNotification(context: Context) {
        val channelId = CHANNEL_ID

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            val ch = NotificationChannel(
                channelId,
                "MigraineMe data reminders",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            nm.createNotificationChannel(ch)
        }

        val notif = NotificationCompat.Builder(context, channelId)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentTitle("Whoop data still missing")
            .setContentText("We haven’t received today’s Whoop data yet. Open MigraineMe to retry.")
            .setAutoCancel(true)
            .build()

        NotificationManagerCompat.from(context).notify(NOTIF_ID, notif)
    }

    companion object {
        private const val UNIQUE = "whoop_late_data_reminder_11am"
        private const val CHANNEL_ID = "migraineme_data_reminders"
        private const val NOTIF_ID = 91011

        fun scheduleNext(context: Context) {
            val zone = ZoneId.systemDefault()
            val now = ZonedDateTime.now(zone)
            val targetTime = LocalTime.of(11, 0)

            var target = now.withHour(targetTime.hour).withMinute(targetTime.minute).withSecond(0).withNano(0)
            if (!target.isAfter(now)) {
                target = target.plusDays(1)
            }

            val delayMs = java.time.Duration.between(now, target).toMillis().coerceAtLeast(0)

            val req = OneTimeWorkRequestBuilder<WhoopLateDataReminderWorker>()
                .setInitialDelay(delayMs, TimeUnit.MILLISECONDS)
                .build()

            WorkManager.getInstance(context).enqueueUniqueWork(
                UNIQUE,
                ExistingWorkPolicy.REPLACE,
                req
            )
        }
    }
}

title: WhoopSyncLogStore.kt
text:
package com.migraineme

import android.content.Context
import org.json.JSONObject
import java.time.Instant

/**
 * Rolling log + per-table daily sync outcomes for WHOOP.
 *
 * Rolling log:
 * - append(), get(), clear() operate on a single text blob (capped)
 *
 * Per-table outcomes (NEW):
 * - Stored per day ("YYYY-MM-DD") as JSON in SharedPreferences
 * - Allows UI to distinguish: couldn't fetch vs no data vs stored, per table
 */
class WhoopSyncLogStore(context: Context) {
    private val app = context.applicationContext
    private val prefs = app.getSharedPreferences(PREFS, Context.MODE_PRIVATE)

    // -------------------------
    // Rolling log (existing)
    // -------------------------

    fun append(line: String) {
        val ts = Instant.now().toString()
        val entry = "$ts | $line\n"
        val cur = prefs.getString(KEY_LOG, "") ?: ""
        var out = cur + entry
        if (out.length > MAX_CHARS) {
            out = out.substring(out.length - MAX_CHARS)
            val idx = out.indexOf('\n')
            if (idx >= 0) out = out.substring(idx + 1)
        }
        prefs.edit().putString(KEY_LOG, out).apply()
    }

    fun get(): String? = prefs.getString(KEY_LOG, null)

    /**
     * Clears ONLY the rolling log. Outcomes are kept.
     */
    fun clear() {
        prefs.edit().remove(KEY_LOG).apply()
    }

    // -------------------------
    // Per-table outcomes (NEW)
    // -------------------------

    enum class TableOutcomeType {
        FETCH_OK_STORED,
        FETCH_OK_NO_DATA,
        FETCH_FAILED
    }

    data class TableOutcome(
        val type: TableOutcomeType,
        val atIso: String,
        val note: String?
    )

    /**
     * Record an outcome for a specific table + date.
     *
     * date: "YYYY-MM-DD"
     * table: e.g. "spo2_daily"
     */
    fun setOutcome(
        date: String,
        table: String,
        type: TableOutcomeType,
        note: String? = null
    ) {
        val key = outcomesKey(date)
        val root = loadOutcomesJson(date)

        val entry = JSONObject()
            .put("type", type.name)
            .put("at", Instant.now().toString())

        if (!note.isNullOrBlank()) entry.put("note", note)

        root.put(table, entry)
        prefs.edit().putString(key, root.toString()).apply()
    }

    /**
     * Read outcome for one table on a given date.
     * Returns null if we never recorded an attempt (NOT_TRIED is implicit).
     */
    fun getOutcome(date: String, table: String): TableOutcome? {
        val root = loadOutcomesJson(date)
        if (!root.has(table)) return null

        val entry = root.optJSONObject(table) ?: return null
        val typeStr = entry.optString("type", "")
        val atIso = entry.optString("at", "")
        val note = entry.optString("note", null)

        val type = runCatching { TableOutcomeType.valueOf(typeStr) }.getOrNull() ?: return null
        if (atIso.isBlank()) return null

        return TableOutcome(type = type, atIso = atIso, note = note)
    }

    /**
     * Get all recorded outcomes for a date.
     * Tables never attempted won't appear in the map.
     */
    fun getOutcomesForDate(date: String): Map<String, TableOutcome> {
        val root = loadOutcomesJson(date)
        val out = mutableMapOf<String, TableOutcome>()

        val keys = root.keys()
        while (keys.hasNext()) {
            val table = keys.next()
            val entry = root.optJSONObject(table) ?: continue

            val typeStr = entry.optString("type", "")
            val atIso = entry.optString("at", "")
            val note = entry.optString("note", null)

            val type = runCatching { TableOutcomeType.valueOf(typeStr) }.getOrNull() ?: continue
            if (atIso.isBlank()) continue

            out[table] = TableOutcome(type = type, atIso = atIso, note = note)
        }

        return out
    }

    fun clearOutcomesForDate(date: String) {
        prefs.edit().remove(outcomesKey(date)).apply()
    }

    fun clearAllOutcomes() {
        val editor = prefs.edit()
        for (k in prefs.all.keys) {
            if (k.startsWith(KEY_OUTCOMES_PREFIX)) editor.remove(k)
        }
        editor.apply()
    }

    private fun outcomesKey(date: String): String = "$KEY_OUTCOMES_PREFIX$date"

    private fun loadOutcomesJson(date: String): JSONObject {
        val raw = prefs.getString(outcomesKey(date), null) ?: return JSONObject()
        return runCatching { JSONObject(raw) }.getOrElse { JSONObject() }
    }

    companion object {
        private const val PREFS = "whoop_sync_log_prefs"
        private const val KEY_LOG = "log"
        private const val MAX_CHARS = 8000
        private const val KEY_OUTCOMES_PREFIX = "outcomes_"
    }
}

title: WhoopTokenStore.kt
text:
// FILE: app/src/main/java/com/migraineme/WhoopTokenStore.kt
package com.migraineme

import android.content.Context

/**
 * Stores WHOOP tokens privately.
 *
 * Tokens are bound to the currently logged-in Supabase userId.
 * - On save(): record owner_user_id
 * - On load(): only return tokens if owner_user_id matches current SessionStore userId
 *   Otherwise clear and return null
 */
class WhoopTokenStore(private val context: Context) {
    private val app = context.applicationContext
    private val prefs = app.getSharedPreferences("whoop_tokens", Context.MODE_PRIVATE)

    private companion object {
        private const val KEY_OWNER_USER_ID = "owner_user_id"
        private const val KEY_ACCESS = "access_token"
        private const val KEY_REFRESH = "refresh_token"
        private const val KEY_TYPE = "token_type"
        private const val KEY_EXPIRES = "expires_at"
    }

    fun save(t: WhoopToken) {
        val currentUserId = SessionStore.readUserId(app).orEmpty()

        prefs.edit()
            .putString(KEY_OWNER_USER_ID, currentUserId)
            .putString(KEY_ACCESS, t.accessToken)
            .putString(KEY_REFRESH, t.refreshToken)
            .putString(KEY_TYPE, t.tokenType)
            .putLong(KEY_EXPIRES, t.expiresAtMillis)
            .apply()
    }

    fun load(): WhoopToken? {
        val currentUserId = SessionStore.readUserId(app).orEmpty()
        val ownerUserId = prefs.getString(KEY_OWNER_USER_ID, "") ?: ""

        if (currentUserId.isBlank()) return null

        if (ownerUserId.isNotBlank() && ownerUserId != currentUserId) {
            clear()
            return null
        }

        val access = prefs.getString(KEY_ACCESS, null) ?: return null
        val refresh = prefs.getString(KEY_REFRESH, "") ?: ""
        val type = prefs.getString(KEY_TYPE, "Bearer") ?: "Bearer"
        val exp = prefs.getLong(KEY_EXPIRES, 0L)

        return WhoopToken(
            accessToken = access,
            refreshToken = refresh,
            tokenType = type,
            expiresAtMillis = exp
        )
    }

    fun clear() {
        prefs.edit().clear().apply()
    }
}

title: WhoopTokenUploadWorker.kt
text:
package com.migraineme

import android.content.Context
import android.util.Log
import androidx.work.BackoffPolicy
import androidx.work.Constraints
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import java.util.concurrent.TimeUnit

class WhoopTokenUploadWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result {
        val ctx = applicationContext

        // Need a valid Supabase token to authenticate edge functions.
        val supaAccessToken = SessionStore.getValidAccessToken(ctx)
            ?.takeIf { it.isNotBlank() }
            ?: return Result.retry()

        // Ensure userId persisted (WhoopTokenStore is user-bound).
        val existingUserId = SessionStore.readUserId(ctx)
        if (existingUserId.isNullOrBlank()) {
            val derived = JwtUtils.extractUserIdFromAccessToken(supaAccessToken)
            if (!derived.isNullOrBlank()) {
                SessionStore.saveUserId(ctx, derived)
            }
        }

        val whoopToken = runCatching { WhoopTokenStore(ctx).load() }.getOrNull()
            ?: return Result.success()

        val edge = EdgeFunctionsService()

        val uploaded = runCatching { edge.upsertWhoopTokenToSupabase(ctx, whoopToken) }
            .getOrDefault(false)

        if (!uploaded) {
            Log.w(TAG, "upsert-whoop-token failed; retrying")
            return Result.retry()
        }

        val backfillEnqueued = runCatching { edge.enqueueLoginBackfillGuaranteed(ctx) }
            .getOrDefault(false)

        if (!backfillEnqueued) {
            Log.w(TAG, "enqueue-login-backfill failed; retrying")
            return Result.retry()
        }

        Log.d(TAG, "WHOOP token uploaded and backfill enqueued")
        return Result.success()
    }

    companion object {
        private const val TAG = "WhoopTokenUploadWorker"
        private const val UNIQUE_WORK_NAME = "whoop_token_upload_and_backfill"

        fun enqueueNow(context: Context) {
            val appCtx = context.applicationContext

            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()

            val req = OneTimeWorkRequestBuilder<WhoopTokenUploadWorker>()
                .setConstraints(constraints)
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30, TimeUnit.SECONDS)
                .build()

            WorkManager.getInstance(appCtx)
                .enqueueUniqueWork(UNIQUE_WORK_NAME, ExistingWorkPolicy.KEEP, req)
        }
    }
}

title: Color.kt
text:
package com.migraineme.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

title: Theme.kt
text:
package com.migraineme.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun MigraineMeTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

title: Type.kt
text:
package com.migraineme.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

